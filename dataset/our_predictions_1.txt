Is this order guaranteed, ie ls-refs before fetch?
Could this relatively general code be reused in the needsOrderBy method?
It's better to introduce a new variable this.request, like it's done in other classes (for example RtIssue)
Here is also that unusual check.
Why setting Token or MID imply sent = false ?
Should we assert a string valued parameter too?
shouldn't be setDaemon(true)
Consider to move into constant variable into SAMLConstant
Add SubChild here as well, perhaps SubChild is just persisted as a Child currently..
Maybe not needed? We don't have to check if a target process definition exists in the source container.
As I think a DTO needs to be returned; we should implement this method.
ERR_DELETE_ERROR, add if there isn't one already
Out of interest why can you not do DecisionTableOrientation.values()?
in what scenario path list will be empty with copy error set to true ?
Maybe its just me, but this calculation looks wrong, since we are assign a = b, then b = a % b will always be 0, since a = b. Shouldn't it be: long c = b; b = a % b; a = c;
Missing blanks around "=".
check to make sure notificationUUID is not null
nit: might be clearer as: return involvedTables.stream().anyMatch(this::isValidationNecessary)
how about the following ? I find this easier to read : while (selIterator.hasNext()) { Object sel = selIterator.next(); ... }
Seems like there's a spacing issue here, two spaces instead of 4.
"PasswordController.NewLicenseKey" ->"LicenseKeyController.NewLicenseKey" is better
Because it can be called by both focusGained and mouseEnter, sometimes you have two active contexts. Maybe there should be only one?
This assumes that the iteration orders of both sets are the same. This should use the same implementation as AbstractSet.equals.
> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
Remove public. Also let's reformat all the ctor to our latest code style.
Nit-pick for the variable name. It is really not file, so just entry would be good. The new HashMap() is bad code too. Must be with generics
can't be null?
This can delegate to the two-argument createSystem variant.
You can use CollectionUtils.toImmutableList
Should this be String.valueOf or is cnn the way to go?
Do you think naming it removeFromParent() could be enough?
||?
This is not a related change... if you can move it to a separate patchset. Also, as per discussion, I think that rather than cutting the mark functionality in the middle here, we should zero it out in the config and leave the logic. If we really want to do this then we ought to remove the logic wholesale (which I'm reluctant to do). For now, maybe let's just set it to 0 in the config?
Shouldnt we have this defaulting to the common namespace (ICommonAttributes#COMMON_NAMESPACE) so that we can tell the user what this defaults to?
two places where partition is serialized? Not very comfortable with that - this is repeated code that needs to be kept in sync.
According to which rules do we throw and InvalidSyntax or an IllegalArgument or an IllegalState exception. Sry, but this looks quite randomized to me
Possible copy/paste bug in the order by clause.
Suggestion: extract new SimpleDateFormat("yyyyMMddHHmmss") as a private static final constant
Hash code
This is extremely wasteful. Try a CopyOnWriteArrayList for listeners instead?
no need to create a set here..
Maybe it's just me, but I would find a simple if-else clause more readable.
If opening is true, doesn't it mean it's still opening but not done opening yet?
null or empty list?
Preferably have one call the other?
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
Add this to WireMessages localization resource
Can this really happen? If not why care?
As above, I'd use String.valueOf here.
Should use StatusHandler.log() instead
Same here: The new flag withAttempts is not passed (used) the paymentProcessor#getAccountPayments
return Boolean.TRUE.equals(bypassIfSameMimeType)
this.monitor to avoid confusion with the parameter of the same name optional: this whole block could be a ternary: this.monitor = monitor != null ? monitor : NullProgressMonitor.INSTANCE;
i would split this line into two for better readability. also gameUser.getAchievements() could be puted to variable
@Serranya The same here. See above.
Too many dots, there should only be 3!
IMHO it does not need to be public
I think it might be easier to create a list and compare that?
you can use instead: return Version.v3_5.less(version);
We have a removeConfiguration so let's not allow null value here?
this should be private also
We shouldn't ignore an invalid enum value.
Doesn't seem as something which should be public, I would say, it should be rather private. If it is required by cancelAndDismissReloadRequiredWindow, it should be most likely improved in order for this method not being required public
Use StringBuilder please.
I continue to think that **aifc** should to be here...
SetActivityCalendar should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
why sink->getSink()?
use return ... ? ... : ...?
do you need to select et_name here?
More accurate error message
would this be called often, and would the list copy be expensive?
Just a note that FetchSessionHandler is used by the consumer too, so we will either need two separate implementations or make sure it works just as well for the consumer too.
The forbidden apis check is flagging an error here: > [ERROR] Forbidden method invocation: java.lang.String#matches(java.lang.String) [Use startsWith(), endsWith(), contains(), or compile and cache a Pattern explicitly] The regex also looks more complicated than necessary and is causing test failures: <LINK_0>  [ERROR] testIsTaskCurrent[numThreads = 1](org.apache.druid.indexing.kafka.supervisor.KafkaSupervisorTest) Time elapsed: 0.142 s <<< ERROR! java.lang.IllegalArgumentException: dataSource cannot contain whitespace character. at com.google.common.base.Preconditions.checkArgument(Preconditions.java:125) at org.apache.druid.segment.indexing.DataSchema.validateDatasourceName(DataSchema.java:108) at org.apache.druid.segment.indexing.DataSchema.<init>(DataSchema.java:76) at org.apache.druid.indexing.kafka.supervisor.KafkaSupervisorTest.getDataSchema(KafkaSupervisorTest.java:3636) at org.apache.druid.indexing.kafka.supervisor.KafkaSupervisorTest.testIsTaskCurrent(KafkaSupervisorTest.java:3099)
Is this really needed?
final
Can we make logger a private static final
checking for nullable parent was added specially, cause going into project node simply has no meaning
Same question as above
Seems like the previous tests should also assert on the length?
A create card payment request should always have a return URL, so I don't think this should return an optional
Closed channels are automatically removed from a channel group. This line can be removed
Again, processible gets renamed to runnable, process to run, yet doProcess remains as it is. I think that's an easily avoidable inconsistency.
can just be hash.hashcode()
The value returned by isPlaced depends on the mapped flag as well. It would be a lot simpler if this provider had tuples of [seqID, start, mappedFlag, usePositionDeltaEncoding, expectedIsPlaced], with test cases for each possible combination, and the test just created a new record for each case using those values, and verified isPlaced.
Is this really sufficient to test your WCheckBoxWebElement? One check box is sufficient if it is exposed through a getter so the tests can set properties on it.
We should validate that's non-null (to fail sooner).
This should return an immutable collection.
The date string format should probably be a protected static constant. Also do we need the temporary variable? (This method is called many times a tick.)
If people don't provide any commandline arguments it would be nice to have a help message explaining what they should be.
Don't open things up that don't have sufficient parameter validation, the @Nonnull is not enforced here because it was an internal method, so you'd need to add a Validate call here.
Can you add this property in secor.common.properties with default value. We prefer setting the default value in properties file instead of java class. Is default value 3 better than 5?
remove this method. you dont reuse the variables anyway.
This description should mention TC and SC, I guess.
I think this should be headers.get(name).
In general, all injection constructors should be package private.
The formatting is a little weird here.
@apc999 This needs to be public or reflection will not work
No need to use ConcurrentMap.
Can this method return void instead? I feel it's a bit funny to return the same thing we just provided as input.
@erimerturk let's rename this to ex
Code style: Always use curly brackets, and space after if.
Consider a constant symbol for -1 to indicate an error value.
... that way when accessing them from the class we won't need to use "this." for example fString = string vs this.string = string
Do we actually need this then? Wouldn't toString() be called by default, too?
Shouldn't this return true?
add requireNonNull for clazz
you can just return false here, even better : return trace instanceof TmfExperiment && super.canExecute(trace);
what else? any warning or exception should be there?
Unknown file name and known line number? Should that be an error?
Maybe we should derive this from Prefs.getMediaWikiBaseUri() or require the client to pass in a default protocol. I think I prefer the latter to avoid complicating this nice and simple model type.
We don't need to minus LOCAL_TZ offset for TimestampData, the millis is already an epoch milliseconds.
@Override is missing - propose to mark class OneTableJdbcKeyValueStorage as deprecated - it is not used any more
I see no reason for the setters to be public.
nit: name = tableName or this.name = name
I think there is a StreamsJacksonMapper.getInstance() method you can use to not create a new object.
please stick to java conventions regarding variable names
Do a detection.  if (e instanceof RuntimeException) { throw (RuntimeException) e; } else { throw new RuntimeException(e) }
we should also check for n <= 0 here
Please consider writing a class version number (e.g. 1) as part of SerDe in case this is ever stored on disk.
Not sure whether worth doing, but since the only usage is "DownloadImageManager" (that is in the same package), it is possible to remove "public".
<LINK_0>
Do we need some kind of synchronization here, or will next() never be concurrently called from two separate threads?
I'd rather toLowerCase() is applied after substring(), not before.
Use MethodType.DERIVATIVE.getCode() and MethodType.MAINTENANCE.getCode()
java.net.URI has an isAbsolute() method might be better to use that.
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Consider returning List<> via Collections.unmodifiableList(awards) instead.
just return supplier != null && !supplier.isEmpty()
kind of curious what these magic numbers are
It would have been more readable to split this commit into 2 : - One about refactoring to sanitze code - One about using new format
not sure if this makes a difference or not, but won't the max size be Float.BYTES if storeDoubleAsFloat is true? I see the pattern you used is the same as what's used in DoubleFirstAggregatorFactory - probably a bug in both?
This null check should be done in line 274
DEFAULT_LOADING_THROTTLE_LIMIT?
maybe just using try-finally in the other cases would have also fixed the problem if the order matters for some reason
Recheck some of these please. In Java, all non-primitives are just references, so these lines will not be making deep copies unless you do something like .cpy() which you have done for relativePosition. width, height, relativeAngle and relativePosition will be deep copies with this code. texture, drawableLevel, and tint should all have clone() methods
same question here: shouldn't labelsWidget.cleanup() be included in the generated driver.cleanup()?
getParent() can return null
use hasNext instead of contains (do not use toIterable() we want to check Iterator)
getCells() can never be null
Please close client at the end.
Why bother locking if the size returned is immediately going to be invalid? aka, some other thread may have already changed the size.
I don't understand here: why do you need this change here? it doesn't seem to be necessary.
Let's do return fDetailedLoad; even if it is always null for now
Let's rename "ignore" to "ignired" Please use fail(): <LINK_0>
Fix the method name here please.
Like, super.onFailedToRecycleView, this doesn't seem to do anything. Why call one super and not the other? Ditto for below?
To be safe, should check gerritTrigger.getJob() != null first.
... yes it does ...
why is that needed?
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
Can you specify the exception/message being thrown on this call? Otherwise you could use the Assert#nonNull(T, Supplier<String>) function contained in the framework. Doesn't return the field like requireNonNull() though. :/
log and throw anti patttern
also check this
Assert.notNull(expiry,..) checking might make sense here
we should not throw an exception here, simply ignore
<LINK_0>
instead of dropping this should it be an exception?
Putting fetch inside get() might not be good. If this api blocks writer, writer can starve because fetch can really take a long time due to hole fills. If this api doesn't block writer, then the NoRollBackException issue will still occur quite often as this reader may override the writer's value with no undo record.
Please use curly braces for conditionals
just return "" instead of new String()
Good note. I think USER_PORTRAIT would be better so it works upside down too
I don't understand why you verify if filterChain needs to be updated with every message read. Maybe filterChain should be volatile.
@apc999 This needs to be public or reflection will not work
Check first that target is not null.
No need for this logic - Guava does it anyway. Just call copyOf. This method will then reduce to a single stream operation.
submit?
By the way, name the reporter thread.
You could move the construction of msg and response under the if clause as you don't use it in the else case. Just curious though, since the check and the write aren't atomic, what happens if writeAndFlush() is called when the channel isn't active?
please add new HelpTag and HashName (as in StorageListModel)
suggestion processInstanceIds.forEach(processInstanceId -> {  You dont need to use _.stream_ to access _forEach_
This should check to make sure that notificationUUID is not null before attempting to delete it.
Maybe make this a static final List now that is is used two places? (here and line 123).
True. I've never seen a case with -1 as the default. 0 has special meaning in the JVM, so best to stick with 0 as the default and adjust the size to cope (add one or size 0 -> -1)
Per IRL, I meant to say uploadApiBase. This is fine too, but unrelated.
Use constants for 1 and 2.
Please add a check Objects.requireNonNull(supplier, "supplier is null");
don't catch, but instead allow the ExceptionMapper to handle it
You can look at using a joiner: <LINK_0>, which will join this iterable of string
don't forget default case
disable table has some validity checks, should this?
Do we need to remove this? I have no idea how this can be exposed to users, but it looks useful. If this should be removed, the code computing the INVALID_ROW_COUNTER in HadoopDruidIndexerMapper should also be removed as well.
might be nice to make this a method instead withDefaultResources, and use that in the no-args constructor but let the explicitly specified constructor not inherit that opinion by default
Uh, IllegalStateException?
Consider adding null check here.
There should not be a need to set this to public. Perhaps private would be better.
You should throw a WebApplication exception with a JsonError as entity for the client to receive a valid JSON.
optional: change this to Life_Version_Field_Offset_In_Bytes
protected instead of package protected
Why we removed final?
style nit: no braces around single line blocks
Likewise don't need the if statement since the optional value will return empty.
You shouldn't use 'Z'... it's just Z it is the flag for the timezone. 'Z' is UTC, but if I put +03:00 it's also valid ISO.
I would suggest to let this test failed with some unimplemented exception. Or at least ignore it. Otherwise it will provide the false assumption that it is implemented and working.
These checks should happen within the build function when delegated to the object they are building, not a builder's set function. Don't duplicate the logic.
Can we check for an empty string too, please?
I would recommend dropping size var and just calling timeStamps.size() ... this way do not have to keep this thing correct... for example should set this to zero when calling clear
No need to use UriBuilder
I think we can remove this line.
I would not call the leaderContender under the lock because of the risk of introducing potential deadlocks.
You don't need to add this exception to the signature as it is an [unchecked exception](<LINK_0> :)
you can just return 'Collections.emptyList()' - permission check is unneeded as the command is executed only internally
why was this done?
Ternary
agentDisconnect also sets this state.
ImmutableSet.copyOf(Iterables.filter(...)) ?
There should be a null check here if it doesn't accept null values
this test will be filled?
Mid return may worsen readability
Hi, I thought about changing back the name because all the classes in the AElement hierarchy use double dispatching mechanism and it looked like a convention, and the double dispatching mechanism is more clear according to Michael. This class is the only one for which the second equals method isn't used anywhere, and I'm not yet familiar with the complete codebase so I thought it was error prone to change the public api of the class, that's why I changed back the name and made the change so that the equals(Object) calls the correct method. I do have the merged equals method in a branch. Should I make a pull request from it?
can we factor out this code, here and other places? e.g, java return withContext(context -> replaceItem(itemType, itemId, doc, requestOptions,context)) .subscriberContext(reactorContext -> factoredOutFunc())
assertThat(result).hasId("analysis")
These calculations require explanations, and possibly breaking out into methods and constants, depending on the explanations. Is this the complete possible span of random dates uniformly distributed? I think that should otherwise be the aim, to be aligned with the general expectations here.
Because there is only one argument, we can pass workerMetrics instead of an object array.
IOUtils.close
super.init() method never throw an exception.
!sizes.isEmpty()?
Please make the methods in Calculator non-static and rework the examples accordingly. I think it's fine to create the calculator as the _SUT_ in a field (in all affected test classes) as follows. java private final Calculator calculator = new Calculator();
This variable should be called something more generic instead of sort since it could be any int
Why change the order? You normally stop in opposite order to creation. So, if you create embedded cache manager first and then the server, you normally stop server first, then the cache manager.
Consistency: queryConverter() instead of query()?
The <Integer> can probably be omitted.
I think you should throw exception if somebody calls setEvent and give an empty event name. #Pending
Sounds a bit odd, better use "Expected %1$s to be a valid email".
I suppose this should be true ?
How about inlining it?  if (!contains(o)) return false;
Use Objects.equals() to handle nulls concisely.
Please remember this ctor changed.
I think this should be reverted, so it would still take into account additions from pre-TransientActionFactory implementations.
@bgeVam please remove the unnecessary parenthesis around encounter.getUuid().equals
Instead of collecting transaction edit logs here, we can add the count header in AbstractTransactionLog.sync() method before calling append, right? Since the edit logs are already being collected over there, we will then avoid code duplication.
are these setters used anywhere?
Same variable names (change to senderVouches.
Shouldn't this be a field so we don't have to create one each time
On START_DATE, the discount factor for start date should be 1.
Seems a typo "reregister -> unregister"
can you add to Builder as well
Make this "info". there's relatively fewer operations scheduled on the executor, and would be good to log their completion status
declaredOuputStreams is too verbose. the variable/method can be outputStreams/addOutputStream.
We're setting running to false and interrupting the thread here. Isn't one sufficient?
Would be awesome to rename it to something more descriptive like isDiscussionsPresent() or similar
getUsage(...) expects a localization key.
Overdid - setUp("redis")
This change is not necessary.
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
May I suggest this?  int i = url.indexOf("/#/"); return i == -1 ? url : url.substring(0, i);  It only searches the string once, and more important, doesn't duplicate the search argument.
Please capitalize "Illegal"
there's probably some precondition where like, we should only be updating the lease if it's advantageous to do so? E.g. if someone tries to update it into the past, that's probably not great
Similar
Can be transformed into an if statement.
This from field appears to be redundant, as this is an inner class.
there is no other (more elegant) way of getting article name
I think this should be > 0 since a value list item of 1=One does not work.
I think isConnected() would be appropriate here since you're saying "active" network connection. If we allowed the "connecting" state then we would need a BroadcastReceiver to delay the (re-)try until the network connection has been established.
is this tear down necessary? the next setup overwrites anyway, doesn't it?
Needs to be in finally - we might get interrupted.
This isn't right given the method signature of the base method -- name should be used in some way. If you want to pass in the full path to the db file, then I think DatabaseContext needs to be redesigned.
not sure if it will matter for your tests, but calling value() is not what normally updates access time. It is the Cache/Store operation that returned the value.
possible NullPointerException: there might be violations without application. With Optionals it could look like  java return v -> applicationId.equals(Optional.ofNullable(v.getApplication()).map(ApplicationEntity::getName).orElse(null));
use return ... ? ... : ...?
Here and elsewhere, the Fragment probably shouldn't force the host to do things by getting its internals and changing them. The dependency on a toolbar is clear because of the callback pattern but exposing the toolbar directly allows any Fragment to change it. It's ok to defer but consider pushing onSearchOpen() into the host and allow it to hide / show the toolbar.
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
To make the tests more resilient to future changes, please pick values that are unlikely to ever be the actual defaults. For example 234MB and 11MB.
Should use parameterized logging instead of string concatenation.
what else? any warning or exception should be there?
Use this.key
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
Is replacing separators enough? We should look into something that will work for any special characters.
Do we actually call init multiple times on a trace or is it a safe-guard? Just curious.
Should be a SamzaException with a message, not NPE.
super-method only
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
We should add blank behavior here directly. A blank value should be identical to an absent one.
fos can be inside try ()
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
[FindBugs] WARNING: SA: Self assignment of field KafkaSingleThreadedMessageReceiver.subscription in pl.allegro.tech.hermes.consumers.consumer.receiver.kafka.KafkaSingleThreadedMessageReceiver.update(Subscription)
Would it work to drop the iterator and just execute  operations.forEach(this::add);
early return when if (testIdent.isContainer())?
Why setting Token or MID imply sent = false ?
![INFO](<LINK_0> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_1>](<LINK_2>
Should this refer to a platform-relative constant?
Change to use this.jsonAsString.hashCode().
extra ()
super.init() method never throw an exception.
It should also validate that the content is valid JSON, otherwise it will fail "silently" when trying to create it.
I wouldn't call classes with invokedynamic bootstrap methods "utility classes" :smile:
This one is already done on line 816. Do we need it again here?
Likewise.
Should be getStartTimeAsLong() and not getGenStartTimeAsLong().
Let's use static import for simplifying constant references similar to how it had been done in other parts of code.
This code duplicates method isSwitchRuleLambda. Should this method be used here?
You don't need this as compareAndSet will set it to true.
If using Function<ClientBuilderImpl, T> for the build function type, instead of a custom interface, this method becomes return builderFunction.apply(this);
I would suggest You to use Logy.d here instead, as we did it [here](<LINK_0>
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
merge else if?
can simply to return period != null || cronExpression != null; If you use IntelliJ, it automatically suggests these refactors.
no!
I think KernelTransactionsTest.exceptionWhenStartingNewTransactionOnShutdownInstance is failing because of this change.
IOUtils.close
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
I've got a fix in a PR that [removes the watchManager](<LINK_0>, so let's just make sure that doesn't get squashed by this :)
one more method where it can take file location of properties would be good.
we can use try(BufferedReader...) {}
Needs some sort of assert to show it succeeded
minor: change SocketNetworkClient to LocalNetworkClient in line 98 and 102
Does this need to be public?
there is no other (more elegant) way of getting article name
The test incomplete, because of two reasons: 1. It always checks empty cache iterators. 2. It doesn't check that we can actually iterate on the iterator() and spliterator() results. See suggested changes below, does it makes sense for you? (changes will made test fail).  IgniteEx ign = startGrids(1); IgniteCache<Integer, String> cache = ign.cache(DEFAULT_CACHE_NAME); cache.put(1, "1"); cache.put(2, "2"); cache.put(3, "3");
Check for the existence of the file to delete?
Why is this removed?
Could we prefer a proper logger instead of System.x - we already have a logback.xml in the module.
new AcceptAllValidator<String>()
requireNonNull?
> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
But the task is still running in the executor, which could prevent the Jolie program from terminating in case we're done with the service. executor.schedule actually returns a ScheduleFuture that supports a cancel method that you can use to cancel the task.
Is forEach better that putAll? I suppose we also need to take care of the case when params are null.  if (params == null) { namedParameters.clear(); } else { namedParameters.putAll(params); }
I think this is main issue that needs to be resolved. The problem is that this implementation can consume a lot of resources because of the retrying and the long latency. It could even end up in a livelock. The best approach is to get everything done in a single remote call. There is no retrying needed here because the operation will have exclusive access to the partition.
I'm not sure if I agree with this change. if we have a case where setValue() is invoked multiple times, I would rather return "prev" than "oldValue".
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
This is not necessary.
It's safer to call getProperty("replicatorFactor", DEFAULT_REP_FACTOR). You should validate the arguments as well.
Can make this into a singleton as we have with UNSET.
Shouldn't this close the iterator before returning the list?
It would be nice to provide some feedback if this check fails. Like "The file BLABLA doesn't exist in the directory you provided. Please try again..."
How about:  int size = Math.min(b.height, b.width); setMinimumSize(new Dimension(s, s)); setPreferredSize(new Dimension(s, s)); setMaximumSize(new Dimension(s, s));
Please add the 'can not recover' back? It clearly tells why we must abort the region server.
Normalize the use of required/missing at the end of the method name across all the validator tests classes.
This involves a look up of the character encoding type table. Use MessagePack.UTF8
I don't know if we ever call put twice for the same key, but null effectively removed the previous value in the method's "before" form, and now it doesn't.
use return ... ? ... : ...?
Thanks for this clean-up throughout the code! I should probably start enforcing fcrepo4 code style rules sooner rather than later...
I would recommend dropping size var and just calling timeStamps.size() ... this way do not have to keep this thing correct... for example should set this to zero when calling clear
If it is meant to only check syntax, do we need to return model? I'd rather have it return true/false.
any particular reason why this method doesn't require an IJavaProject ?
True. I've never seen a case with -1 as the default. 0 has special meaning in the JVM, so best to stick with 0 as the default and adjust the size to cope (add one or size 0 -> -1)
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
If the variable name is normalized on the set() method, is it necessary to normalize on the get() as well?
are these setters used anywhere?
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
I would turn this && around. A simple deadlineName check is a lot cheaper than the full parameter assignment verification.
This is now hard to read since it combines two multiline expressions. Please break it up into separate expressions and use suitable variables for each value.
instanceof Dataset is redundant
pull this out into getMockAuthorizer() {return getFileSystem().getAbfsStore.getAuthorizer()}
"ws" and "wss" must be defined as constants.
Why is it public?
matter of taste, this could also be return this.profileTypeRegistry != null;
This can be package private, no?
not sure if it will matter for your tests, but calling value() is not what normally updates access time. It is the Cache/Store operation that returned the value.
Granting that this CL otherwise consists entirely of automated refactorings, consider revising the other two lines of this computation for consistency with the revised middle.
Should we use org.apache.kafka.common.utils.Utils.closeQuietly ?
nit: Could be this.conf = requireNonNull(conf);
Could be a try-with-resources.
use return ... ? ... : ...?
I think here, it should be requireNotNull(userName)
This will return true if the value is "no". Why has this changed?
Minor suggestion to change this exception to:  throw new IllegalArgumentException("g may not be null.");
With these changes, the test should fail as no exception is thrown anymore. The only reason this still passes is because there is no fail call before the catch block. Can you adapt the test to make sure it tests what was tested before?
Use constants
please remove else, code will be more readable
Should the shadow not store this value and the one above in variables and provide setters for them, rather than just always returning false? The same goes for all values actually... Would be better to provide setters for them.
This should be public
Can be reduced to throws IOException.
Should we add null check?
Doesn't seem like we need to throw Exception here as shutdown() doesn't declare a checked exception.
same as others: log should have Exception as arg
Is this a bug fix? (Like the one below) .. Can u explain .. Previously it was a config based thing and now hard coded.
This should be an @Override of implemenatioin super type..
I think we should prefer accuracy over speed here, and use a BigDecimal for all these calculations. It won't be noticeably slower (I don't think anyone is calling this every frame or op!), and it would allow us to provide better guarantees about the results of the method.
This should be Repository.class. The method is supposed to return the list of adapterTypes, i.e., the types to which this adapter can adapt objects to.
Can't we rely on System.out here because as far as I know we are not printing an error but an expected behavior.
Need to restore configurations using serverConfigurationManager.restoreToLastConfiguration() and make sure all changes done to configuration files will be reverted.
Unnecessary (and incompatible); revert.
<b>Reporter: </b>PMD<br /><b>Violation: </b><a target="_blank" href="<LINK_0>">JUnitTestContainsTooManyAsserts</a><br /><b>Notes: </b>JUnit tests should not contain more than 1 assert(s).
Maybe let the stop() method throw the exception instead of catching and printing?
What is this for? Feels like some unintended checked in code?
Add message to new RuntimeException
Why is it public?
you should check if the message severity is ERROR
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
Is it useful to keep the Exception generic, or should we narrow the Exception type on the interface?
Not sure, why not use @NotNull?
Could be inlined here by using test()
This needs an @Override annotation.
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
Nitpick: startingCounter?
It's really not clear if this is the source or the target.
Shouldn't this close the iterator before returning the list?
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
We need ofNullable. I am running FDB to demonstrate we need it. It will cause GuidedDecisionTableModellerPresenterTest to fail.
rename to contribution
Why do we have this constructor?
could be static
can be !isDisabled()
Args.notNull
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
you should use Integer.compare(o1.., o2..) here, since this method should return either -1, 0 or 1.
The editor can't be null
name can be null, causing compareTo to NPE if its on the wrong side. In these cases maybe treat the name as though it was "".
Can localityManager or readLocality results be null?
Should be an iterator assertion, e.g:  assertThat(Arrays.asList(ITEMS).iterator()).hasNext();
Do not use e.printStackTrace(). Log the exception. > this.logger.severe( e.getMessage()); > this.logger.finest( Utils.writeException( e ));
Now this method does not do as it's named...
Wouldn't it be better to not mock this ? This way we will test filtering. In ACUnitTestBase you have method to create Patient, so you can build a list and see if the filtering returns proper list.
This check is redundant because you check this in handleSelection()
can you add to Builder as well
Check the env variable before returning true.
I wonder if this is really necessary... jansi uses [isatty](<LINK_0> to avoid writing the escape codes when output is redirected.
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
What's the thinking behind inverting values that are passed in?
unnecessary
on IOException|RuntimeException you could add a binary annotation of "error" -> message, as that will turn the thing red in zipkin's UI
This is somewhat confusing to read - why does setup() call something named validate(), instead of setting up the cluster? One has to go to inside validate() to figure out what is going. Perhaps it can be named setupClusterAndValidate(), or something more readable?
Encapsulation
This message should be more descriptive. The only was for the handle to be invalid is either if: 1) There is some other thread trying to access the iterator. 2) The iterator has been previously closed. The message should reflect the above conditions.
Move the logic to configAccessor.
^ This method no longer throws IOException
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
you can remove this
Same here. Should this be a Mono instead of a PagedFlux as it's returning a single message?
In alignment with valueOf, perhaps name this valueOfType or fromType?
Please don't move this line around in the constructor, its not essential to the patch.
I had to add a scrolledComposite.setExpandVertical(true); here to see an actual list widget (at least recognizable as such) when having multiple values.
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
There is no need to call super explicitly. Same applies to other constructors.
You could remove method("POST") as you set the HTTP method on create
Same here, no need a transaction
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
Could you please use DecisionTableInputType.XLSX
This pattern is captured in Optional's [ofNullable](<LINK_0> method, so in this case the body of the method can be simplified to  Optional.ofNullable(gitRepo)  Similarly for other methods in this class. Let's get rid of the boilerplate :)
To always be safe please use context.getApplicationContext()
I would have inverted the check but that may be unnecessary
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Can these be the same object?
Use context.getApplicationContext() to ensure the class can't leak any shorter lived contexts that might be passed to it (it's always fine to hold onto the application context, since it's expected to be around for as long as the process remains alive).
If instrumentation fails, then exception won't have location information due to this usage of instrument(ClassReader) instead of previously used instrument(byte[], String). Maybe simply preserve readFully?
I barely understand how this is working, Content-Type is a header present in the response how can this affect cache negotiation?
suggestion return Arrays.toString(value);
nit: Could be this.conf = requireNonNull(conf);
name could be more descriptive
are you sure this is the best way to handle this exception?
return LanguageUtil.LOCALE_CACHE.getUnchecked(this.locale);
I think this will cause a memory leak as you're going to be holding onto an indefinite chain of references, so the GC can never garbage collect the request metrics objects. It would be better to create a new request metrics payload that is a copy of the current
Why you will need substring() when Class.getSimpleName() would only return the class' own name without package? Please remove.
catch Throwable? When methods shouldn't throw, like where shouldThrow is false here, it's easy to end up with a hang because an exception type changed.
Any reason /path is required?
This method cannot have a side effect (i.e. creating a module if missing), otherwise checks in MultiModeDrtConfigGroup will get broken. Re disallowing a standalone DrtConfigGroup: probably the only risk is that most people use a single DRT setup. So by doing this, we will break lots of scenarios (which we do from time to time anyway) and we will make the typical setup a bit more complicated (no injection of DrtConfigGroup, and obtaining it by providing additional argument: String drtServiceName). But maybe worth doing. Will add this to my task list for the upcoming (remote) DevMeet:-)
Added because?
Same here. Should this be a Mono instead of a PagedFlux as it's returning a single message?
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
Feel free to simplify the code by getting rid of some of these constructor variants. I would lean against any of them that take String instead of DataSource, and against any combination of arguments except 1) (source, schema) [rest default], 2) (source, schema, delimiter) [rest default], and 3) all arguments specified.
Should we use UTF-8 instead of default character setting?
Should close kill the memspace? What if someone want to reopen the key?
You should go one step more in simplifying the rule: Change this method to return a boolean: hasNoDefault(switchStatementTree)  return allLabels(switchStatementTree).noneMatch(SwitchLastCaseIsDefaultCheck::isDefault);
suggestion if (this.currentTask != null) checkAndRethrow();
Magic number. Please run checkstyle/pmd/findbugs and fix all violations.
How about "Type is not supported"?
(nitpic) 0.0f is float, you mean 0.0 (double)
final
Why not unconditionally update the SessionData?
should the second arg be true here?
This is an anti-pattern. Use a StringBuilder instead. Why not comma instead of |?
The two methods above are the same except for the first line...perhaps reuse the code instead?
Parameter should be a string instead and be called label
StringBuilder
return 'A'
only one of isJavaxScriptSource/isJavascriptSource seems necessary
Is it OK to swallow this entirely?
I should explain it better earlier, what I mean by "inline" is to move the implementation body of isNonRetryableServiceException  to inside the isRetryableException method, then the negations should be applied onto each expressions, return true -> false; etc. This is still a double negative.
Log using a java.util.logging.Logger at the warning level and swallow. There's nothing sensible to be done on the way out.
Maybe good to add a limit to the total number of events that can be queued (suppose the send takes a while because of network issues and lots of events queue up in the meantime, leading to high memory usage)
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
Not provided the Locale in the first argument can cause issues depending on which user the Locale has the app set to. I ran into this with the Simperium library.
style nit: we don't use braces around single line blocks
Apply changes similar to setVisibility.
Eclipse is warning that the argument r is unused. I guess this should be changed to r?
what else? any warning or exception should be there?
The super() returns "" on null. Why should we differ?
Just in case, please wrap with Collections.unmodifiableCollection()
fyi: if we counting everything, fs.getContentSummary(path) would be the most efficient.
Did you intentionally ignore the patientProgram parameter?
Great idea! Can we use Locale.ROOT instead, though?
I think we should at least log this exception here before throwing other one
Does this need to be a singleton?
sed 's/value == STRICT.value ? true : false/value == STRICT.value/' (Redundant inline if)
assuming this was for debugging, should remove.
This updates all gauges when any of these gauge is visited. It'll be better to override getValue() instead, and only calculate the percentile for the gauge currently being visited.
Wouldn't this implementation give false for this.equals(this)?
Padding should probably be extracted in a separate method. (I could also argue that getting the int value could be another method, but I sense that there might be some opposition there).
Who is calling cleanup? Better if it is done by Junit after/afterclass annotations.
....and then you don't need to call it on every other method
Shouldnt we have this defaulting to the common namespace (ICommonAttributes#COMMON_NAMESPACE) so that we can tell the user what this defaults to?
Need to verify no interactions with log
If there is nothing to draw, what about just skipping the drawing and return 0?
Wouldn't it make sense to call setImage here? Or do we have different semantics in that method and this one?
Something like this.
ViewUtil.destroy(View) use the GMF CrossReferenceAdapter and should be removed
Style-nit: Remove the added final keyword.
> return new String[] { resource + "/.default" }; [](start = 7, length = 48) Should this use the DEFAULT_SUFFIX constant above?
Move this validation to PluginProfileService.
Put the cast on the same line
make this synchronized.
Since we know we're in ConnectStoragePoolVDSCommand, is the getCommandName() really necessary? also, remove the "to" - "Failed in VdsCommand %1, error = %2$s"
Maybe its just me, but this calculation looks wrong, since we are assign a = b, then b = a % b will always be 0, since a = b. Shouldn't it be: long c = b; b = a % b; a = c;
Same here.. we should not have these checks here.
Why is it public?
I think I prefer "Invalid key" as exception message
ImageData for current image needs to be updated in the array?
same again: do not create a new empty exception but reuse the old one.
I think only one impassable entity should be allowed on a Square. Exception otherwise.
<LINK_0>
Should this be putTransient because of IMap#putTransient?
the results changed?!?!?!?!?! this is not good. We need to do a seek before, we cannot rely on a "fixture" that changes depending on the order or the tests.
adding an extra pair of around endTime - startTime would be nice for those of us who never memorized arithmetic operator precedence, like me :)
Doesn't seem as something which should be public, I would say, it should be rather private. If it is required by cancelAndDismissReloadRequiredWindow, it should be most likely improved in order for this method not being required public
constant?
Unneeded parenthesis. You probably can one-line this method anyway :)
This looks wrong: you should not ask customDataTypesHandler about builtin types.
can move ListVersionView object construction in ViewFactory? this will replace publicBodiesConfiguration dependency by ViewFactory to make it consistent with other resources.
is super.init throwing the parents class Exception? Whats throwing Exception within the init method ?
please remove else, code will be more readable
Could you please create a new enum for the Menu and Button constants (I don't like magic strings).
Isn't this... just a re-implementation of natural ordering? I don't think you actually need this.
use hasNext instead of contains (do not use toIterable() we want to check Iterator)
don't forget default case
Same issue here, double delete user.
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
can be !isDisabled()
Why not .filter(exam -> exam.getPeriod().getPenalty() != 0)?
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
I know you didn't add this, but it would be great if you could change throws Exception to throws TriangleException as it's usually best to be as specific as you can :)
The super constructor throws an IAE, so why not mark this one, that the IAE could be thrown? Wouldn't it be helpful for the caller of the constructor to know that this runtime exception could be thrown?
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
IDEA says that using toArray(new String[collection.size()]) has no performance improvement over toArray(new String[0]) so the second call is encouraged.
annotate this instead
Implementation of this and other similar methods is highly inefficient. Better to use Character.isJavaIdentifierStart.
Two loops again :(
Please use the more compact one-line syntax:  java if (defaultUI == null) return;  for consistency with the other blocks of code in these here parts.
This may not be thread safe if only one sender is instantiated. We probably only want one sender or at least only one httpclient.
Avoid ByteSource in API. byte[] is ok here
i would add additional check to make sure we will never make it to more then 100 :)
I think that this logic should not be in htsjdk. getDescription() should return null or blank if there's no decription. the user can choose what to do with that information.
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
You should create a ServerSocket on 0.0.0.0 to attempt to bind the port, rather than attempting to connect to it. There are a lot of reasons the connection to the port could fail, and it could even block for a bit trying to connect which would cause this function to hang. Additionally, there's no real guarantee in singularity that the app will bind to 127.0.0.1, it could just bind to the main IP of the host and you'd miss it, so binding 0.0.0.0 would ensure it's not listening to the port on any address.
Why not try these first?
This can delegate to the two-argument createSystem variant.
rename
Avoid logic in this class. This is inconsistent with other collection fields. You can't do an update with this field set to null. Also, why a tree set?
This is a bug
Should be a SamzaException with a message, not NPE.
@ivandalbosco This method should be annotated withjavax.annotation.CheckForNull.
Please add ioe to the exception.
Ahhh, the speaking check is here. Calling speakNames() to have to sometimes not speak names is confusing and wastes a method call. I think we should just pass the boolean into presentation manager.
This doesn't honor the contract of an iterator's remove. In fact, i'm not sure you can support this atomically with only a single file.
Static string constants
given that specificity of this SV is exception type I would add the exceptionType in this.
Should have a space after add
Assertion is missing for operator name
Lets leave this get() however as its part of the public NoteMap API and some callers may prefer this variant.
this.configuration = Assert.requireNonNull(this.configuration, "this.configuration"); We should use this pattern for each final param that is created by the constructor. By doing so exceptions in case of a null value will be thrown as early as possible
IMPORTANT res = pipe.waitForCompletion(timeoutMillis) && res otherwise after the first fails to complete the boolean expression will short-circuit and the other waits won't get executed..
It would be nice to change the parameters class so that it uses List instead of ArrayList, then you could use just "toList".
@inverno Why public?
But existing rows use null not "" for the parentUuid.
CheckReturnValue?
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
Optional.map
Hmmm. The process() method should be as lean as possible. This calls for a DisableMaterial() class to be used as default instance, in which the process method is just shaderManager.disableShader();
How about return ((List<?>) ((IStructuredSelection) selection).toList()) .stream().allMatch(e -> e instanceof RepositoryNode); ?
why is this null check necessary? I'd rather see checkNotNull(item) than this
Do we need the empty constructor?
Maybe some not-null check should be added here.
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
StringPool.EMPTY instead
(Alt) Can we move the skip condition to the testSetup method just above.
SHould we check that values is neither null nor empty?
SimpleDateFormat is not thread safe, so you can't share it across threads. The static instance _can_ be used across threads since this method is static, so it's not safe to make this change.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Is it really filter name?
If the first orchestrator throws an exception when closing, the second one will never get closed. Please use a closer instead; see org.hibernate.search.backend.elasticsearch.impl.ElasticsearchBackendImpl#close for an example.
lockRefreshToken should be set to Optional.empty() here, otherwise isHeld() will still return true. There should be a test for this.
You check whether all arguments are not null in all the methods below. Why not in the other methods (as here)? If you always check the same type of variable please introduce a small private method as check instead of repeating the same check multiple times.
I think this should be enough:  try (InputStream stream = classLoader.getResourceAsStream("project.properties")) { properties.load(stream); return properties.getProperty("version"); }
unnecessary parenthesis?
This warning suppression can be removed if the below line is changed to PartitionAttributes<String, String> attributes = new PartitionAttributesFactory<String, String>()
do you need to make it public?
Since it isn't an expensive operation after each test would be better
do you want to create a new list if its null?
EchoParametersDao.getEchoParameters() already returns a list.
Need {}
I am wondering if we should move the project towards scala or kotlin to make the data objects less verbose
Nested try here too.
Why do we need this constructor? It doesn't use the 2nd parameter...
You could use ternary if for this: return getVds() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST) : ValidationResult.VALID;
Lists obtained from a message are immutable. No need for extra copying.
Don't return null. Make it Optional<String>, and return Optional.fromNullable(...)
This method takes a varargs of String. There may be zero elements in this varargs, but you don't bounds-check and may run into an exception on line 88. I'm also curious if there is information being thrown away if multiple scopes are provided?
I'd consider this style of loops dangerous as if the escape hatch out of the loop isn't perfect it can become an avenue to perform a denial of service as threads get stuck in a loop. If changing the way the loop operates isn't simple then just adding a limit to the loop is a simple way around it so it will only remove up to 1000 "/../" or something like that.
Could use assertEquals?
Since this method uses a Transciever to respond, should it be named 'serve', not 'read'?
Shouldn't this be set to false?
Nitpicky stuff: This method performs the key lookup twice when you could do the same operation with only one: JsonNode node = json.get(key); return node != null ? node.textValue() : null;
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
I'd just like to say what an awesome tool for optimization this class is. Kudos to you and @cadonna .
this should be the disk id, not the image id
Integer.MAX_VALUE + 1 and Integer.MIN_VALUE return the same hash?
If this is only for testing, use stream api
I believe the order is guaranteed in partitions by the sort order of Partition which is on the partition ID.
Couple more static imports here?
use return ... ? ... : ...?
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
How about narrowing it to ClassNotFoundException and fail with other exceptions?
Can StringUtils.fromUtf8 be used?
just return "" instead of new String()
I think there is some findbugs issue with not using {} not sure.
Why are you looping here? Can you give a use-case?
What if the arrays have difference sizes. EIther you get an index out of bounds or you are not checking every element.
This noneMatch(notVisited) seems rather convoluted for no practical reason : wouldn't a Collections.disjoint be enough in our case ? and/or maybe Guava Sets.intersection (maybe applicable to sets only) ? Ideally encapsulated in a "visitedAllParents" method ?
I notice the computation in this method is duplicated. If the steps were passed as a parameter, that could be consolidated, eg: java public BigDecimal getMovementCost(final Unit unit) { return computeMovementCost(steps, unit); } public BigDecimal getMovementCostIgnoreEnd(final Unit unit) { final List<Territory> territories = steps.size() > 0 ? steps.subList(0, steps.size() - 1) : steps; return computeMovementCost(territories, unit); } private static BigDecimal computeMovementCost( final Collection<Territory> territories, final Unit unit) { BigDecimal movementCost = BigDecimal.ZERO; for (final Territory t : territories) { movementCost = movementCost.add(TerritoryEffectHelper.getMovementCost(t, unit)); } return movementCost; }
setSelection takes an ISelection, no need to cast what you get from the viewer. you also do not need a local variable
I am still in favor of removing this static. I don't think its necessary. I think if tserver wants to keep one instance, then it should keep a reference to it. All the current static stuff we have is troublesome and we would like to move away from it. Could rename this method to newInstance if you drop the static.
No need to call file.toString() -> FileWriter can take File in the constructor as well.
Probably want to assert the behavior of the iterator as well
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
The this. in getters are unnecessary too.
I've noticed that some values are not checked, for example patient.display here, is there any reason for that ? I think it would be better to verify all used values
Lets pass the ListIterator constructor as method reference and do not subclass it: java return new SeqAsJavaList<T>(seq, (delegate, index) -> new LinearSeqListIterator<>((LinearSeq<T>) delegate, index));
I think we should separate concerns more clearly here: - FormValidation ensures that the value in fields make sense and if not display a meaningful error message. - DatadogClient checks connectivity to the provided endpoint for example this function should only check that the string looks like a valid url, not that the url is a datadog one, nor that it is reachable.
Single or double pipe?
Can we make logger a private static final
Why is this call needed for getting the skill level? Isn't the team's skill level stored already so the calculation isn't necessary?
why this change?
Please add also VOOBSERVER.
This seems unfortunate. Does the RS spec forbid null values?
TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - started)?
@garydgregory Please use Args.notNull for consistency with the rest of the code base.
It'd be safer to put EXTRA_SUBJECT only if !TextUtils.isEmpty(subject)
static imports
does this have to be a list or can it be an iterable?
innerInterfaceOrClass checks parentType, but in line 236 similar check is performed. They can be merged in one method
This check is useless as the customParams can never be null.
you have to add a canDoAction message if you fail canDoAction
Request.State.OPEN
extension can't be empty or /
There is no harm in setting the confirmWindow to null, but since you are not actually setting it, there is no need to set it to null.
this method suppose to return instance of DiffPagePageObject class, because its redirecting to diff page beginning of the method should be: public DiffPagePageObject goToDiffPageFromHistoryPage() and last step should return new object: return new DiffPagePageObject(driver);
according to rsdl_metadata.yaml you should be validating these fields: action.name: 'xs:string', action.service_type: 'xs:string'
This won't invoke the additional interceptors, is that okay?
Why U don't want to consider id in equals and hashCode ?
optional suggestion: since we're extracting helper methods... it's mostly "false * 4" or "true * 4", so consider adding e.g. whenEverythingIsInitialized and whenNothingIsInitialized.
nit: can we consolidate producerFencedOnCommitTxn to the more-general commitTransactionException? I.e. if you want to fence on commit, you just register the commitTransactionException as a ProducerFencedException
True. I've never seen a case with -1 as the default. 0 has special meaning in the JVM, so best to stick with 0 as the default and adjust the size to cope (add one or size 0 -> -1)
This logic flipped?
Maybe we should use a logger here, and print to a different file? In case there are issues with updating and we need to diagnose.
right ... will change it
simpler:  return (this.partitionSelectorClass == null) || (this.partitionSelectorExpression == null);
maybe we should add a log here so we know that nothing has been updated to the corfuStore and not that it is complete necessarily.
Should be a SamzaException with a message, not NPE.
The field should be removed as well.
if we continue with this convention, please init to true also here
I'm not a reviewer but FYI  CredentialModel.PASSWORD.equals(credentialType) in that order can't throw a null pointer exception, usually always the constants first because equals accept "null" but null don't have equals function.
use ImmutableList
This should be used and check the ORGANIZATION_WQP_URL.
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
Before go through the loop make sure that position and symbol parameters are not null.
What does the magic number 2 mean?
These checks should happen within the build function when delegated to the object they are building, not a builder's set function. Don't duplicate the logic.
Idem this could be handled with an Optional...
why would server be null?
Call I18N.getString(String) (there are no parameters in the resource messages).
The null argument will lead to a NPE below in notify. Leaving it as this(null) should work.
This is another behavioral change that I don't want to see in an unrelated PR.
Name is no longer used
Instead of FileHandler, you should use the PropertyConfigurationLayout to save it to a FileWriter.
Looks like there are some spaces missing here.
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
you can either remove else or add pair of curly brackets
Is this supposed to be <code>return "Bump"</code>?
AFAIK it would be good to shutdown the executor when it isn't needed.
Why do you want to unconditionally enable it here? It's definitely wrong.
can we remove this method and simply have the poolsOfString.take() where this method is called?
same here for node
return id;
Not needed?
Does it make sense to cache the result?
Same as above: I think it is clear enough without the id variable same for below too
rpcClient.close()?
Check command and status null.
suggestion return new BridgePath(virtualFile.parent(), fileSystem);
Which is perfectly valid, if there is no Internet access available. Hence this must not result in any errors being logged.
null != settings
we could use reduce instead of fold, like:  java return Stream.rangeClosed(1, n) .map(BigInteger::valueOf) .reduce(BigInteger::multiply);
key.setDataId(event.getId()); -> key.setDataId(event.getDataId()); This issue was the culprit for failing on itest profile. I am going to test the cluster profile to check if everything is green also.
suggestion return new Intent(context, CustomTabsManagerActivity.class);
Should be here ac.stateChangingCheck(); @zlamalp?
As we are not exposing the original Scan directly, why to create a new Scan again here? No need
?? why this and the following ones could be left empty?
since this is an instance variable, regardless whether it's thread local, you should have it qualified with this.
You could just use Closeables2.closeQuietly(azureBlob);
are you still creating new contexts here?
No need for a null check here, instanceof would allow both the class and null check as one.
M-m-m. Seems for me we don't have here in this application context any other listeners. Am I missing anything ?
from and to can be null. suggestion return "Script " + this.name + (from != null ? " from version " + from : "") + (to != null ? " to " + to : "");
should atleast check o being non-null and instanceof IdentityExtractionFn .
pls call this(null, DEFAULT_LIMIT)
To follow the conventions of Spring Security, please change to "webClient cannot be null".
I would feel more comfortable with this if you did something like throw an IllegalArgumentException if !ref.startsWith(oldPrefix)
nit: maybe merge the lines as the formatting looks a bit strange.
@inverno Why public?
can we use sysprop or something for url?
456L
Is start check needed? Could it be problematic (somehow delay/miss the start when it should be immediate)?
Think this needs to go right below line 91. parseResponse can return null (line 133), which will cause this future to never complete.
one more method where it can take file location of properties would be good.
why is this public?
lets return empty string "" to avoid hypothetical NPE in future code.
Just a nitpick: could we remove the access modifier to enable access from within the package?
This can delegate to the two-argument createSystem variant.
if you are synchronizing whole methods on the same object, you might as well use the class's monitor, by using the synchronized keyword in the method signature (public synchronized void ...) This avoids extra sync objects (and saves one level of indentation!)
@weisebrazil all indentations should be 4 spaces, not 8.
is this something like /system/tasks ?
do not assing parameter! nowhere!
looking at the gson code base, remove also could return null if element not exists hence we might want to guard aganist NPE here as well.
oops, I missed to merge with Stefans fix for annotated tags (calling getPeeledObjectID()). I'll add that again.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
I would guess that the work queue itself listens to the stop event and cancels the tasks. But this would have to be verified.
this variable name is misleading, it contains not only the commandData but also Ne field (see also other ApduTest classes)
what about location ? we do not need LocationSerializer ?
Used to be fileSystem.deleteFileOrThrow underneath.
unnecessary array new: {{true}, {false}} should work here
I think we should at least log this exception here before throwing other one
I believe this method should be getServerMetricConf()
This is a local variable, should be camelCase not fCamelCase
Agreed. Yep - that's why I mentioned it was fine, though it looks weird
I think baseUri.toAsciiString() always has a trailing / in our usage so with the current build() method I think you will end up with (for example): http://some.example:80//path/path/path?query=true changing to this.path += encodePath(path) + "/"; will result in: http://some.example:80/path/path/path/?query=true I think both of these are valid URLs, but I think we need to be sure there are no server side issues if we use either // or /?. @tomblench any thoughts on this?
Nitpick: AS is complaining about the unnecessary rootView variable.
What do you think about making more general methods like: verifyTopLeaderboard and decide what selector to pick inside this method? Based on wikiPage object/browser info.
Why include the name in the comparison? fullName should be enough.
bad name of method <LINK_0>
Add a message to checkState so that it's easier to debug if we ever hit it.
Same as above, this looks like an error.
I think we should sort the tags in a specific order here. Otherwise we could have tests excluded for the same reason, but the strings will not match if tags are not in the same order.
please use {}
we don't need to change the Creation classes.
addCustomValue(GlusterConstants.VOLUME_SNAPSHOT_NAME, getParameters().getSnapshotName()); return super.getCustomValues();
should be edit
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Maybe the interval can be a bit longer since maxWait is in seconds.
Hello @mcimbora , I think it can be worth to provide a more fine grained filtering here. To be sure that the method is not a constructor, has the @Generated annotation, and also "is one of the generated" by the planner stuff. Probably inspecting some additional planner generated annotation for the method (I I don't remember wrong for this planner generated method you added has also a planner annotation with two parameters?) or eventually exploring the return type, or some other trick. This will prevent us from loading other methods with the @Generated annotation that we don't know how to manage. Specially because when the java source is being updated, all the accepted methods are being deleted.
> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
can we remove the version completely?
This methods should return the index of the max/min axis: x = 0, y = 1, z = 2, but it would probably be better to remove them from the interfaces.
Now we have this constructor , what is the benefit of having default constructor and setPath() method explicitly .
I think I'd rather store the instance as a field than to have to loop through the projections with instanceof attempts? You can easily store the EntityInstance during populateWithEntityInstance.
Put the close() into a finally block so that an attempt is always made to close the session, even on rollback fails. If closing the session fails, there's not really anything we can do -- log and move on.
We don't need to cast to int.
DoubleMath.isMathematicalInteger?
Should be public.
Same here. Add clarifying parenthesis
Please don't catch general Exception class, this could catch also exceptions that we don't want to be catched. E.g. NullPointerException.
Out of curiosity, why is the return type of this setter not void?
Symmetry (throw)?
true=>false
Request.State.OPEN
I think the code will be easier to understand like that: java Object object = getInstance(); if (object == null) { clazz = getConstructorOrMethod().getDeclaringClass(); } else { clazz = object.getClass(); } ITestOrConfigurationclassAnnotation = getAnnotationFinder().findAnnotation(clazz, annotationClass);
@fanifieiev the same above.
write null explicitly rather than an empty string
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
Also, since RxJava is used here otherwise.. this code should follow RxJava patterns. Basically, instead of this codeblock, use something like  java metrics.filter(m -> publish.isPublished(m.getMetricId())).map(pendingMetrics:add)  Or make it even prettier with some more reactive handling.
can't -> could not ? I would remove even though TopologyTestDriver is shutting down (read cleaner this way IMHO.)
I am wondering if we should move the project towards scala or kotlin to make the data objects less verbose
Same as above. this is deprecated and should no longer be used.
I am a bit confused that this check will be called on almost every line of code.
"balance" -> "budgetRemaining"?
Does it makes sense to return a boolean here(indicating it the application had shutdown within the timeout). Returning void on a timeout doesn't convey if the application had shutdown within the timeout or not.
For increasing stability "wait" is better to use than "Assert":  waitUrlStartsWith(testRepo.getHtmlUrl()); } private void waitUrlStartsWith(String expectedUrlPart){ seleniumWebDriverHelper.waitSuccessCondition(driver -> seleniumWebDriver.getCurrentUrl().startsWith(expectedUrlPart)); }
could this hide bugs? Would it make sense to throw an exception or simply remove the check? Also because 0x0 is a valid code point this makes this return value a bit ambiguous. I'd be in favor of just accessing the array and let the JVM throw an error if this is possible.
there is no other (more elegant) way of getting article name
I generally don't have an issue wit bitshifts when they are actually useful but here it only obfuscates the code for people who don't know much about them
I do see your point and let me rephrase it to make sure I understand: Either we should implement the mark/reset APIs properly or we should implement markSupported() to return false. My concern remains for this use case, today: - I open a stream - I read - I call mark() and read() here and there - I read to the end of stream and the stream closes as it should - I do not bother to call close() - All is well With this change, my random calls to mark() before I read to the end of the stream cause the stream to remain open. Clearly a leak. Granted, I _should_ close a stream that I open somewhere or in a try-with-resources block but this class lives outside of this use case. It seems to me like the simplest solution would be for markSupported() to return false. WDYT? Or create a new class.
The description for the logging is the same as verifyShareScreenClosed. Perhaps the description here is "Lightbox is closed" ?
I like that you tie the default value back to the source. Consider moving the min value there as well.
use execute i mentioned above
Looks like both XmlTest and XmlSuite could share this code. Maybe extract it in a common parseParallelValue?
Or even better, this.mName = Objects.requireNonNull(name);. To be check everywhere else.
isn't missing the modules configuration and the simple cache attribute?
Create an io.realm.internal.objectserver.SessionManager and move sessions there? I am quite uncomfortable to expose removeSession() to public.
Item dropped should be a hopper
you set the prestarted to zero so VMs won't be start again after stopping them right? so you need to lock the pool because stopping the VMs might take some time and the user can update the prestarted VMs count in the meantime
Why do we use iterators? I know the base class does, but why in the first place?
I think the super will do the normal "is my Fragment there" dance? When I look at FragmentPagerAdapter source (docs aren't so good :/ ) I see: @Override public Object instantiateItem(ViewGroup container, int position) { if (mCurTransaction == null) { mCurTransaction = mFragmentManager.beginTransaction(); } final long itemId = getItemId(position); // Do we already have this fragment? String name = makeFragmentName(container.getId(), itemId); Fragment fragment = mFragmentManager.findFragmentByTag(name); if (fragment != null) { if (DEBUG) Log.v(TAG, "Attaching item #" + itemId + ": f=" + fragment); mCurTransaction.attach(fragment); } else { fragment = getItem(position); if (DEBUG) Log.v(TAG, "Adding item #" + itemId + ": f=" + fragment); mCurTransaction.add(container.getId(), fragment, makeFragmentName(container.getId(), itemId)); } if (fragment != mCurrentPrimaryItem) { fragment.setMenuVisibility(false); fragment.setUserVisibleHint(false); } return fragment; } /** * Return a unique identifier for the item at the given position. * * <p>The default implementation returns the given position. * Subclasses should override this method if the positions of items can change.</p> * * @param position Position within this adapter * @return Unique identifier for the item at position */ public long getItemId(int position) { return position; }
Leftover debug line - edit not leftover, it's just that the logger is not available. Suggested saving the error string to display when creating the exception a few lines down.
Does it make sense to set globalMinimumClock as 0 when workerClockMap is empty?
can be info
If createParams should always have commonParams and commonServerParams, why not just define it that way to start with? And I think you could make the collection a static final variable at the class level.
@cvrebert maybe MkIssueEvents.class.cast(?
Remove useless assert
can you enclose this in { } ;
Ah - guessing that we are using static Bugsnag everywhere to make this whole interface possible. Any workarounds you can think of that would avoid depending on the static class?
one more method where it can take file location of properties would be good.
This will loop forever if the user sets a negative size.
Missing a newline.
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
This looks very nice! What about adding a throws JSONException to the signature of getValueForOptionalKey() and parseImageLicenseMetadata() since you have the needed try / catch already in place for processPage()?
Try remove package
Probably should crash if bad format string
I'm not sure this is consistent with the rest of our API. Like this you always return all member-group attributes, even if caller specified eg. single group attribute in the outer API call. So you should probably check emptiness only on outer attrNames param and not on filtered values. But maybe you have different expectations for this specific method.
Although we need to figure out how to propagate interruptions, this will now cause a problem as it this method is called from within tryUpdate which is recursive and propagating here means the next attempts will also fail for the same reasons. We need to figure out how to retain the fact that we were interrupted and propagate the interruptions outside the whole thing.
I am a bit confused that this check will be called on almost every line of code.
Name is no longer used
it appears that this change can be reverted.
I suppose make it private and create via static method. To make it easer to support compatibility in the future)
just wondering, w/ slf4j do we still need the custom format() ? I hope/think that's done by the slf4j logging library
Init should only be called one single time when constructing the controller. That is done in OnStart. Please add a space between if and (
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
Encapsulation
use return ... ? ... : ...?
Also I18N is needed here
I meant this constructor should be private. You made constructor of LdapObjectDefinition private. Actually both should be.
not all listener
unecessary test : less is more.
Same here. I dont think we should be throwing exceptions.We should instead be having empty implementations.
It might be nice to also have a test with a user in the administrator group, so we can verify that it gets the ADMINISTRATE_SERVER permission.
Prefer not to have a null environment from start.
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
Maybe for cases like this where the list is only consumed once it would make sense to add a mapLazy that is based on something like this: java static class LazyMapList<I, O> extends AbstractList<O> { private final List<I> list; private final Function<? super I, ? extends O> mapper; public LazyMapList(List<I> list, Function<? super I, ? extends O> mapper) { this.list = list; this.mapper = mapper; } @Override public O get(int index) { return mapper.apply(list.get(index)); } @Override public int size() { return list.size(); } }
Some proxies may not grok the comma-separated headers; any reason we can't just do Cache-Control: no-cache here?
Method body should be: return moduleName.replace('.', '/'); without ending slash, because later this path is used in combination with "/module.xml" string.
Are consecutive reloads necessary or will be one reload at the end sufficient?
Should there be a SavedPage.markPageToDelete()? (I think the implementation would be in a different card though.)
Optional should be used in interfaces. Use null as internal value.
Use constants
It makes sense for this method to be boolean. I am not sure we should be throwing an exception here. The caller can decide that based on the return value.
Who is calling cleanup? Better if it is done by Junit after/afterclass annotations.
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
I think it's safe to remove the local recovery info in the caller thread and then return the stage. Slightly off-topic, I've been looking at RecoveryAwareTransactionTable.removeRemoteTransaction and it seems horribly inefficient. It should only iterate over the transactions when there the GlobalTransaction is not available.
Here can you assume that the value contained in uniqueId is the internal integer id and hence fetch by it?
java return (bundle.getState() & (Bundle.INSTALLED | Bundle.UNINSTALLED)) != 0;
Should this constructor one just delegate to the new one with Function.identity()?
Double* variant of this class uses object == null ? null that is better
Default should be false
see in Volt how to properly shutdown an executor service
I know this was just copied from the original endpoint but bundle can be null here (although very unlikely)
MemStore is used for tests, so we need to implement this function.
should return false if the validation fails
> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
please use (1 << priority) instead of priority + 1
jsonObject.get(name) can return null if element does [not exist ](<LINK_0>, we might want to ensure it's not causing NPE in JsonNodeUtils
I think we can avoid this .INSTANCE. business by putting the fromV1APIJson method inside a companion object.
These implementations are fine, but I wonder if the code wouldn't become a bit simpler if the defaults were stored as String values, and instead of the parameters.containsKey(String) you would do something like: return EventLogCategory.fromValue(Helpers.getString(parameters, PlatformSmartmeteringKeys.EVENT_TYPE, DEFAULT_EVENT_LOG_CATEGORY)); as a one-liner.
If I understand this "fix" properly, we were basically creating a new appender for each test, which you're now auto-closing. Plus, you're creating a new logger for each test. Would it be possible to just have LogFixture take in a level, and auto-generate the logger name, so it does not need to be passed in, even if just to avoid copy-paste errors?
remoteVolumeName passed twice. I feel remoteHost to be passed as second arg
Can you just change the return type of this method?
Just want to double check that the following null check is correct:  if (mScrollDirectionListener != null) { mDetector.onTouchEvent(event); }  I think yes, since mDetector is always not null, and it fires updates on mScrollDirectionListener.
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
Replace by Map<String, String> result = new HashMap<>(map.size());
This should follow the normal exception handling path and let the caller handle the printing of the exception.
So, if the xpath query matches event than this method will return true, right? Than the event will be propagated to TreeWalker. This java if (!filter.accept(event)) {  will be evaluated to false and the message will not be removed from the set. Thus, what is the sense of the suppression? What do you filter? Look at testMatching. The user writes the query /CLASS_DEF[@text='InputSuppressByXpath'] in order to suppress the violation, the filter should deny the event, but your filter will accept it.
Please use assertThat (result, failsWith(NAME_OF_FAILURE))
@RomanNikitenko just FYI - com.google.common.base.Strings#nullToEmpty
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
Why did we make this public?
How about inlining it?  if (!contains(o)) return false;
could be simplified: Collections.addAll(refsSpecs, specs);
Formatting issues. Please use appropriate spaces between string literals.
Can we name this in a way that makes the distinction with shouldSuccessfully_authoriseForAChargeRequiring3ds clearer? shouldAuthorise_whenRequires3dsAnd3dsAuthenticationSuccessful or something?
Should be a SamzaException with a message, not NPE.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
You create a getColumnNames(table) method later on in this class. This change is unnecessary, as it should just use that other method.
Keep an static GeometryType array private static final GeometryType[] ID_TO_TYPE_MAP = new GeometryType[] {POINT, MULTI_POINT, ...}; Then you can avoid the switch branching for better performance return ID_TO_TYPE_MAP[id];
Are you sure that you should check value on null here?
Argument name
This will trigger for thread exists also. We should make sure we are dealing with a process using: if (event.getDMContext() instanceof IContainerDMContext)
Use Arrays.asList instead.
Same question as above
I meant this constructor should be private. You made constructor of LdapObjectDefinition private. Actually both should be.
Not sure if you noticed, but you can use a different notation here: suggestion return Optional.of(path).filter(Files::exists);
You're invoking generateEvent twice
What about the previous mImageReader instance ? It should be closed when detached .
Are you sure it's a good idea to throw an exception here? I'd better return Optional. It's pretty uncommon to throw an exception from Protobuf message.
Can you specify the exception/message being thrown on this call? Otherwise you could use the Assert#nonNull(T, Supplier<String>) function contained in the framework. Doesn't return the field like requireNonNull() though. :/
Shouldn't there be an assertion checking that the shipping method was actually set, price and all?
why rewind?
Please add a java Objects.requireNonNull(computation, "computation is null");
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
Missing codes.
Use Arrays.asList instead.
Can we have a thread name here?
must be package local
suggestion connectionFactoryList.forEach((ldap, connectionFactory) -> connectionFactory.close(); );
nitpick: tab
Should be a SamzaException with a message, not NPE.
use ShellIsAvailable
DatalakeClusterUpgradeTriggerEvent should be renamed as it is general now
Should this method be in the account object instead? Something like isRegistered():boolean?
The code can be simplified to rely on autoboxing.
![Codacy](<LINK_0> Issue found: [Use explicit scoping instead of the default package private level](<LINK_1>
do we care to check the length to be positive here?
Lets keep these methods internal for now (package accessible).
I thought you wanted to end this practice, Adrian?
Yeah this should be return set.get();
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
I don't understand why you verify if filterChain needs to be updated with every message read. Maybe filterChain should be volatile.
Not following XWiki codestyle.
If we log an error that doesn't have any vararg arguments this will throw an exception from what I understand.
Should it be possible to extend this Stats-class? If yes, this instance creation should be extracted into a method.
You might want to consider creating a ViewAction1<T> abstract class to contain the reference to the WeakReference<View> and avoid having a Field for the view in all your Action1 implementations?
> Alternatively, as we're concerned about usage of the image in a Wiki article, I think it makes sense to copy the wikicode for the "thumbnail" image rather than the wikicode for the full image. I agree with the thumbnail approach, pictures are almost always displayed as thumbnails in wiki articles AFAIK.
Not sure, why not use @NotNull?
Null comparisons can be replaced by UtilMethods.isSet(object)
This is a bug! The requested interceptor might not be in the list, so we should decrement only if true from remove().
Why is there a fromByteArray method? Why not call the constructor directly?
Why first the connect, then the check and disconnect?
This caused problems in the tests for me. A better approach here (and ultimately more user friendly) would be variable length second fractions. An example of this is here: <LINK_0>, along with adjustments to the tests to make sure they are consistently truncated (H2 supports milliseconds but the tests were comparing it to microseconds on my machine).
You need to add a check: if (!(selection instanceof IStructuredSelection)) { return null; } This will also make sure that selection is not null; Also, usually we cast to IStructuredSelection instead of StructuredSelection.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
It is there to compare a string with "\n"'s in it to some output which contains some kind of line ending, which is normalized to "\n" so they match. If I remember correctly :-)
@ztravis synchronized scope, can be more smaller, like below.  private final Object getDateFormatLock = new Object(); public DateFormat get() { DateFormat dateFormat; synchronized (getDateFormatLock) { dateFormat = (DateFormat) threadMap.get(Thread.currentThread()); } ... return dateFormat; }
"Modifier 'private' is redundant for enum constructors"
Do we need to do this here? This seems like it's creating a circular dependency of the EMF into Guice, but the EMF depends on Guice.
Instead of this constructor using the other, I would make the other to use this constructor with a null linkUrl. What do you think?
I think you want to do this in the reverse order
> There is one new test cucumber.runtime.junit.CucumberTest#cucumber_can_run_pickles_in_parallel which is now failing. I don't quite understand the problem at the moment - could look at this another day but think you know this better than I I reckon this has something to do with it.
Remember to revert this file, it should know about the transport class.
Since "hasErrors" is a primitive boolean initialized to false above, and since it's being passed to the service by value and not by reference, the variable will stay false and hence this "if" block will never be executed. You may want to rework this part accordingly (along with any other areas where you were expecting "hasErrors" to be passed by reference).
Maybe its just me, but this calculation looks wrong, since we are assign a = b, then b = a % b will always be 0, since a = b. Shouldn't it be: long c = b; b = a % b; a = c;
We don't include the underscores in the field names.
getFirstName() considers empty getNames(), getConcatenatedName() doesn't.
Generic type not used, remove.
- log warning that option is not supported by SNMP
shouldn't you do a defensive copy?
The default matcher tests equals() AFAIK. So basically you can do: this: Assert.assertThat(myVar, Is.is("expected value"))
This thing does check the value for not being null. So the previous expression is redundant.
The original constructor can delegate to your new one, i.e.: java public KafkaRecordSupplier( Map<String, Object> consumerProperties, ObjectMapper sortingMapper ) { this(consumerProperties, sortingMapper, getKafkaConsumer()); }
Might want to call out (method name? or at least docs) that this is non-daemon since a lot of the other methods in this class seem to use daemon threads
not all listener
Here we need to check the OMResponse flag also. As for existing acl, we should set OMResponse response to false. And in that case, we don't need anything to be added to DB.
But we have already clicked the button in the command before, haven't it?
Looks odd to use buffer a couple of lines above and payload() here since both refer to the same thing.
As requested in another pull request, please have a utility method for building a CommandRequest by command and context. There should be such a method already.
The order of the arguments is reversed - it should be assertEquals("Vds id is not empty as expected", "", result);
Now we have this constructor , what is the benefit of having default constructor and setPath() method explicitly .
Don't call getMethodName twice. See the implementation. It is slow method!
I know this default is here for backwards-compatibility but I'm not sure about the value. If I create a factory - "OffsetDateTimeFactory" - I wouldn't want that to be the logicalType name. In other words, what do you think about the default implementation being: default String getTypeName() { throw new UnsupportedOperationException(); }  This way it is required by any new LogicalTypeFactory to implement it?
are you sure this is the best way to handle this exception?
Please use the positional parameters.
<LINK_0> Let me know if you have any issues managing or adding items to the project
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
@fuss86 we probably need to check that there were no exceptions here.
ArrayUtils.isNotEmpty(doc_string) so empty string is treated as no doc_string
use a Constant
instead of e.getMessage() use org.apache.commons.lang.exception.ExceptionUtils.getStackTrace(Throwable) to capture full stack trace.
name or zoneName?
Remove all "null" cases. There is a default case for that.
We try to prefer these to be the proper enum for the getter/setter methods, with the translation of char<->enum hidden inside of the getter/setter methods. That way we store the smaller char in the database, but application code isn't exposed to the database's insane char based storage.
replace with ReferenceCountUtil.release(msg)
is the server name mandatory still ?
replacing this with helper method would be great
Just to confirm, you know if TIME_MULTIPLIER is 2, not only will this speed up time by 2 (like you would expect), but also jump 44ish years into the future, since System.currentTimeMillis is posix time. I'm not sure if this actually matters or not for the way we're using this.
How about "Type is not supported"?
Make a copy of the keySet like ImmutableSet.copyOf(modes.keySet())
Avoid the intermediate variable and directly assign selfID.
Perhaps we should explicitly prevent nulls here (and for password) Misc.checkNotNull(username, "username") or whatever exact syntax it is?
super-method only
final?
StringBuilder
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
We require complete input validation here. I miss the validation of the network and an error message if validation fails. Please use NetworkValidator.networkIsSet(), you could create a Validator like UpdateNetworkValidator
this is 3.3 feature, not 3.2
Please remember this ctor changed.
If I were you I would just remove all nodes from parent, sort them using Collections.sort and add back to the parent in the sorted order. This will make the code more simple and less fragile.
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
the attribute is not used
It's beeter to used int type.
Check first that target is not null.
return (Number) config.getAny(parameterName);
use return ... ? ... : ...?
it needs to be protected against concurrent modification
why not replace these two lines with return (getState(key) == State.SET)
idx -> index
is this needed?
this param is unnecessary
Remove by dn/key.
I think it should return Array here.
Everywhere we call entity.getClass - we need to use the EntityDictionary.getTYpe instead.
Why are you changing to patient 7 here too?
Log debug - not info.
url should be checked for null.
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
please remove else, code will be more readable
What if we have only private static boolean isIncluded(String[] groups, Collection<String> includedGroups, Collection<String> excludedGroups) instead of 2 methods?
it can be replaced with Objects.hashCode(channel) (since java 1.7)
this imply hostedEngineVm may be null. shouldn't other flows consider the same ?
Should this really be public?
Please, use text "Projects base path" (Name was fixed after sending this pool request) thank you.
This can be made static
I guess this should be NilColumnValueSelector. Otherwise, this will throw NPE if any aggregator needs ColumnVauleSelector like in HyperUniquesAggregatorFactory.
why is there "waitForCongratulationsLightBox " in PageObjectLogging.log, if you don't wait for lightbox? Maybe it should be waitForElementByElement method or in PageObjectLogging.log method should be "closeNewWikiCongratulationsLightBox" and "Congratulations lightbox closed".
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
This extra check is not necessary: species is required and will never be null.
This is the bug. I overwrite anonymous with Registered Users.
Why not public access?
It's better to use static import here to improve readability of code.
I think we will have to discuss whether or not to include the fromKafka functions in this class.
shouldn't print the stack trace from the test
you set the prestarted to zero so VMs won't be start again after stopping them right? so you need to lock the pool because stopping the VMs might take some time and the user can update the prestarted VMs count in the meantime
nit: can we consolidate producerFencedOnCommitTxn to the more-general commitTransactionException? I.e. if you want to fence on commit, you just register the commitTransactionException as a ProducerFencedException
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
Verify that at least returns one element?
why this is in vmCommand? should be in stopBase command
You shouldn't depend on the expected value passed by the developer - you should go by MaskValidator.getInstance().isMaskFormatValid(mask).
add Reporter.log(String.format("<br>INFO&nbsp;&nbsp; - Accepted alert <b>%s</b>", alert.getMessage());
No need for the instanciation, right?  webView.getSettings().setJavaScriptEnabled(true);
I think we should store ignoredRegions instead of ignoredLineNumbers. Single lines that need to be ignored can be stored as <LineNum, LineNum>.
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
why is this public?
Could we get a deadlock now in some cases? #reset holds a lock for the outer ProxyWhitelist, and when this is called it will also acquire the lock for the delegate ProxyWhitelist. Do we know that the locks will always be acquired in the same order? I would be surprised if there are cyclic references between instances of ProxyWhitelist, so my guess is that it should be fine, but it would be good for someone to confirm.
this can be stored as a field; an ObjectMapper instance is threadsafe once constructed
what else? any warning or exception should be there?
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
Please add assertion for exception cause type and message, we must be sure that it's really expected exception.
Rename -> CosmosDbFactory to CosmosFactory
I'm not sure why this variable is needed here. Could be: java public static String getAttributeValueFromString(String string) { if (string.length() > 0) { return string; } return null; }  This functions also will fail if string == null. Should be something like this: java if (string == null || string.length() > 0) { return null; }
- log warning that option is not supported by SNMP
Why does the handler require a zkUtils reference itself? Same for the other one.
Boolean _final
Can you specify the exception/message being thrown on this call? Otherwise you could use the Assert#nonNull(T, Supplier<String>) function contained in the framework. Doesn't return the field like requireNonNull() though. :/
i wonder if using Pattern.compile() as a static member to hold the compiled expression is more efficient.
don't need optional, just use ImmutableSet.of(ports.get(getNodeType()) should work
entries.forEach(LedgerEntry::close()); entries.clear(); entries = null;
you can also write this as return sql.replaceAll(TRIM_SQL_PATTERN_STRING, " ");
use return ... ? ... : ...?
I think you need a null check here similar to the getViewIndexId. If the view index was created by an old client it won't have the VIEW_INDEX_ID_DATA_TYPE and you can assume its a short.
There's no point to else here...
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
Should we add: Objects.requireNonNull(record)?
Can you also rename the other instance methods named compile? The only usages are in CompilationTestHelper and ErrorProneTestCompiler.
return Objects.requireNonNull(remoteFuture).get();
- [x] Why need this? Please re-consider based #768.
restore empty line.
final And you're not checking dates aren't null
As IOUtils has been imported why not just use IOUtils.closeQuietly()?
please rebase, arik removed the lock in a different patch.
"valid times" should probably be "setup time" or just "setup"
should call super: <LINK_0>
fSuffix is guaranteed to be null at this point, but it's preferable to pass CharArrayUtils.EMPTY as the third parameter to minimize amount of work done inside the getSuffix method.
Why can't the implementation of this method be pulled up here?
This is not time zone?
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
I don't think this is equivalent. There are other variants of DOWN than WONT_START and if those are true the existing code drops into a call to AbstractDeploymentUnitService.getStatus. And that checks a StabilityMonitor for both failed and problems and if either are found the result is DeploymentStatus.FAILED, not DeploymentStatus.STOPPED. In other words, DOWN due to missing dependencies -> DeploymentStatus.FAILED.
I'm not sure about public modifier here as version field represents reference's implementation details. I doubt consumers would be really interested in it. I would leave it private (or even remove it) unless there is a real usecase that requires access to its value. Making it private later would be hard (due to API breakage), we can make it public later without any problems.
And then else if this
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
For this value, we should do something closer to what ProductDTO does. Leave the building of the URL to the actual entity so we don't have two implementations of it floating around. We should also update Pool to be nicer about generating it so we either generate a valid URL or nothing at all (see Product for an example)
Missing final
"line"
please check here isSetPmProxies() otherwise you can get NPE
No, this isn't good. With this way we lose all the customization provided via the common shared config for EvaluationContext. I'm that won't hurt to evaluate just to Object and check it to the supported String and BasicQuery types. And of course convert String appropriately. That's how we will still pursue the backward compatibility and flexibility. Thank you for the update any way! Will take a look tomorrow closely. Right, that looks pretty much possible to backport the feature to 4.3.x
The methods to add or remove a listener are usually thread-safe in Smack. This is not the case here.
The streams created are T1 and T3, but the ones added here are T1 and T2. Something is not right?
Could the cipher suite be made configurable?
this can be null, and shouldn't be. So either create an empty map, or check if it's not null before.
I don't think it is useful for us to organize the tests using "regression" category. I'd rather see them in the regular test suite.
suggestion this.cause = requireNonNull(cause);
Check null. The caller might pass an unknown type.
Will this have any effect to legacy data (i.e. those existing before this PR)?
Perhaps we should explicitly prevent nulls here (and for password) Misc.checkNotNull(username, "username") or whatever exact syntax it is?
What about testing the happy path - that a POST is made to a correct URL if correct arguments are provided?
does it make sense to send 2 versions of the verb to different hosts in the data center? (if one is older than 3.3 and other is 3.3) i think you should use storage pool compatibility to be consistent with all hosts in the storage pool.
you no longer need those methods to be synch right?
But why do we handle 400 differently than all other errors?
Is this method really needed? It's similar to make init public
I don't think this should be removed, since looking at the setup code the cookieBasedClient isn't the same as account.
If you'll eliminate the lock, accept method will contain just "this.value = value;" statement
The value returned by isPlaced depends on the mapped flag as well. It would be a lot simpler if this provider had tuples of [seqID, start, mappedFlag, usePositionDeltaEncoding, expectedIsPlaced], with test cases for each possible combination, and the test just created a new record for each case using those values, and verified isPlaced.
map(Queue::getActualName)
Is this method really needed? It's similar to make init public
Another question, this is something I am not sure. No true or false passed in here as 3rd parameter in line 962. THe function signature has not default value. What value would be then for this invocation of fireDataChangeEvents?
The first object in the database may not necessarily have an id of 1. I think a better implementation would do a find with an order by ascending id and limit the query to a single item.
throws TaskException is part of the interface, did you mean to remove it?
nit: not sure you need two statements here
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
Use this.key
not so readable. looks like good candidates for parametrization
similarly
Don't set statusCode in this class, just delegate to the appropriate super that takes a statusCode.
why not use the MessageLevel type?
It should be Memory metadata/dump disk could not...
This test case in error-prone. Both the first and the second statement may cause an AssertionError. Try using try-catch instead. This may help us to determine that the AssetionError is thrown from the second statement.
Not using curly on the else branch? :)
You are still programming in Javascript here. :-P What about replacing "" with null here and remove "" from the variable declaration?
optional: consider returning this from setters to support chaining configuration.
It should return ReadOnlyDictionary not ReadOnlyDictionaryInterface. Also IIRC, ReadOnlyDictionaryInterface is internal for Java.
This involves a look up of the character encoding type table. Use MessagePack.UTF8
Looks, the assertion call is missing.
unnecessary array new: {{true}, {false}} should work here
Shouldn't this be new Fraction( t.getBitsPerPixel(), 64 ) instead of new Fraction( 1, 64 ) here?
> APIEvent(final String eventName) { [](start = 4, length = 34) nit: new line please. #Closed
You could use ternary if for this: return getVds() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST) : ValidationResult.VALID;
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
I don't think exception should be swallowed
can be simplified with java return o == this || (o instanceof Incomparable && Objects.equals(s, ((Incomparable) o).s));
Could we instead check that this thread is fZoomThread? That should always be the latest. It would also prevent any applied result after we set fZoomThread to null (e.g. in traceClosed()).
Looks like this should be withoutActionBits(permission.getActionBits()).
should the interface not the implementation suggestion public List<String> getTopics() {
this.currentLocation.get() this may fail, as the currentLocation is not always guaranteed to be set. Check for presence
normally we use italic text for info icons like this: numaInfoIcon.setText(applicationTemplates.italicText(message));
Better to return an empty Hashmap than null.. Check the upstream code..
Instead of Cruel Deceiver you should add {this}
final
return Collections.emptySet(); ? BTW, it seems that class DummyGroupMapping is never used now, do we need scrubbed it off?
I think this should be fieldSet, as there is existing fields method (that returns Iterator)?
Wait, this is worse than the previous version. What happened to the assertEquals()?
please verify response on remove()
why not set to cause.getMessage() ?
wouldn't be better if we returned next date directly like: return generator.next(new Date());
No need to override this or the following method if you are not going to handle commands or updates.
I would prefer to use String.valueOf(value)
click on element
Why contains instead of equalsIgnoreCase?
"engine" can be extracted to constant
This function should be a single line (inline return).
"http.url" is the current name, when query parameters are present (which I think this is..)
assertThat(a.val()).isEqualTo("foo");
This is an anti-pattern. Use a StringBuilder instead. Why not comma instead of |?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
this is just a setter, why we need to update it?
Looks redundant.
This plays the current, not the next station.
I would suggest You to use Logy.d here instead, as we did it [here](<LINK_0>
@aschworer same here, once used variable minTime can be replaced by delay
I think that may have been an oversight in longSum. Try a query that results in +Infinity at the historical level and you will see why it is needed to deserialize at the broker level
This should probably throw an IllegalArgumentException if it is provided a conf object that is not of type StatefulMongoDBRdfConfiguration because the code will not work if that is the case. Throwing an exception make it easier to hunt down that bug.
does this need to catch all exceptions?
These two could be simplified to assertNull.
return Arrays.asList(ERepositoryObjectType.PROCESS_MR, ERepositoryObjectType.PROCESS_STORM) if it needs to be modifiable - add new ArrayList<>(...)
What if we save the return value here and close the result set immediately after that?
We may want to STATE.remove() rather than clear if these deques are going to grow significantly beyond their default size, to allow shrinking.
it's already set to true
JDBC has java.sql.SQLTimeoutException the method should check if exception is an instance of that, instead of simply returning "false". Besides, that's the exception that MS SQL Server throws on timeout.
This reads as if TenantIndex initializes the BoundedContext.
This reads as if TenantIndex initializes the BoundedContext.
Given it's for a test, I don't really care but... I much prefer using higher-level synchronization utils from java.util.concurrent whenever possible, rather than synchronize. An object.wait() can wake up prematurely, which is why one should always wrap it in a while block rather than an if block.
Since the menu item click has been handled, return true instead here.
it is possible that getItemAtPosition returns null -> sure NPE here
Shouldn't this close the iterator before returning the list?
Similar change as first(count).
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
add Reporter.log(String.format("<br>INFO&nbsp;&nbsp; - Accepted alert <b>%s</b>", alert.getMessage());
I would not silently ignore one passing a null parameter. In other words, i would remove the if check and assume that the condition is not null. If it turns out to be null, better for the caller to automatically get a NullPointerException than chewing it quietly.
Did we want to have this normalize the path also by returning the normalized version from Path?
Is that safe to call when not holding it?
Hm, I think this should probably fall back somehow in its current form, or throw a much more explicit error if it fails. Before we had a guaranteed no-error, since the array was fetched from ID resource. Now it could get removed and our error message would be incredibly vague. Especially since this can now fail due to a change in commcare-core that is quite invisible to the end-user here.
How about directly returning the result? java return this.name.equals(a.name) && this.airport.equals(a.airport);
Is this really needed?
do not call real method.
other places use "error" lower case
I foresee clashes here. Should at least use <type> + "/" + <name>
return null to make this more explicit ?
wonder if it would not be more interesting to have false here to see that we are correctly jumping into the catch.
In the wonderful world of JUnit4 ;) you can use @Test(expected=IllegalArgumentException.class) public void testCallsiteCopy2() { new TmfCallsite(null); }
should this call SQLUtil. sanitizeCondition instead?
This must be supported.
assertThat(a.val()).isEqualTo("foo");
- log warning that option is not supported by SNMP
Same here when trying to save the context without specifying the script (or when trying to import the context).
spelling: radious -> radius
move this setter on top of methods. then should be all getXXXxxxToken then should be beginTree
You should not change this, it is not backward compatible.
Should we better make this method package protected to only allow jackson access to it?
This seems wrong, it should be rawField( absoluteFieldPath, Object.class ). And tests do not fail, so you're missing a test here.
Better style to revert and remove the static import.
CheckReturnValue?
Please parenthesise nested ternaries.
![MAJOR](<LINK_0> Make "isExcluded" a "static" method. [![rule](<LINK_1>](<LINK_2>
I guess we could make it more concise as: java if (!parameter.isAnnotationPresent(Auth.class)) { return null; } else if (principalClass == parameter.getRawType()) { return new PrincipalContainerRequestValueFactory(); } else { final boolean isOptionalPrincipal = parameter.getRawType() == Optional.class && ParameterizedType.class.isAssignableFrom(parameter.getType().getClass()) && principalClass == ((ParameterizedType) parameter.getType()).getActualTypeArguments()[0]; return isOptionalPrincipal ? new OptionalPrincipalContainerRequestValueFactory() : null; }
this variable name is misleading, it contains not only the commandData but also Ne field (see also other ApduTest classes)
Adding this to a field is good manner.
CheckReturnValue?
final This should probably contain this.value = value at some point... and it should only do so if isListening = true.
Shouldnt we have this defaulting to the common namespace (ICommonAttributes#COMMON_NAMESPACE) so that we can tell the user what this defaults to?
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
Please have a look at org.jboss.as.controller.operations.common.Util.createEmptyOperation.
This is an anti-pattern. Use a StringBuilder instead. Why not comma instead of |?
I would prefer not to use null ... just a empty set and then assert that its not null
Perhaps you fix this in a later commit elsewhere, but there shouldn't be a setter here as this object is no longer immutable.
Should close kill the memspace? What if someone want to reopen the key?
suggestion assertTimerEventEmpty(emptyTopEvent.getExecutionSet(), CANCELLING, EMPTY_VALUE);
can this be part of new module as InputSource seems to replacement for firehose related interfaces ?
Then I wonder if this is the correct behaviour in the case of garbage being returned. Isn't the contract to retry in the case of invalid reads?
I don't see the benefit of this. It does make it less obvious that it is the same object having cancel called and being set to null below.
Are locks needed in Build and Merge Aggregators alike?
@vilchik-elena Charset.defaultCharset() should be replaced with a given charset.
isn't the currentRow the instance of RowBuilder which was just added?
Shouldn't this be HttpCustomHeaderClient , not HttpClient?
Should we log this to TRACE at least? Just in case we need to see this happening? As long as any formatting happens in varargs / parameters, we can avoid the cost of formatting a string in case TRACE is turned off.
You can remove the one line above and rely on the below one.
same again: do not create a new empty exception but reuse the old one.
perhaps if not has permission?
The sensitive flag should apply to all payload types, not just string ones.
this mapping should happen via public enum and not via mapping backend enum to string
It seems that the following does the same thing with super.unparse(...).
Request.State.OPEN
You shouldn't expose your internal list directly, callers are then free to modify it. What's the use case for this method anyway, is it really needed? Should do ImmutableList.copyOf() or Collections.unmodifiableList() if you really need it (the latter is more lightweight, but the data can still change under the caller's feet, which can cause problems).
You can actually represent 2 \* Short.MAX_VALUE by subtracting Short.MAX_VALUE for each offset and then adding it back when reading.
Please make the constructor private to be consistent with the other controls. Instances are created via the Validation API.
suggestion return componentName == null ? "Unknown" : componentName;  If this goes to the UI, we're gonna need i18n for that.
You're probably making this public for test purposes. Instead of making such methods public, we should be having the tests in the appropriate package so that we don't need to use the access modifiers inappropriately. I say inappropriately because this method shouldn't really be exposed to applications, it should not be public.
Unless I'm missing something, testFinished(class) == testStarted(class) (either a test starts and finishes, or it never starts). Can we just have one method (perhaps named wasRun)?
Is there a reason why this method throws InterruptedException?
I thought I already implemented this for the MavenArtifactGenerator...?
suggestion assertkeyPair(file, null);  suggestion assertkeyPair(file, null);  suggestion assertKeyPair(file, null);
Returning false seems fine, you could also return (enable == modifier.isEnabled()) to make it clearer.
Conceptually, this should be readRaf() since querying the length is a "read" operation. (I realize that in practice, it won't matter due to the exists() check beforehand, but the code looks strange/wrong with writeRaf() here.)
Class and constructor can be package-private as only used internally.
Not sure whether this will work, If it does, do you think it makes sense to just clear out the offsets for the partitions that got reassigned, This way we will still have checkpoint state for the partitions that didn't get reassigned?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
why not use builder.append(SEPARATOR).append(value) . In this way , there is no need to remove last ":" in build method.
Please do the List changes in a separate PR. This PR should contain only benchmark changes.
Why not use if
Check for null
I would move this to a constant so we can access it from tests as well.
Feel free to simplify the code by getting rid of some of these constructor variants. I would lean against any of them that take String instead of DataSource, and against any combination of arguments except 1) (source, schema) [rest default], 2) (source, schema, delimiter) [rest default], and 3) all arguments specified.
Any worry about case sensitivity wrt to scopes?
more specifically, it's going to try and use writerFor(JavaType)....but that's just a nit
30_000 sounds too long here. What if the shutdown method fail? Will it take 30 seconds to fail this particular test? I'd like this combination: Thread.sleep(5000) and islessThan(1000). If JVM can not interrupt the sleep thread within 1s, there must be something seriously wrong.
Isn't a HTTP Status 404 just enough? Do we really need to write a json message as well?
Same as in Alientype2.java (add type of alien)
use return ... ? ... : ...?
trivial: orderedTenantsIds -> orderedTenantIds
Why this change?
does this need to catch all exceptions?
Should just return properties.get(), the containsKey() call is redundant.
cosmetic: move the catch line to prevous line following }
This does not need to be public. Instead, just pass the builder to the private constructor. See what we do in HtmlRenderer.
Should probably remove(key) if value == null.
Please use ? ternary operator
can builder even be null? if not, it is just getSslBuilder().build(), or in-line it.
use hasNext instead of contains (do not use toIterable() we want to check Iterator)
Fix please :-)
maybe worth calling this TimelockRpcs or TimelockRpcClient or something like that? TimelockServerInterface seems a bit fixable...
I think that the process here is confusing, failedOvfDisks seems to be out of context. Perhaps a better solution would be to have updateOvfStoreContent return boolean value, which will indicate whether the update succeeded or not, same as being done with createOvfStoreDisks
move it before synchronized
Is this thread-safe? I guess, maybe, although it might do extra work since not all threads will see the update at the same time. I'm also not sure if ParseSpecs need to be thread-safe; if it's an issue could you please double-check it?
Does this also require a null check similar to setcontentType() ?
Consider replacing both of these with a private utility function to getSafeLogTag that will truncate (and warn) and could potentially be extended in future to do other sanitizations. That way your code reads more clearly: java String safeTag = getSafeLogTag(logTag); // Or sanitizeTag or normalizeTag, etc ...
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
This class has no fields so its methods should be static.
this seems like it should be a try() with resources
should the second arg be true here?
Maybe its just me, but this calculation looks wrong, since we are assign a = b, then b = a % b will always be 0, since a = b. Shouldn't it be: long c = b; b = a % b; a = c;
Revert this.
I would turn this && around. A simple deadlineName check is a lot cheaper than the full parameter assignment verification.
not needed; just cut it
We can do without final here since the whole class is final.
better return a null object (new Pair(this, null)) or throw UnsupportedOperationException
I would prefer not to use null ... just a empty set and then assert that its not null
String.format("%s", s) is s, therefore filePath() will always return fileName, so it is obsolete, and we should consider renaming fileName to filePath.
> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
needs 2 _arguments_, plural
Should this be delegating to a different method than encodeLink, above?
store variable
If we can't get a model-set, will anything work? Perhaps this should throw an appropriate exception in that case.
Code style. Private constructor + static factory method
Possible NPE here unless I am mistaken -- there may be no defaultValue.
Shouldn't you rather log directly?
nit: suggestion if (CookieParam.class.equals(annotation.annotationType())) {
suggestion public @Nullable ImageIcon getImageIcon() {
change variable to something more meaningful
These checks should happen within the build function when delegated to the object they are building, not a builder's set function. Don't duplicate the logic.
I this refactoring, very nice. Could make this method protected.
shall we add some message here?
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
Not ImageJ style.
Do we need some escaping mechanism to guard against the possibility that 'table', 'column' names might contain special characters (like "(", ")", "'", etc.)?
please use "else if" since only one option can be valid at a time. Please also format the code according to the Eclipse coding standards.
Use assertThat instead on assertEquals everywhere e.g.  assertThat(modelMap.get("login_error"), is(false));
Code style: Always use curly brackets, and space after if.
Could you change this into assertEquals(expected, result) ?
This should be package scoped, not public.
Is there a reason we need the executeInternal() method, given we could just use execute() in the executeToX methods?
Prevent from inlining. We do not want this to be inlined and constant folded.
add null information
nit: you can merge both lines above as checkNotNull will return the given argument
A set seems to be a not so good choice in terms of API : order is not guaranteed for API user whereas in the case of an AST order of elements matters.
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
use Map<> on LHS?
Throw IllegalStateException is pauseDepth becomes negative.
We could call: java checkNotNull("command", command);  :-)
Should be a SamzaException with a message, not NPE.
Lets return back previous version of this code since it was more compact; and basically exactly the same.
can this throw any exceptions?
Shouldn't this replace with something like .*? Or else it seems to me it is just removing the % symbol?
instead of delegating to the super class I would instead not override this method in this subclass
do you need to check for nulls on paymentWorksNewVendorDetailDTO and paymentWorksNewVendorDetailDTO.getRequesting_company()?
Double* variant of this class uses object == null ? null that is better
given that specificity of this SV is exception type I would add the exceptionType in this.
As above, assertions the wrong way around?
magic number
You can just get it instead of doing two map accesses, doesn't work? Same with below. java return (String) dataMap.get(key);
I'd suggest simplifying this block to (and for the similar cases below):  return super.getConfiguration(igniteInstanceName) .setIncludeEventTypes(EventType.EVTS_ALL);
avoid one char names
I suggest to keep the order consistent for easier reading/comparison: * field declarations in StashNotifier (maybe) * setters/getters in StashNotifier (maybe) * default values (lines 751-758) in StashNotifier::configure * assertThat calls (lines 27-33) in ConfigAsCodeTest::should_support_jcasc_from_yaml * setter calls (lines 40-47) in ConfigAsCodeTest::should_support_jcasc_to_yaml
Likewise..
can this throw any exceptions?
nit: this is a filter function, might be better to use filter replicaIds.stream().filter(r -> replicaAndState.get(r) == state && (dcName == null || r.getDataNodeId().getDatacenterName().equals(dcName))).collect(Collections.toList());
is this problematic for cycle detection?
are you sure we need to use OSString ?
Maybe we can eliminate some logging noise by logging HazelcastInstanceNotActiveException at FINEST level? If a member is gone, then there's not much we can do about it. Also, would it make sense to keep the previous abstraction (scanMembers) so at least the member-side implementation could take advantage of InvocationUtil#invokeOnStableClusterSerial to get a clean run on all members even when cluster topology changes?
Need to verify no interactions with log
@fanifieiev it isn't the correct way to calculate hashCode. Please, look the others Cactoos classes to know how can do it.
Please replace the following 2 lines with return failCanDoAction(VdcBllMessages.HOT_PLUG_IS_NOT_SUPPORTED);
Please make the constructor private (see Invalid).
Remove this "if" statement. That said, here are a few things for future reference: 1. You use "is[Level]Enabled" to check that specific level (e.g., if you're going to log trace, you'd check "isTraceEnabled()", not "isDebugEnabled"). 2. There is no "isErrorEnabled" -- unless you disable logging altogether, it's always enabled. I suppose you could use "isEnabledFor(Level.ERROR)", but you'd only be checking if logging is on at all. 3. As a rule of thumb, unless the logging operation is extremely heavy (e.g., transforming a large object for the trace logs), you don't want to check if "Info" level or lower are enabled, only higher (debug, trace).
Let's keep the boxing as is please and focus this PR on the new API. If you want to go through the whole code base and consistently use one boxing style that's a different PR IMO. But: I prefer to know when boxing and unboxing takes place since it is not free; this gives the compiler the opportunity to flag unintentional boxing and unboxing and let the programmer decide that's really what should happen.
I meant, we don't need a separate method. Lets do the things in power.
This condition seems like it'll fit in InstructorCopyFsToModal.java more, to reduce the reliance on that id string.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
Does this have the desired effect on UTF-8? I think a lot of images end up starting with a pile of underscores, sometimes even just "_____________.jpg".
you could replace this line with this()
Minor: since locateMember has been renamed to locateMainArtifact, maybe downloadMember should be renamed, too?
I thought we had agreed that to preserve idempotence the local operator would always overwrite any existing view definition?
Is it really worth checking before setting it?
It's a good update
return settings == null || settings.isChatColours()?
We're on Java 8, so: IntStream.range(start, start+length).toArray()
It's Comparator.reverseOrder()
Use RS_MAINTAINER instead of ALLOC_MAINTAINER ?
parentheses please ;) return (number == null ? null : Long.valueOf(number.longValue()));
This is now comparing to the value from cmd.getRefName but before it was ctl.getRefName.
Set read and connect timeout. Ex: final HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory(); factory.setConnectTimeout(httpConnectTimeout); factory.setReadTimeout(httpReadTimeout); RestTemplate restTemplate = new RestTemplate(factory)
I would suggest to use a mock Subscriber here. Then the test should just verify onCompleted() is never called. Also you may want to test the behaviour for onNext() and onError()
use return ... ? ... : ...?
Please don't catch general Exception class, this could catch also exceptions that we don't want to be catched. E.g. NullPointerException.
This implementation looks odd: Don't you want to check that obj is an instance of NotLoadedFragmentMatch? Here a list with the same elements will be equal to this object, it seems dangerous.
Move String values used more then once to a constant.
Why setting Token or MID imply sent = false ?
Please use StringHelper.isNullOrEmpty()
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
Recommend to use ToStringBuilder
+/- 1 confusion: suggestion this.startDistance = start;  that was the last one.
The last assert is different from the first 2
Is there a more specific exception that can be caught?
"prefix" has a null check in the constructor, so the nullToEmpty call is not needed here
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
suggestion thrown.expect(containsCause(new ValidationException("Option 'csv.quote-character' must be a Character.")));
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
String.format
Why singular?
use 'L'
With set() and find() now bypassing Square and using Entity directly, should we have get() return List<Entity> ? That way the Square class won't have to be public, it'll be an implementation detail.
I don't think this should be public; or even be a method.
any reason for explicitly invoking super.toMap() ?
@lautarobock I believe there is a need to forward exit call on the Pass instance corresponding to the index.
If url params change order, this could create a false negative. I think the .equals method of Uri could help to insulate from param order: <LINK_0>
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
Should also have tests for strong with preceding character content, and following character content. (those are areas where we've had troubles before)
Why don't you do this at the end of the running phase?
I must be missing something; I don't understand how the above change would make any difference performance-wise. Was this change made to be more readable, rather than to improve performance?
Use Strings.isNumeric
Also too many dots
You probably could reduce it to return type.isPrimitive() || Number.class.isAssignableFrom(type) || Boolean.class.isAssignableFrom(type) || Char.class.isAssignableFrom(type)); (PrimitiveTypes is not really needed in this case).
IMO while would be better here
static?
Is forEach better that putAll? I suppose we also need to take care of the case when params are null.  if (params == null) { namedParameters.clear(); } else { namedParameters.putAll(params); }
As we are not exposing the original Scan directly, why to create a new Scan again here? No need
Lets create constants for these strings
return null to make this more explicit ?
return tags;
Work is generic, so add <?> at least
@ivanursul, I think this should be as it was... The idea is to be able to import a strongbox.xml if one is on the path, or specified as via the parameter. If there is no such specified (and there is no configuration yet in OrientDB), then load the one from the classpath (available in the strongbox-storage-api-resources artifact).
be backwards compatible
We may also want to cancel our subscription.
It's easiest to initiate the field directly, and I'm not sure it's needed, the primitive should be false by default
style nit: we don't use curly braces around single line blocks
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Why is csrf disabled in general?
We have different conventions. Please see the spaces around brackets and method parameters, and brackets on new lines. The checkstyle plugin would crash the build. Did you try to run "mvn install -P run-its"? It would take quite long time to complete the build, cca one hour.
IOUtils already checks for null...
@RomanNikitenko just FYI - com.google.common.base.Strings#nullToEmpty
Why not in combination with above do this: setValue(value, false);
I will be nice to have more meaningful error message. E.g. "Text condition must not be empty string." or smth else which explain the problem with comparing actual text and the empty string.
minor thing, but this doesn't need the throws clause
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Typo: Ant**P**atchersPathVariablesCa**mm**elCaseVariables should be Ant**M**atchersPathVariablesCa**m**elCaseVariables
@vilchik-elena Why not simply returning bitSet?
No need for final parameters?
use Long.valueOf() instead of new Long() - always for performance reasons
If VM's custom compatibility version is set, cluster's compatibility version is ignored. That means we don't need to display any warning, because nothing was changed for the VM.
Why do you we need to keep a reference to the activity here? This will leak the app. We should use mEditState array instead.
Best to leave super() to avoid empty block complaint from Sonar.
missing {}
checkArgument(max > 0, "max must be greater than 0");
It crashes because lastSearchedText is null on first launch. check for isEmpty?
Lets use super.cleanUpUsingRest() here
What does the constant mean?
return null to make this more explicit ?
Do we need this to be public?
Should this not be by.css as well?
I'd rather toLowerCase() is applied after substring(), not before.
Hi @mderamos, Add code to check if value is not null before using substring.
What event is being waited for here?
revert this unrelated formatting change
Just a small micro-optimization here: If you swap the ItemSetting and the Material check, then this statement may execute just a tiny bit quicker as Enum comparisons are sped up by the compiler. Other than that this is looking good to go!
I suppose there is nothing wrong with this, but there is no need either, is there? (other cases of the same marked with ditto3)
I would prefer return type(type.getDefaultState()) instead, to be less repetitive.
Shouldn't this be < instead? if the end of the time range of this request is before the time range that has been updated in the traceRangeUpdated signal handler?
use return ... ? ... : ...?
Why super?
You should test for both instructor and student?
Is it possible to get rid of this?
This should probably have a higher severity. Also, should use parameterized logging instead of string concatenation.
can u extract a final constant with a readable name out of "<[ ]*/[ ]*%s[ ]*>" ?
This is a bad reference ownership. I feel this whole class can be part of TableWriter to avoid issues like this
![Codacy](<LINK_0> Issue found: [Use explicit scoping instead of the default package private level](<LINK_1>
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
Please do not catch a generic exception. Why can't the consumer of this library call finish on it's own?
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
Can still be forSchema
I see this method does something similar to execute minus the optional processing with the rowProcessor
It's not from the changes in this pull request, but to clean up a bit more, the superfluous super() call could be removed.
Optimization? putAll should not be expensive if there's nothing to put...
You want to use assertEquals instead?
this mapping should happen via public enum and not via mapping backend enum to string
calling endAction here is dangerous, I don't think we have it anywhere else. it is problematic because the execute phase was not finished and there is all the infra in CommandBase that handles it. Please call endSuccessfully directly instead (and need to verify that the 'log' method is called)
Do you think it is worth logging if there was an attempt to set the timeout below 2 minutes?
We really should define an order here. Right now you might get a random localized name, if I understand the code right. I suggest: housename, int, loc, reg, alt, old Also, note that again only NAME has other names than the default and localised ones. So a special handling of the name would be a good idea.
IMHO it does not need to be public
Maybe you could drop id and just increment sequence here?
Add an IllegalArgumentException to fail-fast when the process is null
You're probably making this public for test purposes. Instead of making such methods public, we should be having the tests in the appropriate package so that we don't need to use the access modifiers inappropriately. I say inappropriately because this method shouldn't really be exposed to applications, it should not be public.
Meh: you could use rs::close instead of a lambda. They're semantically equivalent--I just like the way method handles look. Not critical for merge, obviously.. :)
use return ... ? ... : ...?
Should return the empty list, not null
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Perhaps we should explicitly prevent nulls here (and for password) Misc.checkNotNull(username, "username") or whatever exact syntax it is?
since this Bindings needs configuration through openhab.cfg setProperlyConfigured should be called after the configuration has been read and applied properly (see method updated()
System.lineSeparator(): standard HTTP end-of-line marker is CRLF (<LINK_0> so we can't be system dependent here
Maybe we should keep the original name of the member variable and enclose the string errorMsg with single quotes. java @Override public String toString() { return "SegmentPublishResult{" + "segments=" + segments + ", success=" + success + ", errorMsg='" + errorMsg + '\'' + '}'; }
you can either remove else or add pair of curly brackets
@ptirador I mean it should be like this: java this.of(coordinates).buildPublishJson(); return getPackagePath();
can be info
nit: this definition looks really awkward
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
AFAIK it would be good to shutdown the executor when it isn't needed.
Overriding is quiet hard now that the method is private ;-)
Let's make this private and introduce two factory methods known(String, UUID) and empty()
you can also write this as return sql.replaceAll(TRIM_SQL_PATTERN_STRING, " ");
Should we add: Objects.requireNonNull(record)?
And then else if this
You're not making defensive copies of the Set, how do you know that it's immutable?
There's still a leak here because the original code is rather odd. It's opening an input stream here, and then possibly re-assigning inputStream immediately in the if below (I have no idea why). Perhaps move line 173 into an else block after line 179?
Can session.getPath() ever be null? If yes, instead of throwing a NPE (which requireNonNull will do) we should do throw new PrestoException(INVALID_FUNCTION_ARGUMENT, "Session path is null");.
Shouldn't that be Class<?>
This method should be static and need not pass this as an argument to the constructor.
I this refactoring, very nice. Could make this method protected.
This is breaking the existing conventions about allowing nulls. If we ever receive null inputstream we should throw an error here. To avoid them, we should change the calling site, not these utility methods, which operate under narrow set of constraints. suggestion
if i get it right: if response is null, we will not retry. i think we should retry even if response is null. btw what caused this in your case? so it would be:  response == null || ....
Shouldn't need the null check here: now that PP-4105 is done, connector should always return delayed_capture
The super() returns "" on null. Why should we differ?
This can be replaced with  java return newName.isEmpty();
@Before / @After could overwrite System.out :-P
we don't need to change the Creation classes.
Consider refactoring updateService to take serverId, and List<GlusterServerService>. Do not create a VDS here.
this imply hostedEngineVm may be null. shouldn't other flows consider the same ?
Can we and should we check that the short index is shorter than the long index?
call notFound
this method is useless. Can you send a patch to remove it so all the code that needs uuid will simply use UUID class?
Better to use Collections.singletonList rather than guava for this.
casing inconsistency: rocksDbDir
Don't open things up that don't have sufficient parameter validation, the @Nonnull is not enforced here because it was an internal method, so you'd need to add a Validate call here.
Stream closing?
Any reason for this change? The previous assertion with assertThat has the benefit of showing the expected and actual strings if the assertion failed, whereas the new assertion will just say something like "expected true, got false", which is a lot less useful.
your toUrl method would throw AssetionError itself, so no need to null check here
In general I wonder why one should instantiate an (immutable) null Password. I mean passing a null parameter to the constructor. Should this be considered a bug instead and hence throw a runtime exception? Should we update the copyright date to 2017?
does this have to be a list or can it be an iterable?
This is a pretty cool solution :) I think we'd need to excavate something out (or bake something into a plugin) to make sure tests run with -ea, because I just tried putting assert false in a test and it still passed!
Just to be really style-conscious, Preconditions.checkNotNull would be good on timeToLive as well. Or you could move the Optional.fromNullable to this line and change the constructor argument from Optional<Integer> to Integer.
add brackets to make this expression more easy to understand
The implementation is the same as in HostNetworkQos, please implement in HostNetworkQosProperties.
format
Not an exception
do we care to check the length to be positive here?
As I suggested in another patch, we should consider having a version for persistAsyncTaskPlaceHolder with one argument (parentCommand) which by default uses a DEFAULT_TASK_KEY. Same goes for getTaskIdForTaskKey - we should have a "getTaskIdMethod". This is not mandatory, it's a suggestion.
The error message doesn't match the actual behaviour.
This test uses the same jboss-all_fine.xml file as FineWebFailoverTestCase.java, what about using a new one for covering the reference to an existing server profile from a jboss-all.xml file? (at present we have it from distributable-web.xml file in testsuite/integration/clustering/src/test/java/org/jboss/as/test/clustering/cluster/web/persistence/distributable-web.xml)
I would recommend to use this(in, null). It would be less error-prone.
this method should be changed to private
vmNames
This should be Repository.class. The method is supposed to return the list of adapterTypes, i.e., the types to which this adapter can adapt objects to.
I would really appreciate if you rewrite this so it doesn't use -1 as startIdx. A year from now I won't remember why we want to load from position -1.
are these setters used anywhere?
there's an issue here - when running the vm as stateful, we'll get to this else block (as there's no stateless snapshot) and will detach the user although everything went fine. generally speaking, i think that in this flow we can inspect the result of RunVm instead of running the endAction() from here (Example - <LINK_0>
nitpick: tab
listeners are not notified?
break?
Can you make all of the accessors final?
this can be 'long' instead of 'Long'
I think that may have been an oversight in longSum. Try a query that results in +Infinity at the historical level and you will see why it is needed to deserialize at the broker level
Please use style instead of getStyle(), as this is more consistent with the rest of the code base. I.e.: if ((style & SWT.HORIZONTAL) != 0)
And then else if this
Please use static imports for Assert methods.
@ekondrashev Same here, let's declare Exception being thrown.
I believe a null check is needed here. A CI run has a NPE <LINK_0> at org.infinispan.query.remote.impl.LifecycleManager.processSerializationContextInitializer(LifecycleManager.java:142)
Can we set a charset? Like ASCII or UTF8?
null == manager
super.getVm() will do dao call...
Why not public access?
We should only be pulling down upstream changes here.
It does not look to be a good public API. Why would you need it here? Could it be just moved to the storage?
Should we add null check?
IMHO it does not need to be public
Should be a SamzaException with a message, not NPE.
Simple test is also possible to verify result stat. See #971.
Please parenthesise nested ternaries.
It seems we have kept these GoraHiveTestDriver setUpClass / tearDownClass? Is it possible to pragmatically control ( start/stop ) embedded server instance? With this setup can we guarantee embedded server instance is up and running before we start executing tests? There can be failures if we cannot have that guarantee.
for the case where the file is being thrown away (abort is called rather than commit) we could get away with not calling force. (that is the ATF.commit could call a force method which does a flush, force, and then subsequently call close)
This should be Repository.class. The method is supposed to return the list of adapterTypes, i.e., the types to which this adapter can adapt objects to.
better return a null object (new Pair(this, null)) or throw UnsupportedOperationException
![MINOR](<LINK_2> 'Severity: MINOR') Remove this use of "getBaseComponentId"; it is deprecated. [![rule](<LINK_1>](<LINK_0>
Yes, it shouldn't be cached in memory.
Is this correct?
return id;
If using Function<ClientBuilderImpl, T> for the build function type, instead of a custom interface, this method becomes return builderFunction.apply(this);
Instead of this constructor using the other, I would make the other to use this constructor with a null linkUrl. What do you think?
Does it have to be public? Couldn't it be package visible only?
Don't we want to keep this?
Please parenthesise nested ternaries.
lets cache interruptor instance. If JIT leaves double de-reference inside the loop - its bad
Seems doing all these potentially long-running operations as synchronized leaves a good chance for deadlock. Not sure how waitUntilAllOperationsAreDone ever completes if it's not empty, since you wouldn't be able to call operationComplete(), no?
THREAD-SAFETY This is a poor construct to use for a thread-safe class. It doesn't save (that much) memory, and can be solved by using a volatile boolean set to false as a default value instead.
What I'm missing here is the check if the element is null. I know that the probability is very low, but still...
Why not have this method private?
Be careful of nullable fields!
What about using Saml2FailedLoginRedirectUrl.value() instead of getConfigKeys()[0].value()?
More efficient: getDB().getRecPtr(record + DEFAULTVAL) != 0
unnecessary null check
Call setFocus() on the table control.
checkstyle
This doesn't check all fields. Use the super.equals() to check the parent class's fields and, if that returns true, then check this class's additions ((volumeSize).
create instance of this object when requested not in constructor
Please align with Double (no protected)
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
ofNullable maybe, no?
To avoid unnecessary calculations, it would be better to return an empty list when !is(Kind.AND, Kind.OR).
I found this code called so many times during app execution. What are your thoughts about using a pre-compiled regexp to split the strings? private static Pattern languageSplitter = Pattern.compile("_"); and then use it with String[] opts = languageSplitter.split(languageCode, 0); Do you think that this will improve performance?
THREAD-SAFETY You need to make up your mind, use locks OR the thread-safe collection
- log warning that option is not supported by SNMP
I would really appreciate if you rewrite this so it doesn't use -1 as startIdx. A year from now I won't remember why we want to load from position -1.
does setBrickPosition do something different than brickPosition in all other brick tests? if not, please rename to brickPosition
checkOne can be used or is unused?
It would be good that user can resize the dialog box. If you do that set also a minimum size.
why is this necessary here?
calling is.close() might produce exception. Please define: private static void safeClose(final Closeable c) { if (c != null) try { c.close(); } catch (Throwable ignored) {}; } and use it instead of InputStream.close() method
These 3 methods should be private, or if useful outside of this controller, they should be in a utilities class
Might this be clearer as: java if (capability.equals(CAPABILITY_OFFHEAP) && isSubscriptionBasedLicense()) { return capabilityLimitMap.getOrDefault(capability, UNLIMITED_STORAGE_AMT_IN_MB); } else { return capabilityLimitMap.get(capability); }  This captures the logic of subscription licenses having unlimited offheap by default quite succinctly I think.
Should this be marked as deprecated as it is in Page?
SINGLE_THREAD_FOR_AUTOBATCHER?
wouldn't it be enough that one of these is null?
why rewind?
I assume the list is never null. right?
If you'll eliminate the lock, accept method will contain just "this.value = value;" statement
the ConnectorTopology.NONE is one of the supported connectors of the this component. So i don't understand this filter here.
UnsupportedOperationException would be better
A post-processor with neither NsURI nor resourceURI is totally useless; which makes this constructor a very misleading implementation. It'll basically create a post-processor which only use is to occupy memory and time (when we loop over it). This is the "UML" post-processor, and we already have a default contribution with an hard-coded URI in the plugin.xml. We can set a more sensible default NsURI than that. Change the call to super(Pattern.compile("<LINK_0>\d.0.0/UML"), null) ... or remove this constructor altogether.
avoid using \n, I remember windows contributors having tests failing because of such usage.
If it's not good to use level(...) this time, let's remove my commit. Or please rebase it into your commit it if the changes are fine :)
Should this try to create a URI with the old logic when it's null for retro compatibility ?
this lambda will alway return true if at least one representation is present in the resource. That is also the case in aird resource. we should get the first element in getContents() and next check that is element is instance of DRepresentation
Perhaps add further information to this exception
Need to declare the adapter type here, too.
I think it is better to do that on the code calling it, and in the getter.
Looks like this changeset killed a small shortcut here: if the user shares text and have one only site, we didn't show the picker at all but we opened the editor directly.
No need for getInstance(), the container can be passed
Maybe better to return null
Can use EntityPredicates.attributeEqualTo(Startable.SERVICE_UP, true) Note that will also avoid the strange NPE that you might hit if there is a router with SERVICE_UP attribute still equal to null.
@dalifreire this doesn't throw IOException anymore now, you're just creating a stream on a Strings bytes :)
isCacheable is now true? I guess this was supposed to be false for generic extractors. Or am I wrong?
Should this stream be closed?
StringBuilder
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
Well, with the squash GH doesn't see changes and don't notify via email. I have missed this change therefore :cry:
Are you sure it's necessary to use the Bus for this? Why not simply obtain a reference to SearchArticlesFragment, and call the startSearch function?
Use .substring(1) so that we don't have to allocate a new String instance.
Should we maybe wrap other throwables in a RuntimeException here? Or throw a new RuntimeException? Seems inadvisable to just ignore an error. Someone who's already using this might see an AggregateException with no causes.
I don't think you want to call the super implementation, as you are handling capability registration conditionally.
Is this correct? Based on the definition of the special day entries in the DLMS Blue Book I would expect a long-unsigned value (newUInteger16Data).
What happens if we are unable to load the inputStream.. Do the messages still show? Should we be rethrowing this IOException? @JonathanGiles ?
@Happy-Neko Same here, let's throw IndexOutOfBoundsException with custom message.
Use Assert.fail() instead
Move String values used more then once to a constant.
The labels for these date parameters are wrong. They should reflect the parameter names (eg. reporting.parameter.startedOnOrAfter"
Code with embedded newlines is hard to read. Please split the literal after each newline.
Need to declare the adapter type here, too.
Optimization? putAll should not be expensive if there's nothing to put...
should be setSucceeded(true)
please use NotImplementedException()
This should be Repository.class. The method is supposed to return the list of adapterTypes, i.e., the types to which this adapter can adapt objects to.
No parens on condition.
We have different conventions. Please see the spaces around brackets and method parameters, and brackets on new lines. The checkstyle plugin would crash the build. Did you try to run "mvn install -P run-its"? It would take quite long time to complete the build, cca one hour.
What does it mean here to decorate it with Nullable while null is actually not allowed in the following line?
Does this need to be implemented for live-serving mode?
'em.persist(member);' should be enough, you only need to wrap the EntityManager when needing to access methods which are not exposed on the JPA API.
nit: you can merge both lines above as checkNotNull will return the given argument
We try to prefer these to be the proper enum for the getter/setter methods, with the translation of char<->enum hidden inside of the getter/setter methods. That way we store the smaller char in the database, but application code isn't exposed to the database's insane char based storage.
addCustomValue(GlusterConstants.VOLUME_SNAPSHOT_NAME, getParameters().getSnapshotName()); return super.getCustomValues();
just curious why here returns new JSONObject, however, in previous test, null is directly returned?
Use the solution in the large Overall/Manage PR instead, please.
return (source != null && source.isValid()) ? source : null;
Since we are improving this code anyway, I think we should switch to using [StringUtils.containsIngoreCase](<LINK_0>, java.lang.String%29) instead of toLowerCase+contains, since lowercasing a string is not always the same for non-ascii characters.
Why Integer is excluded? LongOrNarrower should contain all integers, should it?
Use Iterators.transform from Guava?
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
May as well use static final byte[] EMPTY = new byte[0]
what if you get an exception before doing the inc. Would it be better to test <=0 instead of ==0 (and reset it to 1 in that case instead of a simple inc?) or maybe check if it's <0 after the decrement and reset to 0?
I'd also set a flag internally on this listener. Then, if in future some code called listenToCache() with an already-triggered listener, you could just return immediately.
This evaluates different value that it stays isLeftTurn will return true, in case it is slight left turn
Do we have to care about UnsupportedOperationException here, or can we be sure that since isSymbolicLink() == true, the operation is supported? Same question also below.
I think this would be potentially better with scheduleWithFixedDelay so that there's a guaranteed pause between runs. I'm concerned that a large data set would result in doDataExpiration taking longer than 1 second and putting pressure on the system by constantly running back-to-back.
If there is no default value this can be  .setDiscard(DiscardAttributeChecker.UNDEFINED, WeldResourceDefinition.THREAD_POOL_SIZE_ATTRIBUTE)
Why do we need those queues? Can't we just invoke handlers in add(), delete(), move() methods? Are there any benefits of using queues that I've failed to catch?
Move to update please. < layout
Use Java 8 String.join instead of a third party library
I don't think you need this new String
Same issue here, double delete user.
This needs to use justOrEmpty as the response value can be null which is an illegal value in a Reactor stream.
return null to make this more explicit ?
Do you hate static imports? :)
Please log the bundle ID here.
recordCount++; doesn't work?
calling is.close() might produce exception. Please define: private static void safeClose(final Closeable c) { if (c != null) try { c.close(); } catch (Throwable ignored) {}; } and use it instead of InputStream.close() method
Why can't you just return value here?
they both disposing the same trace. Keep the second call
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Avoid the scannerLock object and synchronize on KieRepositoryScannerImpl.this. I believe this will make also clearer that you're sync'ing on the same lock of the scanNow() method.
Can we inject this feature directly ?
I prefer using () when there's a single value and {} when there are multiple properties, but it's just a matter of personal taste.
You could do the same thing by doing @Test(expected = BluefloodServiceStarterException.class) I would say checking for exit code equals -1 is not that important to do.
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
Should those hashcodes be hardcoded ? They depend on HashCodeBuilder.toHashCode() implementation.
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
that's the same?
check if it started here.
Wenn super.close ne Exception wirft, wird der Export-Job nicht geschlossen :( suggestion try (Closeable c = super) { exportJob.close(); }  Das try with resources macht intern ziemlich viele coole Sachen: <LINK_0>
can we also cover that a null response comes back with content type text/plain and you get the right Optional behavior?
Might be worth having a displayName?
This should be 10 << 20 so that the default is 10 MiB. That allows users to specify configuration with standard suffix units e.g.: [merge] inCoreLimit = 10m for a 10 MiB limit.
string resource
does this really need throws Exception
Should this not do something like ErrorPopup.showMessage( ProjectEditorResources.CONSTANTS.NoRepositorySelectedPleaseSelectARepository() )?
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
use return ... ? ... : ...?
do not assing parameter! nowhere!
After thread sleep, I think need to continue the loop. Otherwise, consume messages from the consumer. Code snippet for if condition be as follows: if (wrapper.waitForReplay) { Thread.sleep(100); continue; }
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
return Status.BACKUP_FINISHED.equals(status) || Status.RESTORE_FINISHED.equals(status);
What does it mean here to decorate it with Nullable while null is actually not allowed in the following line?
java Objects.requireNonNull(runnable, "runnable is null");
No key for encryption? ;-)
....and then you don't need to call it on every other method
I know this is just test class, but this is what Optinal.empty() is for - avoiding necessity to sometimes use null ;-)
use ShellIsAvailable
throws
what about using IntSetsExternalization.writeTo() and IntSetsExternalization.readFrom()?
Is modified always called and you do not need to to process the config in activate() at all? I didn't know this, that makes the implementation indeed easier :-)
Is this a method to be used in production? Or is it more for developing/debugging purposes? If the latter, we could create the webrequestMap HashMap within this method instead making it a field in the object. It would be slower for tests because we'd have to recreate it with every print, but would be a lot lighter for production (I guess the heap and garbage collector would feel it, given that we create a WebrequestData object for each web request). Also, it's likely that for each webrequest we do only 1 print, right? In that case, speed would be the same. Also, being annoying :P, I agree that we do not need the {"webrequest": <json>} wrapper, just the json object will be fine, no?
This should be simplified to just: >return value;
I don't believe you ;)
You are still programming in Javascript here. :-P What about replacing "" with null here and remove "" from the variable declaration?
I think this method can be final with addition of extra "hook" (overridable) method to register handlers: public final void setEventBus(EventBus eventBus) { this.eventBus = eventBus; if (eventBus != null) { registerHandlers(); } else { unregisterHandlers(); } } /** * Override this method to register custom event handlers as necessary. */ protected void registerHandlers() { // No-op, override as necessary }
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
I'd use a different name, e.g. doStream
Every time we change a JSON test using JSONPath a cute kitten is born.
Why are you blocking here? this should be async throughout.
Not sure if you noticed, but you can use a different notation here: suggestion return Optional.of(path).filter(Files::exists);
Can't we just set without compare?
StringUtils.isEmpty(namespace) will take care of both (not important, just FYI)
Let's checkNonNull() the params of the builder, which must not be null.
unnecessary array new: {{true}, {false}} should work here
unused try catch block
Add a private final stripeMask field that is initialized to stripes - 1. This will eliminate an arithmetic operation from this hot path.
This looks like something Jack might optimize out (we're still using dx for Checker tests). Could you acquire the nulls through an inlined method and test the later constant folding? That seems more future-proof.
So all HashFunctionPartitioners are equal to each other? What about the 3 different variables? Also the hashCode is broken as that uses 2 of the fields :(
suggestion timer = getMetrics().timer("file-read");
suggest this.getName().equals(other.getName())) since other.getName() _probably_ returns a value, but this.getName() is guaranteed in the constructor to return a non-null value.
Why make this an ArrayList explicitly? Wouldn't it make the code more flexible to leave it as a List?
We should just use String concatenation (due to performance difference I very rarely use format)
!isEmpty ?
should not we also remove the old one sometimes? notifyChanged may be called a lot of times, including changes unrelated to multiplicity.
Note that all references to CoreRegistry.get(class) need to be replaced with either @In annotations (best idea) or context.get(class) codes (find-and-replace). You'll probably need an @In annotation to pull in a context.
please use {}
Avoid the scannerLock object and synchronize on KieRepositoryScannerImpl.this. I believe this will make also clearer that you're sync'ing on the same lock of the scanNow() method.
can builder even be null? if not, it is just getSslBuilder().build(), or in-line it.
new AssertionError -> new UnsupportedOperationException
Now that we use the number of passing alt alleles, we can get ride of that +1
I would prefer return type(type.getDefaultState()) instead, to be less repetitive.
This should be done in the constructor. Then you can also make the member final.
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
Should have a period on the end of the string for consistency.
return this.parent == null ? this : this.parent;
The order of the arguments is reversed - it should be assertEquals("Vds id is not empty as expected", "", result);
I think that instead to save an ordinal (that is hard to remind) it can be also good to store the literal of the triggerMode, I guess that at this time it's ok and we can gain for clarity.
Use this(...)
"line"
I would log something at least.
Nit: Why public?
Do you want to accommodate value merging here? I don't believe we have a case at present where two different rules produce the same key, but in that case the implementation above would cause the latter to overwrite the former. Merge semantics would be preferable. On the other hand we can say "don't do that."
Maybe we should derive this from Prefs.getMediaWikiBaseUri() or require the client to pass in a default protocol. I think I prefer the latter to avoid complicating this nice and simple model type.
Please make the methods in Calculator non-static and rework the examples accordingly. I think it's fine to create the calculator as the _SUT_ in a field (in all affected test classes) as follows. java private final Calculator calculator = new Calculator();
this can be done simpler using a sorted stream of param entries to produce output string
Shouldn't we use super.hasPathCapability(path, capability) here? It would delegate to FileSystem's call, so effectively no difference (including the supportAcls() call there), but would be cleaner.
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
I don't think it makes sense to try to recover from this exception, we should just log and fail in the sensor (i.e. skip analysis)
log this instead of printing
Args.notNull
Ditto for java.util.Objects.hash(Object...)
fos can be inside try ()
Using "/" directly is not portable. Java has a system method to get the directory/path separator character.
I'd increment a counter and assert its 1.
given, when then please so this is clear what are you testing here
Does this need to be public? It seems to me this would only be useful to call from subclasses, so it could be protected. Shouldn't we make it final in a 1st iteration or do you have use-cases that need to override it?
just use string concat instead of format
what do you expect this to do on windows :-)
@dskalenko when line can be null?
can this be readSafely instead of readBuffer so that read uses readSafely
but this doesnt solve the issue, even if the events are disabled in the config eventsRefresher will be created because it will pass the first 'if' statement (above) why not adding the check for events to the line above?
Is there a reason not to clean this up in a finally block sooner?
use return ... ? ... : ...?
"" + x.doubleValue() - is this the most elegant way to get a String from a double...? And if it is a usecase to instantiate a QuantityType without passing a unit, might we want to add a constructor for double as well)?
Aren't there url's like this too? file://some/path/my.jar!org/foo/bar The ! is often used in java url's to indicate that it's inside zip (not sure if it's used in these kind though). I agree contains has false positives (like tony.jarvis) but endswith might have false negatives (like my.jar!org).
getCells() can never be null
For now I just hardcoded this. But we should have a way to access these properties.
throw exception
Please parenthesise nested ternaries.
suggestion final StringBuilder sb = new StringBuilder();
Write todo the same "way" in both places.
Maybe we should use a logger here, and print to a different file? In case there are issues with updating and we need to diagnose.
given that this uses no atomic operations (cas, etc) might be worth just leaving this as volatile?
suggestion ResponseEntity<String> response = restTemplate.getForEntity(url, String.class);
decrease to DEBUG
Its best to just do one atomic "test" per method in this class. I'd probably break this up into - testAssignVariable - testAssignVariableMultipleAssignment - testAssignVariableNotDefined Also note that junit has some built-in exception checkers <LINK_0>
Is null the right thing to do here as the default or should we do something like throw new UnsuportedOperationException()?
Can you reduce the nesting depth here?
Should you call analysisReady(false) here?
suggestion assertSignalEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);
Does it add an error message?
Declare as final static..
Same here, this can be boolean
You can combine the cast with the call below, like .map(stat -> ((Statistic) stat).getStatisticFormat()...
bracket should be on the previous line
unrelated: this can do 'super(msg, cause)' now that we require Java 7.
since this is an instance variable, regardless whether it's thread local, you should have it qualified with this.
rename to signature
normally we use italic text for info icons like this: numaInfoIcon.setText(applicationTemplates.italicText(message));
Unnecessary log.
Why remove these?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Sorry to be a pain, but we should use uk.gov.pay.logging.LoggingKeys.PROVIDER here, similar to how <LINK_0> does it.
Shouldn't this close the iterator before returning the list?
you can use instead: return Version.v3_5.less(version);
Are consecutive reloads necessary or will be one reload at the end sufficient?
there is no need for this.
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
isn't it cleaner to keep this function as append?
Subscribing to METHOD is only introducing confusion, and cause problem with the rule. Subscribing to METHOD_INVOCATION should be enough. When hitting a method invocation, you can then look into the map if something exist for that symbol. If it's not the case, retrieve the parameters names and add a new entry on the map. Then you check for parameter names.
Perhaps make it private so no one will be able to initialize it outside the class? It makes sense cause regular initialization will not do much without injecting the members
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
Not sure this is the best place for these generic checks.
Shouldn't this close the iterator before returning the list?
Implementation of this and other similar methods is highly inefficient. Better to use Character.isJavaIdentifierStart.
To increase readability of this test I would just drop this statement, and move ifCond block inside if condition
You should check whether the type is assignable in all cases. Just, when the projection converter is disabled, you will call isConvertedTypeAssignableTo on the *raw* converter. Note that your tests didn't fail, so you're missing a test where you try to pass the wrong type to rawField(String, Class).
Please add a check Objects.requireNonNull(supplier, "supplier is null");
Make the fileInfo map immutable.
missed to implement
I'd return suggestedId for the time being, but if you have reasons to keep it this way for the time being I'd be ok with it.
why is that needed?
Again not an error, it's possible to have an offer with 0.0 cpu resources, but with 2048 mem resources. While it's not useful to the framework, it's not an error. Debug or info.
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
I think baseUri.toAsciiString() always has a trailing / in our usage so with the current build() method I think you will end up with (for example): http://some.example:80//path/path/path?query=true changing to this.path += encodePath(path) + "/"; will result in: http://some.example:80/path/path/path/?query=true I think both of these are valid URLs, but I think we need to be sure there are no server side issues if we use either // or /?. @tomblench any thoughts on this?
could be static
ACTION_TYPE_FAILED_GEOREP_SESSION_ALREADY_RESUMED
nit: can you put "File connector started" instead?
this.
As a safety precaution, should we make this assignment just once to grab only the very first line number in case generated synthetic lambda method contains more than one line numbers?
judgment.getJudges().stream().collect(Collectors.toList()) could be replaced by simple judgment.getJudges()
minor: you can return Collections.emptyList() instead
Why not Optional.empty()?
No, I meant to actually implement the methods!
Use Assert.fail() instead
UnsupportedOperationException ?
Should the name of the FileSystem be included in this message? Would help troubleshooting issues.
i think this might need to encdoe the name and bitmap type too.
Not related to this change but this should be spelled "Cancelled" to be consistent with method "isCancelled" of ProgressMonitor.
null credentials and demo credentials is no the same case
When using a byte[] buffer, I believe we need to capture the returned byte count because it will likely be less than the full array on the last read. As in: int byteCount = 0; while ((byteCount = in.read(byteArray)) != -1) { out.write(byteArray, 0, byteCount); }
Why does do all methods have to be inspected in the constructor, instead of checking for the annotation in this method, after checking the static list (possibly caching the result in a field so it does not have to be repeated on each call)? That way not all methods have to be checked for each instance created, which is quite expensive time wise. And I expect most methods will not be annotated. Furthermore if the annotation is NOT present a wait was required, so the time spent checking for it is most likely not that important.
Put each on a separate line java .setMetastoreUris(null) .setHiveUserName(null));
You can call this.setTimestamp(timestamp) from here.
Is there a reason to have this setter instead of using a randomly assigned uuid and having the RollingOperation constructor check not null on it? We use this in some tests, but I don't see us testing the Id itself (and we shouldn't, I think).
Throw the proper exception if something is not supported: - NullPointerException if status == null or command == null. - IllegalArgumentException if frameID < 0 or if frameID > 255.
Same as above for otherNonCodedConceptUuid
Do we want to make the change inside mkAssignments(String scratchTopoId) so we can count errors during the rebalance command as well?
return 'A'
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
MemStore is used for tests, so we need to implement this function.
this param is unnecessary
You don't need to call .getValue() here, since the method neither does anything with the value, nor does it return it. You can invoke the API and leave it at that.
Shouldn't options be Immutable?
I know this was just copied from the original endpoint but bundle can be null here (although very unlikely)
How would you feel about using more descriptive column names? For example, day(shipdate) as ship_day and month(shipdate) as ship_month? These 2 will give you values within TINYINT range and will have meaningful names that are easy to understand.
tree.symbol() reused 3 times, make it a variable.
hope you know the diff between ceilingKey() and higherKey() and you are using higherKey intentionally
I think I prefer "Invalid key" as exception message
What happens when one of these TypedOutput instances return -1 because they don't know their length?
This should not be registered on an HC.
return Promise just to symmetric with start()...
suggestion console.warn("Usage: \"changeShip module:shipName\"");
Consider removing the "Optional" part. Seems better to return an empty map, if not present.
Missing StringUtils.isNotNullOrEmpty() check
cannot be null.
Class<?>
Why not make implement Closeable rather than this private close?
+ desc
You can extract a method to checking tags
You can extract getUnits to a local variable Same with getName since you're going to use it anyway
I know this was pre-existing, but the variable is capitalized Map, but should be just map.
need to make sure that only one call to flush is in the queue maybe synchronize around start ?
nit: orElse("null") is clearer.
delete the old file when a new one is generated? It's nice behavior to clean up our mess. Or use .deleteOnExit, if some tests might still be using the old file.
Is there a reason to have this setter instead of using a randomly assigned uuid and having the RollingOperation constructor check not null on it? We use this in some tests, but I don't see us testing the Id itself (and we shouldn't, I think).
Can an ArrayValue ever equal something which is not another array and thus an instance of SequenceValue? I would assume that this row always returns false.
boolean is never null. Please find a user where it is true.
Must be with this. Also how about addAdvices(Advice... advices) ?
I'm not sure why this variable is needed here. Could be: java public static String getAttributeValueFromString(String string) { if (string.length() > 0) { return string; } return null; }  This functions also will fail if string == null. Should be something like this: java if (string == null || string.length() > 0) { return null; }
see below re: spaces
@dmzaytsev ThreadInfo can read currentThread in Ctor, no need to pass static
This is another behavioral change that I don't want to see in an unrelated PR.
Should not we synchronize here too?
use hasNext instead of contains (do not use toIterable() we want to check Iterator)
minor thing, but this doesn't need the throws clause
also use a map here (this is likely to be extended I guess)
Give a name to this thread, so if it hangs or blows up, the stack trace will give us a clue who called it. i.e:  new Thread(r, "Hawkular Java Agent Stop Thread").start();  I also need to think about this some more before merging since we are now making the stop() method asynchronous. We have to check to see what kinds of thread safety/concurrency issues this might cause (especially in cases where the agent is restarted, for example, and the stop is followed quickly with start. We need to make sure nothing in start is initiated before this stop thread is actually kicked off and finishes). In other words, making stop method asynchronous could have some side affects that are "bad" without some synchronization/locking put in place.
add this selector to UI mapping at the beginning
isNull()
should probably be named s. But then it's conflicting with the subscription s. So I guess ss would be more appropriate.
no need to extract this out to private method if it's only being used here. same for onClusterRemoved
Please add cmd.getDhcpOptions to the log message to assist with operational debugging.
Don't forget to update this
@fabriciofx Here also, we could return the body() of our decorated object directly
use return ... ? ... : ...?
isNull()?
These are from the org/json library. Edits to this are really not recommended.
Can you explain why protected field access are expose via public methods ? Do not change access modifiers without understanding its purpose.
Same here regarding the messages.
Either call getComputedValue(buffer, ...) here or remove the second signature of getComputedValue since I don't see it used anywhere.
static.
Why not add the creds in executeRequest? Are there any calls that go through executeRequest where it's not needed? (Can we make executeRequest private?)
I don't think you need this new String
Can be made _package private_.
local variable e is never used.
This method should be static and need not pass this as an argument to the constructor.
Name is no longer used
Do you want to check exists?
handleExceptions();?
Don't rely on the JRE platform encoding here. Use a specific encoding, like Constants.encodeASCII(). This also applies to the other getBytes calls below.
Aren't there any test methods that require compatibility?
nit: spaces around + I'd also change / to use OS-specific path separator, i.e. [File.separator](<LINK_0>
Here and elsewhere, the Fragment probably shouldn't force the host to do things by getting its internals and changing them. The dependency on a toolbar is clear because of the callback pattern but exposing the toolbar directly allows any Fragment to change it. It's ok to defer but consider pushing onSearchOpen() into the host and allow it to hide / show the toolbar.
I think this will cause a memory leak as you're going to be holding onto an indefinite chain of references, so the GC can never garbage collect the request metrics objects. It would be better to create a new request metrics payload that is a copy of the current
This method causes several build warning.
This logic is a bit awkward. I guess it's because client.poll is disconnected from the send logic. I wonder if it would be reasonable to create a method like maybePollTransactionalRequest which handles both the inflight check, sending the next request, and calling client.poll if necessary.
Please throw NullPointerException instead (also, use braces for the if statement)
ewwww, abusing try/catch for this is really unideal... We have a Pattern for Numerics you know?
Prefer not to have a null environment from start.
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
@lmontrieux Wow... Strange. I think in this manner you need to add addional {} to log message.
I think this should check that also the non coded value is not blank, we normally user StringUtils.isNotBlank
Should be added the Override annotation.
deserialize can return null.
It might be nice to also have a test with a user in the administrator group, so we can verify that it gets the ADMINISTRATE_SERVER permission.
Shouldn't this close the iterator before returning the list?
UOE instead of ISE (x3)
Is this an error condition or just timing? When will it happen?
Please make the methods in Calculator non-static and rework the examples accordingly. I think it's fine to create the calculator as the _SUT_ in a field (in all affected test classes) as follows. java private final Calculator calculator = new Calculator();
I think you should dispose the ShapeRenderer here.
suggestion info("Consistent ID: " + ignite.cluster().localNode().consistentId());
assert is not useful in Android apps I think
Alot of noise in that (what looks to be an) IDE-autogenerated toString? How about just "SenderId{id}" to be returned from toString?
can this use submit?
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
check if it started here.
IIRC this is not carried into the new clone reader by any other implementation.
Why not in combination with above do this: setValue(value, false);
extract private method boolean waitForOperator(Operator operator, Duration timeout):  try { operator.isBlocked().get(timeout.toMillis(), TimeUnit.MILLISECONDS); return true; } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw new RuntimeException("interrupted", e); } catch (ExecutionException e) { throw new RuntimeException(e.getCause()); } catch (TimeoutException expected) { return false; }  and build assertions around this method
good practice: usually actions go before WS as they are injected into it and so they are grouped together
This would just be icing on the cake but you could factor out these defaults into a package-private Util, with a method, something like declareQueueDefaults(Channel channel, String queueName). Totally up to you, though. This is already an improvement. If you do it, just do the refactor in a commit on top.
Nit: we tend to always use braces in the selenium codebase. It makes it harder to cause chaos accidentally :)
if you do this, better put N/A :)
you can remove this
space before trailing {
I remember that there was a PR that removed public. We'd better follow this style.
Need to remove codec from here too, right?
why are we changing the visibility of these methods?
Use context.getApplicationContext() to ensure the class can't leak any shorter lived contexts that might be passed to it (it's always fine to hold onto the application context, since it's expected to be around for as long as the process remains alive).
better don't call the setter here since the configuration (from updated()) must not be called already
why is this (and others) ""?
[trivial] You can write !stop instead here
Remove
code style: space after //
Changes to this file should go in the previous commit
I haven't tested this, but what happens if the user is running init on an existing site, which already has the Verified label, and he selects "yes" on this option?
does this need to catch all exceptions?
Maybe better to return null
public boolean hasValue(@Nullable String value){ if (adapter != null) { return (getAdapterPosition(value) >= 0); } return false; }  Not sure why we are instantiating a variable here.
use the interface here
If you never need the stack trace, consider calling super(message, null, false, false) to avoid some overhead.
revert this unrelated formatting change
Just a note. RedDeer has "shortcut" for this - OkButton (as well as CancelButton, FinishButton, NextButton, YesButton etc.). There is no need to edit this... It's just FYI.
Another place where we could note that the boolean is unused.
I presume this was to avoid log noise. Why change? If your intention is to alert the user of the problem, it would be better to log rather than the task executor printing the stack trace.
use hasNext instead of contains (do not use toIterable() we want to check Iterator)
point here is to clear entries if some were removed compared to previous state, would selectedIds.containsAll(fSelectedIds) remove more clear cases? (replace the selectedIds by a hashset in that case) Also, the actual clearing / update happens at org.eclipse.tracecompass.tmf.ui.viewers.xycharts.linecharts.TmfCommonXAxisChartViewer.UpdateThread.updateDisplay, should this code be there, to avoid the clear/update pattern in child classes?
or just java public static Object[] data() { return TestPlatform.values(); }
I think this one could be private
Would it make sense to automatically call this method via on-persist/commit hook, depending on the event state?
It's a good idea to run your tests before submitting them to Gerrit.
This test uses the same jboss-all_fine.xml file as FineWebFailoverTestCase.java, what about using a new one for covering the reference to an existing server profile from a jboss-all.xml file? (at present we have it from distributable-web.xml file in testsuite/integration/clustering/src/test/java/org/jboss/as/test/clustering/cluster/web/persistence/distributable-web.xml)
Shouldn't this be wrapped in a try... finally block?
Locale.getDefault().getDisplayVariant() works for me but getScript() returns an empty string.
Why is this removed?
suggestion private static InputStream openStream(String url) throws IOException {
if an empty set of permissions was passed in does this work as expected? (permissionsDisplayName would be an empty string) - so would the error message be correct?
This is the replacement for [this](<LINK_0> We might want to consider --non-interactive at least.
The rest of this method used the ctl.getRefName() inline where it needs it. I proposed to remove this variable and use ctl.getRefName() to match the style in the rest of this method.
The message is missing.
check directly on viewOperations map.
It is a good idea to add all releases in a finally block, so that we never lose permits.
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
@ekondrashev Too much indentation for lines 61-64, move them back four spaces.
Is it really necessary to put the full enum name here? If yes I'd actually be surprised because I'd consider values() a static method of every enum
Seems like a lot of work just to verify that the json is valid. Perhaps there is some 3rd party utility to do that for us? Something to consider
Usually for this it's reasonable to have a hasMessageContaining(...) to make sure the exception is what you want it to be.
nit: you can merge both lines above as checkNotNull will return the given argument
Can you use the information stored in the row for all parameters? That might be slightly more safe in case there ever is a big with any CQL statement? Also the creation time should be set to the creation time and not 0.
return Collections.emptySet(); ? BTW, it seems that class DummyGroupMapping is never used now, do we need scrubbed it off?
cannot be null.
Args need to be included in operation.
Suggest unindenting for clarity: if (!Objects.equals(mIfaceName, route.getInterface) { return false; } int i = ...; if (i == -1) { return false; } mRoutes.remove(i); return true;
How about inlining it?  if (!contains(o)) return false;
Add SubChild here as well, perhaps SubChild is just persisted as a Child currently..
checking for nullable parent was added specially, cause going into project node simply has no meaning
It's useful to put something like this here:  java LOGGER.info("Groovy console starting...");
constant?
How about using something like org.apache.commons.lang.math.NumberUtils.isNumber()
This change breaks null-safety. null.isPresent() will crash and burn.
Please use: return !steps.isEmpty();
Use Arrays.asList instead.
suggestion return (original == null) ? null : original.toUpperCase(Locale.ROOT);
minor thing, but this doesn't need the throws clause
Why absent?
Need to declare the adapter type here, too.
won't this log bearer tokens?
it looks like you have to adjust this one to your recent changes -> see pr build on travis.
is it worth adding if it's null to return REQUIRED, to prevent old persisted items from returning null here? or have an explicit @Nullable
No need to implement these?
public isn't needed
Why is this method required? Didn't see it used anywhere in the code
an empty ArrayList is better than a null
What about Arrays.equals? Also possibly an intrinsic in JDK9.
Consider removing the "Optional" part. Seems better to return an empty map, if not present.
same here - result should be null
Do you want to check the compile options before asserting this?
How about just context since we have it?
Qualify with this.
Now you have two copies of this method, one of them needs to be removed. It would be better to place this method in StringUtils class instead with some generic name, such as startsWithIgnoreCase(String string, String prefix). Please also send a license statement as described here <LINK_1> to our mailing list: <LINK_0>!forum/h2-database
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
Switch the order of getting the mean and filtering:  java segments.stream().mapToDouble(ACNVModeledSegment::getSegmentMeanInCRSpace) .filter(x -> Math.abs(x - 1) < 0.1)
Check for null
Please make the methods in Calculator non-static and rework the examples accordingly. I think it's fine to create the calculator as the _SUT_ in a field (in all affected test classes) as follows. java private final Calculator calculator = new Calculator();
Logging using standard output
please apply java conventions (spaces before and after +) and total amount of characters per line
Again, needs a more descriptive error message please. In this instance we likely need to log something like "Could not create Item in Collection with UUID=[uuid]"
ClientLogger.logAndThrow all exceptions. Please search for all cases because soon Shawn will check in his CheckStyle rule and it will break the build.
good practice: usually actions go before WS as they are injected into it and so they are grouped together
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
This should be cohort class
Looks like these two typeTextIntoEditor commands can be united into the single command:  editor.typeTextIntoEditor("\n\nobject = MyClass()\nprint(object.");
use: import static org.hamcrest.CoreMatchers.instanceOf; ... assertNotNull(result); assertThat(result, instanceOf(ClassName.class));
Wouldn't have been possible to override the afterFromProto in the ForwardNatRule class, adding there any initialization code as needed?
How about inlining it?  if (!contains(o)) return false;
Maybe we want to keep something similar to what id was before
Please use Singleton annotation and remove this explicit binding. We plan to remove existing such usage pattern.
Any reason to create doSave ? Shouldn't extenders be able to override 'save()'
Capitalize Thrift (or remove the word)
Inline.
ImmutableList.of
Please reformat: } else {
Can header name and value be null?
@Override should be on line above. Checkstyle/formatter config?
super nit: List<Object>, private static final Object CANCELLED = new Object(), requests.add(CANCELLED) java assertEquals(5, requests.get(0)); assertEquals(CANCELLED, requests.get(1));
That seems like a new behavior? What would the user do with half of the UUID ?
List#isEmpty()
I think that may have been an oversight in longSum. Try a query that results in +Infinity at the historical level and you will see why it is needed to deserialize at the broker level
"our" => "out"
Would it make sense to have DisplayBlock keep an instance of this type and keep making fresh copies of it? This invokes the ANTLR parser every time.
I don't think we should call abortWorkItem here as the work item most likely won't be there as it failed to execute.
Possibly could store this in a field to avoid creating 3 objects every call
Like with the equals, this hashCode looks fine, but take a look if you'd prefer: return Objects.hashCode(this.deviceIdentification); here to match the equals.
wouldn't this fail if pattern was null?
Should you attempt Path.toFile() here?
I thought format used "%s" and "%d"?
about this API... for Cedric's VM, I just had to implement something that may change some style value for specific events. I'd like to just be able to update one style value, but the returned style map is read-only and for just cause! You could add a method Map<String, Object> getSpecificEventStyle(event) that would return only the difference and this method would merge the 2 maps if not empty. This one can be final.
The super() returns "" on null. Why should we differ?
Shouldn't we have tuples in all cases?
Can't really understand what's going on here. We multiply by 1,000,000 a millisecond unit and add it as a nanosecond? (it would _probably_ make sense if we divided instead of multiply, but then why not just do now.plus(resyncPeriodInMillis, ChronoUnit.MILLIS))
Shouldn't be protected as this method is used only in tests + shouldn't be something editable no ?
Please verify the returned can-do-action message is VdcBllMessages.GLUSTER_TASKS_NOT_SUPPORTED_FOR_CLUSTER_LEVEL
Just for consistency, please use final boolean actual
my sense of beauty tells me that this code should look like the following:  guard(); try { verifyReadOnlyModeSupport(); ctx.state().changeGlobalState(readOnly).get(); } ...  Perhaps, verifyReadOnlyModeSupport should be a part of ctx.state().changeGlobalState(readOnly) method, I am not sure here.
Please follow the strategy employed in ParallelExecutionIntegrationTests to make these tests faster.
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
it's a bug, we should throw UnsupportedOperationException when a method is not implemented
Use a concurrentHasMap, then you can remove the synchronized on the public methods.
This is causing us to communicate with jdt.ls for every folder change in the file system. I think it would be more efficient to send every folder change to jdt.ls and let jdt.ls do the filtering. Also, are we interested in every change or only in create/delete?
this will trigger NPE on OffheapIncrementalIndex
I would prefer to use String.valueOf(value)
Can we not verify that the text boundaries are correct? Verifying that we simply set the boundaries on the text decorator is better than nothing but can we not ascertain the values that should be being set?
Not going to work once we fix ItemListener to catch errors from onLoaded implementations, though that is also true of InduceBootFailure. But the :bug: is because the fact you needed to do this suggests to me that you somehow regressed the logic in WebAppMain.contextDestroyed which is supposed to be interrupting the initThread and which this test (from #1950) was verifying.
Why do we need those lines? Unit tests are still green if I remove them.
I found this code called so many times during app execution. What are your thoughts about using a pre-compiled regexp to split the strings? private static Pattern languageSplitter = Pattern.compile("_"); and then use it with String[] opts = languageSplitter.split(languageCode, 0); Do you think that this will improve performance?
This is not needed anymore... now you can just return id
Suppose makes sense to convert value to lower case before comparing.
should hashCode really depend either on taskName, or description, or hashCode?
if service is not present it should throw error? same question to the other methods
Create your own session to make the property to be true.
I believe the conditional above will need braces otherwise this is considered outside of the block and will always execute, which may not have been your intent due to the indentation. If you did want it to always execute, you should update the indentation to reflect that.
suggestion assertSignalEventExecutionSet(emptyTopEvent.getExecutionSet(), EMPTY_VALUE, NON_CANCELLING, EMPTY_VALUE);
should probably test for null delimiter and either ignore or preferably interpret null as "no delimiter" (the empty String)
nit: perhaps, test floating points as well: st_point(122.3, 10.55) Also, consider testing invalid WKT strings.
I do not know much about databases but whether this method is properly constructed? My Eclipse returns "This method must return a result of type boolean" and I can add return for firstRun of false.
Consider changing it to "command.getName().equals("OnRemove")" so it will fit the 'else if'
we should log a warning here so that users who have wrong permissions on ~/.gitconfig by mistake have a chance to detect the problem
How about inlining it?  if (!contains(o)) return false;
I am leaning toward moving this back to requiring Jenkins.ADMINISTER
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
We could throw an UnsupportedException here.
Is there a reason that the GapBuffer is initialized with a buffer size of 1 by default? I know this is a very vague question, but 1 seems like a weird choice to me. It reserves ram in anticipation of future insertions to save computation time, but still only allocates so little buffer space that the array size will have to be increased after one insertion. And if the first action is a deletion, this one additional character of buffer size won't make much of a difference. But I have no experience with gap buffers, so maybe I am missing something (or am overthinking this).
for this and above we should be using the convertView to recycle the view, if it is null we inflate, if not we assume it is of the correct view type.
I think this pattern will work throughout the whole string, while we want that it only works for the suffix of the string, which is not enforced. To enforce it, it should be "_[0-9]+_g\$$" or "_[0-9]+_g\$\z" or something similar.
i18n?
Maybe it should say "Casting to float type is not supported". Similar for getLong().
ObjectMapper is fully thread safe, we can have it as a single static variable inside this transformer class (also because we do not configure it differently per method usage)
This should never have a null value. I need to work out how LeashData is going to work.
Instead of defining this attribute, it would be better to invoke countdown for the latch (initialized in the constructor)
Moving that bits above and allowing the user to change the decorator via a public setter means you can completely shadow what AbstractTransactionSupportingCacheManager used to du using public API. Also, if CacheDecorator is a first-class concept, you should probably expect that more than one decorator can apply at a given time. This wrapping shouldn't be the responsibility of the caller.
And this one stays "display_name", not?
Comparators classes don't generally have to implement equals (i.e. is this comparator the same as this other comparator?), so this is effectively "assertSame" because it's probably relying on Object.equals(). I don't think it's particularly rigorous to test for equality by using the comparator so I can't think of something better and I'm happy enough if we just compare instances. So, I think we should probably assertSame where we're expecting the same instance returned to make it clear.
Shouldn't this come from the builder?
Please remove printing to stdout
If you never need the stack trace, consider calling super(message, null, false, false) to avoid some overhead.
Use StringUtils.isNotEmpty instead
We should probably prefer setReference and setAlternate to be private (or protected if used by a child class, but I assume that is not the case right now).
how about  java private boolean needAck(Message message) { return message.getSequence() == message.getBatch().getWindowSize() }
do we want to have actual percents? not rates as everything else is in Picard?
This is not used anywhere
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
java * @param error a potentially empty error message. * @param errors the List of error messages, which @code{error} is appended to, if @code{error} is nonempty.  @damithc errors description stills seems too verbose, ideas for a better one?
Get the service registration reference and unregister within the deactivate method
can you just pass "i" in readLacComplate?
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
declare throws please
I would actually recommend removing the throws IOException from the interface. Any checked exception can just be dealt with by calling callback.onComplete(null, ex). I think that this helps unify the failure handling paths that the caller needs to deal with.
You can remove this since hasNext will call checkInvariants
warn maybe? and not sure if we want the exception. maybe just the message?
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
Merge to one if?
does this need to be calculated on the fly each time or can we save the iterable?
I don't think you need this check. Just return size * 1024 ?
How about a deleteQuietly function if this is frequently needed?
typo
What does the above line mean?
Use Objects.equals() to handle nulls concisely.
log exception
We'll probably need to move this return out of the catch-block if we're going ahead with this. I'm guessing currently we get an NPE that blows up, so the change makes sense in general.
This iteration is not protected against ConcurrentModificationException. At least 3 possible solutions: 1. synchronize on fOtherProviders 2. only iterate if fIsLoaded is true (the list won't change anymore) 3. use a CopyOnWriteArrayList (iterate on old copy if it's being changed concurrently)
remove that one from commit again
I personally prefer this approach instead of Thread.sleep() so we know how long the sleep value represents.
You need to copy the array to have the object itself immutable.
Nice, but AFAIK MediaInfo is not able to parse it...
can be inlined
it can be replaced with Objects.hashCode(channel) (since java 1.7)
Same feedback as other classes. check equals(), equalTo() methods in the changeset
this is for ensureConceptIsSet
please use "else if" since only one option can be valid at a time. Please also format the code according to the Eclipse coding standards.
The groovy test was configuring key rather than principal
Why there are things that are irrelevant to this PR? Although we need sanitise field here.
This should be Repository.class. The method is supposed to return the list of adapterTypes, i.e., the types to which this adapter can adapt objects to.
A public (instance) constructor writes to a static variable. I think you can make the constructor private and assign the static from getInstance(). First check for null and then assign if needed or return the existing object. public static UsageReporter getInstance(Map<String, String> configs) { if (s_instance == null) { s_instance = new UsageReporter(); //make sure it is private so it can only be called from here s_instance.init(configs); } return s_instance; }
This is another behavioral change that I don't want to see in an unrelated PR.
Not sure if you noticed, but you can use a different notation here: suggestion return Optional.of(path).filter(Files::exists);
Would it make sense to reduce this to the columns that are relevant?
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
I think this pattern will work throughout the whole string, while we want that it only works for the suffix of the string, which is not enforced. To enforce it, it should be "_[0-9]+_g\$$" or "_[0-9]+_g\$\z" or something similar.
this.monitor to avoid confusion with the parameter of the same name optional: this whole block could be a ternary: this.monitor = monitor != null ? monitor : NullProgressMonitor.INSTANCE;
I think that this logic should not be in htsjdk. getDescription() should return null or blank if there's no decription. the user can choose what to do with that information.
we should refactor out all the dupe code here, so that there is a helper method like:  boolean hasFlag(Read read, int flag) { ... }  also, if that method exists, it might not be necessary to make all these wrappers
StringBuilder
suggestion .until(() -> !j.jenkins.getQueue().isBlockedByShutdown(task));
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
Is there a reason to have this setter instead of using a randomly assigned uuid and having the RollingOperation constructor check not null on it? We use this in some tests, but I don't see us testing the Id itself (and we shouldn't, I think).
use subjectDataService.deleteAll() instead of this loop
It's better to introduce Pull.STATE_OPEN and Pull.STATE_CLOSED and use them
Maybe put how the player would get that ability (mention set_pflight)
I will be nice to have more meaningful error message. E.g. "Text condition must not be empty string." or smth else which explain the problem with comparing actual text and the empty string.
The remove method of the ConcurrentHashMap already performs its own synchronization, so the "synchronized" modifier is not required.
suggestion blobSoftRef = (BlobSoftRef) field.get(accessPath.apply(descriptor.getReferenceInstance()));
I am wondering if we should move the project towards scala or kotlin to make the data objects less verbose
Each of the getters in a POJO like this should have the same return type as the private member variables they expose. In this case, I'd recommend having extension, dateformat, and frequencyOverride be Optional<>s (in both their member variable types and their getter types). Our Jackson YAML deserialization should automatically take care of setting a missing field to an empty Optional<> in the resulting Java object.
Again, you can get rid of the this. here I guess.
I'd recommend to add process id to the name as well as there might be tasks with same name in different processes but still in the same kjar
<3 Better, but formatting :)
The same Arrays.stream() can be applied here as well.
remove public
You could make tryList final and perhaps inline initialisation in declaration.
Please update this string to say "developer mode" instead of "debug build".
this method is useless. Can you send a patch to remove it so all the code that needs uuid will simply use UUID class?
Use Arrays.asList instead.
You can sample the value as a static variable. You will save an access to the system properties map
This can / should probably be Locale.ROOT yeah?
Probably should crash if bad format string
please remove or decrease log level to TRACE
this.clientTags = Collections.unmodifiableSet(requireNonNull(clientTags, "tags is null"));
Use Strings.isValid(styleId)
Better to return "";.
please decrease or remove this statement
BUG: 10000 => 60000
this method deserves a description
"line"
H-m. Why don't call ThreadPoolTaskScheduler.shutdown() in the actualShutDown() instead?
I guess this will overflow maximum instructions per method before FIELDS_PER_CLASS is reached? Again, I wonder if it would be good to generate multiple companion classes.
Use KeyboardShortcuts.CREATE_RIGHT_PANEL?
Should also include context and suspend
These methods don't need to be synchronized any more due to the ConcurrentHashMap and the use of atomic operations.
If this is on the write side, keep in mind that texts can be reused.
I guess this method should be removed entirely here and below. (It was one time and it flush process to server log twice). As an option it can be optional using some system (maven) property for debugging purpose.
One last question. So we get and forget the returned result?
We could call: java checkNotNull("command", command);  :-)
This whole block can be simplified, no? You're effectively checking for negative health twice now.
Can't we have a confirmTimeout initialized with DEFAULT_CONFIRM_TIMEOUT by default? I see there is a logic where if (this.confirmTimeout != null) though, but why then just don't return that null with an appropriate @Nullable on this method instead? I think that way we would have a consistency with the current logic and what is possible with this getConfirmTimeout() in the inheritors.
abort is out of place here.
These methods don't need to be synchronized any more due to the ConcurrentHashMap and the use of atomic operations.
Minor inconsistency: Return type is Boolean and not primitive boolean
![Codacy](<LINK_0> Issue found: [Method names should not contain underscores](<LINK_1>
We shouldn't expose internal ES queries lang to Java users. I suggest that if we want to allow query by NodeID we had withNodeID to builder. In your example, maybe it's best to test what we have at end which is Builder(5) for taskId=5.
[Checkstyle] ERROR: '{' is not preceded with whitespace.
I think this should just return null, similar to the default MyFaces implementation of InjectionProvider.
what happened to handling of nullables?
return tags;
Possibly a better choice: Arrays.fill(password, (char)0);
This test is wrong. Its title states that the minutes will be out of range, but the hour is actually out of range (60). Minute is 0, but never gets checked.
These checks should happen within the build function when delegated to the object they are building, not a builder's set function. Don't duplicate the logic.
Sort of believe We should have MetricManager in parameter given this case.
Could you add one more call after getFoo() to make sure it does not crash on a second invocation? Just to make sure and base on the original bug report.
ohh.. actually we should default to 443 if https!
Is toString() required here? I'm not sure, but I think you can remove the toString() call. Maybe the toString() call is cheap and if so, not a problem. But the reason for the check of log.isDebugEnabled() is to not call toString() if debug is disabled. If you have this line as below instead, this problem goes away: log.debug("Notified of timeout on message '{}'", msg); I think this will work since I think log.debug will call msg.toString(), but I'm not sure and I haven't tested it lately.
You could simply turn this into !isEmpty()
& is not correct need to use &&. if data[0]==null then data[0].equals(Boolean.TRUE) will through a null pointer
You could remove method("POST") as you set the HTTP method on create
if at all possible let's try to avoid introducing more mess:)
can this be readSafely instead of readBuffer so that read uses readSafely
This is not going to compile. You can't return an object in a void method.
Better to create a new set, rather than update the super set. The super set might (and should, I think) be immutable.
null? why not just a () -> {} ?
Do we want to make the change inside mkAssignments(String scratchTopoId) so we can count errors during the rebalance command as well?
To always be safe please use context.getApplicationContext()
We could call: java checkNotNull("command", command);  :-)
why do we need to make this method final and none of the others?
Possible deadlock: remove this call to sleep(). It's possible that no events will ever arrive.
Is there any other output method that you could use besides System.out ?
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
s/executed/execute/g or maybe even simplify this to "An exception was thrown by a Executor"
wonder if it would not be more interesting to have false here to see that we are correctly jumping into the catch.
Please use [IOUtils.toByteArray()](<LINK_0> from Apache Commons IO. You may have to adjust the file pom.xml, which I have not checked. (The same one more times two lines lower.)
Please make the methods in Calculator non-static and rework the examples accordingly. I think it's fine to create the calculator as the _SUT_ in a field (in all affected test classes) as follows. java private final Calculator calculator = new Calculator();
it is not obvious. thx
This should be obtained from the i18n file in case there is a language specific reference. The solution should actually provide some guidance, this CS could be added to the references.
wouldn't it be enough that one of these is null?
suggestion AlterationUtils.getVUS(alteration).contains(alteration);
use return ... ? ... : ...?
This should be synchronized
you do not need InternalNakadiException on line <LINK_0>
Would it be helpful for debugging purpose to log out a statement when this method is called. This way, we can easily tell from the log.
suggestion bean.setSourceList(new ArrayList<>());
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
synchronize(FastSyncManager.this) { }
Don't throw the exception. It causes a lot of exception stack traces printed on the screen and stored in the .log file. It would be easy for the user to miss the usage message that is printed as well. I suggest, to find a different way to exit the application. Can't you just call CliParserManager.getInstance().parse(Platform.getCommandLineArgs()); in Application.java and exit if needed? I don't see the reason why it's done in the activator class.
No need for super()
this could be private, or is it used on other classes?
Can you use "," as the default separator? The thing is called "CSV" ... ;)
nit: spaces around + I'd also change / to use OS-specific path separator, i.e. [File.separator](<LINK_0>
The combination of succedded and force is not clear to me, let's discuss this; I believe this API should change.
While I am not denying the setter is confusing, this is not the scope of this PR to change that.
recordCount++; doesn't work?
My understanding is a 'synchronized' block will be slower, but I cannot really say how much in case of AHC.
pls format (>120 chars)
As the Constructor for WTab is protected, the addTab method should probably be protected as well, which would allow the class to be extended. What do you think?
I think it's fine, I've just a curiosity: why add an 'a' in front of parameter name?
.event() is might be better
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
Consider using a more informative message in the log, something like "The value \"" + value + "\" isn't a valid quota mode.". Also, try to use the slf4j {} mechanism: log.error("The value \"{}\" isn't a valid quota mode.", value); log.error("Exception", e); Using two lines is needed because the version of slf4j that we currently use doesn't support a mix of arguments and exceptions.
I'm probably stupid, but I can not get this code. Each time when one call subscribeForCursorsReset() there will be cursorResetCache built. call for isCursorResetInProgress is dependent on previous call. (and btw do not work all the time, cause StartingState is initialized before StreamingState)
suggestion if (this.currentTask != null) checkAndRethrow();
The aforementioned "never return null" rule would be good for all the string getters here.
This doesn't need to be public it can be protected.
Can you add getId() and mark id() as deprecated?
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
You can also use something like return url.replaceFirst("^\\w+://", "");
optional suggestion: since we're extracting helper methods... it's mostly "false * 4" or "true * 4", so consider adding e.g. whenEverythingIsInitialized and whenNothingIsInitialized.
Can we make the type of this field ProblemFactChange instead of Object?
the superclass implementation seems to expect action may be null, also the super implementation also has some logic about whether the context is active. I don't know that we need this since our plugin XML is checking that property.
No need of this. Its marked as @NotNull.
ImmutableSet.copyOf instead of Collections.unmodifiableSet
Please, express if it is permanent or random in error message:  Known permanent failure <LINK_1>
URL instead?
{ }
Add a proper log message.
This could be considered a strange implementation of MVP; as your P is calling V.init(..) which then calls V.setup() which then calls the P to call the V to setup some UI elements. Why not have P call perform the complete setup rather than have the V call the P to call the V to complete setup? Or did I miss something?
Can we not use @JsonSerialize(using = ExternalMetadataSerialiser.class) ?
MessageQueue.RegisterBankAccount_EventMessage
I think there is a StreamsJacksonMapper.getInstance() method you can use to not create a new object.
@rakeshadr is there a potential race here between setting the shutdown handler and checking if it is null?
suggestion return getChannel(context) != null;
Use UTF-8 Charset here and the getBytes(Charset) implementation (it doesn't throw an exception). This use depends on the default system encoder and if it were to change it'll be trouble.
here we'll also have changed from ConfigException.BadValue to IllegalArgumentException I think; a toBytes that takes the origin/path could solve.
I think we don't need to create a table for this test. Just call the procedure and see if it fails.
Why is this needed here?
if we can avoid hardcoding strings here and [here](<LINK_0>, that would be great. Otherwise everything looks good to me.
Here as well I believe we can rely on Kind.
@JonathanGiles, was there guidance in the past to use Iterable or Collection instead of List as it is more flexible?
Should this exit after finding the first visible widget that can be focused?
This isn't a valid implementation of equals. You can have non-equal things have the same hash via a hash collision.
I think baseUri.toAsciiString() always has a trailing / in our usage so with the current build() method I think you will end up with (for example): http://some.example:80//path/path/path?query=true changing to this.path += encodePath(path) + "/"; will result in: http://some.example:80/path/path/path/?query=true I think both of these are valid URLs, but I think we need to be sure there are no server side issues if we use either // or /?. @tomblench any thoughts on this?
You should determine if you need a regression model in the scheduler
Should invoke object.toString()
I think you should throw exception if somebody calls setEvent and give an empty event name. #Pending
Missing codes.
nit: suggestion log.error("User [%s] had role [%s], but role object was not found.", user.getName(), roleName);
Maybe it makes sense to print Log.info instead. Then admin would understand better why namespace is not deleted after workspace creation.
Maybe good to add a limit to the total number of events that can be queued (suppose the send takes a while because of network issues and lots of events queue up in the meantime, leading to high memory usage)
throw exception
"0"?
executorService? connectionStartupExecutor? How about closeConnectionExecutor?
better to cast to string instead of using toString()
You can also use something like return url.replaceFirst("^\\w+://", "");
This check is unnecessary. context can never be null for a properly constructed object.
I think this Map.class.equals(type) is a remnant from a previous implementation and can be removed?
Bad copy/paste: InMemoryRegistrationStore
Why not just use fixture?
DRY: would use this(username, password, null) instead
isRemote(command.getKey()) instead of false
Alot of noise in that (what looks to be an) IDE-autogenerated toString? How about just "SenderId{id}" to be returned from toString?
Instead of doing a copy, Arrays.asList() would work as well (copy would be done later by filter constructor)
Can we get the root class as a generic parameter of the aggregate class or, more straightforward, the repository class? If we can, we won't need to accept it as a constructor parameter.
Can we and should we check that the short index is shorter than the long index?
Can you use inline returns carriesUnmergableSack() ? ... : ... please?
Why this needs to be hidden?
I think this pattern will work throughout the whole string, while we want that it only works for the suffix of the string, which is not enforced. To enforce it, it should be "_[0-9]+_g\$$" or "_[0-9]+_g\$\z" or something similar.
Why it's "EXTERNALVIEW"?
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
remove local variable
Can make this into a singleton as we have with UNSET.
I'd add a guard to prevent surprises if (db.isBare()) { return null; }
The ListenerList implementation already takes care of this. Remove the "contains" test.
This is not necessary. It is done in the RestResourceController, indeed the value here retrieved is not returned
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
... yes it does ...
remove this extra line
@ikhvostenkov this variable can be inlined
no reason to explicitly set to null, its default behavior
merge else if?
Can you reduce the nesting depth here?
nit: Could be this.conf = requireNonNull(conf);
better to cast to string instead of using toString() .
Agree with you. We will probably test this on different level.
Add Gst.checkVersion(1, 16);
Please consider having a method overloading for the case there is no volume name.
Avoid
can we remove the version completely?
Shouldnt we have this defaulting to the common namespace (ICommonAttributes#COMMON_NAMESPACE) so that we can tell the user what this defaults to?
if i get it right: if response is null, we will not retry. i think we should retry even if response is null. btw what caused this in your case? so it would be:  response == null || ....
Do you think this is an more efficient way to implement enforceAdd: java public static List<GraphQLDirective> enforceAdd(List<GraphQLDirective> targetList, GraphQLDirective newDirective) { assertNotNull(targetList, () -> "directive list can't be null"); assertNotNull(newDirective, () -> "directive can't be null"); // check whether the newDirective is repeatable in advance, to avoid needless operations if(newDirective.isNonRepeatable()){ Map<String, List<GraphQLDirective>> map = allDirectivesByName(targetList); assertNonRepeatable(newDirective, map); } targetList.add(newDirective); return targetList; }
Do you know anything about the expense of these methods? Will these cause RPCs to namenode?
would it be better to use isNotBlank here?
100 seconds is 1 order of magnitude more. It seems a lot. Would doubling to 20s be enough? Or could we instead use org.jboss.as.test.shared.TimeoutUtil#adjust to adjust the time of this test?
static
i do not think we need to save this line better make it more readable
Following the sample code I shared for updating the setFollowing function, this function could use the same refactoring too.
you could just do setConfirmWindow(null); like above method
I think the old way is correct as these methods are public factories for the class and thus are logically part of the class' public API. Visibility is controlled at the class level. Similarly, if we have a top level package-private class, we'd make the methods public rather than package-private. In addition to being more clear about the public API, it's a one line change if the class later needs to become public (instead of changing / thinking about each method).
If I correct, we can remove 'client', field because it is used only once, and change condition in 'getConfiguration' method from: if (!client) { to: if (!c.isClientMode()) {
We could call: java checkNotNull("command", command);  :-)
This can now be deleted.
does it have to be public?
version == null should be bfeature.getVersion() == null --> the candidate feature always has a version, only the site feature may be version-less
Similar to above, why did you moved the try block?
can you add to Builder as well
I'm not sure it's worth sharing this method checking permissions: 1. the call to checkLoggedIn should be the first call in method handle so that we don't do any SQL when user is not logged in 2. this leave method checkQProfileAdminPermission with a single method call which is hardly useful to factor
Although we need to figure out how to propagate interruptions, this will now cause a problem as it this method is called from within tryUpdate which is recursive and propagating here means the next attempts will also fail for the same reasons. We need to figure out how to retain the fact that we were interrupted and propagate the interruptions outside the whole thing.
I prefer shorter method names, when the important information can be said by the argument type - which is the case here. LGTM.
instead of building loadService in the constructor just a create MutableSupplier (see code in the ltr plugin). Make your QueryBuilders accepts Supplier<LoadService> and call the set method in createComponents when you have everything needed to build your service class. That's not particularly better but it allows to keep dependent services final in your class.
Any reason not to use return type Collection<Report> here, then return reports.values()?
This will throw a NullPointerException when state is null. Reverse the equals checks to prevent this. if (STATE_ERROR.equals(state) || STATE_FAILURE.equals(state) || STATE_PENDING.equals(state) || STATE_SUCCESS(state))
you should also check that log contains GIT_COMMIT is
What was the reason to change getActionInformation (i.e. instead of returning a new instance of the action, keep one and update it)?
I think I prefer "Invalid key" as exception message
WTF is lala
please use static import for Mockito
I think we have some constraints regarding the target URI? (e.g., exactly one? at most one?)
Make secrets an immutable list if present.
There seems to be an output change here: original: Base32.encode("a".getBytes()) => "ME" new: Base32.encode("a".getBytes()) => "ME======" We might need omitPadding() to ensure this is an exact drop in replacement.
This should always be read from the configs.
We could throw an UnsupportedException here.
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
isErrorIfHostDoesntExist => isNewHost
I'd put notEmpty there
This is redundant.
Please don't print stack trace like that. Either log it properly or ignore if the information is useless.
Should use parameterized logging instead of string concatenation.
Can you look at the resource test i pointed you in the ticket description and then put some thing in these method bodies? You can even just copy some ideas from the pull request i pointed you to done by one of your team members.
Unnecessary call to super()
this should go to super.reset(), shouldn't it?
IDEA says that using toArray(new String[collection.size()]) has no performance improvement over toArray(new String[0]) so the second call is encouraged.
Again, not sure if it's more readable, but this could be:  java return Const.* + "?key=" + regkey + (institute == null ? "" : ("&" + ... + "=" + ...));
You should use a consistent method naming paradigm within your class. I think this is the only setter that says "set" on the start. Either have all of them say set, or none of them. This might also be a good opportunity to change "rya prefix" to "rya instance name" since the prefix is Accumulo specific.
perhaps vds load blanacer
this should be "/api/pid","pid" It could be better to define a constant to use in the Controller mapping annotation and here
![MAJOR](<LINK_1> Refactor this method to throw at most one checked exception instead of: java.io.IOException, java.util.concurrent.TimeoutException, org.osgp.adapter.protocol.dlms.exceptions.ProtocolAdapterException [![rule](<LINK_2>](<LINK_0>
Will this always be this value?
another log that can be removed (I know it's not part of your commit, but please do it anyway).
nit: you can merge both lines above as checkNotNull will return the given argument
why 40 as a limit?
can we split this into multiple lines and add tab support?
If you follow my advice above about disposeLookupSourceIfRequested you will end up with a method called disposeLookupSource, which you could call here... Also as above I would put the if in the call-site
suggestion createGrantAuthorization(PROCESS_DEFINITION, DEFAULT_PROCESS_KEY, userId, ProcessDefinitionPermissions.READ_HISTORY);  Both works, I guess. But since you used ProcessDefinitionPermissions.NONE in testCheckReadOnHistoricProcessInstanceAndNonePermissionOnProcessDefinition, maybe we should stick to one format.
public isn't needed
hashCode -> System.identityHashCode
i didn't find a disconnect method for influxdb   can you confirm there is no method to disconnect?
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
Please use P.lazy(u -> f.f(a)
Same issue here, double delete user.
Why are we configuring drawer in this activity. This activity shouldn't have it.
adding an extra pair of around endTime - startTime would be nice for those of us who never memorized arithmetic operator precedence, like me :)
Same as above: Can we use AtlasDbConstants.DEFAULT_INITIALIZE_ASYNC?
return type JPAQuery<?>
This should probably throw if the value is null.
How about just context since we have it?
You can use mapToLong here and then sum()
Can we not verify that the text boundaries are correct? Verifying that we simply set the boundaries on the text decorator is better than nothing but can we not ascertain the values that should be being set?
l10n
bracket should be on the previous line
This is not correct, orderGroup and sortWeight need to be copied too, this should stay unchanged instead you update Order.copy to copy over these fields too
Let's avoid raw types, please.
My brain capacity is quite limited so often I simplify it to:  Employee e = entry.getValue(); return e.getSalary() == salary;  This is easier on the eyes.
Missing codes.
StringUtils.isEmpty(namespace) will take care of both (not important, just FYI)
I thought this was to be debug to prevent unwanted data from appearing in the log.
Does any of these have to be protected?
probably worth using a linkedlist here as well, although I doubt allocating 10 ints makes much difference though compared to other stuff we do
you could just do setConfirmWindow(null); like above method
You want to use FormField.getFirstValue() here and everywhere below.
boundedElastic
This code to get the feature is used here and in the remove method. I'd suggest to create a new BackendClusterFeatureHelper class and put this code there. Then you can call it from these methos. Look at BackendDataCenterHelper for example.
How about inlining it?  if (!contains(o)) return false;
hmm, really not sure about a cache. The aspects are not necessarily "immutable" for a given event. Calling resolve at one point may not yield the same result as calling it later, so I don't think we should cache them. Every class that calls .resolve() could only call it once and "cache" its value though. About possibly merging the two methods: If we look at the use case here, for example the classes using a TmfCpuAspect, basically what they all do comes back to: "Go through all the aspects of this trace, find me a TmfCpuAspect that returns a valid non-null value, gimme this value". Couldn't we have one utility method that does just that? It could even be specific to a TmfCpuAspect (and derived classes) too!
Should be !socket.isValid()
This should be able to remove a membership that matches the patient, if there is multiple for the same patient then you can ignore it
Missing a newline.
How is this expression different from "this"?
Actually, would you please have this still error? It likely represents a programmer error if the application is handing a null Collection to this method. I'd instead suggest something like: suggestion Assert.notNull(userAuthorities, "userAuthorities cannot be null");
I don't think this is correct. Consider changing a disk to use QuotaA instead of QuotaB. I'd assume you need ManipulateDisk on the disk, and consume on QuotaB, no?
Same here, use config.getMessageTimestampName() directly where appropriate.
you don't need to check for null since this gets set in the constructor
suggestion throw new UnsupportedOperationException("FileStoreAttributeViews aren't supported.");  Indicating currently isn't needed, let's be more blunt on the exception message.
The object passed as the last parameter of MethodRule.apply() needs to be the test instance, not the test class. The only way to get it is to have the caller pass in the test instance into the TestRuleAdapter constructor.
Declared exception from update method can be removed as well as this try-catch block.
checking for nullable parent was added specially, cause going into project node simply has no meaning
Why are we removing the call to hsync()? hflush() doesn't guarantee that data has been written to stable storage.
This condition seems to be backwards. I think it should be index < array.length
what else? any warning or exception should be there?
this param is unnecessary
We should use the spring.application.name boot property instead of the applicationContext.getId.
Can we configure the application to use a connection pool when creating the connection factory? We recommend connection pooling as a best practice in our docs. The [spring-data docs](<LINK_1> call out [r2dbc-pool](<LINK_0> as a popular option
code style
Similarly
Could you rename variables to make the purpose more obvious? Like: newHandlers = handlerMap.merge(address, handlers, (oldHandlers, h) -> oldHandlers.add(h.first())) At least do not use current for the second var of the remapping function.
Same here. Consider just propagating the current exception.
This could just be return !(isDiscarding() || isCalleeData()) || isAsync();
An additional blank line.
We can make DestroyProxyMessageTask implement the Supplier, so that this method will no create a lamda but return this instead.
since this happens before canDoAction, getVdsGroup() can be null
there was a NOT ('!') before the check.. i think still relevant, no?
throw exception
You're not making defensive copies of the Set, how do you know that it's immutable?
I prefer using () when there's a single value and {} when there are multiple properties, but it's just a matter of personal taste.
Should this link to the course?
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
I think we should depend on the fact that this is an instance of EmptyByteBuf... just check it's not readable and release it
No need for requireNonNull here as the encode method will throw NPE. The rationale for null checks in constructors and other places is to ensure the object invariants and to have the exception occur at the right time, when you know who provided the null. In this case, the caller will get an NPE with the proper stack trace. Occasionally, we might want the explicit check to provide a better message, but that shouldn't be needed here as there's only one object. Now, if bytes was an argument to this method and was being put directly into the lambda capture, we'd want a null check to ensure the capture is valid.
Add character limit check - #2105
checking for nullable parent was added specially, cause going into project node simply has no meaning
Isn't it a bad design to have a method required by only a single concrete class in the generic interface? Can we fix it so that we don't have to do things like this?
There is also StringUtils.removeStart for that
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
add brackets around if the clause or move on to same line.
synchronize(FastSyncManager.this) { }
Why that read() has to be under lock? We only need to protect usage of the "position" field (or even make it atomic instead) and let actual read() / write() concurrency to be taken care of by underlying FileChannel.
This should return a BitSet.
l10n
No need for final parameters?
Rogelio's above suggestion applies here as well: > I think we could modify the code a little to call one time ImageUtil.getInstance().getDimension(getFileAsset()) and store the dimension in a private variable, so that way you don't load the file twice to get height or width in the same instance. > Just check if dimension is not null and get the proper value
null? why not just a () -> {} ?
nit: For list with just one element, I think we could just make it in one line (unless it's too long..)
this("SingleOp);
I wonder what if this.k and other.k are different.
The synchronized block should include stopThread = true and close.notify() before thread.interrupt.
I am curious about how temporaryRoot get formed on line 563. Does that mean if the targetPath is hdfs://path/to/your/table, then temporaryRoot will be hdfs://path/to/your/table/tmp/presto-userid/ ? I thought temporary path should be something like hdfs://tmp/presto-userid ?...
![MAJOR](<LINK_0> Make this line start at column 7. [![rule](<LINK_2>](<LINK_1>
don't you need to increment the index to avoid infinite looping? how do you avoid having seriesName, and seriesName(0)?
Can you have an @After method that unbinds this connection. This is more reliable.
I am reading the class again again and I think we do not need sourceColumnIndex to be class variable. I think we can keep its scope just in the for loop. Then I think the only usage of sourceColumnIndex can be replaced by columnIndex.
Should be a SamzaException with a message, not NPE.
you can't get here with vm == null, so it should be removed from here.
given that specificity of this SV is exception type I would add the exceptionType in this.
Depending on the stream type, you can't actually rely on the return value of skip. I've learned the hard way to follow commons-io's skipFully and use read instead.
Do we have to make new instance of NMFDataCodec every time?
My personal preference is to use brackets even for one line loops and condition. Not a blocker to merging.
In alignment with valueOf, perhaps name this valueOfType or fromType?
it is not better to use Clock.systemDefaultZone() instead ?
Don't open things up that don't have sufficient parameter validation, the @Nonnull is not enforced here because it was an internal method, so you'd need to add a Validate call here.
it always primitive, no sense in returning Object
UOE instead of ISE (x3)
use Long.valueOf() instead of new Long() - always for performance reasons
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
Hmm, this is going to blow up if there isn't a provider session ID for some reason. In practice, there should be, but I think I would prefer it the absence of a value meant the cookie wasn't sent at all. This will probably still result in the authorisation failing but it will be handled by our existing code authorisation errors, which is fairly graceful and cleans things up.
{}
I think super implementation is correct (size == 0). Nulls are still considered part of the list, they just take no memory in internal structure.
:-1: for magic number
Have you tried this with an existing stream with applications deployed? I wonder if we can use the explicit streams/logs/{streamName} endpoint for this.
A flip != 180 rotation
why this is in vmCommand? should be in stopBase command
Why are you assigning 0 to numElementOnPage, as you assign some value again in the next line?
I had a feeling there must be something like this to control it, fantastic!
It seems like we would be better off making this actually return the path instead of a String. It's different than the old API, but I'm not sure I see the use of getting a string back.
There is no need to call super.close() on InputStream. It is a no-op method. Instead you just need to do is.close();
let's update all the includeTextDetails references to includeTextContent
Instead of all these null check why don't you make getContribution always return non-null? I.e. return default provider if there is no mapping
Out of curiosity, why is the return type of this setter not void?
I guess you could reuse the method in ForwardingGridDialect
do we want eventually to have a writeTo(ByteBuffer) ?
Move to a separate commit
I think we should store ignoredRegions instead of ignoredLineNumbers. Single lines that need to be ignored can be stored as <LineNum, LineNum>.
please remove or decrease log level to TRACE
can be !isDisabled()
I don't see a reason to return an Iterable here instead of the more specific return type Set. The result is very small and a lazy evaluation is not necessary (which could justify returning an Iterable). Returning Iterable instead of a more specific type unnecessarily limits what the caller can do with the return result.
I believe the order is guaranteed in partitions by the sort order of Partition which is on the partition ID.
would be nice for the 4 to be a constant for readability
I think you mean "Liquid Glass"
Similarly use the Java 7 template
why do we need this part?
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
I don't know what has been @sjka intentions and I agree that this could be removed... ... but didn't we have a discussion in another topic where you / Kai argued that we cannot rely on correct usage WRT to the nullness annotations for code that is called by third party ones (e.g. binding developers etc.)? So, if we don't trust non ESH framework developers that he uses annotations classes correctly, isn't that exactly what you want?
Why do you we need to keep a reference to the activity here? This will leak the app. We should use mEditState array instead.
Let's use @CacheEvict(value="userSearchLocales") public User saveUser(User user, String password) instead. We will get rid of CacheManager in Context as well. It would be better to evict just for the specified user, but our key consists of user and currentLocale. SaveUser is not called that often so invalidating all entries is no issue anyway.
root would not change and I can't think why its access needs to be serialized with other methods so why does this need to be synchronized?
map(Queue::getActualName)
We also need to override that in NestedUDTMapper and EnumMapper (using an enum as partition key, though unlikely, is possible).
Shouldn't this come from the builder?
Please keep the indentation consistent.
Should me make it default and use Objects.requireNonNull? The logic of the setter is a bit unexpected
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
Pager builder can be replaced by Pager.single().
The "brackets for single statements" cleanup in this file should be done in a separate commit, as we should not mix unrelated changes.
Can make these final and use checkNotNull(catalog, "catalog")
return type JPAQuery<?>
checking for nullable parent was added specially, cause going into project node simply has no meaning
I know this default is here for backwards-compatibility but I'm not sure about the value. If I create a factory - "OffsetDateTimeFactory" - I wouldn't want that to be the logicalType name. In other words, what do you think about the default implementation being: default String getTypeName() { throw new UnsupportedOperationException(); }  This way it is required by any new LogicalTypeFactory to implement it?
I think here we re-introduce logic we already have [1] [2], from my point of view would be worth to extract this scroll logic into a separate class and reuse it multiple times. [1] <LINK_0> [2] <LINK_1>
can we plesae use specific exceptions here ?
If opening is true, doesn't it mean it's still opening but not done opening yet?
This check is useless as the customParams can never be null.
rename to clusters
I think we have a race here with close.  T1 check assertOpen T2 close() T1 factory.apply( slot )
Please extract the constant string.
This is not thread safe. Is it guaranteed that this will only be called in a single thread? Does this guarantee still hold if Nimbus is sweeping many products at once? We should either make this safe or make it very clear to our future selves that this is an issue we need to fix.
Can we retrieve our actual gson instance? I don't care if it has to be exposed on the component level
you're not the author of this code but still, it may be useful to add exception or message to logger.
What is this log statement for, exactly? Seems like a trace?
This shouldn't be needed as StatementClient.close() should be idempotent
I still recommend to put here human friendly text.
must be immutable :  if (null == this.map) { this.map = .. } else { throw new KasperException(..); }  if you can add this also on the CollectionQueryResult it would be really appreciated :)
Why are you building JSON by hand?
Well, what happen then if user still use the deprecated method? we need to be backward compatible, right?
The constructor of DynamicStringProperty is package private. The reason is that we want people to use DynamicPropertyFactory to create instances where DynamicPropertyFactory will lazily install a default configuration source and attach to the dynamic properties, if none is explicitly installed. You might also want to make this constructor package private and provide a factory method in DynamicPropertyFactory. Or, try call DynamicPropertyFactory.getInstance() in a static block at initialization of this class. === update === After looking at the constructor of PropertyWrapper, it calls DynamicProperty.getInstance() where DynamicPropertyFactory.getInstance() is called. So the initialization of a configuration source is already taken care so it is not necessary to force it again. The constructor can remain public.
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
It is there to compare a string with "\n"'s in it to some output which contains some kind of line ending, which is normalized to "\n" so they match. If I remember correctly :-)
What happens when one of these TypedOutput instances return -1 because they don't know their length?
Shouldn't this close the iterator before returning the list?
are you sure we need to use OSString ?
Default the member variable to Proxy.NOPROXY. Never mutate or translate a value in a getter, it breaks all expectations that the caller will have. This one breaks the relationship between the get and set.  options.getProxy(null); if (options.getProxy() != null) System.out.println("Whut?!");
I think this belongs more to Logger.debug level.
If the expectation is that this always get built from Bugsnag.buildReport we should remove the public here to make this package protected. This will enforce the API usage which will make it easier to maintain and refactor in the future.
[minor] It could use (slightly) better naming - ie hasCancellationSucceeded or something (more along the standard naming). handle is a bit generic for me and in this case the method determines whether something has been successful or not.
Avoid the use of swtDefaults(). fillDefaults() and explicit alignment makes the layout logic easier for others to read. applyTo() is preferred over create(...) when attaching to a control since it's easy to generate a ClassCastException if you mistype this and omit the ".create()". The applyTo version is also shorter. Change this to: GridDataFactory.fillDefaults().align(SWT.BEGINNING, SWT.CENTER).applyTo(l);
will be null after view disposal. PlatformUI.getWorkbench().getDisplay() is our friend.
This payloadTypeCache must go to the MessageSerializationUtils directly. I see you have something similar in the JavaClassMimeTypeUtils for the mimeTypesCache. So, why don't be consistent?
Just use inCoreLimit here. Don't convert units to MiBs.
Timestamps have no unit ?
Nope, make it false please :)
This and line 59 can be a global variable to clean up tests a bit
@dmzaytsev let's replace this with a try-with-resources - JsonWriter is Closeable, so I think it might work. If not, let's close it in a finally block
As we are not exposing the original Scan directly, why to create a new Scan again here? No need
I believe that other implementations are either returning an actual String representation of the operation, or the result as String. Could you double check that?
shouldn't this be: return setAddress(null); ????
Would it make sense to use Predicates.await() here and limit max wait time somehow?
NoSuchElementException is more accurate
This implementation looks correct to me, but I think it should have its own unit test, to be sure, and to prevent regressions. I think testing all the boundary cases for arrays of length 1, 2, and 3, would be sufficient to cover all possible cases. (i == 0, i == a.len-1, and 0 < i < a.len-1)
I think I prefer "Invalid key" as exception message
this shouldn't have been here either, format is required.
I would prefer to make this public since otherwise it's impossible for clients to correctly initialize the class. Mark it as @noreference to hide it from the API.
Same as above: Can we use AtlasDbConstants.DEFAULT_INITIALIZE_ASYNC?
why the key cannot be session id?
Seems like a reasonable change. Can you extract formatter.withZoneUTC() into another constant to avoid additional overhead each time?
@Override should be on line above. Checkstyle/formatter config?
this.id -> id
I don't see you overriding this in your Bounded implementation, why make this protected?
This isn't necessary. When you need the inserter call getObjectInserter(). Your super class manages allocation and release for you.
I should explain it better earlier, what I mean by "inline" is to move the implementation body of isNonRetryableServiceException  to inside the isRetryableException method, then the negations should be applied onto each expressions, return true -> false; etc. This is still a double negative.
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
Typo? "BlobDet4acryptionCount"
Why there are things that are irrelevant to this PR? Although we need sanitise field here.
[minor] It could use (slightly) better naming - ie hasCancellationSucceeded or something (more along the standard naming). handle is a bit generic for me and in this case the method determines whether something has been successful or not.
You almost got me right now. :-) There is no need to test the injection point. You only inject instances of this interceptor to the injection points where it should do its work anyway. Because of that it is unnecessary to provide and check the injection point. Just delete this method and the field and constructor parameter and change java private void invoke(IMethodInvocation invocation) throws Throwable {  to java @Override public void intercept(IMethodInvocation invocation) throws Throwable {  and you should be fine. :-)
this. for consistency
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
IF EXISTS should be reflected in unparse
Same here. It's more readable when part of deserializeValue
As noted above, just put the init code in init() unless there is a reason not to.
Let's rename locationModule to just module. Then we can bind SessionPropertyProvider inside the module. (The name is already bad, as it's no longer for location. I missed that when converting to Drift.)
Init should only be called one single time when constructing the controller. That is done in OnStart. Please add a space between if and (
Are you sure that this class contains all that is needed/changed/new in cdi 2.0 specs? Aren't they any different?
requireNonNull
I would use checkNotNull pattern that you used elsewhere to be consistent and more succinct. here and everywhere else in the new code.
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
you could just do setConfirmWindow(null); like above method
Use ServerUtils.isMainThread() etc.
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
Should this variable be something like 'needsDefaultRelativeTo' with a default value of true and here and L217 sets it to false? I think a few years from now a future colleague in SET is going to see this and have hard time understanding why a value for PATH results in "relativeToEncountered = true". It took me a few minutes to figure it out and I'm looking at a diff where I understand the goal of the change very well.
I'm pretty sure we use IllegalArgumentException for these everywhere else.
Style-nit: I think I would prefer this to be defined as: public CommitCommand setCommitter(String name, String email) { return setCommitter(new PersonIdent(name, email)); }
remove public
you can use containsKey()
Would you please explain why clear() need to call ?
Just new Date() is enough
Please add lazy initialization here as it is done in other classes
nit: we usually write id.equals("server")
same logging here as in perform next operation
the methods are public by default, no need to provide modifier
annotate with nullable.
Lists obtained from a message are immutable. No need for extra copying.
Also this: parent.syncScroll(DisplaySide.A); // match A's viewport
remove this
I am not sure using a flag is the best choice here. the bookkeeper client should be *smart* to figure out whether it should be reading explicit lac or piggybacked lac.
optional: can take the opportunity to add braces
Can we change this to Throwable? Then we also catch issues with dependencies, classpaths. It is what all other parts of Flink do and it is important. Otherwise one job with wrong dependencies kills a shared cluster.
The super() returns "" on null. Why should we differ?
Assigning revisionId = ArticleRevisionIdentifier.create("0", 1) could be done within the @BeforeMethod.
Save the null check: !"".equals(model.getEntity())
minor: this v == null check is unnecessary.
Remove throws Exception
Should be- setTitle(text.asString()) not setText.
Is it required to have doScan(...) both for producer and consumer?
StringUtils.isEmptry(XXX) if possible
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
nit: you can merge both lines above as checkNotNull will return the given argument
@lautarobock Same here, let's declare throws Exception
@Override this annotations is not needed in test inputs
Missing a newline.
Let's rename locationModule to just module. Then we can bind SessionPropertyProvider inside the module. (The name is already bad, as it's no longer for location. I missed that when converting to Drift.)
Check if an entry with the given key (name) already exists and throw in that case an exception.
but if the feature is unchangeable, then the user cannot do anything about it, so it should be set to readonly, or am I misunderstanding the unchangeable feature?
A LinkedList is better since you don't seem to access specific indexes anyways.
This test should contain assertions. At least to verify the existence of the variable a in each scope.
Does this really throw a IOException given the try...catch below?
check for READ_ONLY style is missing?
This isn't right. It shouldn't return a lock if acquire returns false.
Maybe just return map.computeIfAbsent(x->create())?
return array == null || array.length == 0
can you add to Builder as well
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
I think we should centralize the quote parsing logic. This is the 3rd place where we unquote/unescape quoted names.
The super() returns "" on null. Why should we differ?
please verify that the amend function is actually executed
Please use Yoda DateTime.now().getMillis() for a timestamp
Shouldn't this file name change too?
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
Indeed, that is better than my suggestion. Let's do this.
Can you add a hasUnfinishedInput method like the in the RowNumber commit? I think it made the code easier to read?
assertEquals(Foo.class, foo.getClass()). The produced Foo is @Dependent and so there is no client proxy and we can be sure the instance is the result of the producer method.
I should explain it better earlier, what I mean by "inline" is to move the implementation body of isNonRetryableServiceException  to inside the isRetryableException method, then the negations should be applied onto each expressions, return true -> false; etc. This is still a double negative.
... and below.
I suggest to keep the order consistent for easier reading/comparison: * field declarations in StashNotifier (maybe) * setters/getters in StashNotifier (maybe) * default values (lines 751-758) in StashNotifier::configure * assertThat calls (lines 27-33) in ConfigAsCodeTest::should_support_jcasc_from_yaml * setter calls (lines 40-47) in ConfigAsCodeTest::should_support_jcasc_to_yaml
Maybe use Objects.requireNonNull since this is built into Java 8 instead of using Guava.
Squash into one line? unregisterAndCloseRepository(i.next().getKey(), null)
I would really appreciate if you rewrite this so it doesn't use -1 as startIdx. A year from now I won't remember why we want to load from position -1.
any particular reason why this method doesn't require an IJavaProject ?
I would replace " " with ' ' since there is only one character.
i think java return vv -> connection.getContext().runOnContext(handler);  Would have the same result and it avoid 1 extra lambda
please use Objects.hash() which simplifies the code
final method?
calling Thread.isAlive() seems like a bad sign. I don't think fixing "query engine source single" or equivalent should be considered out of scope here
we don't need to change the Creation classes.
Ha you see here you use a simpler constant! I think "" is fine too.
Currently you're parsing the message JSON twice: once in extractDataFrom and once in getMetaData. This could be improved by modifying extractDataFrom to use the output of getMetaData perhaps.
ActiveMQWebLogger.LOGGER.debug("..."); would also work... but I prefer to have the actual logger on debug or trace
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
Out of curiosity, why is the return type of this setter not void?
Change seems unneeded. And actually the unchecked can be removed as well.
public isn't needed
You shouldn't need to specify it. I guess that Kubernetes API is the default mode.
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
Do you think we need sync control on all the map operations here?
As above, I'd use String.valueOf here.
There should be a null check here if it doesn't accept null values
if the dependent graph doesn't have cycles how can it be, that grandParents.add(gp) == false ? If it can never be false why to include it in the while condition?
You almost got me right now. :-) There is no need to test the injection point. You only inject instances of this interceptor to the injection points where it should do its work anyway. Because of that it is unnecessary to provide and check the injection point. Just delete this method and the field and constructor parameter and change java private void invoke(IMethodInvocation invocation) throws Throwable {  to java @Override public void intercept(IMethodInvocation invocation) throws Throwable {  and you should be fine. :-)
Unnecessary whitespace.
can be !isDisabled()
Similarly here, exec. should not be necessary.
StringPool.EMPTY instead
move this setter on top of methods. then should be all getXXXxxxToken then should be beginTree
I think you could avoid to use this to reference the fields in the unit test, because there are no name conflicts.
missing a parameter? {} is there but there's nothing passed
A little sanitization here would make a lot of sense, if nothing else make sure no ' ?
Aren't we also prioritizing savepoint barriers here? Or are they guarded by using NO_ALIGNMENT_TIME_OUT on creation?
notEmpty check?
Why is this not return this.kind == kind ?
Can't this be further improved to just Arrays.asList(values)?
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
wouldn't it be enough that one of these is null?
Again, use IOUtils.
It shouldn't be an error. We have warn log tracking in many places now, so would pick up if this was frequent.
Do we want to include the original throwable so it can be shown in stacktrace as "caused by"?
suggestion @Override public GridCursor<Row> find(Row lower, Row upper, BPlusTree.TreeRowClosure<Row, Row> filterC) { assert filterC == null; return find(lower, upper);
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
I'd make this a throw new NullPointerException("registry == null"); instead
package-private? Only used by AbstractJmxRegistration
you don't need this function, you can use constructor directly
Optional should be used in interfaces. Use null as internal value.
I had to do a doubletake here, it's an extra line but this could help readers java if (caught != null) return caught; if (request == null) return null; return request.maybeError();
no need to check for null again...
I this refactoring, very nice. Could make this method protected.
This is never returned.
This should probably throw an IllegalArgumentException if it is provided a conf object that is not of type StatefulMongoDBRdfConfiguration because the code will not work if that is the case. Throwing an exception make it easier to hunt down that bug.
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
Should this be above "isColorTeamMatch"? For example, on line #755.
suggestion return Collections.singletonList(MagicThingActionsService.class);
use return ... ? ... : ...?
return String.valueOf(this.properties.get(key)) perhaps? to protect from null...
Don't need this keyword here - the rest of this code only uses this when necessary.
Do we need a throws declaration here? It seems to be inconsistent in the existing methods.
should this be StringUtils.empty?
This means TestHiveClientInMemoryMetastore won't run the statistics tests. Do we implement this in a later commit?
Same here. Add e as an argument to the IllegalArgumentException constructor.
Just return data.
Doesn't look like conditions are same.
Did you think about using [appendQueryStringToURL](tests/blob/master/src/test/java/com/wikia/webdriver/common/core/url/UrlBuilder.java#L71) method for appending URL params to URL?
Its the _Matcher_ that gets reused multiple times - the list probably doesn't.
Hmm...while at first look this looks ok, I think we should 'harden' it a little bit to prevent cases of leaving compensation context uncleared in the DB. I'd suggest doing the following: boolean clearCompensation = true; try { endSuccessfully(); } catch (Exception e) { clearCompensation = false; } finally { if (clearCompensation) { if (getCommandCompensationPhase() == CommandCompensationPhase.END_COMMAND) { getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand(); } } else { if (getCommandCompensationPhase() == CommandCompensationPhase.END_COMMAND) { compensate(); } } The code can be improved, but this is the direction to go to reduce leaving compensation trace in case of a failure during the end action.
it would be better to use compositions of iterators, e.g:  Iterator<Page> -> Iterator<PageWithPosition> -> merge -> Iterator<PageWithPosition> -> build page -> Iterator<Page>
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
Please don't change API visibility. Thanks!
So this will be used for quantity and duration too or you need separate ones?
public isn't needed
And then else if this
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
just wondering, w/ slf4j do we still need the custom format() ? I hope/think that's done by the slf4j logging library
return Promise just to symmetric with start()...
final This should probably contain this.value = value at some point... and it should only do so if isListening = true.
A test without any test ? That's unusual
this whole method could be a oneLiner: return find(...) != null
I think this can return null if there is no timeout. From what I see, a null SocketConfig is supported and what occurs normally (if you have no customizations).
Is there right message? Because this one is same like for UserSyncFailed.java event.
Should we really have a listener if x-site wasn't configured?
Unnecessary boxing?
Why are you changing to patient 7 here too?
You have missed oldValue in the criteria. See the replace contract in the ConcurrentMap.replace
Make getters private and use this on instance members.
should really be stored as a long in UTC, or at least ISO 8601.
We could call: java checkNotNull("command", command);  :-)
I'm wondering why do you use RtForks in MkForksTest tests. We should test MkForks instead
please remove else, code will be more readable
Why are we configuring drawer in this activity. This activity shouldn't have it.
could you provide a test for option(null) also, I'm not sure how that should behave differently from some (I guess it should represent a none intuitively)
This test should be verifying that you _can_ use this event, not that it throws an exception.
you have to add a canDoAction message if you fail canDoAction
Symmetry (throw)?
Use TRY_CAST_NAME in the following constructor.
move null check back as first action in the method to not change behaviour
In their naming, these are the "Account Id" and "Application Key"
Let's merge creating cache configuration and passing it to ignite configuration.
Should we prevent setting the executor while the connector is running? Otherwise we get concurrency issues with hasInternalExecutor flag. Is it even necessary to have this setter instead of setting it in the constructor? Then we could make the executor field even final. atm we are accessing the executor from different threads without appropriate locking or making it volatile.
don't forget default case
does this need to catch all exceptions?
use getGuid(rs, "disk_id")
null check
plase fatcor out that hardocded path segment
String.format("%s", s) is s, therefore filePath() will always return fileName, so it is obsolete, and we should consider renaming fileName to filePath.
suggestion return cachedBody.next().map(ByteBuffer::array);
use return ... ? ... : ...?
UnsupportedOperationException seems reasonable here.
There are maps that don't allow null keys and (stupidly) throw an exception when you try to check for its existence. You need to account for them here. suggestion try { return map.containsKey(key) && super.valueMatcher.matches(map.get(key)); catch (NullPointerException ex) { return false; }
What is the purpose of this conditional?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
The stacktrace here is pretty boring. Therefore it was left out intentionally (although due to the missing placeholder still wrong). It would have been nice though to let the user know what exactly was the value that wasn't so great: java logger.warn("Could not set new location {}, keeping old one: {}", location, e.getMessage());
Money is a reference type and needs to use .equals() instead of ==. Also we need to make sure calculateCost is called first. suggestion return part instanceof CombatInformationCenter && getStickerPrice().equals(part.getStickerPrice());
Remove?
Why long?
StringBuilder
don't need getName() just this.oldSelectedVersion.notEquals(newSelectedVersion)
Should properties be setable? Also what if properties argument is null?
suggestion public GHDiscussion wrapUp(GHTeam team) throws IOException { this.organization = team.getOrganization();
Use faster methods, should not use data processors when possible.
Please make the constructor private to be consistent with the other controls. Instances are created via the Validation API.
another
Iterables.all(toolGroup.getTools(), Predicates.instanceof( AbstractToolDescription.class)); allow to return false if all items are not of type AbstractToolDescription
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
no need for the ||
ZooKeeper supports try-with-resources so using that may make this code cleaner
did you mean to keep this?
since this persist is triggered by the maxRows config, would it make sense to persist the one having the maxSize ? as the oldest one may have very small number of rows.
Buffered it
Style fix suggestion public long getIgnoredPlayerTimeout(UUID uuid) {
more a style thingy but we prefer using AssertionsUtil.expectAssertionError as shown <LINK_0> java @Test void should_fail_if_optional_is_empty() { // GIVEN Optional<Object> actual = Optional.empty(); // WHEN AssertionError assertionError = expectAssertionError(() -> assertThat(actual).containsInstanceOf(Object.class)); // THEN then(assertionError).hasMessage(shouldBePresent(actual).create()); }
IMHO it does not need to be public
are spaces OK in namespace strings?
I think that may have been an oversight in longSum. Try a query that results in +Infinity at the historical level and you will see why it is needed to deserialize at the broker level
wouldn't it be enough that one of these is null?
Should be  java int result = Long.hashCode(articleId);
Does this method need to be public?
There will be other validation errors here so it's not enough to test if there are any, but you need to use the for loop as below to test there's a one with code "Concept.error.notAtLeast..."
Prefer not to have a null environment from start.
do not assing parameter! nowhere!
@cuenyad Add exception management
I think the setter would be a more appropriate place for this defensive logic.
would it be better to implement it like this? java @Deprecated protected Object decodeHeartbeatData(Channel channel, ObjectInput in) throws IOException { return Response.HEARTBEAT_EVENT; }
you could use a newly added utility to get the color based on the state color to avoid "white on yellow": Color stateColor = gc.getBackground(); gc.setForeground(Utils.getDistinctColor(stateColor.getRGB()));
let's stick to if (style.isVariableHeight()) { return true; } for this patch.
I'd also set a flag internally on this listener. Then, if in future some code called listenToCache() with an already-triggered listener, you could just return immediately.
Give a name to this thread, so if it hangs or blows up, the stack trace will give us a clue who called it. i.e:  new Thread(r, "Hawkular Java Agent Stop Thread").start();  I also need to think about this some more before merging since we are now making the stop() method asynchronous. We have to check to see what kinds of thread safety/concurrency issues this might cause (especially in cases where the agent is restarted, for example, and the stop is followed quickly with start. We need to make sure nothing in start is initiated before this stop thread is actually kicked off and finishes). In other words, making stop method asynchronous could have some side affects that are "bad" without some synchronization/locking put in place.
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
Remove final.
explicit real ref?
suggestion if (rowIdx >= rows.size() && requested > 0)
As requested in another pull request, please have a utility method for building a CommandRequest by command and context. There should be such a method already.
As you already invoke this 4 times what do you think about varying the size of the bloom filter as well? It shall not generate any false negatives even if the bloom filter size is not optimal.
can be simplified with java return o == this || (o instanceof Incomparable && Objects.equals(s, ((Incomparable) o).s));
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
No need to call super() since it currently doesn't extend anything.
SourceImpl?
We require complete input validation here. I miss the validation of the network and an error message if validation fails. Please use NetworkValidator.networkIsSet(), you could create a Validator like UpdateNetworkValidator
This doesn't need to be "re", as it's just evaluating stuff once, not twice.
This is a good approach IMO.
Isn't this previous "if" block duplicated?
Should we be consistent with the assert assert VoltDBLRel.VOLTDB_LOGICAL.equals(getConvention()); vs assert traitSet.contains(VoltDBLRel.VOLTDB_LOGICAL);
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
please apply java conventions (spaces before and after +) and total amount of characters per line
This evaluates different value that it stays isLeftTurn will return true, in case it is slight left turn
URL instead?
return tags;
Use CommonImages.getImage to prevent memory leak.
I do not know much about databases but whether this method is properly constructed? My Eclipse returns "This method must return a result of type boolean" and I can add return for firstRun of false.
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
negative logic
Can this be private, or is there another use case for default attribute outside the builder's call?
Why not use null instead of ""?
Is threads.isEmpty() necessary ? I think the foreach loop can handle the same case.
To always be safe please use context.getApplicationContext()
And then else if this
This is a good way to handle exceptions in the CompletionStage. However, as you mentioned below, it makes sense to handle Try.NonFatalException in a special way. Because FatalException and NonFatalException cannot be created outside of a Try, they are under our control and it is safe to unbox them. I.e. we know that their only purpose is to wrap exceptions in a RuntimeException. From what I see the code should look look this: java final CompletableFuture<T> completableFuture = new CompletableFuture<>(); try { completableFuture.complete(get()); } catch(Try.FatalException x) { throw x; } catch(Try.NonFatalException x) { completableFuture.completeExceptionally(x.getCause()); } catch(Throwable x) { completableFuture.completeExceptionally(x); } return completableFuture;
boundedElastic
This collection type is not thread-safe. Without synchronization such logic will likely fail at some point
this.streamsAddressSpaceMap = new HashMap<>();
simplify this
checking for nullable parent was added specially, cause going into project node simply has no meaning
this lambda will alway return true if at least one representation is present in the resource. That is also the case in aird resource. we should get the first element in getContents() and next check that is element is instance of DRepresentation
getFirstName() considers empty getNames(), getConcatenatedName() doesn't.
return (e.getScriptStackTrace().isEmpty() ? null : e.getScriptStackTrace();
Likewise..
given that specificity of this SV is exception type I would add the exceptionType in this.
should this be splitted into several try/catch blocks because now the httpPoolingClient might not be touched if httpClient.close() throws an exception.
If you"ll use generics you won't need this cast.
All of the methods on this class should be synchronized. Otherwise this change looks good.
Maybe switch this around to use Logger?
Shouldnt we have this defaulting to the common namespace (ICommonAttributes#COMMON_NAMESPACE) so that we can tell the user what this defaults to?
Not sure, why not use @NotNull?
can we print the throwable?
Presume this code is supposed to be calling kiww, not start.
why would server be null?
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
I wouldn't change the behavior of this constructor. Instead, leave it to the AnnotationEventListenerAdapter to choose a default HandlerDefinition. That would allow it to create an instance based on the listener's class loader.
where did this go?
Why do we need it here?
I am not sure, but we tend to use the returning values of such methods as plain Lists and then eventually wrap them into ImmutableLists over and over again. So if we can declare the ImmutableList as a type of the returning value, I would do so.
For safety and future-proofing it might be worth including the set of potential answers as a list or enumeration in this class (or elsewhere) and using a count of that set. This seems like invisible/loose coupling to a concept that won't necessarily be clear when updated elsewhere.
We had requests for the existing timers to return the duration for use in logging. These should probably do the same.
boolean is never null. Please find a user where it is true.
suggestion final long align = 4 * 1024; final long writeBufferSize = 64 * 1024 * 1024; final long expectArenaBlockSize = writeBufferSize / 8; // Normal case test assertThat("Arena block size calculation error for normal case", RocksDBMemoryControllerUtils.calculateRocksDBDefaultArenaBlockSize(writeBufferSize), is(expectArenaBlockSize)); // Alignment tests assertThat("Arena block size calculation error for alignment case", RocksDBMemoryControllerUtils.calculateRocksDBDefaultArenaBlockSize(writeBufferSize - 1), is(expectArenaBlockSize)); assertThat("Arena block size calculation error for alignment case2", RocksDBMemoryControllerUtils.calculateRocksDBDefaultArenaBlockSize(writeBufferSize + 8), is(expectArenaBlockSize + align));
Should we throw an error here?
Should use the log, maybe a warning.
We have different conventions. Please see the spaces around brackets and method parameters, and brackets on new lines. The checkstyle plugin would crash the build. Did you try to run "mvn install -P run-its"? It would take quite long time to complete the build, cca one hour.
This should return false if the method is declared with the default keyword or is static
Instead, start with bot.checkBox("SWT.READ_ONLY").select();
DateTimes will not always work... because of daylight savings time: <LINK_0> doing a toLocaleDate should solve this issue.
Hm, is it allowed that the extended discovery services still use the callback if this component has been deactivated (e.g. because a mandatory reference gets lost)? Shouldn't you unset the callback?
You need to check that other retireable related fields at are not null and that they were null before i.e dateRetired, retiredBy, retireReason
nit: should the last 3 lines be a separate test?
you MUST catch (Throwable) and not Exception, as you do in other parts. Maybe it would be better to have a common utility function to create all the EventLoopGroups in fact running without the native epoll support libraries on the library path make the test fail
Collections.addAll(whiteListPatterns, patterns) can be used here.
We should move the naming of the threads to common configuration as well. It is just easier from debugging point of view and production support can easily make sense as well.
We should just use String concatenation (due to performance difference I very rarely use format)
NPE at line 72. ColumnarRow.toColumnarRow throws for null argument
You should have the ex as an inner throwable to that illegal argument exception, so consumers can understand why that parse failed.
Since there is an explicit coupling between lines 371 and 373 (if you were to reorder 370 and 371, it would break), can we factor those into a method that just returns the appropriate value?
assuming this was for debugging, should remove.
Can you get just the crn from the database?
return Collections.emptySet(); ? BTW, it seems that class DummyGroupMapping is never used now, do we need scrubbed it off?
Should be if (app != null) Entities.destroyAll(app.getManagementContext())
replace the if with checkIndex(toIndex)
Build failed: Need to throw IOException or catch it  public void close(){ try { if (input != null) input.close() } catch (IOException e) { // ignored } }
that can be null? This means all the locks above can throw NPE? Also accessing this object here without synchronized lock? I don't get what is the strategy is here. Again: object that can be set to null CAN'T BE USED FOR SYNCHRONIZATION. Please either make sure they are never null or use different objects for synchronization.
Get the size directly don't use getAllEvents()
if you want to make this code more efficient, you can go for something like  private static final boolean IS_WINDOWS = System.getProperty("os.name").startsWith("Windows"); public static final boolean isWindows() { return IS_WINDOWS; }  That way the check happens only once at class loading and initialization time. Since we do not assume that we change the OS underneath a running JVM, it should be fine ;-)
check NPE and make SITE as a Constant
Should probably use findItem with the particular ID than rely on index.
listeners are not notified?
IMHO it does not need to be public
s/vmId, null, deviceEnabled/vmId, deviceType, null, deviceEnabled
to avoid a crash on orientation change in tablets we should add: if (handler != null && runnable != null) { handler.removeCallbacks(runnable); }
So before this change, it would make sense to return the reference to the stopped service, since it wasn't part of the API that we supported re-initializing the ErraiService. But if we are going to allow that, maybe we should be checking isInitialized() here, instead of just service != null?
?? why this and the following ones could be left empty?
No key for encryption? ;-)
Consider adding a wildcard to the front of the string as well. Right now searching for KGMT will match KGMT_0015, but searching for 0015 will not. Since the query string is not escaped, it's currently possible to use SQL wildcards in queries (this is not something a general user will do.) So searching for %0015 will match against KGMT_0015.
endOffsets is usually used for the topic-partition end-offsets -- however, the new semantics is different -- maybe rename to restoreOffset (hope you find a better name) for avoid confusion? queriedEndOffsets can than be endOffsets what is accurate and aligns with all other code.
again, just set the element in the array ?
Make static
If it is then do what exactly? If we don't want to do anything do we need this if(..) block at all?
why public? at most it should be package-private if this is test-only
> return new String[] { resource + "/.default" }; [](start = 7, length = 48) Should this use the DEFAULT_SUFFIX constant above?
So, technically, it is possible for a Sequence to get used more than once. Meaning that with this setup, we can actually get multiple decrement()s for a single increment(). We don't use them multiple times right now, but I think it would be better to be safe. In order to be safe, though, we have to do the increment on the Sequence.toYielder() call instead of here. This ends up introducing a delay in when the actual incremental happens, which is unfortunate, but I don't think it's the end of the world. I think we should move the increment into the toYielder() method of the ReferenceCountingSequence<>, and we also need to make the ReferenceCountingSegment thread-safe and aware of when it has been closed. Once it is closed, it should reject increment() calls (let's make it return a boolean and set it to false once it is closed, meaning that it is not safe to use the instance) and return null for all of the other methods that rely on the underlying buffers.
just curious why here returns new JSONObject, however, in previous test, null is directly returned?
This should not be on fields as this is custom-role-mapper specific - not related when used as mapped-role-mapper in subsystem.
Why is this no longer necessary?
Do we need this? All it does is assert that the message is equal
other methods like this put name first, then id. switch for consistency
else { // remove the request from the queue. }
I presume this was to avoid log noise. Why change? If your intention is to alert the user of the problem, it would be better to log rather than the task executor printing the stack trace.
Could use this::updatePartionInfo
format
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
Why not use assertNull and assertNotNull?
This evaluates different value that it stays isLeftTurn will return true, in case it is slight left turn
null checks?
You may also want to verify that the dir is writable.
This thing does check the value for not being null. So the previous expression is redundant.
why are you testing Java's stream?
nit: it's my personal style preference, but I much prefer instance != null ? instance : result.newModule() rather than the flipped case you have here.
shouldn't these fields be covered by the autogenerated driver.cleanup() method? (Since they are fields and implement HasCleanup interface)
Can use curSelectedIndex.orElse(-1) + 1 here.
This method might be the one in public.
[FindBugs] WARNING: SA: Self assignment of field KafkaSingleThreadedMessageReceiver.subscription in pl.allegro.tech.hermes.consumers.consumer.receiver.kafka.KafkaSingleThreadedMessageReceiver.update(Subscription)
This is causing us to communicate with jdt.ls for every folder change in the file system. I think it would be more efficient to send every folder change to jdt.ls and let jdt.ls do the filtering. Also, are we interested in every change or only in create/delete?
can super be called first?
<LINK_0> handled the case when metadata was null, does that check need to go here also?
if we don't compare value - there is no point in keeping it AtomicReference. Volatile can ensure new config will be propagated to all threads.
Was seconds an intentional omission here?
final
I would add a guard here to ensure your cast doesn't result in an invalid cast exception. I'm surprised there isn't a spotbugs issue that pops up.
assertExplainAnalyze should be called assertDoesn'tFail ...
Please remove System.out
Since Date instances are mutable, the this.endDate should be a copy of endDate to avoid side-effects.
You might as well move the call to Account.retrieve() inside getPersonCollectionFixture() and remove the argument.
unneeded instanceof check for same reason as above
I'm fine on doing this on all server side classes, but in this case for ClassUtils, which is inside core-common module, it's not correct, because that class is also visible to the GWT compiler, and as far as I know it does not emulate the isAssignableFrom method from JRE... That's the reason I remember to do the comparison via classname, which the method is emulated and so we can always compare on js two strings... but feel free to test it guys, if I'm wrong lemme know and I'm agree on this change.
Unnecessary boxing?
@dskalenko when line can be null?
No need for final parameters?
could use a more meaningful variable name
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Qualify this.uri
Maybe use message "Config job.name is missing" ?
Is it Novoda style to have this Exception in a new line? If not, could be better to have it in the same line.
Might be better to have dao.exist() and call it, but OK to do that later.
assertFalse(...);
0 is a legitimate option value for min. selectable choices. Why not -1?
Also too many dots
Make sure you have a mutable details field here.
urrgh, not so nice. catching exceptions in control flow. especially catching general exceptions
It would be nice to provide some feedback if this check fails. Like "The file BLABLA doesn't exist in the directory you provided. Please try again..."
Why do you use package-private access for this constructor?
The image attribute is not supposed to be the text of the node. I'd rather keep it separate (the previous @Text attribute was fine). A practical reason for that is in the future, other languages may have a way to get the text of their node, in which case that wouldn't be fetched with getImage, for compatibility, but probably with a getText method, or getSourceCode like in #1728. Also we *may* deprecate or otherwise put getImage out of use as soon as 7.0, given its contract is super loose.
nit: if (p != null)
If it's not good to use level(...) this time, let's remove my commit. Or please rebase it into your commit it if the changes are fine :)
remove this.
creator may be null, this needs a check.
This change should be made also for DiskListModel
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
use Guava lists for consistency + throughout code
maybe a word mistake? it is orc instead of parquet
change variable to something more meaningful
We still need to call to deactivateParticipants()
Wouldn't it be easier to use Mockito here? Or is there a reason not to use it for this test?
Add this to WireMessages localization resource
Eclipse is warning that the argument r is unused. I guess this should be changed to r?
Why did you add the round braces?
Can we define these strings as a constant in the ChartProvider interface?
Can we set a charset? Like ASCII or UTF8?
Shouldn't this fail?
The super() returns "" on null. Why should we differ?
Instead of sleep, what about replacing with CountDownLatch? We can unblock through the code rather than depending on the timing schedule.
Is it safe to let the else case fall through? Perhaps the entry display type should be the first thing checked in the method and return immediately if it's not DISPLAY.
If I understand this "fix" properly, we were basically creating a new appender for each test, which you're now auto-closing. Plus, you're creating a new logger for each test. Would it be possible to just have LogFixture take in a level, and auto-generate the logger name, so it does not need to be passed in, even if just to avoid copy-paste errors?
May I suggest this?  int i = url.indexOf("/#/"); return i == -1 ? url : url.substring(0, i);  It only searches the string once, and more important, doesn't duplicate the search argument.
should this be buffer.isReadable(size) ?
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
You could remove "verify that the" from the logging description.
@rakeshadr is there a potential race here between setting the shutdown handler and checking if it is null?
Could you change this into assertEquals(expected, result) ?
Should use the log, maybe a warning.
That was exactly what I want.
Is this supposed to be <code>return "Bump"</code>?
Suggest to use StandardCharsets.UTF-8 here
Is this going to cause a problem upon restart? Should we log something higher than debug?
The code can be simplified to rely on autoboxing.
See the Headers class.
give the thread a name by using Executors.newSingleThreadExecutor(new ExecutorThreadFactory("the name you want"));
Equals and hashcode should be generated by Joda-beans
needs 2 _arguments_, plural
Any reason to create doSave ? Shouldn't extenders be able to override 'save()'
Use a constant.
I think we can replace this with a normal runtime exception with a message saying "Interrupted while blocking on a throttled call" (after setting interrupt status back on the thread)
suggestion Assert.notNull(id, "Labelset ID must not be null.");
we don't need to change the Creation classes.
nit: you can merge both lines above as checkNotNull will return the given argument
Same nit about L.e(caught)
nit: I'd probably include the arrow icon, as seen at the end of the next file name link to catch the eye better, but this makes sense to me too.
is this check necessary since noChevrons.get(index) is already being called prior to this?
Same here, a constant can be used instead.
Shouldn't this method do something?
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
We don't use this form in JGit code, can you move the assignment to its own line?
This is an anti-pattern. Use a StringBuilder instead. Why not comma instead of |?
I would favour use of an external library that already handles email validations, rather than including our own regex here. Take a look at the [JavaMail](<LINK_0> or the [Apache Commons Validator](<LINK_1> for some ideas.
make this synchronized.
What if it's absent? In my account it may be absent, for example
Should close kill the memspace? What if someone want to reopen the key?
This is obviously faster, but how do you prove the runtime performance gain outweighs the memory overhead of adding inward edges?
should this be more strict ? i.e. require at least one character inside the parens ?
synchronize(FastSyncManager.this) { }
Can you also capture stats on the hit ratio, load time and total weight.
getAttribute returns null - add null check
why is this noncompliant?
Tip: If you actually didn't change the logic, please avoid formatting the existing code. You could have a separate PR with just reformatting and make it clear that there are no logic changes. It makes reviewing harder and you'll take longer to get it reviewed.
Use the immutable value cache
No need for null check.
I'm fine on doing this on all server side classes, but in this case for ClassUtils, which is inside core-common module, it's not correct, because that class is also visible to the GWT compiler, and as far as I know it does not emulate the isAssignableFrom method from JRE... That's the reason I remember to do the comparison via classname, which the method is emulated and so we can always compare on js two strings... but feel free to test it guys, if I'm wrong lemme know and I'm agree on this change.
What do you think about changing the return type here to the enum ArrivalFilter? Seems like a conversion always needs to be done anyway, so we might as well do it here.
The super() returns "" on null. Why should we differ?
On reflection, I suspect that this was done for backwards-compatibility reasons, since overriding and delegating to base would be a behavior change whereas this change is only a performance optimization.
I think we should add some text here, to explain why we're rejecting remove() call. maybe something like "this iterable is immutable, can't remove anything"
use hasNext instead of contains (do not use toIterable() we want to check Iterator)
Then this one could become java return ImOption.apply((Focus) getValue()).map(f -> f.getStringValue()).getOrNull();
It seems like you are expecting a certain exception here. Can it be made more specific than "Exception"?
move this line before above line, After super.cleanup method couldn't do any of the server requests.
Hi @rezita, I think this should be isSHREnabled
We may consider just don't set TL flag if channel isn't Proxy. See a couple lines above - RabbitUtils.setPhysicalCloseRequired(true).
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
please remove this statement or enhance it to something more context/meaningful
change variable to something more meaningful
The field should be removed as well.
If you'd like you can go ahead and add the name property to the job options.
Similar
Return value of the method is never used.
Sorry but I did not find where we call the close method?
Don't we need to use .toLowerCase()?, I thought the keys where saved lowercase in the keystore.
Should you call analysisReady(false) here?
This isn't the listener I was worried about. This should be fine, as the main tab model is probably destructed soon after its view. What I worried about was the systemTree listener, because the system tree stays there and will keep trying to send events to the disk main tab view (which will not exist anymore). So basically, I think instead all is required is CommonModel.getInstance().getSystemTree().getSelectedItemChangedEvent().removeListener(systemTreeChangedEventListener).
Robolectric.setupActivity() - may want to make it a field initialized in setup() ?
same here, access to vmStatic should be null safe
Use try-with-resources so you don't need to manually close the session.
The synchronized block should include stopThread = true and close.notify() before thread.interrupt.
if you do this, better put N/A :)
There is an INVALID_NAME type you can use instead of OTHER. (Same for the NAMESPACE validation method).
Missing <>, this is a raw type.
checkArgument(max > 0, "max must be greater than 0");
Listener which does nothing, looks weird for me. Is it okay?
remove this too if it is not used.
simplify this to  return getVarArgIndex() > -1;
Use context.getApplicationContext() to ensure the class can't leak any shorter lived contexts that might be passed to it (it's always fine to hold onto the application context, since it's expected to be around for as long as the process remains alive).
we can make this more efficient if we first do something like: int startSura = pageSuraStart[page - 1]; then start the loop below from i = startSura instead of 0. also, once you hit a sura with the start page > page, break out of the loop.
Same here ICDKMolecule is the type that is asked for
use return ... ? ... : ...?
assertThat(topic).isNotEmpty();
Remove public. Also let's reformat all the ctor to our latest code style.
Need to 'put' in the cache, after the trace set has been updated - the put may result in the cached object being written to disk or distributed to remote node if we change the cache type.
As we discussed before I would simply add an audit log as been done in line 133
whole block indented one extra
Verify that at least returns one element?
Given there is no caching going on and lazyEntriesView is not exposed externally anyways would it make more sense to remove lazyEntriesView all together and just do lazyEntries.keySet() (with the remainder of the line being as it currently is).
possible NPE
do you want to create a new list if its null?
Missing final
why Object?
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
encoder returns data as a double representing rotations, so it wouldn't really make sense for this method to exist. Have we ever used get? should we modify it to fit this type of sensor as well (in CustomEncoder) or delete it?
I think driverPool.forEach(d-> d.getDriver().quit()); would look neater :)
Looks like previously we have had a CorrelationDataWrapper instance independently of the userData, but now you restrict it only if that one is not null. Also I see that you are protected against null in the CorrelationDataWrapper any way. So, what is the motivation to not do that any more?
Have you intentionally omitted index check?
@guiseco you don't need to check the validity of the position argument here, since it's based on the getCount() that you overrode above.
Can you please remove this line from assertResponse and place it for example directly to test methods? It is a side effect and is unrelated to meaning of assertResponse method - according to its name I would expect it just to check response, not setting some method variable.
use hasNext instead of contains (do not use toIterable() we want to check Iterator)
Perhaps a good practice is that the driver is switching back to the defaultContent to reset the driver's state. That way, the next method that is being called after this method does not need to know anything about this method.
Nitpicking: would have been more compact with a constructor KeysSupplier(Collection<Object>, boolean).
Would be good to move this contstant to this file and name it something like WIDGET_ANSWER_STANDARD_MARGIN_MODIFIER.
userRepository and modelMapper invocations are not verified
This is super wrong. zzUnpackAction populates result.
Should be a SamzaException with a message, not NPE.
Do we need to remove this? I have no idea how this can be exposed to users, but it looks useful. If this should be removed, the code computing the INVALID_ROW_COUNTER in HadoopDruidIndexerMapper should also be removed as well.
You can use CollectionUtils.toImmutableList
I think this should be in GerritGlobalModule, which requires moving this type to the gerrit-server package. But if we ever support editing permissions over SSH (which git-store enables!) we need to run this logic in a context where the gerrit-http code might not be visible.
Looks like there are some spaces missing here.
Shouldn't this be wrapped in a try... finally block?
WFLY-4294 says this op will fail in runtime on a server. But it looks like this one is still adding services.
Would it make sense to add something this.caches.clear() to the stop ?
suggestion corruptionNotifiers.forEach(this::reportCorruptionToRemote);
wrong arg order
why rewind?
Will this ever be ok? Not quite sure why this just wouldn't throw a SessionUnavailableException as part of the method signature
Request.State.OPEN
Unnecessary parentheses (and an extra line break).
Why not <code>return ExitStatus.COMPLETED</code>?
(Alt) Can we move the skip condition to the testSetup method just above.
should this say throws PatternSyntaxException ?
Does this need to be public?
Why don't you just use Boolean#getBoolean()?
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
Should this variable name be updated as well?
lambda?
we should also check for n <= 0 here
I find it more intuitive if the @Auth User user is @Auth User authUser and this one is just final User user because the 2nd one can really be any user if the first one is an admin
In updateChart(), the collection fModules is updated first, then this method is called. So you don't have anymore the old modules to be able to recreate the old series that need to be deleted. How about getting the series set directly from the SWTChart and delete them one by one using their own id provided by ISeries?
off topic: I've been writing this as "client == null". I think this conveys just as much information in fewer characters, so by Shipley's law I should switch over. The drawback is that "client == null" is a boolean expression, and is consistent with "limit < 0" etc. . .
@lautarobock Same here, let's declare throws Exception
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
trace
- log warning that option is not supported by SNMP
There are not parameters though. I really do not want to go through and make these all final, since we have not configured checkstyle to do that. I also don't see a big benefit, as I don't think I've ever accidentally modified an exception reference in a catch clause.
In alignment with valueOf, perhaps name this valueOfType or fromType?
what about setting db isolation level to serialization?
i don't think its a good idea to include password in exception message
The code can be simplified to rely on autoboxing.
Include an error message for all null checks using Objects.requireNonNull Objects.requireNonNull(credential, "credential cannot be null");
no need to handle failure (rollback, log, etc..)?
not sure if there's a reason for removing the parametrized type MarshallingResponseBuilder<T>, see that when setting the messages you loose the type. The other methods state, addMessage, and resout has the type.
Might be worth having a displayName?
Shall we catch specific exception?
shouldn't this be done.setValue(true)?
According to encodeColumns(), it seems we need additional Integer.SIZE bytes for encoding List<Pair<Integer, Double>>.
In general I wonder why one should instantiate an (immutable) null Password. I mean passing a null parameter to the constructor. Should this be considered a bug instead and hence throw a runtime exception? Should we update the copyright date to 2017?
given that specificity of this SV is exception type I would add the exceptionType in this.
Is there any way to tie this to LoadLocalSpec ? parsing the loadspec and calling getPath seems a little extreme for here, but can "path" be put as a public static final String in the class or something?
We also need to replace childTraits with enumerable convention. also hashjoin.
Although we need to figure out how to propagate interruptions, this will now cause a problem as it this method is called from within tryUpdate which is recursive and propagating here means the next attempts will also fail for the same reasons. We need to figure out how to retain the fact that we were interrupted and propagate the interruptions outside the whole thing.
@fanifieiev RequestOf is a better name than RqOf.
you can simplify that as return getInternal(key) != null
combine with assignment this.outputType = requireNonNull(type, "type is required");
RuntimeException?
I realize that the Cocoa SWT also does this, but is this is not a good hash function. It will always return a value in the range [0..255]. Why not just treat RGBA as a single int? ((alpha << 24) | (blue << 16) | (green << 8) | red as in org.eclipse.swt.graphics.RGBA gives a much better distribution.
Why not use null instead of ""?
You can just put the whole trigger text here instead of calling the super, it'll keep you from having to use setText on the token effect
You could remove method("POST") as you set the HTTP method on create
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
Check for overriding is uncessary.
Do we need the empty constructor?
specify charset?
I am leaning toward moving this back to requiring Jenkins.ADMINISTER
Could we get a deadlock now in some cases? #reset holds a lock for the outer ProxyWhitelist, and when this is called it will also acquire the lock for the delegate ProxyWhitelist. Do we know that the locks will always be acquired in the same order? I would be surprised if there are cyclic references between instances of ProxyWhitelist, so my guess is that it should be fine, but it would be good for someone to confirm.
The condition should be replaced with !TextUtils.isEmpty(assignmentId)
This should be simplified to just: >return value;
Why contains instead of equalsIgnoreCase?
This is easier to read as: return type.getClass().isArray() || isList(type);
is the VM null too perhaps? maybe just move the condition from line 63 up?
If storageManager gets a value in constructor, then we don't need to check null.
I don't think it's actually possible for this code to get called as the parser will not accept *3 or /3 but NaN doesn't seem to be the right result. You can just throw a new IllegalStateException() to indicate that something has gone really really wrong.
remove double a valid from test & implementation
Can we move this isAdded() check back to the top of the function? I recall that we placed it here to prevent a crash (that we may or may not have reproduced), and I'd rather err on the side of caution.
Shouldn't this close the iterator before returning the list?
feedDisplay is a strange name. I had to look at the xml file to find out what it actually is. How do you feel about feedDisplayContainer? I know it was like that before and the guidelines we have come up with say that it is not necessary. How do you feel about this? Should we update the guidelines?
use .getUuid instead of getArtId, which will go away
It may be better to return an empty string here instead of null. Unless others look into this code, we may be pushing the null pointer higher. Thoughts?
more specifically, it's going to try and use writerFor(JavaType)....but that's just a nit
Very minor, but a bit redundant?
We could shorten to one line return Optional.of(new Context());
If fOperator is op_throw, we need to return true :)
for readability, consider extracting it to a method..
Why don't we set name to empty string here?
Maybe do a null check.
Check for overriding is uncessary.
You could kill offset and pass 0
Better to return "";.
Could you move this method next to doHibernateSearchList? This class is already a bit hard to read due to the many methods, so we should take extra care to keep related methods together... Sorry, I know we shouldn't have to do that :/
Wouldn't we want to unify these names and pick either onReady or onDataChanged? Other than that, LGTM!
This shouldn't declare throws Exception.
Is this really needed? There is a chance that there are two HTML elements with the same id in the DOM.
maybe test first char for empty letter as well to reuse s if possible?
String.format
Our standard convention is to prefix with this for instance members - return this.context
We should have a final fallback here if dateStopped and getAutoExpireDate are both null... (not sure if that should ever happen, but both fields are allowed to be null in the db so it's *possible* it could happen). I would just fall back to dateCreated (since it is the one date that is guaranteed never to be null).
Niche!
simplify this to  return getVarArgIndex() > -1;
30_000 sounds too long here. What if the shutdown method fail? Will it take 30 seconds to fail this particular test? I'd like this combination: Thread.sleep(5000) and islessThan(1000). If JVM can not interrupt the sleep thread within 1s, there must be something seriously wrong.
Met List:  @Override public boolean inputsAreConnected() { return inputs.stream().allMatch(ConnectionAnchor::isFullyConnected); }
This modification looks a bit suspicious without a testcase and definitely does not sound like a quality flaw fix.
Unnecessary log.
Would suggest using another MapID for 004 and 005 to break dependency from 001 and 002 to be successful
I didn't even realize that we have logic in otj-server that also copies conserved headers to responses, apart from what already happens in otj-conservedheaders. Would the be any way to consolidate this logic in one place?
This does not need to be public. Instead, just pass the builder to the private constructor. See what we do in HtmlRenderer.
nit: Use StringUtil.EMPTY_STRING.
nit: throw new RuntimeException(e); so if this ever happens (unlikely), the error will be more obvious in the test
Can this be private, or is there another use case for default attribute outside the builder's call?
Maybe its just me, but this calculation looks wrong, since we are assign a = b, then b = a % b will always be 0, since a = b. Shouldn't it be: long c = b; b = a % b; a = c;
it would be better to reuse:  <LINK_0>  to construct PagePosition iterator.
I think you mean (d<=0)
suggestion @Override public void onSaveInstanceState(@NonNull Bundle outState) {  Can we move the @Override annotation to a separate line for code style consistency?
I think "9" would work as well :-)
You should clear the set after the scan to, to be sure that references to the IfStatementTree are not kept for the whole scanning process. Actually, I think I'd prefer to avoid using a set altogether by using the parent to retrieve the else keyword (i.e. if the parent is a IfStatementTree and current if is the else statement of the parent). What do you think?
Are all recipes groups uppercase?
return null to make this more explicit ?
The default impl is disputable. Each invocation of this method would result in new pool and the caller would be responsible for shutdown etc. I think we should rather throw unsupported operation exception or something like that.
Collections.EMPTY_LIST
Is there a reason this class is doing this through lazy initialization instead of a BeforeMethod/BeforeTest like the other classes?
Not necessary to call super(). There is an implicit call to super() with no arguments for all classes that have a parent
@ivandalbosco IMHO it's better to move the call to isPrivate into isException
Please make the methods in Calculator non-static and rework the examples accordingly. I think it's fine to create the calculator as the _SUT_ in a field (in all affected test classes) as follows. java private final Calculator calculator = new Calculator();
name should also be checked.
maybe default to ":" like in other cases?
Is this thread-safe? I guess, maybe, although it might do extra work since not all threads will see the update at the same time. I'm also not sure if ParseSpecs need to be thread-safe; if it's an issue could you please double-check it?
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
The connectTimeoutMillis and readTimeoutMillis in the builder appear unused.
return null to make this more explicit ?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Same as above, why not use try with resources?
So this will be used for quantity and duration too or you need separate ones?
I think worth to introduce data-row-uuid as a string constant
any difference between this test and the previous one?
Why this change here?
this can call the method on L290
I think you should pass the numCompletedIterations to the last parameter of LOG.log().
Use Objects.equals() to handle nulls concisely.
nit: if (p != null)
(non-blocker) under the hood this does Pattern p = Pattern.compile(regex); Matcher m = p.matcher(input); for every jar file. Is it possible to simply have a static Matcher, or Pattern? Note that Matcher instances are not thread safe but Pattern is.
Is this load operation necessary each time this method is called?
I thought format used "%s" and "%d"?
Entity#getTags returns the original set. While I don't see any vanilla code that makes use of the fact that the backing set is mutable, mods very well might. It would be stupid for them to do so, but they might. Thankfully, there is a really easy way to sidestep this: make this method return a Collection<String>! While Java doesn't let you vary only by return type, no such restriction exists on the JVM. That way our method and the vanilla Set<String> getTags() method can co-exist peacefully.
Please implement toString() to provide debugging state information for debugging purposes.
Don't set statusCode in this class, just delegate to the appropriate super that takes a statusCode.
return getRetryAnalyzer() otherwise you'll have to check null value from here and then call previous getRetryAnalyzer in the business code (where we expect to call the new method only)
final
return 'A'
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
same as above, skip public
calling super not needed
Why can't you just return value here?
Not sure if you wanted to leave this hardcoded?
Add .omitNullValues() before the toString() call
would it be better to throw an UnsupportedOperationException rather than return something that won't work?
Why do we need to call snapshot() again? I can see the snapshot calculation just happened in the previous call during constructor initialisation.
This involves a look up of the character encoding type table. Use MessagePack.UTF8
- Will suggest not to apply Ctrl_BackSpace feature for Passwords Text field, instead return. For this include PASSWORD in above if condition: if ((style & SWT.READ_ONLY) != 0 || (style & SWT.PASSWORD) != 0)
you're right, not sure how I missed that thanks!
I think its better to rename the function deleteResultsByID to deleteResultsCollection. It should take Collection<AsyncQuery> as an argument. All of the iterator logic can be then moved to the function implementation. The reason being in our database interpretation we have to delete each row one by one but for a filesystem-based, we can delete multiple at the same time.
Could you use AssertJ for assertions, please? assertThat(mvc).isNotNull()
Instead of this constructor using the other, I would make the other to use this constructor with a null linkUrl. What do you think?
format
Change this to PDataType.VARBINARY, as that's what the evaluate method returns.
This implementation looks odd: Don't you want to check that obj is an instance of NotLoadedFragmentMatch? Here a list with the same elements will be equal to this object, it seems dangerous.
This is a bug! The requested interceptor might not be in the list, so we should decrement only if true from remove().
<LINK_0>
This seems unfortunate. Does the RS spec forbid null values?
we need hostName only to log error. Please call it there.
Remember to call  configureConsumer(answer);  also as that is needed, see other components.
....and then you don't need to call it on every other method
This can be static.
I think we probably want to validate that userAgent is a valid form
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
Just curious: why checking 'isClosed' ? Can't we call 'close' multiple times?
Erm, well there's no need to map launcher to itself suggestion return model.getLauncher();
There is no harm in setting the confirmWindow to null, but since you are not actually setting it, there is no need to set it to null.
The test would be quicker if it waited on a CountDownLatch instead of sleeping for a fixed time.
This is not enough. Look at the method DecoratorAdapterFactory#dispose(). You have to iterate on the values of the map and dispose them propery
hmm, that method makes somewhat sense in core java, but I'm not sure I like that behavior for selendroid. We're expecting a boolean value, but essentially we only care about either true or "true" coming across... everything else is false. Is it going to be confusing to any users? I'd almost rather add an additional else clause to check for the string of "true" or "false", otherwise raise the exception. Since users of other programming languages (like javascript or python) may have a different impression of what a truthy value should be.
!keys.isEmpty()?
This shouldn't be needed anymore
you set the prestarted to zero so VMs won't be start again after stopping them right? so you need to lock the pool because stopping the VMs might take some time and the user can update the prestarted VMs count in the meantime
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
IntelliJ code generation is at it again! I suggest replacing the method body with a single call to [Objects.hash](<LINK_0>
This should be an Optional<...> on the member by convention instead of wrapping on access. I realize this is against IDEA advice.
It seems that throwing a generic Exception is not a good practice in Java. Is there a strong reason for that?
curly braces
The synchronized block should include stopThread = true and close.notify() before thread.interrupt.
The call to super dispose should probably be at the end.
Can't the cTestEvent be made a spy in the constructor. You already wrote this code twice and will probably need the spy more times.
Same as before: the logic of filtering out NonBinding attributes probably should be external to this implementation.
java return (bundle.getState() & (Bundle.INSTALLED | Bundle.UNINSTALLED)) != 0;
fmt (there should be   after ...)
This check is redundant because you check this in handleSelection()
return tags;
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Why did you catch any RuntimeException based class here? So far as I can see only NullPointerException  and ClassCastException are official thrown.
This seems a bit hacky to me, can't we move the code from the bodyEnd() to this overridden addToString? Is the implementation different from the default anyway? The toString in bodyEnd() doesn't really seem that sophisticated. Rather more a debugging leftover...
These line is proof you don't need QuotaConsumptionParametersWrapper
Make it immutable. new HashMap<>(properties). Otherwise clients can still be able to mutate the state of WireRecord using the provided map reference.
Should the name of the thread be maxwell-kafka-producer-worker instead?
I see this method does something similar to execute minus the optional processing with the rowProcessor
Should we use pushInlineDeployments here ?
shouldn't these fields be covered by the autogenerated driver.cleanup() method? (Since they are fields and implement HasCleanup interface)
Extract this into a method, given that it's called twice
CoreUtilities.noDebugContext
If this is called before recomputeDigest(), we will get a different description string than the original implementation. Is that you want?
you can use Objects.hashCode()
parentheses please ;) return (number == null ? null : Long.valueOf(number.longValue()));
I don't think you need this new String
use 'L'
Could be a try-with-resources.
Add and offer are the same thing for ConcurrentLinkedQueue.
Maybe check if batch update exception has nested SQLTransientConnectionException?
Avoid the scannerLock object and synchronize on KieRepositoryScannerImpl.this. I believe this will make also clearer that you're sync'ing on the same lock of the scanNow() method.
What's the intent behind this? Generally we want to allow this to be changed at any point. Is there something in particular that requires this with the update?
return flagdown; ?
revert this unrelated formatting change
Do where need to complete the full queue here?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Should allowedValues be considered for object equality?
Nit: For defensive programming, I would prefer String.stripToNull(region); Please update for similar invocations.
_verify
Why are we declaring strings of white space characters to be the same as requesting the default pool?
Please use here also java Objects.requireNonNull(partialFunction, "partialFunction is null"); return filter(partialFunction::isDefinedAt).map(partialFunction::apply);  (Yes, please use map instead of mapTry - I'm sure it makes no difference because of JIT magic).
Maybe better to return null
Should we log this to TRACE at least? Just in case we need to see this happening? As long as any formatting happens in varargs / parameters, we can avoid the cost of formatting a string in case TRACE is turned off.
Is it really worth checking before setting it?
Collections.addAll(whiteListPatterns, patterns) can be used here.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
we should validate (and the feature support check) it in the validate() method.
any reason for explicitly invoking super.toMap() ?
Please change to externalSearch =
Why U don't want to consider id in equals and hashCode ?
Method name is missing from log message.
This makes the action no longer work on multiple repositories. I'd prefer not to regress here.
no need for the ||
What happens if a checkpoint fails? Wouldn't cancelAfterCheckpointId <= checkpointId be more safe?
static (same for isMap).
I think baseUri.toAsciiString() always has a trailing / in our usage so with the current build() method I think you will end up with (for example): http://some.example:80//path/path/path?query=true changing to this.path += encodePath(path) + "/"; will result in: http://some.example:80/path/path/path/?query=true I think both of these are valid URLs, but I think we need to be sure there are no server side issues if we use either // or /?. @tomblench any thoughts on this?
conditional could be clearer here.
ewwww, abusing try/catch for this is really unideal... We have a Pattern for Numerics you know?
This should return a builder with the current options set.
assertion .isTrue() missing
return flagdown; ?
also here. if true.remove(element) returns the same instance, we may test with == instead of size and length
since there is an exception being thrown, there is no need to log an error. Otherwise, there will be double logging.
Remove throws Exception
checking for nullable parent was added specially, cause going into project node simply has no meaning
Request.State.OPEN
unnecessary array new: {{true}, {false}} should work here
remove this
Is it a conscious decision to throw an unchecked here?
typo
Can this be private (or at least package protected)? It's only used by this class.
Did you still want to put this off?
Request.State.OPEN
For such small method (next one in next file too) having extra blank lines doesn't bring anything.
Possible to log only one debug line here?
I believe the Auth system should remain on in this method.
hmm, that method makes somewhat sense in core java, but I'm not sure I like that behavior for selendroid. We're expecting a boolean value, but essentially we only care about either true or "true" coming across... everything else is false. Is it going to be confusing to any users? I'd almost rather add an additional else clause to check for the string of "true" or "false", otherwise raise the exception. Since users of other programming languages (like javascript or python) may have a different impression of what a truthy value should be.
I'm a bit confused by this test and shouldFailWitNoSchema test, especially the following part: java AvroItemWriter<PlainOldUser> avroItemWriter = new AvroItemWriter<>(output, plainOldUserSchemaResource,PlainOldUser.class); avroItemWriter.setEmbedHeader(false);  Why should I provide a Schema if I can set embedHeader to false? For the reader, we can read PlainOldUsers from an avro file not containing a schema without providing a schema. In the same way, we should be able to write PlainOldUsers to an avro file without embedding any schema. In that case, why is the schema mandatory? To be specific, having a mandatory schema and an option to not embed it is confusing to me.
Moving that bits above and allowing the user to change the decorator via a public setter means you can completely shadow what AbstractTransactionSupportingCacheManager used to du using public API. Also, if CacheDecorator is a first-class concept, you should probably expect that more than one decorator can apply at a given time. This wrapping shouldn't be the responsibility of the caller.
I this refactoring, very nice. Could make this method protected.
Why do we return the parents name instead of the name we store a few lines above?
Couldn't we use assertEquals(...) here instead for better reports in case of failur?
need to strip the colon too
Not all announcement activity is public. I think there might need to be a separate manager method to have the right permissions. There are specially written queries in one of the DAOs to get only appropriate announcement activity because it was a pain. Anonymous users should be able to see activity for public announcements and logged-in users should be able to see all announcement activity.
Not sure, why not use @NotNull?
File.separator instead of "/"?
"Modifier 'private' is redundant for enum constructors"
@CTI777 this is ok.. because it is private.. we shouldn't expose IdentityLinks in our APIs, so no action needed.. just for you to know
Better to return "";.
Maybe it makes sense to make the empty HashMap a singleton, too. It will be frequently used.
Isn't this just type instanceof Class<?> && ((Class<?>) type).isPrimitive()?
This does not need to be public. Instead, just pass the builder to the private constructor. See what we do in HtmlRenderer.
consider changing "alt text" to "link text" in the markup, since "alt text" could easily be confused with HTML "alt" attribute.
Are we sure WDateField is the only input element which has a div wrapper? It may be safer to limit in some other way too - such as a check on the outer element's class attribute containing wc-datefield. I am pretty sure a WDateField in a readOnly state is wrapped in a time element and a WPartialDateField in read-only state is wrapped in a span element (the div for editable WDateField is only necessary because of the need for a calendar in the polyfill). Therefore this will fail if trying to get the component in a read-only state and the other input extensions do allow getting read-only components.
It seems like this would be more appropriately placed in the NUMERIC category.
I'm not a lover of passing nulls to methods or constructors.. would another constructor without the contextId be better?
I this this(url,new HashSet<>()); would better. What do you say?
please change this to simply return Objects.hash(...) to keep the boilerplate/LOC down
I think this should be stripe_account_id ? as per PP-4302
replace with ReferenceCountUtil.release(msg)
This can be removed.
please include a helpful error message here, including the bad field value
Does this need to be a singleton?
Why are we configuring drawer in this activity. This activity shouldn't have it.
Per docs when null is returned, a message should be logged. <LINK_0>
Can we deprecate one of getURL or getUrl, and have the deprecated one call the non-deprecated one?
nit: line to long (break each parameter in it's own line)
this("Safety Command")
please update - should we keep this or format to remove ====
You could try:  @FindAll({@FindBy(css = "section.hero-block .hero")}) private List<WebElements> heroUnits;  But I think it's fine doing it this way. Only thing I would change is selecting on .hero, because clickable-unit is used for tracking and doesn't necessarily define the element itself. That CSS class could change or move to another element inside the hero unit.
add wait condition for shell
It feels like this logic should be refactored into a utility function since we have multiple copies of it. I generally also prefer to wrap compound clauses in parentheses to clarify that the second & third components are paired:  java if(ignoreHiddenFiles && (System.getProperty("os.name").contains("Windows") && Files.readAttributes(dir, DosFileAttributes.class).isHidden())){
No, no. Remove this logic (that checks whether the provider exists).
I'm guessing merge/rebase error. RequestManager method was the correct source for this. Controllers shouldn't require database knowledge (jdbc/table names)
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
You could do a contains here like you do with the ACCEPTED_ENTRY_PIDS.
storesToSkip is a hashset, which is not thread safe. If you are planning on calling this from AmbryRequests, you might have to switch to a thread safe collection.
Wouldn't this be getActiveWindowService()... just like the others?
Please add an assertion for an enclosed type: java.lang.Thread.State
We need to synchronize this with #322 @simon04 can you keep track of this change in you PR, depending on what we merge first.
Why did you add the round braces?
Hm, this differs from my suggested implementation a little bit (<LINK_0> forEach: "Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception." So, your one stopped if a job's run method throws a runtime excpetion (silently). This could be hard to detect. Mine logs a warning, and continue with the next job. Do you want to use lambdas and stream whenever possible or why have modified it this way?
I don't see why we need these sorts of constructors... We've never needed them before, and there's nothing special about the useLayerNormalization arg (it's just another boolean)... unless I'm missing something?
Could we somehow get the name of the source into the log lines? I think that would tremendously helpful in cases where there are multiple sources (which are common).
This can be static.
Any worry about case sensitivity wrt to scopes?
nit: spaces around + I'd also change / to use OS-specific path separator, i.e. [File.separator](<LINK_0>
No need for this logic - Guava does it anyway. Just call copyOf. This method will then reduce to a single stream operation.
Suggest using parenthesis to clarify order of operator evaluation
It doesn't feel right. Why it is required?
SA == SERVICE_ACCOUNT? avoid abbreviations
OperatingSystem.equals(String)?
nit: if (p != null)
Is there a reason that the GapBuffer is initialized with a buffer size of 1 by default? I know this is a very vague question, but 1 seems like a weird choice to me. It reserves ram in anticipation of future insertions to save computation time, but still only allocates so little buffer space that the array size will have to be increased after one insertion. And if the first action is a deletion, this one additional character of buffer size won't make much of a difference. But I have no experience with gap buffers, so maybe I am missing something (or am overthinking this).
Cache the call here and above.
If we do not write options unconditionally, we will not validate them on the server-side. Consider a user who submits IndexConfig{type=HASH, bitmapOptions=<not null object>}. This is an invalid config, but how do we know what was his real intention - to create a hash index or a bitmap index? I would rather read/write the object as is, and throw an exception on invalid config, rather than ignoring invalid state silently.
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
We could remove this switch by using an enum and having each part of the enum a value (-2, -1, etc.) that returns the proper ImageDescriptor. This would simplify this function to: return CommonImages.getImage(ReviewsImages.valueOf(reviewsScore.toString()))
It would be good if you can applytrimming for white spaces on platform.
Can you reduce the nesting depth here?
simplify this
I think we can use a pooled bytebuf
change message and status code
Should return type CorsConfigurer<HttpSecurity>
I know this was just copied from the original endpoint but bundle can be null here (although very unlikely)
Is forEach better that putAll? I suppose we also need to take care of the case when params are null.  if (params == null) { namedParameters.clear(); } else { namedParameters.putAll(params); }
Simple for-each?
nit: you can merge both lines above as checkNotNull will return the given argument
I see that address.getHostString() can return null, at least in theory (although it seems to be a pathological case). Do we want to defensively prevent against NPEs here?
Same here, better to wrap the classloader creation inside a method.
reverse params order.
attr.length() doesn't do anything here, you can remove it.
please look at StorageHandlingCommandBase.getPermissionCheckSubjects()
should this be in some MathUtils class?
Doesn't seem like we need to throw Exception here as shutdown() doesn't declare a checked exception.
I recommend using @Test(expected = EvaluationException.class) for these tests.
initialize() or schedule()
In all the other nodes, all the constructors call the most specific constructor to avoid constructor spaghetti. That would mean the this-call gets "null" at the end for example.
HTTP_HEADER_CSP
I expect this query to fail because ship_day_month_nulls column doesn't exist
ins't KEY2STRING_MAPPER missing?
You want to use FormField.getFirstValue() here and everywhere below.
Because it can be called by both focusGained and mouseEnter, sometimes you have two active contexts. Maybe there should be only one?
Is this the best way to determine if PKCE should be used? This seems implicit rather than explicit which can lead to problems later on (if there are other reasons the client secret can be empty). Additionally implicit options in security tends to lead to security vulnerabilities.
Instead of duplicating the values, use PriorityLevel.valueOf() (I don't know why the other methods aren't doing that but don't worry about it)
You can also do  try (FSDataOutputStream stream = fs.create(new Path("s3n://test-bucket/test"))) { assertEquals(CannedAccessControlList.Private, s3.getAcl()); }
Please move such code to UI abstraction.
Why so complicated? Why not LOGGER.debug("Could not process citation", e");?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
public
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
This is a weird place to add a listener.
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
Shouldn't that be List<ClientEntity>?
As IOUtils has been imported why not just use IOUtils.closeQuietly()?
Please use Optional.ofNullable()
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
Do you want to check the compile options before asserting this?
We require complete input validation here. I miss the validation of the network and an error message if validation fails. Please use NetworkValidator.networkIsSet(), you could create a Validator like UpdateNetworkValidator
It seems that throwing a generic Exception is not a good practice in Java. Is there a strong reason for that?
Why overriding it here? If you don't really want to add, don't initialize the variable when declaring it and use copyOf here.
This change breaks null-safety. null.isPresent() will crash and burn.
No reason to catch an exception and then immediately throw it with no changes
If we log an error that doesn't have any vararg arguments this will throw an exception from what I understand.
This from field appears to be redundant, as this is an inner class.
Please use int[] instead of list to avoid unnecessary import and large diff in test
Hi Tolis, would you mind to move the code below to another class?
shouldn't the log message be updated?
nit, can use a ternary here to be a bit more concise. It's generally a bit easier (lower cognitive load) for if statements to lead with the 'true' value. IE:  return valid() ? List.of(AIR_ATTACK_NON_SUBS) : List.of();
This isn't right given the method signature of the base method -- name should be used in some way. If you want to pass in the full path to the db file, then I think DatabaseContext needs to be redesigned.
Same here, you need to check that retireable fields are not null and null after
ohh.. actually we should default to 443 if https!
You should not do this. The unsanitized name only presents problem when displaying as HTML, but not when storing in DB.
what's the point? The method is always false for DefaultDebugExecutor.EXECUTOR_ID without your changes.
LOG.error("Failed to getattr {}: ", path, e)
I think only one impassable entity should be allowed on a Square. Exception otherwise.
No key for encryption? ;-)
why is this if statement inside the function but checking whether snapshots are allowed is not? basically if it's not of type IMAGE then snapshots are not allowed so I'm not sure why we'd even get here (looks like the 'if' is redundant unless AllowSnapshot doesn't report correctly). In addition, personally I dislike a function with all code inside an 'if' statement. Also the name does not reflect what it does this way (it only updates if ...)
Are you specifically allowing air itemstacks to be created now? There is a way to validate that the ItemStack itself is empty (hint, look at the fields in this class).
I would actually recommend removing the throws IOException from the interface. Any checked exception can just be dealt with by calling callback.onComplete(null, ex). I think that this helps unify the failure handling paths that the caller needs to deal with.
Could we log in the constructor rather than here? getBinding() can be called many times over the lifetime of the EvalBinding, so we'd just be getting many warnings for the same instance of the problem.
Please use StringBuilder
"isSearching" should be a class level string
Please add lazy initialization here as it is done in other classes
The given state does not imply that the device is active. If you are going to make sure the device is active, I would prefer "an active device with DeviceID..." so you the scenario matches exactly what happens.
I think that this logic should not be in htsjdk. getDescription() should return null or blank if there's no decription. the user can choose what to do with that information.
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
Please make the methods in Calculator non-static and rework the examples accordingly. I think it's fine to create the calculator as the _SUT_ in a field (in all affected test classes) as follows. java private final Calculator calculator = new Calculator();
\s+
Thoughts on changing this from using withContext and a String constant in Storage Common to making this a helper method in Storage Common?
Note that one of the reasons I chose to use the @EnumeratedBy annotation was due to the fact that we don't know if there are extensions out there that are calling the int version of this method. Using the annotation allows us to keep the signature of the function the same at runtime. By outright changing this, if such an extension exists it would result in a NoSuchMethodError after this change is published. I would recommend we also have an int version to maintain backward compatibility.
I would feel more comfortable with this if you did something like throw an IllegalArgumentException if !ref.startsWith(oldPrefix)
The editor can't be null
synchronized -- this class is thread-safe and guaranteed happens-before between producing value and consuming it
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
This means clockHand will be hot at initialization time. Intended?
Check first that target is not null.
To remove?
just return "" instead of new String()
Check buffer null.
I'm not sure the name SOFT_LIMIT is proper here. How about just omitting SOFT?
this seems wrong. now you keep track of the last one and not the first one.
suggestion public @Nullable ImageIcon getImageIcon() {
should this be package private?
Isn't this... just a re-implementation of natural ordering? I don't think you actually need this.
worth having both these lines as clearSubscriptions()?
Don't set statusCode in this class, just delegate to the appropriate super that takes a statusCode.
This block can be omitted as it will always return false (id cannot be null here) and behaves the same as id.equals(null)
And here too (check exception message)
why are we changing the visibility of these methods?
Let's use catchThrowableOfType and the GIVEN WHEN THEN pattern to make the test easier to read. shoud look like: java // GIVEN int[] nullContent = null; // WHEN NullPointerException npe = catchThrowableOfType(() -> invoke_api_with_null_value(assertThat(new short[] {}), nullContent), NullPointerException.class); // THEN then(npe).hasMessage("The array of values to look for should not be null");
Remove this
We're on Java 8, so: IntStream.range(start, start+length).toArray()
Isn't this quite ineffective? We are implementing a method which explicitly expects a fully qualified ref name and which therefore does not have to deal with iterating SEARCH_PATH. But the implementation is done by calling the expensive method which does all this iterating over the SEARCH_PATH and to throw away the results if we see the input ref name was not the a qualified one. Maybe an internal getRef() method should learn to use a explicitly given SEARCH_PATH.
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
If this is ever true a NullPointerException has already been thrown
doesn't seem right, should be something like "{\"foo\":0,\"additionalPropertyExampleKey\":\"string\"}"
why not use a simple while loop? thus removing the for and the if
Objects.requireNonNull(buf)
An create on-demand Direct Debit payment request should always have an agreement ID
needs filling in :)
this lambda will alway return true if at least one representation is present in the resource. That is also the case in aird resource. we should get the first element in getContents() and next check that is element is instance of DRepresentation
If you'll eliminate the lock, accept method will contain just "this.value = value;" statement
for the case where the file is being thrown away (abort is called rather than commit) we could get away with not calling force. (that is the ATF.commit could call a force method which does a flush, force, and then subsequently call close)
rename to pack
Would be safer to do something like this.groups = Collections.unmodifiableList(group) otherwise anyone can modify the actual path trough getGroup() which is not great for a public API.
This seems a bit profligate... and the stream construction around a spliterator seems a bit unusual.
If I understand this right, the state machine cleans itself up after it disconnects?
== should be replaced by .equals(...) Same thing a few lines below.
Confused, why is the commit changing all field access to getters? The method has visibility of the fields and I see no late/lazy inizialization of them. This kind of change is likely going to be reverted next time someone uses a IDE code generator to update hashCode/equals
progress.split(1) ? Interestingly, the counts seem to off quite frequently. Here only 2 of 3 ticks are consumed. I wonder if that was intentional?
name.substring(ext) is equivalent and shorter to write.
> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
Does this need to be public?
I'm in favor of just using the iterator and remove during the iteration..that's unneeded.
Maybe I am confused, but this is changing from number of children to number of siblings? ast.getParent().getNumberOfChildren() != 1 to ast.hasNextSibling() || ast.getParent().getFirstChild() != ast I am not grasping the equality of this.
Be careful, this method is probably used by core plugins
Please keep this.cell near the related fields (previousFamily & cell count) below
this can be a single line with allForCluster.stream().forEach(glusterCommandHelper::initGlusterHost)
workflow.getEntryPath() here, tool.getEntryPath() up there seems simpler.
Minor: there is also a method, Predicates.asSet(In), that exposes the inner set. I think the purpose of that was to mimic the use of Ranges.asSet(Range), which has to be a static method because we allow ranges of objects that aren't Comparable but back the asSet method with a Guava range that requires a Comparable type. I'm fine with changing to use this method everywhere, since this is more straight-forward. But I'd like to either use Predicates.asSet(In) or In#getSet(), not both.
Does this need to be public? Please do not introduce new public members without cause.
While I am not denying the setter is confusing, this is not the scope of this PR to change that.
Hi Tolis, would you mind to move the code below to another class?
Why have you added this line here? This will automatically choose first local address and then switch to remote address if the ping to local address fails. Adding this dissolves the purpose of having Local and Remote mode explicitly.
for this and above we should be using the convertView to recycle the view, if it is null we inflate, if not we assume it is of the correct view type.
The problem with image. It is a local variable which is returned to the caller, but you still use it in parallel as a container for image data. Situation to consider - user e.g. draw image on some panel, but in parallel the image is updated with a data from camera. Possible side effect - half of image is from old image and half is from the new one. This is because there is no synchronization between operation on image data.
Out of curiosity, why is the return type of this setter not void?
wonder if it would not be more interesting to have false here to see that we are correctly jumping into the catch.
Nit: unnecessary this.
Alot of noise in that (what looks to be an) IDE-autogenerated toString? How about just "SenderId{id}" to be returned from toString?
you can use one single line for this...
Change to unmodifiableSet if we switch to a set. suggestion return Collections.unmodifiableList(tags);
We might use a NavigableSet instead if a TreeSet is used, I assume.
@Before / @After could overwrite System.out :-P
OK, so maybe at least just write it to the log in backend. If we are changing the allocation type in engine and not libvirt so at least logging it should be easy and I guess helpful for users and future debugging.
Do we want to return null or throw an exception here?
Can be simplified to BufferedWriter writer = Files.newWriter(srcFile, Charsets.UTF_8);
can wrap and unwrap be called simultaneously by two threads, if not here you really need one pair of byte buffers
Is this method really needed? It's similar to make init public
Can we not verify that the text boundaries are correct? Verifying that we simply set the boundaries on the text decorator is better than nothing but can we not ascertain the values that should be being set?
Personally I prefer to set all fields using this. in constructors, but you call the shots.
I think there is some findbugs issue with not using {} not sure.
After the change to using JsonElement rather than String, to fix the bug with complex keys, you are implicitly relying on JsonElement's toString method returning a valid JSON string here for us as part of the URL. This assumption isn't part of the toString method's contract. Use gson.toJson to guarantee you are sending in valid JSON in the URL. The same goes for startKey and endKey, below.
Shouldn't that be Class<?>
we can change the implementation as Stream.of(Cardinality.values()).filter(c -> c.getId().equals(id)).findFirst().get();, which will remove the cardinalityMap presence.
use Long.valueOf() instead of new Long() - always for performance reasons
nit: you can merge both lines above as checkNotNull will return the given argument
I think "nor" is more clear than "and"
Can the processor name be null?
I think this should be pushed higher in patch chain.
why is this public?
@fanifieiev the same above.
isNull()
The options are now rebuilt on every call. Did you want to leave the door open in case we ever need an option that would change for every new connection?
since this path was using the deprecated NativeException to wrap a Java throwable, we could make it a bit closer to resembling the previous format (and set cause) : suggestion RaiseException ex = runtime.newRuntimeError(se.toString()); ex.initCause(se); throw ex;  .. probably worth extracting to a helper for re-use. also these changes might need inspecting caller and potentially using a custom wrapping Ruby exception if these were rescue SAXException anywhere.
Could you mark the constructors @Deprecated instead of deleting them / reducing visibility? It makes it easier to transition between versions if we deprecate first, then delete later.
Nit: No need for final.
Why is this change? Should not this minimally depend on if this table is transactional or not? What happens if we call it on a non-transactional table?
nit: can just do this.defaultFilter = Preconditions.checkNotNull(defaultFilter)
use return ... ? ... : ...?
Check error code/description
Instead of all these null check why don't you make getContribution always return non-null? I.e. return default provider if there is no mapping
Should the first parameter not be getTaskServerLogsByTag?
when you implement my suggestions with the DeribitException then it will get thrown here instead methods in *ServiceRaw classes should throw out DeribitException they should be caught and adapted in *Service methods
Scm api has rules on the placement of annotations for methods
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
can't be null?
& is not correct need to use &&. if data[0]==null then data[0].equals(Boolean.TRUE) will through a null pointer
Lazy load this instead of injecting in all constructors.
String.format
input is not @Nullable, remove annotation or add null check.
To always be safe please use context.getApplicationContext()
this can call the method on L290
I think it's better to replace this(type, data, new ArrayList<ColumnDef.TYPE>().
Should be removed if empty
This is getting long, wrap wrap the arguments
- [x] UnsupportedEncodingException <- Please write why exception occurs.
please return String.class here
Mappers can be stored in static final variables instead of rebuilding these each time.
Should be a SamzaException with a message, not NPE.
You can call this.setTimestamp(timestamp) from here.
Let's refactor Topic a bit to be able not to pass anything there. We'll have something like new Topic().withBody("ab") and therefore other fields like title will be generated randomly.
You can use CollectionUtils.toImmutableList
We could the variable declaration and just use return decoratorClass.getConstructor().newInstance();
ServerSocket implements AutoClosable, so try (ServerSocket s = ...) {} might be stylistically better?
String.format
Use readAsString(...) instead
I'm not sure about public modifier here as version field represents reference's implementation details. I doubt consumers would be really interested in it. I would leave it private (or even remove it) unless there is a real usecase that requires access to its value. Making it private later would be hard (due to API breakage), we can make it public later without any problems.
It doesn't make sense to me that these signatures are changed to void, even if they're deprecated.
Doesn't seem as something which should be public, I would say, it should be rather private. If it is required by cancelAndDismissReloadRequiredWindow, it should be most likely improved in order for this method not being required public
Could you explain this change?
nit: can you put "File connector started" instead?
check directly on viewOperations map.
These calls should probably have a not null check and after that check the string does not contain .. I Think in this case if the metricName were null it would successfully concatenate with the string.
Shouldn't this be transactional?
So... return 1 - value;? Am I missing something here? Why the floating point multiplication?
Assert formatted date and check without only asserting event arrival and count (what you have done in dateAddFunctionExtension7)
I don't think that is necessary.
why not use a constant for that?
nit: you can merge both lines above as checkNotNull will return the given argument
Returning the first chunk of the stream before "\A" [implementation] and returning the entire stream contents [interface] don't seem to be in sync.
What's the purpose of this line? I don't see any difference if the url is correct or incorrect. It just clicks on the Verify button and then continues with clicking on OK. It would be nice to preserve the verification result. For example you can return it as String result.
Add this qualifier: this.logicalNodes
I believe final can be removed. IDEA resource: As private methods cannot be meaningfully overridden, declaring them final is redundant.
nit: let's avoid return null even it's unused. Instead we can return Collections.emptyMap()
I think you should also have if (c == null || c.length < 7) return; or else we'll hav an NPE
Call to default super() constructor is implied. This is only a question of style, but it make my eyes hurt... Feel free to ignore.
i think the line below should be replaced with log.trace(addPrefixToLogMessage(arg0)); in order to justify the log.isTraceEnabled(). (as should have been added originally when addPrefixToLogMessage() was introduced in this file)
Not needed, the next statement handles it in the DB, do we really care if we have the status changed in the instance?
nit: if (p != null)
Please refactor to different methods
final?
Should this return the AzureTable?
Don't return null. Make it Optional<String>, and return Optional.fromNullable(...)
Can you throw ElasticProfileNotFoundException() if existing profile is null? the remove function below can be successfully run when null is passed to it, but the user won't know that nothing has changed.
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
Can we not verify that the text boundaries are correct? Verifying that we simply set the boundaries on the text decorator is better than nothing but can we not ascertain the values that should be being set?
Missing codes.
newTreeMap so the raw JSON is ordered in a sane order, for the sake of a poor human reading the output?
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
assert.NotNull ?
warning: The static field AbstractProcessor.logger should be accessed in a static way.
Why overriding it here? If you don't really want to add, don't initialize the variable when declaring it and use copyOf here.
suggestion MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, "typeName", type.getInternalName());
We should also verify that we set the external ID on the account.
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
No need to make createClient a method since it's a really a 1 liner and only use in 1 place
If the _keySize is an Integer then return that here so it doesn't get unboxed and reboxed. Use int everywhere or Integer everywhere.
Why is not the check of presence of certificate with given alias left for the next processing, like in case (principal instanceof NamePrincipal) == true?
(Alt) Can we move the skip condition to the testSetup method just above.
this method should not be public, otherwise doesn't make sense the arguments for the flush(ClientSession, String) method, as each session (editor) will have a different associated FormsContainer instance, which could not be the one set in setCurrentContainer... Can you please change it to package protected access (so no access modifier set)? Does it work/make sense for you?
terminated = true ?
Can you reduce the nesting depth here?
Should return false if !super.supportsRefreshing()
This will cause a null pointer exception if text is null. You should not be calling "trim" here. Please remove the trim() statement. "publish" methods should not alter the data that they are publishing.
Don't expose the whole list. Either a single getter getLocation(int), or an Iterable, or both if needed. And even when using Iterable, you also have to be careful for concurrent accesses. But in this case, elements are added to the array in loadXml(), which is called by the constructor. Which means that once this method becomes accessible (after the constructor has run), it should not be modifier afterwards. In fact, you know what would be clean? Putting the loadXml() stuff right in the constructor, and saving the fields themselves as unmodifiableList/Map's. Then you can expose an Iterable view, but don't have to worry about locking anywhere. Also, you often use List, when in fact the only operation to do is to iterate on them. If the order is not important you should use Set/HashSet (or TreeSet if you store Integers/Longs), it would be more performant.
But this is more complicated than that because this is not just :  Request -> <- Response  In CoAP, there is request acknowledgement which could be separated of response and even worst you could imagine scenario with blockwise transfer that means 1 LWM2M request means several CoAP requests. ([How timeout is handled](<LINK_0> give an idea of the complexity) In the spec, nothing say that the client should response in MAX_TRANSMIT_WAIT. It must wait MAX_TRANSMIT_WAIT after the last request before to go to sleep but between a request and a response time could be longer.
we can remove the status variable by calling "return deleteEndpoint(endpointName);"
verify(fragmentMap.containsKey(id), "fragment id not in map: %s", id);
If opening is true, doesn't it mean it's still opening but not done opening yet?
If you're doing this you need locking. A static initialiser might be simpler.
As a convention, it is typically the responsibility of the refreshSomething() method to extract the style and change the figure. #refreshVisuals() typically calls all #refreshSomething() methods, then each method reads its own style from the notation, and calls #setSomething() on the Figure Also, #refreshSomething() methods are usually protected, so subclasses may adapt the behavior, without having to install their own listeners (Although in that case, I doubt we'll ever have to override the DurationLink EditParts)
Is it possible we do the calculation once during the updateCahce()?
I think that may have been an oversight in longSum. Try a query that results in +Infinity at the historical level and you will see why it is needed to deserialize at the broker level
Are you sure you can set BYTECODE_PROVIDER this way? This property is read only from system properties when the Hibernate ORM classes are first initialized. You seem to have noticed below, as the test is setting it in a different way. I'd suggest to use the Arquillian capability to set JVM properties.
you can either remove else or add pair of curly brackets
you can call just super(text), the same applies for constructor with matchers, and also the empty one
We normally reserve checkNotNull for argument checking, and use checkState for state-like checks.
should be called resources
Why assert here rather than assertTrue(..., message)?
We don't align on columns.
Why do we return the parents name instead of the name we store a few lines above?
would this be called often, and would the list copy be expensive?
Please rename this layout file as well removing _new_api.
Don't need to print the stack trace here since its been logged
I know this is just test class, but this is what Optinal.empty() is for - avoiding necessity to sometimes use null ;-)
filters method argument should be passed to isMessageInLogFile as an argument
Do you think it is worth logging if there was an attempt to set the timeout below 2 minutes?
@apc999 This needs to be public or reflection will not work
Can we revert this constructor argument change for classes that don't implement ResultBearing?
As above: eliminate magic literals.
store variable
@antonini Let's use Collections.addAll instead of having a loop.
do we really need this in 'info' level? we have the log of run-vm..
Remove this (ORDER_MAP_ENTRIES_BY_KEYS).
why are we changing the visibility of these methods?
Let's remove the wrapping finally (including HibernateUtil.closeSession) also
Shouldn't this message be changed to "Should be 500"?
If we log an error that doesn't have any vararg arguments this will throw an exception from what I understand.
I don't think you need to do all this. Just add a method public void init(T data) { render(data); } Are there places where you need to call this Dialog where you don't have this data available i.e. you need to call init without any parameters and it needs to reuse the data that it was initialized with? If not, then the init(T data) approach should work just fine.
hmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm! so we cannot validate this on gwt, but I do want to validate it at core. can we have something conditional? if the isAssignableFrom works then perform validation else not? when gwt will not use these classes any more we can just remove the conditional.
Same here, making methods protected allows users to override them.
same issue
Duplicate in throws clause - [fixed in master](<LINK_0>
Should we add null check?
Same as before. It is pointless to "improve performance" by using code that decreases it. Please revert changes on this file.
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
Won't fix.
if at all possible let's try to avoid introducing more mess:)
please format all changed code properly
@gianm >emitted by default only if the user has authentication configured? What did you have in mind for the "has authentication configured" check?
let parent handle synchronization of its field
Rename "ann" to "rules", "rulesAnnotation" or something more descriptive.
Missing randomDiscard param.
This could be set in the constructor instead of checking this on every request.
Wouldn't it make sense to call setImage here? Or do we have different semantics in that method and this one?
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
nit: if (p != null)
Better to add checkNotNull for the arguments.
same suggestion about static comparator
returning boolean type is useless here because it can only return **true**, or throw timeout exception.
super.containsKey(key.toLowerCase()) ? given ConcurrentHashMap already provides containsKey
Not sure if vm can be null, it is already locked.
checkState?
Instead of collecting transaction edit logs here, we can add the count header in AbstractTransactionLog.sync() method before calling append, right? Since the edit logs are already being collected over there, we will then avoid code duplication.
remove extra line
An exception without any messages or stack traces.
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
code format
How about "Type is not supported"?
Coding conventions: Let's have the @Override on its own line please
Declared exception from update method can be removed as well as this try-catch block.
Isn't the coding convention like: omit "this" when it is not needed ?
This should not be done here. Use StudentFeedbackSubmitPageUiTest to test this.
These checks should happen within the build function when delegated to the object they are building, not a builder's set function. Don't duplicate the logic.
We can use better hash function here and cache this value in methods whenever it's possible.
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
The version check should come before the call to loadTemplates().
constant? nitpicky I know, sorry
where are we doing the initialization blocking call now? If the global endpoint manager is not fully initialized with first databaseAccount fetch could this return null?
Consider a case where user entered a single quote ' in streamName, then the sql query can give a syntax error and the app will crash. I think it'd be better if we use ? in sql query and provide [arguments](<LINK_0>,%20java.lang.String...)) in queryRaw.
Remove extra empty line
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
will be null after view disposal. PlatformUI.getWorkbench().getDisplay() is our friend.
I think we will have to discuss whether or not to include the fromKafka functions in this class.
You already log an error if JNDI lookup fails, as part of getAuditLogger() -- do we need this else statement?
just return "" instead of new String()
This is redundant in Mockito 2
ObjectUtils.objectsEqual(a, b) may help here.
Should be Assert.equals or Assert.<Object>equals so that the values actually get printed out in the failure mesasges
Why not <code>return ExitStatus.COMPLETED</code>?
Like, super.onFailedToRecycleView, this doesn't seem to do anything. Why call one super and not the other? Ditto for below?
nit: can be simplified to return counter++;
This change is still incorrect
I think this Map.class.equals(type) is a remnant from a previous implementation and can be removed?
Exception propagation. No need for subsequent return null
this assigment is not needed, since its default value is false
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
you don't need to check for null since this gets set in the constructor
Any worry about case sensitivity wrt to scopes?
unnecessary array new: {{true}, {false}} should work here
Why the change? This does the same thing as the original code.
suggestion assertEquals(1, IOExceptionOnOnlineListener.onOnlineCount);  I suggest following the existing pattern in this file and calling the assert() methods directly. Then the new import also wouldn't be needed.
I dont think you need the RocketMQ version number in the name here.
can builder even be null? if not, it is just getSslBuilder().build(), or in-line it.
Please catch specific exception(InterruptedException) not generic.
use return ... ? ... : ...?
nullity check here too :)
Was this detected by findbugs?
Doesn't look like conditions are same.
Moving that bits above and allowing the user to change the decorator via a public setter means you can completely shadow what AbstractTransactionSupportingCacheManager used to du using public API. Also, if CacheDecorator is a first-class concept, you should probably expect that more than one decorator can apply at a given time. This wrapping shouldn't be the responsibility of the caller.
Perhaps we should explicitly prevent nulls here (and for password) Misc.checkNotNull(username, "username") or whatever exact syntax it is?
return HConstants.EMPTY_BYTE_ARRAY; ?
This isn't a valid implementation of equals. You can have non-equal things have the same hash via a hash collision.
purge takes too long, just delete
No if block required here either.
again, just set the element in the array ?
How about make "filter" to a constant(KEY_FILTER) in NotificationListFragment, since it's an argument key and many place need to use it. typo it may cause bug in other place.
should the interface not the implementation suggestion public List<String> getTopics() {
Why not just simply "command.setVM(vm)"?
result -> results
Should we clone this? In other APIs we usually make a copy of the byte[].
these setters should not be public
this can be condensed to  if (!chkAuthorization(...)) { return false; } ... return true  and get rid of haveAccess
Same nit as above.
This might throw exception
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
Why fakeThread
Please revert if possible
So all HashFunctionPartitioners are equal to each other? What about the 3 different variables? Also the hashCode is broken as that uses 2 of the fields :(
Hmmm... This pretty tightly couples SQL string with the prepared statement in terms of parameters. I'd go with approach that schema creates the statement with given parameters (aggregateIdentifier, and sequenceNumber in this case). What do you think?
Hmm, is this better than a switch?:  switch (ch) { case ' ': ... }
It seems this given statement is not necessary anymore.
This can be static
1. position should be able to equal count which means the end of the stream. The current logic will never be able to seek to the end. 2. Shall we throw an exception if the position is invalid, for example negative case?
It would be good to use constants instead of hard coded property names. Maybe you could use KFSPropertyConstants.BUILDING_NAME constant instead of "buildingName" or add new constants to CuCamsConstants.java
either handle cocoa like carbon or remove carbon on the fly maybe change "carbon" to "cocoa" by separate change before? carbon is unsupported.
Maybe backoff is needed between retries?
Unnecessary cast.
please move the isEmpty methods to the scimSchema
I meant, we don't need a separate method. Lets do the things in power.
ditto on readability here:  int result = name == null ? 0 : name.hashCode();
for me it's too long. Maybe Result.wrap() ?
this.monitor to avoid confusion with the parameter of the same name optional: this whole block could be a ternary: this.monitor = monitor != null ? monitor : NullProgressMonitor.INSTANCE;
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
can be !isDisabled()
This method can be implemented as return a - b;
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
truck is unused
static import?
Should be a SamzaException with a message, not NPE.
This doesn't seem correct, you need to fetch all the active drug order and of the patient, loop through them to find all drug other orders and compare their none coded value to this drug's none coded value
The new code is not equivalent to the old one: FileQuery.onSource() should be transformed in a predicate on file type.
I know this is just test class, but this is what Optinal.empty() is for - avoiding necessity to sometimes use null ;-)
+1 for clear cache... especially since that does proper synchronization
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
use an overridable getOperationTimeout() method instead
Probably enough to have Longs.hashCode(pointer) which should be a little faster.
There are maps that don't allow null keys and (stupidly) throw an exception when you try to check for its existence. You need to account for them here. suggestion try { return map.containsKey(key) && super.valueMatcher.matches(map.get(key)); catch (NullPointerException ex) { return false; }
can't this be an ObjectArgument.of?
@ob-stripe totally random but do we really need those duplicate collection classes? (nothing to do with autogen, just realizing I haven't asked in a while)
why do we need a Collections.singletonList(cmd) here?
finish() is called in case of an exception but the callback.close() is also included in the finally clauses of the top level methods. This leads to closing a callback() twice which is probably not intended.
Why returning an unmodifiable map? The returned map is a new instance generated in this method. There should be no other reference to it except for what returned from this method. Returning a modifiable map would also save us from converting back to a modifiable map in getTaskManagerLabels and getConfigMapLabels.
Remove
Ah yeah that makes sense to me
extra line
Please put @Test on the line above, not on the same line.
It might be that assertThrowsUnsupported(lambda) could be helpful here so we don't repeat the same Assertions.assertThrows every time, but we use just assertThrowsUnsupported(unmodifiables::incIteration), assertThrowsUnsupported(() -> unmodifiables.remove("some.key")) and so on
1. Did you mean support only Firefox for _testing_ right? I assume the difference in behavior affects testing only? In that case we should keep the production code clean and apply any workaround in the test code. e.g. do an if-else based on WebDriver. 2. Yes, I think at some point we stopped using Chrome for testing. There are many other quirks between the two versions that gets in the way of comparing html. We can check if anyone is using Chrome.
This is redundant AFAIK - it should be Mockito's default behavior. If it isn't, use Collections.emptyList(), not the raw EMPTY_LIST.
This should return the list of resources under it, see FileResource impl for more details
- [x] Why need this? Please re-consider based #768.
just inline this. ex. if configuration.getPercentage() is mutable config, make a final copy. This code is simple enough that it can be inlined, and there's no reason to require an allocation or another type to do this math.
rename to child or childItem
Is this change related to updating apache velocity?
From the wiki: Its fuse lasts 40 redstone ticks (4 seconds/80 game ticks) if activated by redstone or fire, or a random number between 10 to 30 game ticks (.5 to 1.5 seconds) if it's destroyed by an explosion. In other words, right here the number of ticks needs to somehow be passed down to the explosion objects (setFuseTicks). My recommendation is to add an overloaded method to explodeBlock that accepts a boolean: blownUp (name is just a suggestion). If that boolean is true, this 'random' tick count is applied, otherwise the standard is used. I would almost go as far to say that the boolean should further propagate to the explosion object that holds the fuse ticks so that magic numbers aren't all over the place.
maybe also add a check for "mid=?", new String[] {"0"}
using Arrays.asList create a fixed sized list, so doing later getTo().add(something) will throw an exception.
I this refactoring, very nice. Could make this method protected.
It can be null?
Again, processible gets renamed to runnable, process to run, yet doProcess remains as it is. I think that's an easily avoidable inconsistency.
But now these 4 lines above can be deleted.
Now we have this constructor , what is the benefit of having default constructor and setPath() method explicitly .
extra ; at end of line
You may want to add assert size - toRemove.size() >= 0; (my genIntellijRuns task enables assertions by default)
Why do you we need to keep a reference to the activity here? This will leak the app. We should use mEditState array instead.
No tabs please.
Can this be private, or is there another use case for default attribute outside the builder's call?
Should this link to the course?
When you write data to parcel, it is analogous to serialization, so we also need to deserialize the result to get back the NarrowFilterByDate instance in [creator createfromparcel](<LINK_0>
Remove this by returning null above.
merge else if?
suggestion super(() -> name);
@fanifieiev RequestOf is a better name than RqOf.
This can delegate to the two-argument createSystem variant.
Remove the public modifier from all injection constructors.
....and then you don't need to call it on every other method
If the only parameter is the id, do you need to send it in JSON? Maybe just use an url-parameter and get it with params.getRequiredParamInt("id") so you don't have to worry about if it's not sent or if its not a number etc. Also remove the param getting out of the try-block so you don't wrap the possibly thrown ActionParamsException to a new ActionException spamming the logs.
String.format
we should not print the errors to standard output. use StatusHandler.log(new Status(IStatus.ERROR, GerritCorePlugin.PLUGIN_ID, e.getMessage(), e));
Change the second part of || to an assert (verify).
You could simply use getVdsGroup() if you extend VdsCommand
Do we really need this check? I think it's redundant.
This looks to me like maybe you accidentally included an unrelated change?
The super() returns "" on null. Why should we differ?
Just because nobody else currently needs it besides the class itself. I typically keep things as restrictive as necessary and increase visibility when necessary, or when ready to provide a public, stable API.
throws TaskException is part of the interface, did you mean to remove it?
You probably want to pass the exception as the second argument to the logger. If it is in the message all you get is the result of ex.message() but if it is the second argument you get the message and the full stack. Often the message is almost worse than useless and for some exception types it is null
Ye, but it causes a PMD warning.. :P I will fix it, that will be easier. ;) <review, layout
Those two methods are similar. Consider using one.
Agreed. Maybe an Optional<VarRefNode>?
assert.NotNull ?
This should return false if the method is declared with the default keyword or is static
If the getCluster().getMigrateEncrypted() is null, shouldn't this method return the default value from the config?
I'm not a lover of passing nulls to methods or constructors.. would another constructor without the contextId be better?
Comparators classes don't generally have to implement equals (i.e. is this comparator the same as this other comparator?), so this is effectively "assertSame" because it's probably relying on Object.equals(). I don't think it's particularly rigorous to test for equality by using the comparator so I can't think of something better and I'm happy enough if we just compare instances. So, I think we should probably assertSame where we're expecting the same instance returned to make it clear.
throw UncheckedIOException(e)?
Does this need to be a singleton?
getGeometry call here is redundant, because OGCGeometry.createFromEsriGeometry(new Point(x, y), null) can't return anything other than point. Perhaps, remove it.
if at all possible let's try to avoid introducing more mess:)
We may also want to cancel our subscription.
requireNonNull
if you do this, better put N/A :)
These "duplicate" entries should no longer be required afaik, because @AddonDependency now adds an implicit dependency. Try it out.
Call setFocus() on the table control.
I believe these 3 lines should be moved to BMT, it's his logic
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
Nit: Objects.requireNonNull will ensure we never accidentally cause NPEs to be thrown.
as long as it's the same event id that's fine i guess, though i don't really see a problem with using just one. but i don't mind
Call I18N.getString(String) (there are no parameters in the resource messages).
suggestion super(() -> name);
this is potentially costly, depends on what asMap is doing. Maybe getIfPresent and check for not null result?
@aunyks you should make expected a Set to begin with so you don't have to convert the return value of the describe method to an array
Let's keep the old code here or let's try to move this method in the IndirectClient?
minor nit: can we pass time column selector before field selector to be consistent with buffered aggregator ?
should we have an early exit if the trace is the same? I am asking, I don't know
Hardcoded "\n".
It's not needed to check null, also inside of QueryBy.valueOf has internal check if the item is not one of enum items, exception will be thrown, should be changed to something like:  @JsonCreator public static QueryBy of(String value) { return QueryBy.valueOf(value.toUpperCase()); }
This conflicts with the commit message - either Uninitiazlied is OK, in which case the commit message should reflect it, or it isn't, in which case the check should be removed.
Please make the methods in Calculator non-static and rework the examples accordingly. I think it's fine to create the calculator as the _SUT_ in a field (in all affected test classes) as follows. java private final Calculator calculator = new Calculator();
different audit message for the case only the key was updated is needed
String#split() is considered harmful. Use Guava's Splitter.on(";").omitEmptyString().trimResults() instead.
Same as above LOG statement.
tracef
Collections.singletonList is better (at least for meaning) in this case.
SimpleDateFormat is not thread safe, so you can't share it across threads. The static instance _can_ be used across threads since this method is static, so it's not safe to make this change.
I believe the order is guaranteed in partitions by the sort order of Partition which is on the partition ID.
rename to f
How about narrowing it to ClassNotFoundException and fail with other exceptions?
The checkpointComplete() methods take the checkpoint ID, but the snapshot methods do not take any checkpoint Id. That makes it hard to correlate the calls. Because multiple checkpoints can (and ultimately will) happen concurrently, you don't know what snapshot will have completed here. For example in the Kafka case, I assume you remember the offsets at the point of snapshot. And then commit them when the snapshot is complete. If you look at the existing Kafka Connector, then it kept remembering offsets per checkpoint in a Map (checkpoint -> offsets) to commit them as the checkpoints where completed. I cannot see how this interface could support this.
could metric == null?
nonEmpty
seems to be like this should be before the vm is unlocked in super.endVmCommand();
I would just use ASC and DESC like the standard hive syntax
I'd prefer to remove the field itself. Feels a bit unclean to have a field which is only valid during the execute method. It should be a local variable in execute and passed as an argument to getTagTarget. What do you think?
getter
style nit: we don't use braces around single line blocks
nit, deeply nested functional chain. Consider decomposing this a bit with helper methods. EG:  return battleState.getUnits(EnumSet.of(side)).stream() .anyMatch(unitIsActive(BattleState.side.OFFENSE));  I believe you can also get rid of the intermediate variable as well and just return the result directly as well.
np: s/LocalApplicationRunner/RemoteApplicationRunner
Need to verify no interactions with log
Should also have tests for strong with preceding character content, and following character content. (those are areas where we've had troubles before)
suggestion return format("metadata[%s]", key);
It is not, this change should be reverted.
Should be added the Override annotation.
Can you make all of the accessors final?
Creating an exception in Java is very slow. (<LINK_0> Do we really need this ?
I will be nice to have more meaningful error message. E.g. "Text condition must not be empty string." or smth else which explain the problem with comparing actual text and the empty string.
I think there is some findbugs issue with not using {} not sure.
The WFLY-1069 stuff should tie into this.
Should we only validate if there is a cache hit?
Are muting/unmuting video here?
In the wonderful world of JUnit4 ;) you can use @Test(expected=IllegalArgumentException.class) public void testCallsiteCopy2() { new TmfCallsite(null); }
We should probably prefer setReference and setAlternate to be private (or protected if used by a child class, but I assume that is not the case right now).
Should return DataContext (the interface) and not QueryPostprocessDataContext (an abstract class which we don't want to expose to end-users).
This evaluates different value that it stays isLeftTurn will return true, in case it is slight left turn
java if (next == null) { return fromIterator.next(); } else { final TYPE result = next; next = null; return result; }  I find this better to read.
I believe it is better to use request().async().post() instead of creating new thread.
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
Since leap-day/year-day aren't part of any actual month, you need to return the zero range
Move to update please. < layout
1. Removed @throws IllegalArgumentException when alias is null. as it is not required to declare throwing a runtime exception. We haven't declared this in other places e.g. Database class as well. 2. Remove an extra empty line before if(alias == null) {. 3. Add a space between if and (alias. Should be if (alias == null). 4. Add . (full stop) at the end of "alias is null" -> alias is null. 5. Do the same for the other methods.
I think we should store ignoredRegions instead of ignoredLineNumbers. Single lines that need to be ignored can be stored as <LineNum, LineNum>.
Careful. This imply face culling must be enabled. We need an additional state change in this list.
So we decide this class to be a leaf ByteCode Node? (Alternative would be make this returns ImmutableList.of(block, position)
Could you please extract "disabled" as class constant, so we are sure in future we update correctly both enable and disable implementation?
Since this block is used twice, perhaps pull it into a private method?
Why not just do this instead: return obj instanceof DueDateAmountMap && innerMap.equals(obj);
I think we should store ignoredRegions instead of ignoredLineNumbers. Single lines that need to be ignored can be stored as <LineNum, LineNum>.
This also Postgres data type. Let's refer to this doc (<LINK_0> for Clickhouse.
Please use Optional.ofNullable()
not sure if this makes a difference or not, but won't the max size be Float.BYTES if storeDoubleAsFloat is true? I see the pattern you used is the same as what's used in DoubleFirstAggregatorFactory - probably a bug in both?
This is confusing. We have no internal value of system_server. "No valid system_server to be checked" makes it sounds like it's a device side thing
Let's withhold this change. Both Ignite.active() and IgniteCluster.active() are deprecated. So it's OK for one to map to the former. If there's a warning inside IgniteCluster.active(), it's even better that way.
Could we get a deadlock now in some cases? #reset holds a lock for the outer ProxyWhitelist, and when this is called it will also acquire the lock for the delegate ProxyWhitelist. Do we know that the locks will always be acquired in the same order? I would be surprised if there are cyclic references between instances of ProxyWhitelist, so my guess is that it should be fine, but it would be good for someone to confirm.
Why are we returning null here ?
This seems unfortunate. Does the RS spec forbid null values?
should atleast check o being non-null and instanceof IdentityExtractionFn .
i think java return vv -> connection.getContext().runOnContext(handler);  Would have the same result and it avoid 1 extra lambda
I don't see why we need these sorts of constructors... We've never needed them before, and there's nothing special about the useLayerNormalization arg (it's just another boolean)... unless I'm missing something?
this is already called in BasePageObject so you don't have to call it
Sorry, I suppose I wasn't clear. I meant that using == below would mean this check for null 'eref' and returning an unexecutable command would then not be necessary and could be removed. The idea being that perhaps the superclass would be able to do something useful (for example, look for a suitable reference and try again). So, let's remove this null check and see how that works.
you don't need use replaceAll, because above you used normalizeJson
method reference here as well -> anywhere we are calling a static method can be replaced by a method reference
Why is this method parameterized?
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
should the interface not the implementation suggestion public List<String> getTopics() {
Should we add: Objects.requireNonNull(record)?
Can't this NPE as they're Booleans (i.e. objects not primitives)
It'd be informative to mention how long we will wait in the log message.
Please use interfaces where possible.
@xupyprmv the variable master is redundant here, please inline this real quick :)
Second condition is unnecessary (checked in while loop below)
Please avoid one letter variable
In theory this should never happen. But why do we throw here?
Static import
Does this complete faster than early exiting with an if (b != 0) return false ?
In general I wonder why one should instantiate an (immutable) null Password. I mean passing a null parameter to the constructor. Should this be considered a bug instead and hence throw a runtime exception? Should we update the copyright date to 2017?
if from one run to the next, you cannot find the TIDAnalysisModule, you still won't be able to reproduce the analysis results. you should probably used TmfAnalysisManager.getAnalysisModules instead of trace.get... and throw and IllegalStateException if you cannot find it.
as with the others, need to "remember" the first via, not the last.
isTraceEnabled is not necessary here ?
all these methods can be private
Can't we make getTarget a part of the Ref API?
Why singular?
duplicate regex as above, can we reuse it?
Please follow the style guide in CONTRIBUTING.md to add this to field access. You can turn on > save action .
Why not use badges = getBadges(userId); here? I think that's more clear than a call to a void method where you have to read through the whole method to understand the side effects.
only one return is possible here.
ImmutableSet.copyOf instead of Collections.unmodifiableSet
Can this be private, or is there another use case for default attribute outside the builder's call?
Do we have to serialize the state in Operator? I think the caller class would be a better place to serialize it.
Where all is the outer setAddress method used? The AMQP Properties section is part of the immutable bare message so we shouldn't in general be setting the 'to' address in it or creating the section if they weren't present. Exception might be made during cases like protocol conversion, but it seems like it should be explicit rather than a side effect that might see unintended use as here.
I think in this class it is possible.
Yup :)
nit: space after 'if'
Raw type here, generic in the base
do you need to make it public?
Do we need the empty constructor?
I think you can actually make this private. The compiler will generate a synthetic accessor that other classes have no (legal) way to call.
Guice best practices: make this constructor visible only at package level.
Minor suggestion to change this exception to:  throw new IllegalArgumentException("g may not be null.");
suggestion return new BridgePath(virtualFile.parent(), fileSystem);
nit: don't need this return false; line
do not assing parameter! nowhere!
only one of isJavaxScriptSource/isJavascriptSource seems necessary
no need for the manual check (especially for the unannotated parameter).
Please make the methods in Calculator non-static and rework the examples accordingly. I think it's fine to create the calculator as the _SUT_ in a field (in all affected test classes) as follows. java private final Calculator calculator = new Calculator();
we can replace that with findAny/findFirst as we don't really need to know those vms
This implementation does not seem useful, as there may be dozens of those. I would print the number of events and that's it.
combine with assignment this.outputType = requireNonNull(type, "type is required");
![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce the number of returns of this method 5, down to the maximum allowed 3. [![rule](<LINK_1>](<LINK_2>
use ShellIsAvailable(this)
nit: remove brackets to be consistent with 2 lines below.
this variable name is misleading, it contains not only the commandData but also Ne field (see also other ApduTest classes)
Shall we change this to "Unable to resolve the hostname of the ....". there are few other places as well with same error message.
Use a guard method here
unrelated to this commit.
Test with the mangled tabix inputs as well
nit: you can merge both lines above as checkNotNull will return the given argument
We should probably not swallow this exception. We can log and rethrow.
This can be simplified as follows if(refresh != null) { refresh.cancel(); }
There's no point to else here...
add requireNonNull for bytes
There's a Map-specific assertion class:  assertThat(results.get(0)).containsEntry("name", "eric");
Doesn't this duplicate the nonNull check?
Typo here. should be service_type
Newing it up like this will make it hard for someone to put in their own... The rest of the Nodes use a get() method to pull the value and expose a setter so that it can be overloaded, can we do that too?
there is no need to wait here?
s.a.
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
Should be a constant of Run rather than RunQC
I would suggest You to use Logy.d here instead, as we did it [here](<LINK_0>
:astonished:
minor: do you need the super qualifier here?
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
This is another behavioral change that I don't want to see in an unrelated PR.
Use clone or Arrays.copyOf.
I would love to have a java.nio.Path method too!
good practice: usually actions go before WS as they are injected into it and so they are grouped together
[Checkstyle] ERROR: '{' is not preceded with whitespace.
!showButtons
new ArrayList<>(causes);
Just "groupName".
refreshJob field should also be set to null on dispose.
Nitpick: might be better to use constants for these.
Do you get any compiler or pmd error if you remove the line that throws the exception? I get wanting to make the default constructor private, but it would be cleaner if the method were simply empty.
Aren't the name and description properties already added by the super class?
note: Generally having a composition based factory is preferred. However since the ORC writer is already implemented this way - let's keep it so for consistency.
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
data is never assigned, so this method always returns "". How about instead use: public String toString() { try { return getDN(); } catch (NamingException e) { return ""; } } as then you can't forget to return the proper value, and you aren't duplicating the logic which appears in the getDN method above?
I believe the order is guaranteed in partitions by the sort order of Partition which is on the partition ID.
one more method where it can take file location of properties would be good.
If leafCount is still 1, how could it be two rack groups?
@ribhavsharma please take a look at [this](<LINK_0> You will have to use the clone() method while returning the value which will also fix the travis-ci build failure :)
static.
if credentials is null should not execute mocked push
remove unnecessary checks
Shouldn't a cast to int be enough?
add Reporter.log(String.format("<br>INFO&nbsp;&nbsp; - Accepted alert <b>%s</b>", alert.getMessage());
add non null validation
Here we need to take sequence number wrap around into account. Alternatively, what we could do is unconditionally set the maxSeen, and prevent the maxSeen from being set if the end has been set. However, I don't like adding this kind of logic in the setters. Maybe it'd be better to have a getMaxOrEnd() method.
can the selection be null?
Or judge null place here ?
Creating an exception in Java is very slow. (<LINK_0> Do we really need this ?
Why is it public?
You can use StringUtils from the commons.lang3?
suggestion private static void attachSlavesToJenkins(Jenkins jenkins, List<EC2AbstractSlave> slaves, SlaveTemplate t) throws IOException {
Simple for-each?
initialize() or schedule()
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
Can we use BinaryUtils#resolveClass instead of making this method public?
This was already a problem with this in the old code, but the parameter name strings and values are mismatched here.
pls call this(null, DEFAULT_LIMIT)
Please put a space after if.
If quality is an int, we don't need the check.
Perhaps add further information to this exception
Please also delegate to setDnsConfigurationEditor
It would be ideal to clear and repopulate the LibraryType table in the V9000 test data migration. Then it's easier to test against an exact controlled number of LibraryTypes, rather than making the tests more lenient. Same with LibrarySelectionType below
The constructor should be made protected so that users can easily make a wrapper for it.
This seems unfortunate. Does the RS spec forbid null values?
Change log level to debug
Same here, but check the max cook time instead.
\+ unset MDC?
Is this still needed? We don't add any other elements, so parent.get(anythingElse) should return null anyway.
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
Please use MantaClient.SEPERATOR and do not hardcode slashes.
"cwl" should be DescriptorLanguage.CWL.getShortName()
Nitpick: you can remove the unnecessary parentheses here.
nit: Perhaps you should show the user how to parse the JSON?
Do you know anything about the expense of these methods? Will these cause RPCs to namenode?
minor: can be final
Recently, @yingsu00 removed all of the uses of the related form of getUnsetBits to not have an isNull vector. Her change had a good effect on memory pressure, and in some cases increased performance. I suggest we use the pattern she introduced in this new code.
This can delegate to the two-argument createSystem variant.
Not sure what this is supposed to test ? wouldn't the assertion hold regardless of what removeIf did ?
Use context.getApplicationContext() to ensure the class can't leak any shorter lived contexts that might be passed to it (it's always fine to hold onto the application context, since it's expected to be around for as long as the process remains alive).
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
final This should probably contain this.value = value at some point... and it should only do so if isListening = true.
This could race with the emission of run().
Tests should never suppress exception but rather propagate them or use an ExpectedException rule.
This method should be static and need not pass this as an argument to the constructor.
Why return a value if you don't use it when you call the method?
Missing codes.
You don't need a transaction here
nit: orElse("null") is clearer.
delete() should be executed from within the future so it doesn't through right away.
Why not call put in this class for atomacy?
Not sure what this is supposed to test ? wouldn't the assertion hold regardless of what removeIf did ?
Why we are searching through all bundles?
Can't ServiceHelper.getSelectedService be used? It has the advantage of not relying on the specific format of the url.
As we're down to one arg, just do:  return threadRecord.hashCode();
You could probably use the same URL as in getResultById here.
Should this be putTransient because of IMap#putTransient?
Why don't instantiate the provider list within the constructor itself? It would allow you get rid of that "if" condition that always gets called whenever the getProvider method is invoked.
add requireNonNull for clazz
also may need sync
Fixed in next patch set: - Made private. - Added dummy serialVersionUID to prevent Eclipse warning.
Same as above, why not use try with resources?
looks like you don't need these three variables at all. Just use this at line 41?  java List<String> boardNames = TestController.getUI().getPanelControl().getAllBoardNames();  You can probably follow it up with this (not sure)  java assertEquals(boardNames, Arrays.asList(new String[]{SAMPLE_BOARD})
Better revert.
Should this also set engine to null in a finally block? If not, I'm not sure why it checks for null (line 177).
@dalifreire let's get rid once time used variable
What's the rationale for having different semantics for resolve and resolveGroup? The arguments in commit message also apply for Lookup::resolve (while it's depricated it is still valid method of the interface). The previous semantics of those two methods seems is a bit more natural:  * resolveGroup: resolve a group (whatever it means) * resolve: the same as resolveGroup, but assume that each group is singleton (valid only for iterative)  In fact, current semantics of resolve is rather convenience over strict semantics. Do we want to get rid of this convenience eventually? E.g: we can test algorithms on raw trees without any group references.
It would be better to run checks in the constructor to make sure no reconciler is null, or to create an actual list of non-null reconcilers that would be dereferenced here.
Needs some sort of assert to show it succeeded
I'm not sure silent catch is good as after that url is null and it will create exceptions
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
you should check only snapshots of this specific vm
Why U don't want to consider id in equals and hashCode ?
nit: throws for consistency and clarity.
(Apparently GitHub lost this one) Check instanceof Character and throw IllegalArgumentException like above?
blank line
nextMemberPosition is needed only for addMember. Initialize it lazily only when needed.
It would be nice to provide some feedback if this check fails. Like "The file BLABLA doesn't exist in the directory you provided. Please try again..."
This is check in the overriden enqueue method. I think this check is extra here.
perhaps if not has permission?
"isSearching" should be a class level string
Re-use temp file
Neater: String.valueOf(value);
Please use lowercase as it refers to the argument: disposables is null.
Just leaving a note. So far we haven't discussed anything about host-level quotas. But this is something that we need to configure after running a redliner test on Ambry frontends.
@NielsCharlier consider refactoring this to use Java 7 try-with-resources.
should this have a ,  to match the rest of the pattern?
Isn't this quite ineffective? We are implementing a method which explicitly expects a fully qualified ref name and which therefore does not have to deal with iterating SEARCH_PATH. But the implementation is done by calling the expensive method which does all this iterating over the SEARCH_PATH and to throw away the results if we see the input ref name was not the a qualified one. Maybe an internal getRef() method should learn to use a explicitly given SEARCH_PATH.
can be simplified with return value!=null? value : defaultValue?
there is no need to set the value for the object id
Instead of obtaining the Authentication, please use the SecurityContext so that the original SecurityContext is used (this ensures that if a custom SecurityContext was established it is used later on as well)
Text is slightly better but I still think it is better to focus on the positive, e.g. We redact the encrypted secrets... which leaves unsaid but implies the non-redaction of "secrets" that are not redacted
Let's change the signature to ImmutableMap as well, please.
please use baseActivityTestRule.launchActivity() (without the "null")
"Max number of models that can be trained for this account"
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
It is likely to cause issues that there are also static methods that accept an arbitrary salt UUID, while this uses an internal private salt that is almost guaranteed (as far as practicable, which is the reasoning behind UUID) to be different to anything the user submits to the other methods. It may prevent errors in the future if there are only instance methods for these operations, so that the state (the salt, essentially) can be maintained privately and not flow into user code.
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
Please, use "SeleniumWebDriverHelper#waitVisibility" method:  seleniumWebDriverHelper.waitVisibility(navigationBar, LOAD_PAGE_TIMEOUT_SEC);
Since the constructor doesn't "return" the token, we use a different naming scheme here. Here is a suggestion for this method: public void bitreserveClientWithTokenShouldSetTokenAndRestAdapter
This can be set in AndroidManifest
public static? Is that keyword ordering important in this codebase?
looks like wrong indentation, maybe you forgot to run build with qulice profile enabled?
please use VmTemplateHandler.BlankVmTemplateId (i guess this is what you meant..)
Changing the region should also invalidate the client like above.
Please use PathUtils.validatePath to make sure that the path is valid before accepting it.
any reason for explicitly invoking super.toMap() ?
I would prefer IllegalStateExceptions in such cases.
maybe add an assert checking the token's beingLine / endLine are properly filled?
You'd still want to tear it down. How about using a straight-forward if-else ?
isErrorIfHostDoesntExist => isNewHost
I believe this is the cause of your failures as you are setting up a Java17 project which will be called TestSetup17project or something like that.
Better throw a SkipException to see the reason why this is not executed in the test output. this will also serve as a reminder for us that this needs to be implemented.
suggestion /* package */ Intent buildIntentForUri(Uri uri) {
won't there be an NPE if upServer is null?
Shouldn't this be a field so we don't have to create one each time
would it be better to throw an UnsupportedOperationException rather than return something that won't work?
Core.ID
we could use reduce instead of fold, like:  java return Stream.rangeClosed(1, n) .map(BigInteger::valueOf) .reduce(BigInteger::multiply);
Please keep this.cell near the related fields (previousFamily & cell count) below
Also you missed similar fix in the lockInterruptibly() and tryLock()
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Add a message to checkState so that it's easier to debug if we ever hit it.
Changing this to: cfg.setBoolean("notedb", "patchSetApprovals", "read", false); makes most tests fail.
Please keep this.cell near the related fields (previousFamily & cell count) below
Shouldnt we have this defaulting to the common namespace (ICommonAttributes#COMMON_NAMESPACE) so that we can tell the user what this defaults to?
What if type is not Class type?
Another way to do this would be to override setIsAvailable in PluginModel to be no-op. (This would allow us to get rid of the instanceof check here.)
Add a new line: java this.myArrayList.ensureCapacity(this.myArrayList.size()+ collection.size());
root would not change and I can't think why its access needs to be serialized with other methods so why does this need to be synchronized?
combine with assignment this.outputType = requireNonNull(type, "type is required");
"Initial connection"?
Please add at least of project in order to check that the result is empty because it return an empty list
This is normally made so different implementations can override the type() method to go somewhere else in the objectstore - however you have a getType() on BACoordinator so it means no one could ever override the getType() from what I can see, maybe I miss something or maybe its not required but I do need some clarification
Is this the most typical case? I would have thought most chunks aren't null and such I'd suggest flipping the if/else block.
This one also called inside of broadcast() a live above.
Maybe its just me, but this calculation looks wrong, since we are assign a = b, then b = a % b will always be 0, since a = b. Shouldn't it be: long c = b; b = a % b; a = c;
Unchecked.consumer(plugin::customizeJdbi).accept(this); is the right mantra :)
what is this supposed to do?
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
Please use P.lazy(u -> f.f(a)
you unnecessarily flipped the order of these two statements which makes the diff unnecessarily larger
super() is not necessary
This assertion should remain - when caching just Channels, there is only one connection (default). I suppose we can allow it to be set as long as they set it to 1. Will change during merge.
Style-nit: We always wrap statements in curly braces.
This is normally made so different implementations can override the type() method to go somewhere else in the objectstore - however you have a getType() on BACoordinator so it means no one could ever override the getType() from what I can see, maybe I miss something or maybe its not required but I do need some clarification
The doc needs to specify what the keys of the map are used for. From a quicklook I think it's the type of user but I'm not sure.
this could be private, or is it used on other classes?
Validate spelled wrong. "ValidateChainOfTrust"
I guess this method should be removed entirely here and below. (It was one time and it flush process to server log twice). As an option it can be optional using some system (maven) property for debugging purpose.
Exception again
if i get it right: if response is null, we will not retry. i think we should retry even if response is null. btw what caused this in your case? so it would be:  response == null || ....
use return ... ? ... : ...?
The call to super() is unnecessary.
this cast could be avoided thanks to the changes on generics on MultiIterator
I still think you should throw an exception if name is null
remove tabs
writer = System.out;
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
Add the original ClassNotFoundException as cause.
The constraint here should be on the consumer key, since on the old job the TARGET_TYPE is a consumer, and TARGET_ID the consumer uuid.
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
Use another example of expression than a return statement... That example is hard to follow.
So, if the xpath query matches event than this method will return true, right? Than the event will be propagated to TreeWalker. This java if (!filter.accept(event)) {  will be evaluated to false and the message will not be removed from the set. Thus, what is the sense of the suppression? What do you filter? Look at testMatching. The user writes the query /CLASS_DEF[@text='InputSuppressByXpath'] in order to suppress the violation, the filter should deny the event, but your filter will accept it.
add block
Is there any reason to add the this. prefixes? Seems redundant when the member variables are already prefixed with m_.
Let's only use DsfDebugOptions... as mentioned above
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
why synchronized?
extract method
I think it should be return executeCommand.execute(action, resultCallback); else you lose the "good" DispatchRequest in the process.
timed --> direct
@rakeshadr is there a potential race here between setting the shutdown handler and checking if it is null?
Seems like a reasonable change. Can you extract formatter.withZoneUTC() into another constant to avoid additional overhead each time?
This should default to true to preserve the previous behaviour.
real and bigint still applies for qdigest right?
you import ByteBuffer, no need to use the full package path
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
Please put @Test on the line above, not on the same line.
please just define on the next row.
please remove this
You should use a consistent method naming paradigm within your class. I think this is the only setter that says "set" on the start. Either have all of them say set, or none of them. This might also be a good opportunity to change "rya prefix" to "rya instance name" since the prefix is Accumulo specific.
That statement should work, there's no need to modify the source here. If something is wrong maybe it's the file encoding during the git clone or other editor that changed the encoding. On my clone :  $ file src/test/java/org/mockitousage/matchers/MatchersTest.java src/test/java/org/mockitousage/matchers/MatchersTest.java: UTF-8 Unicode c program text
I think package private scope is enough for tests
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
This method might be the one in public.
This line should be "new POSConfigurator().getConfig( new ResourceManager( configFile ) )" -- this way, the user only needs to specify non-default values in the config.
use an overridable getOperationTimeout() method instead
This is an anti-pattern. Use a StringBuilder instead. Why not comma instead of |?
Use UserCoreConstants.DOMAIN_SEPARATOR
Correct, we don't want to the offer cycle to control or be impacted by the need of the seed manager to refresh it's info.
getClients(this, null, null)
make the constructor package private instead of private to avoid going through a generated synthetic constructor.
checking for nullable parent was added specially, cause going into project node simply has no meaning
Can we check first for the directory and afterwards try to load the class? There is no need to load the class, if nothing needs to be done.
use System.getProperty("line.separator") instead of \n
the 10000 looks like a wrong digit.
What's the purpose of "getClass().getSimpleName()"?
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
Apparently this method returns false when the wait time is exceeded. The old implementation was just buggy. It completed the future anyway and lied to the caller the indexing was done. The new implementation avoids this, but makes the caller potentially wait 2x the timeout. When waitForGeneration returns false the method should throw TimeoutException.
Maybe its just me, but this calculation looks wrong, since we are assign a = b, then b = a % b will always be 0, since a = b. Shouldn't it be: long c = b; b = a % b; a = c;
exception does not need to be caught.
Is addToResponseBody() being used from within any other method? Like why have this method at all? Alternatively, why do this single check within write() when you do other checks within addToResponseBody()?
Also check [this](<LINK_0>, you should deep copy instead of clone in setters
this view is using the same context. what about if you use the context from itemView.getContext() instead of passing a new parameter?
Nit-pick: like in HostNetworkInterfaceBondedListViewItem.java, the typecast could be inlined here.
You should probably call super.dispose() here too
@rui-castro can we inline this variable?
Should close kill the memspace? What if someone want to reopen the key?
Not sure, why not use @NotNull?
Lets use isRebalanceEnabled from kernal
Args.notNull
Something wrong is here: ![wrong_object_to_remove](<LINK_0> this.inUseConsumerChannels.remove(consumer.getChannel()); ?
these setters should not be public
suggestion this.converter = Objects.requireNonNull(converter, "The converter cannot be null");
why are we changing the visibility of these methods?
if mockTime was incremented by exactly the time required to trigger the operation timed out error, why would we need a loop?
The constructor should be made protected so that users can easily make a wrapper for it.
This line of code, view.getOverlay().add(this); is repeated in every single HighlightDrawable. For symmetry with ViewHighlightOverlaysJellybeanMR2.removeHighlight(), why not just put this into the ViewHighlightOverlaysJellybeanMR2.highlightView() method?
No logging here? Why?
I see what you meant but that's a very confusing name since the collection holds VdsmVms
You can use ExpressionUtils.methodName(mit) for that.
Is it okay to call this in the main thread?
return (e.getScriptStackTrace().isEmpty() ? null : e.getScriptStackTrace();
should we have Objects.requireNonNull in these?
Mmm actually I spoke too fast, it still fails on the command line...
Should use parameterized logging instead of string concatenation.
Looking at these 3 methods, I don't see why they need to be synchronized. All the state appears to be in method-scope.
\s+
This function no longer needs to be protected. It should be private.
Shouldn't this be wrapped in a try... finally block?
I don't think we want to automatically announce support for spoiler messages. The XEP is pretty clear that if a spoiler message is received the content must only be displayed upon user's request. But this can not, or only with to much effort, be guranteed on the library level. I think we should remove the automatic announcement of spoiler messages and instead provide a method the user explicitly has to invoke in order to announce support for spoiler messages. As beneficial result, the whole automatic manager initialization boilerplate code can go away
@Happy-Neko Let's call this from, [avoid compound names](<LINK_0>
I assume we should have the same behavior as ExportVmCommand. Do we still need this?
replace with: Mono.when()
So before this change, it would make sense to return the reference to the stopped service, since it wasn't part of the API that we supported re-initializing the ErraiService. But if we are going to allow that, maybe we should be checking isInitialized() here, instead of just service != null?
modLog might be null here
Should this be put in the try block so that the exceptions it throws are wrapped?
This is cleaner: return (student != null) && (student.googleId != null) && (!student.googleId.isEmpty())
misspelled
We could probably just pass the existing ImmutableTimestampSupplier to the Scrubber - it feels awkward for this class to implement Supplier.
add null information
This is breaking the pre 2.9 tests. We could just check that the string matches up to the \n.
this code snippet is the same in all of these tests. Have you thought about just making a new CassandraContainers rule which wraps the Containers rule and just contains a CassandraKeyValueServiceImpl?
That is true but you aren't storing or using the blobOutput here right? So why do the getBlobOutput() call?
Should close kill the memspace? What if someone want to reopen the key?
The aforementioned "never return null" rule would be good for all the string getters here.
I believe this method should be private
Should we call clear + setCapacity instead, to reuse objects when data is kept serialized? (I guess that's the case when this problem popped up)
It shouldn't be public
\s+
It should throw exception
these setters should not be public
just return "" instead of new String()
This should really not be public.
should scan be closed too?
Great tests. I'd suggest using nio (Files.copy and Paths), rather than bringing in the dependency in the org.codehaus.plexus util, that is available now, but is not listed explicitly in the project dependencies. For simple things like these it's almost always better to use standard java library stuff in tests.
I prefer to leave this as package-private to avoid a synthetic accessor.
hash = mLocation.hashCode() + 5 * mMessageId + 7 * mSerialNumber;
before accessing it's property, wait for element
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
That's a lot of nested ifs, can we simplify?
java if (next == null) { return fromIterator.next(); } else { final TYPE result = next; next = null; return result; }  I find this better to read.
You'd probably dispose your stuff, and call super.dispose() at the end.
For me it looks very strange that for initialising collections we use two different approaches within 5-line method :) (Guava and java.util.Collections) I would prefer to have homogenous approach (at least within the same method) doesn't really matter which one.
We should use other method, this ends up creating an AccessControlScannerThread unnecessarily.
Seems like we could use the check here too?
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
I think that may have been an oversight in longSum. Try a query that results in +Infinity at the historical level and you will see why it is needed to deserialize at the broker level
use return ... ? ... : ...?
Also this should be Log.d
@ILikeToNguyen Why the change in visibility here?
You change some methods signatures/arguments into _*NameCount*_ but these methods still containing _Segments_ wording
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
Perhaps you fix this in a later commit elsewhere, but there shouldn't be a setter here as this object is no longer immutable.
This test case in error-prone. Both the first and the second statement may cause an AssertionError. Try using try-catch instead. This may help us to determine that the AssetionError is thrown from the second statement.
can we plesae use specific exceptions here ?
use 'L'
add sandbox
So all HashFunctionPartitioners are equal to each other? What about the 3 different variables? Also the hashCode is broken as that uses 2 of the fields :(
Let's checkNonNull() the params of the builder, which must not be null.
change variable to something more meaningful
what .... synchronized access to the VoltDB instance not cool. it has transaction performance impact if you want to initialize without invoking the full thing we can do that without having to resource to this
So, you should look into something called Bindings because they are exactly what you need here. Essentially you specify a method that is run every time the UI wants to know what value to display. In your case it would look something like java uiTitle.bindText( new ReadOnlyBinding<String>() { @Override public String get() { return title } } );  And you would do similar for the subtitle
This class is still beta--I would be OK just making this method non-static and using the registry
Although bound() may be the "better-named" method to call here, it involves two operations (a set and a get). Since this method does not actually read/use the return value of bound(), maybe setContext() is still a better choice (more efficient anyway) ? If the return value of bound() was assigned to a local variable and compared to invocation.getInvocationContext() (to confirm the context was bound as expected to the ThreadLocal) it might be a different scenario. Maybe an additional method with a similar naming convention:  public static void bind(ActionContext actionContext) { ActionContext.setContext(actionContext); }  could be a compromise (named to indicate an attempt to bind, which does not provide a return value to confirm it was actually bound as expected) ?
new ArrayList<>(Arrays.asList( should just be Arrays.asList(. you may have to do a Ctrl F and replace all.
If shouldSchedule() and shouldRun() are overridden, the if is not necessary here.
Why not public access?
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
I this refactoring, very nice. Could make this method protected.
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
Shouldnt this be <= ? Is it possible you haven't pulled latest changes? I think this was changed to < 2_12_0 but <= 2_11_0 would be equivalent (and maintain the appropriate value of MAXIMUM_SUPPORTED_VERSION)
Same question as above
Maybe make it protected instead?
adding an extra pair of around endTime - startTime would be nice for those of us who never memorized arithmetic operator precedence, like me :)
Perhaps I'm being daft, is this condition backwards? Why set 'played' to false when position is greater than 0? Should it be setting 'new' to false?
M-m-m. Can't we simplify the life for Jackson and for client afterward and return null here if properties is empty? I'm sure that we will add eventually more and more here, but there may be some cases when it is still empty.
Use InetAddress.getByAddress(byte[]) instead? byte[] addressBytes = { 0xff & hostAddress, (0xff & (hostAddress >> 8)), ... }; try { inetAddress = InetAddress.getByAddress(addressBytes); } catch(UnknownHostException e) { return null; }
Symmetry (throw)?
I would probably rename this as well to binarySearchTree because I find that clearer. That's just my preference though, feel free to leave it as it is if you prefer it that way :)
The same as with previous - make it final, don't check for null (reduce amount of lines)
StringPool.EMPTY instead
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
It should be success=%b
You don't need to return anything here, as it's unused.
make function synchronized. Res: done with syncronized block
Unnecessary log.
Please change this implementation to throw CloneNotSupportedException. This implementation would result in sharing references to the List field and the items in the list among clones. A deep copy approach like that used by the superclass would work, but it's not worth the effort. Thanks!
Recommend adding a link in the report to the LBA Wiki that explains what this error is and how to fix it. Maybe a link to general information about Validate Requirement Changes so that we could add other things as needed. An this would just be one of them.
IMHO it does not need to be public
There are two locks being acquired here that could cause contention. First executeWithinLock acquires a lock. Second the call to getOrCreateCachedConnections() may acquire another lock within the ConcurrentHashMap. Its possible that multiple locks from executeWithinLock will overlap with a single lock inside the ConcurrentHashMap which can unnecessarily block threads. I think this can be avoided by accessing the concurrent hash map outside of  executeWithinLock. I think this is safe as long as keys are never removed from the concurrent hash map (which seems to be the case currently, and was the case before this change). I think this code could be written as follows, which would acquire the locks independently. java CachedConnection reserveAny(final ThriftTransportKey key) { // avoid aquiring concurrent hash map lock within executeWithinLock var cachedConns = getOrCreateCachedConnections(key); return executeWithinLock(key, () -> cachedConns.reserveAny()); }
suggestion return Collections.singletonList(MagicThingActionsService.class);
I think we shouldn't allow it to be null. This should be @NonNull, same goes for field value as well.
"isSearching" should be a class level string
please fix the whitespace. You just need to return the options here.
We might use a NavigableSet instead if a TreeSet is used, I assume.
@erdemedeiros we should stick to only tasks that we as an authenticated users can see. That is what the default findAllByWebQuerydsl() should do. We should add the check in the getTaskById() method to make sure that the user making the request is allowed to see the task. Does it make sense?
this.heliosDeployment is never used outside of this constructor, it doesn't need to be a field.
As we talked about offline, you can use <LINK_0> to create a separate buffer for each thread.
Again, this could be written more concisely:  public boolean equals(Object other) { if ( other == this ) return true; if ( other instanceof JcrResourceAdapter ) return true; return false; }
hmmok, might as well do it right, I'll push another version in a few
consider merging both lines
Should we enforce the "only settable once, before catalog is loaded"?
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
This is a bitwise OR ... shouldn't this be a boolean OR (||)?
good practice: usually actions go before WS as they are injected into it and so they are grouped together
This can be simplified to return this.cmd.hasOption(optionName));
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
This will most likely blow up when running within Wildfly since Wildfly does not use DefaulCacheManager implementation directly AFAIK. They implement a delegating cache manager AFAIK. I really don't see the need for a removeCacheLocally method at all. Can't you create a private method in this command, get the component registry from the cache manager, which can be injected, and in the private method do everything you do in removeCacheLocally? If the method needs to be accessible from multiple places, add it to a util class as static method passing in all the parameters needed?
why not use super? like: return String.format("%s, volumeId=%s", super.toString(), diskImage.getId())
why not call the new method with null as third parameter?
Response is never closed
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
Can we log ex.getLocalizedMessage() here
not so readable. looks like good candidates for parametrization
better to have fail(); in the onSuccess()?
I'd like to see the code further simplified if possible please. If calling Thread.interrupt() on an already interrupted thread is a no-op, then I'd suggest the following instead...  if (exception != null && !currentThread().equals(testThread)) { testThread.interrupt(); }  ...and remove the testThreadInterrupted field and the separate interruptTestThread() method. Note: this is common practice to move the possibly-null variable to the argument of equals so that a null value returns false for equals without requiring the extra != null check. For example: "nonNullString".equals(nullableString) instead of nullableString != null && nullableString.equals("nonNullString") Note: also common practice to put the cheap-check first in an if condition: if (exception != null && !currentThread().equals(testThread)) ... instead of if (!currentThread().equals(testThread) && exception != null) ...
why not list.stream().forEach?
You can make use of early returns here to reduce nesting, e.g. java if (userInfo.isAdmin) { return; } if (!userInfo.isInstructor) { throw new UnauthorizedAccessException(...); } // everything else
Is it really filter name?
Use the caching util as I mentioned before.
This should return T.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Missing super() call?
There is no harm in setting the confirmWindow to null, but since you are not actually setting it, there is no need to set it to null.
I don't think we need to observe on any particular thread
You're not checking the mediatype here. At this point, do we just have to assume that jax-rs has called the above method and is giving us something sensible?
remote this
This will only work if Jenkins is running on the same host as the docker daemon. It won't work in the general case where Jenkins is on a separate host from the docker hosts/swarms that it's talking to.
Probably returned value can be long.
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
ewwww, abusing try/catch for this is really unideal... We have a Pattern for Numerics you know?
This should be Repository.class. The method is supposed to return the list of adapterTypes, i.e., the types to which this adapter can adapt objects to.
Use java.util.Objects.equals().
Is Error the right exception type? /cc @yloiseau
equals!
Let's remove this? overcomplicates the code
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
I would prefer to use String.valueOf(value)
This should use the GitRepositoryManager.REF_CONFIG constant. I'll fix during cherry-pick when I submit this topic, thanks.
null? why not just a () -> {} ?
Eclipse is warning that the argument r is unused. I guess this should be changed to r?
Could probably replace these hasSize+contains calls with containsExactly, but nbd, this is what the existing code had.
Might as well synchronize, unless this is being called somewhere safe that I missed.
Please move to a separate "Polishing" PR.
Shouldn't this be HttpCustomHeaderClient , not HttpClient?
Class should extend AbstractPathTestSupport and directory path should only be defined in getPath.
Maybe make this "Initializing monitor for..." to distinguish between the init() and configure() method below.
n["+fTimeArray.length+"]("+min()+'\u2025'+max()+')';
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
StringBuilder
@manstis can this synchronized be removed? this method is only calling the defineClass overload which is already sync'ed.
\>= ?
These two assertions should probably be their own tests, testNullPath and testNullPathWithRoot respectively.
Newline between @Test and public. There's only 4 instances like this in the libcore source, hundreds with it on its own line.
finally?
I really feel like there should be a descriptor in the name, e.g. getQueueUrl(), getBlobUrl, etc. Thoughts?
This is a breaking change, since it no longer invokes the filters in reverse order. So please revert this.
Should be a SamzaException with a message, not NPE.
I am guessing your builder needs to have isShared and isAudited set to default values (false) here. Also based on this: <LINK_0> Please add the corresponding docs for the properties here and in other places as applicable.
optional: This message doesn't look so great --- isn't it a valid ref name, but just a missing ref? We can avoid the test being too prescriptive by making the matching less exact (e.g. by checking that the message contains the ref name). Alternatively, a followup change could improve the message.
nit: Do we use caps in other places? We should be consistent with values we expect users to replace.
catch IOException and rethrow to avoid wrapping an IOException with an IOException
nit: space between if and (
Don't this is a good idea to use toString() for equality, since we may modify toString() to include the hashCode and now we are screwed. Introduce an asString() method or toURI() with a clear semantic and use those.
You can call this.setTimestamp(timestamp) from here.
Is this necessary? If I remove the update line everything seems still to work.
can this be an immutable copy of the collection?
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
Alternatively you can do: Arrays.hashCode(new Object[]{command, spec});
Shouldn't a cast to int be enough?
must be package local
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
That is evil, that will remove the original stacktrace. Please *never* do this, because it makes debugging *so much* harder.
Throw a NullPointerException if address value is null. Can any byte array be provided or should establish a concrete length or a min/max length?
should this be: Math.min(baseRetryTimeoutMillis, capRetryTimeoutMillis)
I think we just want the name and not the email in the message. But username is always null to us (for example), you need the DisplayName.
In practice, nobody with deep knowledge of EMF uses interface EClasses, but we are technically susceptible to letting them slip through here.
does it make sense to put the name / ARN of the task definition to the log? Otherwise this log message might be very unclear, as people do not know what it relates to
Shouldn't it rather throw an UnsupportedOperationException? Alternatively, it could return new ByteArrayInputStream(buffer).
Use equals - there is no guarantee that it's the same Guid instance.
if tags are displayed in a list, better use onData to get hold of it
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
All of these early returns you do like this need to be switched to if (!=null)'s 1) it's cleaner and 2) it makes code easier to understand and 3) it makes future expansion easier without need to refactor these two lines. Not to mention all you single line ifs need to be converted into two lined one minus the braces.
throw UncheckedIOException(e)?
please make sure you are rebased. this method was renamed on Feb 11.
++ is not thread-safe, so connectionCounter would need to be changed to an AtomicInteger.
Cant it loop?
This doesn't seem right... wouldn't this result in the file's path being the file path of the parent directory (and hence overwriting that directory)?
these 3 methods are public do you really need them?
java this.fileSystem = requireNonNull(environment, "requireNonNull is null").getFileSystem(EMPTY_CONTEXT, baseLocation);
use return ... ? ... : ...?
Same issue here, double delete user.
I think you will find that there are 1000000L nanoseconds in a millisecond and not 1000L as you suspect
This shouldn't be needed as StatementClient.close() should be idempotent
We can use bit-operators here to test for the bits in the permission bitmask :) Executable is 0b001 = 1 Writable is 0b010 = 2 Readable is 0b100 = 4 So we can replace this with: java return permission & 4;
reduce to debug
doesn't seem right, should be something like "{\"foo\":0,\"additionalPropertyExampleKey\":{\"bar\":0}}}"
this param is unnecessary
I meant, we don't need a separate method. Lets do the things in power.
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
What type of view will TIMEX3 be? Right now, it is of type NULL. Move the case to the block that contains the correct view type.
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
Apply try catch to this line only
Why not just do this instead: return obj instanceof DueDateAmountMap && innerMap.equals(obj);
Each instance of UniqueId [has an internal counter called seq](<LINK_0> that increments when an id is generated and that resets each millisecond. id0 and id1 will be equal when both getId calls fall within the same millisecond. This is because both instances of UniqueId have their seq counter set to 0.
Should probably do nothing, not even trigger the initialization, if we are not already initialized (in this case there is no cleanup to do).
Log using a java.util.logging.Logger at the warning level and swallow. There's nothing sensible to be done on the way out.
This can simply return NON_APPLICATION and isApplicationType() can be removed. The methods will always return false.
Don't you need a super.setUp() call here?
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
use return ... ? ... : ...?
I'd recommend to add process id to the name as well as there might be tasks with same name in different processes but still in the same kjar
Restore to original. Also apply to the other similar throws.
Is it really safe to cast to Table here? What if left or right is a sub query?
I would prefer constant there.
Don't need to return the Arguments.
Add SubChild here as well, perhaps SubChild is just persisted as a Child currently..
By using the above naming convention, we no longer need to use this. to disambiguate which variable that we're referencing.
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
Don't need to return the Arguments.
Add message to new RuntimeException
Although we need to figure out how to propagate interruptions, this will now cause a problem as it this method is called from within tryUpdate which is recursive and propagating here means the next attempts will also fail for the same reasons. We need to figure out how to retain the fact that we were interrupted and propagate the interruptions outside the whole thing.
this method deserves a description
First, this function is never used, and second, the return value would be a summary string of the ByteBuffer. It would cause a problem for getJavaString since it can't be parsed as some value, and also for the ConstantExpression constructor since we're expecting a direct value like in a JSON string. I think an UnsupportedOperationException makes more sense if you don't really want to output all the bytes as string.
And then else if this
Unrelated to this patch. Again this is a good change, but it adds diff noise.
Can we have an order group without an encounter?
return defaultFilterFactorEnabled ?
use hasNext instead of contains (do not use toIterable() we want to check Iterator)
This commit appears to duplicate changes from the #430. Is this intentional? Which branch do these changes belong on? They should only be on one or the other. Please amend one of the branches to fix this.
you should add isAfterOrEqual and so on
Given the other changes, I wonder if the handler is needed at all or whether just need a way to disable it. If keeping it, I wonder if onReceived(Map<String, Object>) and onProcess(Map<String, Object>), and then all _received_timestamp and highWatermark logic could move into the handler.
Can we use empty map instead ?
I think it would be better to use a new CP subsystem specific executor, instead of ASYNC_EXECUTOR.
And get in the end to check that there is nothing in the collection on the matter.
do we need to unvoid..?
Can we switch this to assertj?  assertThat(users).extracting("id").contains(1, 2); assertThat(users).extracting("name").contains("Alice", "Bob");
Do we need this?
I would add a check here: if the ID contains the suffix, throw an IllegalStateException or InvalidParameterException, otherwise, there's a chance that you'll have an ID like abc-client-client, which is never appropriate.
Shouldn't we change memory reservation here?
remove "?true:false". It is unnecessary
Newline between @Test and public. There's only 4 instances like this in the libcore source, hundreds with it on its own line.
@mswiderski if you want you could prevent a NPE by creating a new Set in case you're passed a null one. Also I think that it could be a good idea to declare the Set classes final.
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
return new StringBuilder().append()....toString();
This empty is unnecessary, I believe :)
What is the reason for appending 1 to the variable name?
should hashCode really depend either on taskName, or description, or hashCode?
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
Catching an Exception and just rethrowing it as-is is equivalent to not catching it at all. So the implementation of this method should be just target.stop();, with no exception management at all (much simpler!).
This is three minutes. An since FAT is two seconds we require only larger than two seconds. On many file systems that is three seconds, but 2.001 would do. With a Unit test you would have found this out. Do we break anything because the ObjectDirectory had two /minutes/ as fudge?
put proper String's here :)
I'm not sure if we should add this to the interface. Not all implementations need to generate data ids in this method. How about removing this and instead throwing a RuntimeException at the implementations that use DataIdFactory?
I thought you wanted to end this practice, Adrian?
Any particular reason that you published an EventStatus instead of publishing an EventOutput directly? Remember that pumpEvent exists.
Making only this message a constant only makes it less readable, and is essentially meaningless. It's a good idea to undo the fix or standardize the argument checking.
Check for equality of error code
What do you think about recording the time here instead of having a boolean? Then that could be used to determine how long to wait for the task.
the write call might throw an exception which results in close not being called.
Optional
You probably want to disable some view components in the event of a failure!?
nicer to have a method IncrementableEntryVersion.incrementVersion()::IncrementableEntryVersion to take care of this. Would drop the not-so-nice instanceof.
Do we need the toString() here?
As setInstalledLineNumber, this should also set RESET_INSTALLED_LOCATION
You dont have to use VoltFile as this is for new cli only right?
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
Missing codes.
You want to use FormField.getFirstValue() here and everywhere below.
(minor) I would test the positive condition isEmpty() and swap the cases. It is less information for the human brain to process and ! can be overseen
I think each of these two constructors should provide examples of the querystring's they construct.
What about hashcode and equals, should they need to be regenerated with the new boolean
lowercase for package names.
nit: types is null
nit: types is null
closed.compareAndSet
The main purpose of this collection is for iteration, use a LinkedHashSet.
Seems doing all these potentially long-running operations as synchronized leaves a good chance for deadlock. Not sure how waitUntilAllOperationsAreDone ever completes if it's not empty, since you wouldn't be able to call operationComplete(), no?
l10n
Is this a reason to have separate if statement instead of while (!shutdown)?
It's not public, it can be changed. We need to have it backward compatible for one minor version. If this is to be released as 3.9.4-c1, MC 3.9.x and MC 3.10.x needs to be able to work with this. You can add extra fields which we will use in an upcoming MC 3.10.x release. Removing the field needs to be delayed until HZ 3.11 where we can adjust the codebase to not expect the field.
java String desanitizedCourseName1 = SanitizationHelper.desanitizeIfHtmlSanitized(obj1.course.getName()); String desanitizedCourseName2 = SanitizationHelper.desanitizeIfHtmlSanitized(obj2.course.getName()); return desanitizedCourseName1.compareTo(desanitizedCourseName2);
bad name of method <LINK_0>
You can optimise the execution if this method, due to you are accesing twice to metadatas.get(i), when you can assign to a local variable to access to it previously to the execution of the if sentence.
consider renaming this to detectLanguageBatchWithResponse to be consistent
it doesn't work for multi reference + complete tests please.
what else? any warning or exception should be there?
Is this still needed? We don't add any other elements, so parent.get(anythingElse) should return null anyway.
now that we have some permissions in common in ImportVmCommand and ImportVmFromExternalProviderCommand, we should probably move the code that currently exists in ImportVmCommandBase#getPermissionCheckSubjects to ImportVmCommand and have the permission check on the destination cluster only in ImportVmCommandBase as it is common to all import commands, what do you think?
Why is this required? The test you wrote fails when I don't apply the change on PrimitiveType, but doesn't fail if I don't apply this.
if there are errors at this point, an exception needs to be thrown. This will just ignore the errors, which will cause a confusing error later in transform. call context.getFailureCollector().getOrThrowException() after this line.
You can set the label test in the ui binder file for both versionLabel and userNameLabel now.
I think isDisposed should also be checked here, right?
Should we log this to TRACE at least? Just in case we need to see this happening? As long as any formatting happens in varargs / parameters, we can avoid the cost of formatting a string in case TRACE is turned off.
Why does start() effectively do nothing?
Should we put the check here too?
Can we throw an exception instead?
I don't think copy is required here. Even if we did this for immutability, we'll have to do this again in getter methods which we are currently not doing. So, just copying here isn't useful.
Also too many dots
this does seem to cover some people who might have a legit reason. but some do "gc/runFinalization/gc".
Yeah this should be return set.get();
Same code as in CompletionTest. Consider pulling that out into a static util method.
Can be made package local
I think we have to make as BlockingQueue and use its poll(timeout) to block the testing thread for the message from the async internals. There is no guarantee that all tests are going to be direct and sync. WDYT?
return true? no need to inform the user he sent wrong vm (vm doesnt exist), or other issues?
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
In this impl, JobCoordinator is responsible for the life cycle of containerController. If we add awaitStart(0 inside JC, then there is no reason why StreamProcessor needs to know about containerController anymore. Can we make this cleaner?
You can use assertTrue and assertFalse instead of assertEquals for these tests :)
suggestion Objects.equals(value, other.value);
public isn't needed
@olenagerasimova it should be appendText(this.text(item)), this.itext may point to wrong value, if text(item) != this.itext
let's make it private for no
I would suggest making this method synchronized
The ListenerList implementation already takes care of this. Remove the "contains" test.
I would not use setCleanIdleConnections as the name of the function without parmeters. Maybe add a parameter.
negative logic
use Long.valueOf() instead of new Long() - always for performance reasons
could we use a descriptive value instead of empty string to denote the header was null?
Add SubChild here as well, perhaps SubChild is just persisted as a Child currently..
When pressing the remove button, the directory is not removed. In my case it was the last directory.
Can you reduce the nesting depth here?
Use Assert.fail() instead
perhaps if not has permission?
I know this is just test class, but this is what Optinal.empty() is for - avoiding necessity to sometimes use null ;-)
do "getEntity(id);" here to throw 404 if this is not existent entity
Shouldn't this test keep initial @Deployment annotation here, so it keeps using the same process definition as before?
Sorry but I did not find where we call the close method?
These two lines probably can be combined into one.
Here we could try to store the ObjectMapper in a static field - preferably in a package protected helper class. This way we would avoid that we recreate it again and again. And as far as I can see this should be thread safe too. What do you think about it?
I remember some discussion for coming up with this logic of selecting cards randomly. Have you decided to remove that?
@dmzaytsev Now we can incorporate this into the string above - no need for Matchers.allOf  java Matchers.containsString( "Set-Cookie: foo=urn%3Atest%3A99;Path=/;HttpsOnly" )
Why not check isEmpty()?
I presume this was to avoid log noise. Why change? If your intention is to alert the user of the problem, it would be better to log rather than the task executor printing the stack trace.
@pefernan here the message should be: logger.warn("Unable to parse value of " + KieServerConstants.KIE_SERVER_MODE + " = " + modeParam + "; supported values are 'DEVELOPMENT' or 'PRODUCTION'. Falling back to 'DEVELOPMENT' mode.");
nit: you can merge both lines above as checkNotNull will return the given argument
I think LinkedTransferQueue would be better.
same here (using getNode)
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
I'm guessing merge/rebase error. RequestManager method was the correct source for this. Controllers shouldn't require database knowledge (jdbc/table names)
This will loop forever if the user sets a negative size.
What is this for? Feels like some unintended checked in code?
style nit: we don't use braces around single line blocks
usually data objects never return null where collections is met
use return ... ? ... : ...?
You can define private static final int DEFAULT_WORKER_COUNT = 4..
We're on Java 8, so: IntStream.range(start, start+length).toArray()
I think these methods should throw exceptions (might need to create one). They can't return false, and having the impl throw IllegalStateException on any failure doesn't feel right.
I believe it would be more understandable to do the following:  // Throws a GitLabApiException if format is invalid format = checkFormat(format); Form formData = new GitLabApiForm().withParam("sha", sha); Response response = getWithAccepts(Response.Status.OK, formData.asMap(), MediaType.MEDIA_TYPE_WILDCARD, "projects", projectId, "repository", "archive", ".", format);
Override
Should this try to create a URI with the old logic when it's null for retro compatibility ?
This is effectively your synchronization barrier? After fetch(...) returns, you are guaranteed that the value will be populated in the cache, assuming the writer is utilizing the same cache. Am I understanding this correctly?
typo?
Help me understand why lazySet is safe to use here. It seems we want to have visibility of this value when we next read, but my understanding of lazySet is that it does not guarantee that.
Can we change this line to this(0) and remove the if (port == -1) in the other constructor?
usually data objects never return null where collections is met
+ desc
redundant ";" character
Don't you want to do different things depending on whether it is the default or full representation as we do for other resources?
Does TYPICAL_LOG_MESSAGE need to be a local variable? You can hard-code /typicalLogMessage.json here if only used once.
Should be a space after ,.
This looks very nice! What about adding a throws JSONException to the signature of getValueForOptionalKey() and parseImageLicenseMetadata() since you have the needed try / catch already in place for processPage()?
public seems not required
This method should be protected and most likely use the updater instead of direct field access.
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
remove the explicit initialization?
Might as well synchronize, unless this is being called somewhere safe that I missed.
Did you want to use FRAGMENT_INDEX_KEY instead of key local?
Avoid logic in this class. This is inconsistent with other collection fields. You can't do an update with this field set to null. Also, why a tree set?
The first object in the database may not necessarily have an id of 1. I think a better implementation would do a find with an order by ascending id and limit the query to a single item.
Why do you we need to keep a reference to the activity here? This will leak the app. We should use mEditState array instead.
Rollback should be done after each test case (i.e., with an @After notation, not an @AfterClass notataion), and I think we should preserve the current behavior od tearDownTestCase(). I suggest creating a new tearDown() method for performing the rollback.
Is this double invocation performed on purpose?
Probably enough to have Longs.hashCode(pointer) which should be a little faster.
return only if the provider is an AnalysisModule?
So there's a bit of a elegant hack to doing this: You can redirect to do the same as the original method, and then override this injection method in VillagerEntityMixin to do all this logic that otherwise you'd be doing. I do this with WorldMixin_Tracker and ServerWorldMixin_Tracker to do extra logic only on server worlds for injections that are in the subclass.
Shouldn't this close the iterator before returning the list?
please remove else, code will be more readable
Consolidate this method with its coordinateStringsFromQuery implementation method.
Work is generic, so add <?> at least
not related to this PR but wondering if returning null or an Optional.empty() in case of corrupted data shouldn't be better.
I will be nice to have more meaningful error message. E.g. "Text condition must not be empty string." or smth else which explain the problem with comparing actual text and the empty string.
The this. in getters are unnecessary too.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
this method deserves a description
Please keep this.cell near the related fields (previousFamily & cell count) below
What is purpose of this method?
can this be readSafely instead of readBuffer so that read uses readSafely
suggestion bannedColumns.add(COL_ID_ACTIONS);
I'd recommend to add process id to the name as well as there might be tasks with same name in different processes but still in the same kjar
s.name().equals(state) would be better
This is another behavioral change that I don't want to see in an unrelated PR.
String.format
could metric == null?
Now that looking for this method, let's change the log messages a bit Let's have instead these two log messages logger.info("Skipping file: {} ", source); <- remains unchanged logger.info("Not skipping file: {} ", source); <- just before the return false and let's drop the first looking into file...
This condition seems to be backwards. I think it should be index < array.length
considering having the complete exception logged, stacktrace too.
I think it's better to replace this(type, data, new ArrayList<ColumnDef.TYPE>().
May I suggest this?  int i = url.indexOf("/#/"); return i == -1 ? url : url.substring(0, i);  It only searches the string once, and more important, doesn't duplicate the search argument.
How about introducing EventClass.emptySet() so that it's easier to find places where return empty sets?
String.split?
extra space.
singular
It seems like == would be sufficient and faster than .equals() here since we'd be testing identity of the component rather than equality?
Throw an unsupported operation exception here.
this field name is confusing since the parameter passed to the constructor is a File but this is a PackFileName, maybe better packFileName
There is no need to call super explicitly. Same applies to other constructors.
recipeFileContentProvider param is missing in java doc. DevfileRecipeFormatException is not desribed in @throws section
perhaps if not has permission?
This test checks topic creation. Why do you call replyTopicStubs?
Can you remove this? OPENNLP-922 changes that in one style across all equals and hashCode implementations.
Maybe we should also deny requests while recovering after a shutdown
Using "/" directly is not portable. Java has a system method to get the directory/path separator character.
defensive copy?
use sparse array
Did you take a look at this? <LINK_0>
I would suggest not to lower the case, since it our own database ids are lowercase anyways.
Can simplify by dealing with the exceptional case first: if (!allowPushOptions) { // Reading push options without a prior setAllowPushOptions(true) // call doesn't make sense. throw new IllegalStateException(); } if (enabledCapabilities == null) { // Push options are not available until receive() has been called. throw new RequestNotYetReadException(); } if (pushOptions == null) { // The client doesn't support push options. Return null to distinguish // this from the case where the client declared support for push // options and sent an empty list of them. return null; } return Collections.unmodifiableList(pushOptions);
@ekondrashev Too much indentation for lines 61-64, move them back four spaces.
Is there a reason for post()ing this, instead of just executing it?
Wait, this is worse than the previous version. What happened to the assertEquals()?
shouldn't the test throw the exception, it will be marked as a failure too, with complete stack?
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
would we need the lock if we used a ConcurrentHashMap and LinkedinBlockingQueue?
return (id == null ? 0 : id.hashCode());
> I would rather use the first version and avoid the cast to M. Is that OK? Please cast (M) map.put(key, value). We save an additional Tuple instance which scales for many calls. I see our collections as low-level, they should be as performant as possible. A cast is fast.
Recommend to use ToStringBuilder
unneeded if clause
Instead of exporting this, I would simply replace the future usages with Optional.ofNullable(duration).map(Duration::toMillis).orElse(null)
Move this validation to PluginProfileService.
What is the purpose of catching this exception. If this thread is interrupted it sounds more like an IllegalState somehow?
The first three should be required.
Is it going to return null in case the request is not authenticated?
must be immutable :  if (null == this.map) { this.map = .. } else { throw new KasperException(..); }  if you can add this also on the CollectionQueryResult it would be really appreciated :)
could be made static
These methods don't need to be synchronized any more due to the ConcurrentHashMap and the use of atomic operations.
Use another name here. My suggestion is: Asset Options
if there is possibility of writabilityStates to be null, it might be better to write this as "".equals(writabilityStates)
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
Mb it is better to use common format for toString method? <LINK_0>
Request.State.OPEN
please move calculateScope(ast) inside expression to speedup a little bit performance, scope calculation is not always required.
@pynicolas Are you sure about this method name? As I understand, it does the opposite
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
Could use this::updatePartionInfo
if you never plan to add explicit method names here, it's safe to omit this method
I am concerned that this changes the behavior of the future returned from createNewListener where a callback could see a null value. Instead, how about we create a constant CancellationException and then setException(constant)? Would that give us the same benefit?
must be immutable :  if (null == this.map) { this.map = .. } else { throw new KasperException(..); }  if you can add this also on the CollectionQueryResult it would be really appreciated :)
I don't see why we need these sorts of constructors... We've never needed them before, and there's nothing special about the useLayerNormalization arg (it's just another boolean)... unless I'm missing something?
By composition, do we need this?
Does this need to be public? Please do not introduce new public members without cause.
No parens on condition.
same with the return code here, you could return a boolean to indicate success/failure. the user doesn't have to use it, but the API should provide this info. Res: Done, a return type of boolean to indicate success or not
delete() should be executed from within the future so it doesn't through right away.
any special characters to block in webhook name?
+/- 1 confusion: suggestion this.startDistance = start;  that was the last one.
Shouldn't this file name change too?
Perhaps nameToDataType.
Transaction is mandatory. What kind of error we show in case a transaction is not present? If it's not clear enough we can improve it. Anyway, this would be a separate issue
This method might be the one in public.
The constructors should be package private
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
wrong formatting - every parameter should be in new line
This is a breaking change.
It's not from the changes in this pull request, but to clean up a bit more, the superfluous super() call could be removed.
I don't think you want to call the super implementation, as you are handling capability registration conditionally.
If there is nothing to draw, what about just skipping the drawing and return 0?
nit: this is Optional.ofNullable(metricName.safeTags().get(ADMN.TAG_CURRENT_SUSPECTED_LEADER)).filter(x -> x.equals(String.valueOf(currentLeader)).isPresent(); though I'll leave this as personal preference
I think it's nicer to call the AnnotationCommandTargetResolver constructor here, with, as suggested earlier, this as the sole parameter, so that the AnnotationCommandTargetResolver constructor can pull the identifierAnnotation and versionAnnotation from it.
Can call the method directly, instead of using reflection. return FieldValidator.getPopulatedEmptyStringErrorMessage(...);
you added synchronized to the method here, wanted?
Please omit the version, you cannot know which version is being used. Although wrong, lets just assume that all MySQL versions do not support this.
Maybe its just me, but this calculation looks wrong, since we are assign a = b, then b = a % b will always be 0, since a = b. Shouldn't it be: long c = b; b = a % b; a = c;
bad hashcode.
nit: jut call super.setForceCloseTimeoutMillis(...) this will also ensure we do the correct thing if we ever change the super method content and will allow to make forceCloseTimeMillis private
!sizes.isEmpty()?
I'm not sure we need this. II would prefer to let the logic of collecting exceptions hidden in the visitor. Why not directly handling this case in the MethodInvocationVisitor then? You can perfectly give the symbol of the current methodTree as parameter of the MethodInvocationVisitor constructor, so you don't lose the info from where you are calling. At the end of the visit, you could then simply add thrown exception from the default super constructor, if super has not been called and it's really a constructor.
With set() and find() now bypassing Square and using Entity directly, should we have get() return List<Entity> ? That way the Square class won't have to be public, it'll be an implementation detail.
Please use a [StringBuilder](<LINK_0> instead.
Uh, IllegalStateException?
Please consider to add a log here (maybe warning) someting like : "connection " + connectionId + " has been removed from DB, no hosts were disconnected" Could be worth some scrubbing time
can't we do return (isValidGroup(groupName, cruiseConfig, result) && isAdminOfGroup(groupName, username, result))?
This isn't good, as you're now doing this parse every time we need to know the numeric value, which is very frequently. You should do what Srikanta proposed previously and have the int as well as the string values.
Please make the constructor private (see Invalid).
Should return a more meaningful exception
You could write less code and use google's joiner  java Joiner.on(',').appendTo(sb, args);
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
These <T>s don't occur anywhere in the method signature.
you could just do setConfirmWindow(null); like above method
can we avoid this null check and instantiate it on fields directly (+private constructor if we don't want to create it in any other way) - it's potential race condition if we need that for tests we could have it package scoped reset method
it'd be more robust to explicitly build the cache key, rather than embedding the toString of a List.
Is there a reason why this method throws InterruptedException?
Use Guava Streams.stream(myStream) instead of StreamSupport.stream(myStream.spliterator(), false)
I never did like these local caches in the models that Carlos introduced. :/ Besides, creating one of those is dirt cheap. I have no idea why he wanted a cache.
Shouldn't errorContainer.setVisibility(View.GONE) also takes care of notificationButtonView since it's a child of errorContainer (Not putting this for other use cases, but should get corrected for install and update as well if we do it here)
> DRONE_TARGET_DIRECTORY it means that the last update cache is stored in the target directory, right? I'm not sure if it is a good approach as every new run of the test suite will require a new request - I had expected it in the ~/.arquillian/drone directory. On the other hand, I have to agree that the probability that you would run out of the limited number of request is very low.... Why you've decided to put it into the target directory?
You shouldn't use 'Z'... it's just Z it is the flag for the timezone. 'Z' is UTC, but if I put +03:00 it's also valid ISO.
revert this unrelated formatting change
Also whitelist C
since this Bindings needs configuration through openhab.cfg setProperlyConfigured should be called after the configuration has been read and applied properly (see method updated()
Simplify it as " if (m_isLeader || isForLeader)"?
Again, perhaps I don't understand the Java API, but IIUC client.flush(...) is explicitly telling ES to flush all memory associated with an index to storage, and that ES tries to do this automatically. If we have to do this, then commit() is definitely the place to do it. But is it really required? Do we want to force a flush to get the durability of the write to disk?
Maybe I am confused, but this is changing from number of children to number of siblings? ast.getParent().getNumberOfChildren() != 1 to ast.hasNextSibling() || ast.getParent().getFirstChild() != ast I am not grasping the equality of this.
[Checkstyle] INFO: '200' is a magic number.
The removed bit is important! It needs to know if the dropdown is the focusedWidget (in other words, if it is the current selection by tabbing) in order to highlight the widget with yellow - that's what returning ACTIVE_MODE does. You can probably find another workaround to avoid using TabbingManager, but you need some way to tell if it's been tabbed to
Can be replaced with streams java List<CharSequence> titles = titleList.stream() .filter(titleProp -> fieldApprover.approve(titleProp.getDataInfo())) .map(StructuredProperty::getValue) .collect(Collectors.toList());
getAttribute returns null - add null check
Not sure, why not use @NotNull?
How does this work if the app image is loaded? Won't the test fail?
I think we will have to discuss whether or not to include the fromKafka functions in this class.
Need to verify no interactions with log
segmentStoreStatus
We need to close also this stream.
I think this will be called automatically.
"Unsupported operation type during GET"?
Value nor envVar wont be ever null, but empty strings, so that check will be valuable
Redundant, remove.
you can use instead: return Version.v3_5.less(version);
we need to reset this property in a @Before block
The types could be removed.
May as well use static final byte[] EMPTY = new byte[0]
Well, what happen then if user still use the deprecated method? we need to be backward compatible, right?
.split("[,]") and trim() to support multiple interfaces within single extension, please. return List<String>
checking for nullable parent was added specially, cause going into project node simply has no meaning
Why do we return the parents name instead of the name we store a few lines above?
I'd suggest looking at the block below this as well, since it drops the entity two blocks down.
I would suggest You to use Logy.d here instead, as we did it [here](<LINK_0>
Arrays.singleton()?
nit: combine with assignment this.strategy = requireNonNull(strategy, "strategy is null");
It seems like we would be better off making this actually return the path instead of a String. It's different than the old API, but I'm not sure I see the use of getting a string back.
I believe it should be replaced with produceCalled = false. Could you modify your pull request? Thanks for noticing!
disable table has some validity checks, should this?
isn't this the same bug that you had before, that headset wasn't working while app was minimized ?
suggestion return new ArrayList<>(List.of(units));  I assume the list must be mutable?
normally we use italic text for info icons like this: numaInfoIcon.setText(applicationTemplates.italicText(message));
updateAvialability() calls -> updateAvailability(SystemTreeItemType.System, null); Since the reports init is no longer blocking the ui there is no guarantee the system tree selected item is the 'System'. Calling updateAvialability() will update all the tabs (not just the reports) as if the system is selected. In my opinion, you should extract a method in CommonModel to update just the reports availability and call in from here.
Could be inlined here by using test()
Step type would be StepEnum.REBALANCING_VOLUME;
why do we need to make this method final and none of the others?
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
You've added a bunch of methods in between the two overloaded versions of initializeAppResources. Please move the initializeAppResources definitions next to each other, it will make the code easier to read.
Hmm, is there a builtin method for generating MW titles?
This evaluates different value that it stays isLeftTurn will return true, in case it is slight left turn
we could replace this with this(ID, description, Integer.MAX_VALUE);
@marchof I'd prefer to name local variable invisibleAnnotations or even better runtimeInvisibleAnnotations instead of just list
return !requestType.equals(RequestTypeUpLog);
This does not need to be public. Instead, just pass the builder to the private constructor. See what we do in HtmlRenderer.
Should we prevent setting the executor while the connector is running? Otherwise we get concurrency issues with hasInternalExecutor flag. Is it even necessary to have this setter instead of setting it in the constructor? Then we could make the executor field even final. atm we are accessing the executor from different threads without appropriate locking or making it volatile.
> return new String[] { resource + "/.default" }; [](start = 7, length = 48) Should this use the DEFAULT_SUFFIX constant above?
How about "Type is not supported"?
No, that was temporary for testing. It needs to be replaced with a check to see if it should actually send an update message yet (the status of any of the LED's has changed)
Why not make the test timezone-independent by either calculating the correct long value for "00:00:00" based on local time, or changing the timezone of TmfTimestampFormat.getDefaulTimeFormat() to GMT in the test case.
In general, all injection constructors should be package private.
Not that it makes a difference in practice, but the pattern we usually show in the docs is CqlSession.builder().build().
I am really doubting about this call to super: What about something like :  return new Foo() { //some stuff closing };  The new ClassTree will be checked twice, once with the override of visitNewClass (via the call to super) and once with the checkUsageOfCloseable of the expression of the return statement.
Just "Kafka".
Seeing that the 'Edit Button' patch is already in master, I'd suggest rebasing this patch on top of master to avoid any possible merge conflicts.
It might be slightly less effective, but it's better to delegate to PartitionIdSet.remove here, so ImmutablePartitionIdSet iterator will be immutable as well.
else is not needed. Remove it and you can dedent the block below.
do we care to check the length to be positive here?
Why deprecate this? Seems like it would still be a useful method, no?
I think "$exists operator requires operand to be either true or false" a better error message.
we could use reduce instead of fold, like:  java return Stream.rangeClosed(1, n) .map(BigInteger::valueOf) .reduce(BigInteger::multiply);
Would be cool if we could find a way to run regular and fast inserts in a single run so that both code branches are executed. Any thoughts on how we could pull that off?
nit: combine with assignment this.strategy = requireNonNull(strategy, "strategy is null");
nit: you can merge both lines above as checkNotNull will return the given argument
I think we will have to discuss whether or not to include the fromKafka functions in this class.
If you just retain the below line, the API contract for createInstance can be regular:  UserDTO user = userEntity == null ? null : UserDTO.createInstance(userEntity);
move this setter on top of methods. then should be all getXXXxxxToken then should be beginTree
We could call: java checkNotNull("command", command);  :-)
API breakage errors. You should declare another method and mark for deprecation this one.
I think only one impassable entity should be allowed on a Square. Exception otherwise.
suggestion this.className = requireNonNull(className);
can be !isDisabled()
I think you should pass the numCompletedIterations to the last parameter of LOG.log().
Avoid the intermediate variable and directly assign selfID.
The streams created are T1 and T3, but the ones added here are T1 and T2. Something is not right?
Shouldn't options be Immutable?
import or create (considering we may not use the imported configuration)? there was a good patch by Liron [1] where he called that handleVmLease. not that important though [1] <LINK_0>
s/id/ID
This should not be static. The choice of whether to use BMX should be per apache server, not per agent.
I don't see much point in making db lazily created. It's not an expensive operation.
I this refactoring, very nice. Could make this method protected.
This could be considered a strange implementation of MVP; as your P is calling V.init(..) which then calls V.setup() which then calls the P to call the V to setup some UI elements. Why not have P call perform the complete setup rather than have the V call the P to call the V to complete setup? Or did I miss something?
This is a test so probably not an issue, but please re-interrupt (Thread.currentThread().interrupt()) or use Awaitility if it's available?
Please, always use braces, even for one-liners. Could you please change this across your pull?
Doesn't Datanucleus advise against using id in hash?
Why not just simply "command.setVM(vm)"?
This still has us redundantly check the loading and hasMoreItems values. It would be more correct to instead change the loadMore call below to onLoadMore
return "Enabled".equals(status) would work
same question
Why do we need this constructor? It doesn't use the 2nd parameter...
Those two should be equals (and even ==) rather than going through FQN
Why need to catch to simply rethrow?
Request.State.OPEN
why not use chain calls here? .append(...).append(...).append(...)
The method actually determines if the given processorNode is a duplicate of any of the existing nodes. The action we take on duplicate is stopping the processors. Can you please update the doc?
Where do these numbers come from?
@overquota Should not #close do #closeConnection and #shutdown do #shutdownConnection?
s/B/b/
This method is bad! It should mark the thread as interrupted again, before propagating the exception (but not this pull request's fault). We also have a RuntimeInterruptedException that Peter added: creating one of those will automatically set the the current thread as interrupted.
I don't think a Cluster can be removed while the Host is during monitor, therefore the cluster should be not Null.
this method should be changed to private
Maybe we should derive this from Prefs.getMediaWikiBaseUri() or require the client to pass in a default protocol. I think I prefer the latter to avoid complicating this nice and simple model type.
What are you planning to do here for negative-density fluids? Specifically: <LINK_0>
can't you use constants.empty() here as well?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Request.State.OPEN
if line 91 throws an exception you will try to remove release number zero at this line, which is not correct, I think
log message is somewhat misleading, IMO
I don't see why you introduced mutability here? Local variables would have worked just as well. If you really want that, please at least make the setters package-private.
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
Please check also left content, in order to be sure that left model has not been modified.Please verify all other tests that present the same problem.
checking for nullable parent was added specially, cause going into project node simply has no meaning
Can you add the curly brackets to the if calls.
beginBlock should close the paragraph that was created in assertOpenBlock(), if there is one currently open. Note that it should not close *all* paragraph blocks, only the one that was implicitly created.
Should we even cache raw categories for an article?
This makes this nullable. If you think this will never return null, then you may want to throw an exception NullPointerException. But if it can be null (like the trace is not set yet or something?) Then make this method @Nullable and do a null-check when you call it.
Please define a constant for the tolerance.
s/B/b/
Should we do an Assert.assertTrue on the return value of verify()?
same here, access to vmStatic should be null safe
Can be simplified to AutomaticProvisioningStatus.ENABLED.equals(getAutomaticProvisioning());
Again, processible gets renamed to runnable, process to run, yet doProcess remains as it is. I think that's an easily avoidable inconsistency.
You could probably use the same URL as in getResultById here.
The local var is useless, you can remove it.
omit: Initialing...
the return type should be M
I'd also set a flag internally on this listener. Then, if in future some code called listenToCache() with an already-triggered listener, you could just return immediately.
See identifiedElementQuery.getLabel()
Hmmm are we sure we want to depend on the Channel monitor... for property access it may be preferential to use properties as the monitor object
Take the limit (50) as a parameter, this will be useful for later
These two lines probably can be combined into one.
I'd rename this variable to memberValue.
but if the feature is unchangeable, then the user cannot do anything about it, so it should be set to readonly, or am I misunderstanding the unchangeable feature?
Minor: This message would sound alarming in logs. Possible to add more context here about what might be wrong?
Check if credential and registryUrl are null before creating the Deserializer.
Use Objects.equals() to handle nulls concisely.
Please add a check that from <= to
These asserts are unreachable
Have you considered Activity.RESULT_OK instead?
suggestion return format("metadata[%s]", key);
do we need to unvoid..?
is this tear down necessary? the next setup overwrites anyway, doesn't it?
Could throw IllegalArgumentException instead.
can you please also add method ok(TimePeriod waitForJobs). TimePeriod.LONG may not be enough for all cases
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
If you'll eliminate the lock, accept method will contain just "this.value = value;" statement
@droneboost use the activity parameter instead of calling the getActivity() method.
as mentioned we should maybe discuss this
What's with the null check?
public isn't needed
float?
!getCustomTopicNames().isEmpty()
Why not return "!this.id2descriptors.removeAll(id).isEmpty();" like in LegacyPropertyContributorRegistry.java?
Could simply be xml.append(payloadElements).
avoid using this.
Just to confirm, you know if TIME_MULTIPLIER is 2, not only will this speed up time by 2 (like you would expect), but also jump 44ish years into the future, since System.currentTimeMillis is posix time. I'm not sure if this actually matters or not for the way we're using this.
should the interface not the implementation suggestion public List<String> getTopics() {
make it final. You don't want classes extending it to override this, as it's driving the analysis.
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
suggestion EMPTY_VALUE);
should it be an error condition or log something if both the invoice number and the customer payment number are both blank?
can we remove the version completely?
return dto
add "domain = null;" to avoid problem at super.tearDown()
You can push this directly to the frame so you don't have to pop it manually.
data is never assigned, so this method always returns "". How about instead use: public String toString() { try { return getDN(); } catch (NamingException e) { return ""; } } as then you can't forget to return the proper value, and you aren't duplicating the logic which appears in the getDN method above?
No need for getInstance(), the container can be passed
why is this noncompliant?
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
nit: you can merge both lines above as checkNotNull will return the given argument
This looks like testDataFormat(COMPONENT); Please see other tests for sample
Not sure if it matter much, but the 'better' way of getting an empty list is: return Collections.emptyList(); In this case however we need to specify the type: return Collections.<CertificateInfo>emptyList(); As the compiler cannot infer the proper return type.
calling this command will not move the host to up. need to think of a way to activate the host and keep a flag it already been attested i thought using the non-operational reason but i think it is cleared in ActivateVds command
Please keep the getter and setter closer.
Would it make sense to add this method to ResourceManager interface ?
This looks overly complicated. Maybe  Set<String> set = new HashSet<>(); map.values().forEach((s) -> set.addAll(s)); return set;
This should default to true to preserve the previous behaviour.
notEmpty check?
use return ... ? ... : ...?
what does the flag mean?
This variable is useless. Please just use return in your if/  branches.
This is easier to read as: return type.getClass().isArray() || isList(type);
the workspaceitem needs to be deleted
IMHO it does not need to be public
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
Do you know anything about the expense of these methods? Will these cause RPCs to namenode?
Same here, better to wrap the classloader creation inside a method.
return String.valueOf(this.properties.get(key)) perhaps? to protect from null...
This should have a static logger method with a code
Symmetry (throw)?
Should include tableName as part of hash code?
lets include e.getMessage() to be consistent with other plugins.
subject.getUserName()?
I would turn this && around. A simple deadlineName check is a lot cheaper than the full parameter assignment verification.
I assume these are no longer throwing UnsupportedExceptions because split is something we want to hide (e.g., not have users worry about it at all and make it a no-op)?
return if already destroyed
Is it possible to do this in a constructor and not on get?
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Missing @Override
I don't understand why you verify if filterChain needs to be updated with every message read. Maybe filterChain should be volatile.
Newline between @Test and public. There's only 4 instances like this in the libcore source, hundreds with it on its own line.
better to cast to string instead of using toString() .
final
My personal preference is to use brackets even for one line loops and condition. Not a blocker to merging.
Let's have constructors one near another
use split(":", 2) for correct ipv6 handling
Why not making the following like:  Collection<Integer> ids = translateInternal(transformation, context); if (isKeyed && !isInputSelectable) { transformation.setChainingStrategy(ChainingStrategy.HEAD); BatchExecutionUtils.applySortingInputs(transformation.getId(), context); }  This will make the if () ... check being checked once. The same for the other translators.
final?
Wow, that's pretty useless until you squash this commit with "Implement CostCalculators"
I meant, we don't need a separate method. Lets do the things in power.
These 3 methods should be private, or if useful outside of this controller, they should be in a utilities class
you need call addColorSettingsListener on the new instance.
No need to include this in these calls but it is a minor detail.
I wonder if you should lock the handlers also with toCompletableFuture(), but given it's unsafe to assume toCompletableFuture().isDone() => this.isDone(), it's probably not necessary.
Why U don't want to consider id in equals and hashCode ?
this.monitor to avoid confusion with the parameter of the same name optional: this whole block could be a ternary: this.monitor = monitor != null ? monitor : NullProgressMonitor.INSTANCE;
...so don't pass the "intial hashcode" into location.hashCode(...) but instead mix the various hash codes yourself here. Guava Objects.hashCode() can help.
same shit
Formatting is off here: else should be 1 line above
We do not unpack it for all the inequality operators. Because of that i assume that the assumption is that the higher bits are always zero (or the same). Therefore i don't think the downcast to byte is needed here.
I think you get the idea wrong. We don't store the events in its state - as it's not going to fit any storage or memory. Instead we are going to use history() and develop its API further.
This should be used and check the ORGANIZATION_WQP_URL.
Argument name
unsubscribe()
There should be a null check here if it doesn't accept null values
url.endsWith("/") would be easier to comprehend. String comparison should be done with equals, not == or !=.
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
you can't get here with vm == null, so it should be removed from here.
:astonished:
reportservice
This was renamed to PARTITIONED
Do we need this else block?
unnecessary change
parentheses please ;) return (number == null ? null : Long.valueOf(number.longValue()));
Maybe use the getStorageId method here?
also concat the lines
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Consider the CollectionUtils.isEmpty(this.applicationDefinitions) instead
I would really appreciate if you rewrite this so it doesn't use -1 as startIdx. A year from now I won't remember why we want to load from position -1.
Change the commit title to say "Fix potential overflow in Bing tile functions". Also, for better readability, add parenthesis around (long) tileCount.
if you endup locking the whole method, there's no reason to use a block, you can use synchronized on the method. Applies here and any similar method.
Can we please add limit to the exception message? So it will be much easier to see the problem!
I don't think we need this assumeTrue. Docker API has had build params since 1.18 <LINK_0>
Throwing the generic Exception ?
missing check that vm exists.. (getVm() != null)
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
So what's buggy about the CopyOnWriteArraySet?
throw exception
Remove this line so that you fail on assertion.
requireNonNull
Qualify this.uri
You added this to the ctor's signature, but forgot to save it in a data member.
spacing here looks off
can we plesae use specific exceptions here ?
Format
Give a name to this thread, so if it hangs or blows up, the stack trace will give us a clue who called it. i.e:  new Thread(r, "Hawkular Java Agent Stop Thread").start();  I also need to think about this some more before merging since we are now making the stop() method asynchronous. We have to check to see what kinds of thread safety/concurrency issues this might cause (especially in cases where the agent is restarted, for example, and the stop is followed quickly with start. We need to make sure nothing in start is initiated before this stop thread is actually kicked off and finishes). In other words, making stop method asynchronous could have some side affects that are "bad" without some synchronization/locking put in place.
Have you intentionally omitted index check?
shouldn't it logged not printed?
it can be replaced with Objects.hashCode(channel) (since java 1.7)
Remember to call  configureConsumer(answer);  also as that is needed, see other components.
Not sure what this is supposed to test ? wouldn't the assertion hold regardless of what removeIf did ?
I think you will find that there are 1000000L nanoseconds in a millisecond and not 1000L as you suspect
would it be handy to also print out the other constructor argument fields here? (serializers in particular, not sure if the times are that interesting)
Mappers can be stored in static final variables instead of rebuilding these each time.
lambda
The number should be canonicalized before retrieving the contact, using Utils.canonicalizeNumber(number, username)
Failed to produce *AdvancedInsightResponse* from json
Shouldn't we avoid to have U+0000 or any other chars not valid for table name in the name? I think we should update TestHelper.getRandomString(int) to exclude U+0000 at least.
Might consider using a [SimpleConfig](<LINK_0> here. Won't make a huge difference with the class as-is, but will make it easier to make changes in the future if we ever want to expand on the configurability of this predicate.
Static import
Can we introduce shutdown() to the _PartitionDiscoveryThread class. shutdown method can call the thread.interrupt() or any other mechanism to shut itself down?
not sure we will need this parameter here, as we'd probably use the real locations, but let address that later.
to remove, just use new ArrayList<>() in the constructor, two lines below
new Double is redundant here
move this setter on top of methods. then should be all getXXXxxxToken then should be beginTree
since we will do it for every commit, what if we will move forming of those sets to current register thing where we update it with new index as soon as its added and do not touch it anymore
use same type for instanceof and force casting
You could probably use the same URL as in getResultById here.
Use Arrays.asList instead.
feedDisplay is a strange name. I had to look at the xml file to find out what it actually is. How do you feel about feedDisplayContainer? I know it was like that before and the guidelines we have come up with say that it is not necessary. How do you feel about this? Should we update the guidelines?
Mann knnte das auch ohne "username" machen:  java if(...) return authentication.getName(); return "...";
can you make "9" a constant as we use it most places
Let's import nullRef() statically.
Not null, not empty, no blanks? There should be a pattern for a valid Java method name.
as is in 718
String.format
I think this pattern will work throughout the whole string, while we want that it only works for the suffix of the string, which is not enforced. To enforce it, it should be "_[0-9]+_g\$$" or "_[0-9]+_g\$\z" or something similar.
in case closing one grouper throws ex, we would still want to close the remaining ?
This should be package scoped, not public.
What we are waiting here on?
I believe this is the cause of your failures as you are setting up a Java17 project which will be called TestSetup17project or something like that.
qry -> query
Do update all the places where you can now just use typicalBundle, instead of getting it again.
wait for articleContent before
What does it mean here to decorate it with Nullable while null is actually not allowed in the following line?
Maybe the simpler:  return Objects.hash(podSpec, podMeta);  or maybe not, because that involves an instantiation of an array under the hood. On the other hand, it leaves less room for error. :smile:
I think we should return a dto here and do the marshalling of the response in the IL as we do with other responses.
Is there a reason this is package private? On a fluent builder this feels odd...
use constant for UTF-8
When you will use I18n.marktr with ON_VERTEX you will have to use:  java JRadioButton bVertex = new JRadioButton(I18N.tr(ON_VERTEX));
Hm, you got java doc on the next method, but not here?
Why is this required? The test you wrote fails when I don't apply the change on PrimitiveType, but doesn't fail if I don't apply this.
This does not need to be public. Instead, just pass the builder to the private constructor. See what we do in HtmlRenderer.
Can you reduce the nesting depth here?
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
nit: I would extract webDriverContainer.getContainerInfo().getMounts() variable :)
You should create a ServerSocket on 0.0.0.0 to attempt to bind the port, rather than attempting to connect to it. There are a lot of reasons the connection to the port could fail, and it could even block for a bit trying to connect which would cause this function to hang. Additionally, there's no real guarantee in singularity that the app will bind to 127.0.0.1, it could just bind to the main IP of the host and you'd miss it, so binding 0.0.0.0 would ensure it's not listening to the port on any address.
Too many dots, there should only be 3!
should call clear() on timeStamps and values ... this will cause null pointer exceptions when calling add after clear
make static
Huh?
Using if (...) here makes it much more easy to read.
I think this can also be  java applyCollection(CharSeq::of);
please remove else, code will be more readable
i remember that month number should be 11
Since there is a @FindBy defined for courseid, I think actually can just refer to that
It would be really nice if event updater will get some kind of criteria that will determine how often you do this instead. That will provide an ability to test it in an easy way and to make refresh interval configurable
It may be worth expanding this to include say: + "who also have 'Push' rights on " + GitRepositoryManager.REF_CONFIG
nit: maybe merge the lines as the formatting looks a bit strange.
revert this unrelated formatting change
can you add to Builder as well
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
Is replacing separators enough? We should look into something that will work for any special characters.
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
final is useless here. Also, consider this.  java try { callback.onSuccess(sessionStore.read(AuthEndpoints.NAME).getAccessToken()); } catch (Exception e) { callback.onFailure(e); }
Same here, return ImmutableSet.of(this.modelResultStream, this.rootResultStream);
As noted above, just put the init code in init() unless there is a reason not to.
Can be made package local
It may be better to return an empty string here instead of null. Unless others look into this code, we may be pushing the null pointer higher. Thoughts?
assertFalse(...);
This does not need to be public. Instead, just pass the builder to the private constructor. See what we do in HtmlRenderer.
Intellij tells me that "public" is not necessary here.
"data" is already a plural noun.
why are we changing the visibility of these methods?
I think you should throw exception if somebody calls setEvent and give an empty event name. #Pending
An exception doesn't necessarily mean datastream not found, right? Why not check the http status?
can be !isDisabled()
<LINK_0>
I'd also set a flag internally on this listener. Then, if in future some code called listenToCache() with an already-triggered listener, you could just return immediately.
I think Guava has MapSplitter for this purpose.
Why the heck are we painting all columns ourselves? We only need to draw column 1 containing the graphical commit tree. This suggests a nice two-liner to fix this: replace above by event.index == 1 and...
What is the purpose of this conditional?
Although AsyncClient is deprecated retrieving event loop has some additional checks. Could you please check AsyncClient.findEventLoop?
I agree with @pfink, the follow profile will forward state updates from an item to the following item as commands. Please revert.
Duplicated use of tree.simpleName().name(). Please introduce a variable
Why does it need any change?
This has to diverged internally. Mady, can you incorporate this?
does this mean that we won't try to flush the last session counts when the application shuts down?
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
ohh.. actually we should default to 443 if https!
Formatting (extra {})
remove this.
same here, can be package private
Same issue here, double delete user.
It might be nice to also have a test with a user in the administrator group, so we can verify that it gets the ADMINISTRATE_SERVER permission.
nit: if (p != null)
Remove braces
Same as above, get the caller user/account from current context.
It looks like there's a testSame() method you can use for this one.
I don't think this should be public; or even be a method.
This method causes several build warning.
It is possible for this to return null if no matching Activity is found, e.g. if one has no browsers install or no browsers set as default (not sure if this will happen). In such case we should do a null check and return null. Also can you put a space after ,? Thanks!
@antonini please name it user, and initialize it with Opt.Empty
The writes in this method should be done under a lock, right? But I'm not sure that all execution paths do acquire this lock. Should we add synchronized (buffers) or checkState(Thread.holdsLock)?
I'd use << 3 to match MemoryAddressHash
CalDavConfig has no super class (except of java.lang.Object). Do we need a super() here?
We should throw an exception here too, saying the cluster is invalid.
wrap with Collections.unmodifiableMap() ?
use return ... ? ... : ...?
Would rather be Qubole Spark 2.2 ?
can not -> cannot Maybe Chid name instead of Property name?
This seems to guarantee an ClassCastException, given the input might only be a string, url or uri at this point. Maybe in this if there should be some sort of default configuration based on system properties, that would make it choose the caching or not caching path?
is there a version with more parameter than 3? If not i would use == 3 rather than >=.
java value.trim().isEmpty()  would be more clean IMO rather than java value.trim().equals("")  WDYT?
Test with no assertions whatsoever?
This method can be implemented as return a - b;
Please use PathUtils.validatePath to make sure that the path is valid before accepting it.
I'm kinda ok with 1. although fully share your dislike it introducing APIs About 2. I guess I get where it's heading, but not fully understand it yet, so cannot be sure
SimpleDateFormat is not thread safe, so you can't share it across threads. The static instance _can_ be used across threads since this method is static, so it's not safe to make this change.
java && SCMTriggerItems.asSCMTriggerItem(job) != null && job instanceof ParameterizedJobMixIn.ParameterizedJob  :bug:
latest from today's discussion: return URL
you can't get here with vm == null, so it should be removed from here.
Now we have this constructor , what is the benefit of having default constructor and setPath() method explicitly .
This can be ImmutableSet.
Would prefer this to call getVersion(), rather than the deprecated getVersionFromStatic().
assertThat(c.getParentCount()).is(2);
I'm not sure about coding OS-specific-ness. Is this the sufficient condition for all OS? 1. Does SWTBot has any users on SunOS/Solaris? Will the statemask be correct if someone uses GTK on Solaris ? It will be risky unless we test it. 2. See Util.isLinux() implementation in org.eclipse.jface.util package. It considers 'motif' also as Linux, along with 'gtk'. It seems SWT supports motif. It may be out-dated. Do we need to consider motif? Since 2-3 years we have been discovering some differences in SWT behaviors on win, linux, mac during our SWTBot reviews. There will be limitations to support each such difference. But then there will be inconsistency if we support such difference at some places. What is the best approach for swtbot?
This should be package scoped, not public.
Maybe assert that #put() returns null
This means clockHand will be hot at initialization time. Intended?
why are we changing the visibility of these methods?
This Exception is never thrown. It may be that while developing, you had a change here that required the throws clause, but it isn't need in the proposed patch. I would have expected that would have reviewed your own change before proposing it here, and that you have removed this change.
The DateTime.now().plusDays(4).toLocalDate() seems like a "magic number" that isn't really clear where it comes from. It would be better to set a value to the expiration date inside the testBoletoExpirationDate method to explicit it or compare it to some constant
negative logic
This method boils down to  java return folder == null || recursiveDelete(folder);  or  java if (folder == null) return true; return recursiveDelete(folder);
null? why not just a () -> {} ?
any reason for explicitly invoking super.toMap() ?
use return ... ? ... : ...?
HttpServletResponse.SC_NOT_FOUND
There are quite some AccessResultCodes beside SUCCESS. If the result is included with the exception this could provide useful information about what exactly went wrong.
This looks very nice! What about adding a throws JSONException to the signature of getValueForOptionalKey() and parseImageLicenseMetadata() since you have the needed try / catch already in place for processPage()?
Is this thread-safe? I guess, maybe, although it might do extra work since not all threads will see the update at the same time. I'm also not sure if ParseSpecs need to be thread-safe; if it's an issue could you please double-check it?
I like the approach; but I'd like the TLS 1.2 and allowed CipherSuites to be only limited to API 24 (higher API levels might want to use TLS 1.3 for example)
How about passing in groupBy instead of just groupBy.isUngroupedAggregate() as I think we'd want to get more info eventually out of the groupBy (for example, if it's ordered or unordered which impacts memory usage substantially)?
Do we need these 3 lines?
Do we need this?
This method can give an incorrect result if the last buffer is moved from the inner queue (which is then empty) to the output buffer (which was previously empty) in between those two calls.
Fix method name with prefix..
It is safe to call dismiss multiple times, in the source for dismiss(), there's a nice global if check along the lines of (mView != null && isVisible()) or something.
return a copy of the data to keep DataExtension immutable.
Would it be better to use assumeTrue(), so that the test is skipped if the test trace is not present, instead of failing? This might happen with offline builds.
The incore merger works in memory without a working tree. Does he need attribute handling?
I this refactoring, very nice. Could make this method protected.
You'd probably dispose your stuff, and call super.dispose() at the end.
IMO while would be better here
Can be simplified to java return itemMaterial == null ? 0 : itemMaterial.getMaxDamage();
There is a lot going on this one line.
Instead of this custom code, use @Test with expected attribute
EC Diffie-Hellman public
This should be moved to above solrMapper.configure() so that it does not need to be set in that code path.
It's not from the changes in this pull request, but to clean up a bit more, the superfluous super() call could be removed.
empty function? also no qualifier (public,private)?
I would move this log.info out of if/else let it be logged :))) What is wrong with ENV variable? currently you can set the DATA_DIR in your auto start script and it will work forever In case of applicationContext.xml it has to be patched after each upgrade ....
if i get it right: if response is null, we will not retry. i think we should retry even if response is null. btw what caused this in your case? so it would be:  response == null || ....
Can make this into a singleton as we have with UNSET.
Missing codes.
If this logic is need, please find a way to reduce the code duplication. see azkaban.test.Utils#initServiceProvider
allOn4_1 does not really correspond to version.onOrAfter(Version.V_4_2_0) which means versions >= 4.2.0
suggestion return System.currentTimeMillis();
Can this happen ?
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Is this not needed anymore?
this can be condensed to  if (!chkAuthorization(...)) { return false; } ... return true  and get rid of haveAccess
calling super not needed
unsafeSubscribe shouldn't call the ERROR_HANDLER.
a workspaceitem should be returned
Same here? It is always number or null?
Use InvalidArgumentException instead
Is forEach better that putAll? I suppose we also need to take care of the case when params are null.  if (params == null) { namedParameters.clear(); } else { namedParameters.putAll(params); }
I would like more specific catch clauses. catch'm'all is a bit crude (and it will also happen on the ApiServlet level.
Args.notNull
can't the response be null? if null as return value is legit for non existing snapshot, move the initialize of the VM into the condition.
static.
There should not be a need to set this to public. Perhaps private would be better.
We can return the json string of oAuth2AuthorizedClient, and output json string in logAuthorizedClient.
toString() not needed
Maybe good to add a limit to the total number of events that can be queued (suppose the send takes a while because of network issues and lots of events queue up in the meantime, leading to high memory usage)
I would prefer to use full words. For example directoryAllow.
Add message for this requireNotNull
I think can just use the @FindBy defined at the top instead of findElement() againt
remove ()
whole block indented one extra
Missing codes.
we never use NULL, it is a bad practice in general.
1. position should be able to equal count which means the end of the stream. The current logic will never be able to seek to the end. 2. Shall we throw an exception if the position is invalid, for example negative case?
these setters should not be public
This seems unnecessary, if you going to return the same thing at the end of the method anyway.
Don't open things up that don't have sufficient parameter validation, the @Nonnull is not enforced here because it was an internal method, so you'd need to add a Validate call here.
I think this is a typo -> this.high < this.high -> should be -> this.high < other.high ??
Minor: there is also a method, Predicates.asSet(In), that exposes the inner set. I think the purpose of that was to mimic the use of Ranges.asSet(Range), which has to be a static method because we allow ranges of objects that aren't Comparable but back the asSet method with a Guava range that requires a Comparable type. I'm fine with changing to use this method everywhere, since this is more straight-forward. But I'd like to either use Predicates.asSet(In) or In#getSet(), not both.
here we need to go through Optional.ofNullable(Plaform.getProduct())
Operation can have InputStreams attached. There's a way to translate that to HTTP, we should figure it out. Or at least throw an exception if there are attachments.
How about while (!stateMachine.getCurrentState().equals(STATE_CLOSED))?
I think the CosemDateTimeDto is immutable, and as such there is no need to create a new one to protect the field in this class from changes from outside.
this seems consistent with the exception that was previously thrown but has a more useful error message. I think if you could add o.toString() in the message, that might be event more helpful: throw new ClassCastException(String.format("DesiredCapability %s's value should be boolean: found value %s of type %s", key, o.toString(), o.getClass().getName()))
This needs to be changed to support locked stream syntax now.
And then else if this
other methods like this put name first, then id. switch for consistency
remove public
I'm still having a hard time groking end > start. The typical pattern is to say start < end, its easier to visualize. I think we can also drop out a subtraction instruction from the inner loop here if we are a bit smarter about how we handle the bounds: int ptr = end - 1; while (start <= ptr && isWhitespace(raw[ptr])) ptr--; return ptr + 1;
I think there is some findbugs issue with not using {} not sure.
why the newArrayList? Iterables.filter already returns an iterable.
It would be ideal to clear and repopulate the LibraryType table in the V9000 test data migration. Then it's easier to test against an exact controlled number of LibraryTypes, rather than making the tests more lenient. Same with LibrarySelectionType below
isn't it always 1 or 2 arguments?
This can also use covariant return types
why do we need to make this method final and none of the others?
unsubscribe()
have we change it in scope of this story?
Shall we mark this as deprecated?
Should we include the label too?
@garydgregory Please use Args.notNull for consistency with the rest of the code base.
can we remove: declare-response, useless-assign and just return the object from the method-call?
Minor readability suggestion suggestion model.addPropertyChangeListener("scriptStatus", ignored->{
static
Do not make input file names cryptic. Please rename the file to clearly state its purpose.
Add SubChild here as well, perhaps SubChild is just persisted as a Child currently..
Should reset the values in the config file too?
constant?
I know this isn't supposed to be invoked and I am nitpicking, but should that ever accidentally happen, I'd prefer to either see dummy string returned or an exception with explanation.
you have to add a canDoAction message if you fail canDoAction
why not using the super constructor? super(nodeId, nodeLabel)?
Should we add: Objects.requireNonNull(record)?
Wouldn't it be more appropriate to raise a configuration exception here? This will lead to null pointer exception as far as i can tell
return filterSet.getActionFilterOrder() != null
Should we be 310-ing it up in here?
move the get with null return to own method so we don't have code duplication, but make method private
Never use FileLocation.UNKNOWN if you can help it. Here you should use location
Why aren't we passing in the fatalErrorHandler or Dispatcher::onFatalError?
matter of taste, this could also be return this.profileTypeRegistry != null;
We should not get into firewallType being null, it should always be set for cluster add/update. If it's null, then proper error should be raised
You should pass here message not group converted to string.
check valuesInUse
This condition seems to be backwards. I think it should be index < array.length
please implement asLong() method instead of Long.valueOf(id), see asGuid(id) for details.
Should these have some kind of validation, e.g., non-negative, from less than to?
minor: do you need the super qualifier here?
this method should not be public, otherwise doesn't make sense the arguments for the flush(ClientSession, String) method, as each session (editor) will have a different associated FormsContainer instance, which could not be the one set in setCurrentContainer... Can you please change it to package protected access (so no access modifier set)? Does it work/make sense for you?
I don't think you need this new String
Here dirName should never be null, and delegate should always be null.
racey single check
Sorry it seems I was wrong. It seems that indeed your previous attempt was correct. java if (t == null) { throw throwable; }
Changing the region should also invalidate the client like above.
:ant: double check of a single field.
concise way to do this would be value = value.replaceAll("&", "&amp;").replaceAll(...).replaceAll() I think it would be more readable and concise.
Is shutdownNow more appropriate (which would interrupt running tasks)?
We should consider extracting the functionality of the stringValueOf(...) to some helper/utility class, as we may use the same functionality elsewhere? :cake:
Instead of toString and parsing, store the Project.Id passed in the constructor into a field that this method returns.
Do we want to keep the method names like this or give it a more general name?
Redundant brackets suggestion return tryActivateAndGet(e, stack.getItem()) != null;
I'd probably format this to have a : before the actual digest value, just to delineate between the hash type & the value.
return new StringBuilder().append()....toString();
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
lowercase for package names.
As above, I'd use String.valueOf here.
java authCardDetails.getAddress() .flatMap(northAmericanRegionMapper::getNorthAmericanRegionForCountry) .map(NorthAmericaRegion::getAbbreviation) .ifPresent(smartpayTemplateData::setStateOrProvince);
why did you remove this ?
make sure to propagate cancellation to the completableFuture
should we use "this" on line to make more evident what we are doing
I believe that other implementations are either returning an actual String representation of the operation, or the result as String. Could you double check that?
These are from the org/json library. Edits to this are really not recommended.
Make the fileInfo map immutable.
Does this mean that we get an additional object per invocation? If so, then I'm not in favor of merging this pr.
nitpick ... this should be renamed to simply gammaId, it's not necessarily new.
Unneeded parenthesis. You probably can one-line this method anyway :)
assertFalse(...);
It feels like there's a lot of context and state that's being managed here that would be much cleaner to delegate to a composed cacheState object (which would also make it easier to change this later more safely without requiring safely updating 5-6 implementaitons
unnecessary array new: {{true}, {false}} should work here
Totally optional: we could tighten up the code a bit by getting the boolean value for !DeviceUtil.isOnline() and then passing it in as a new param to conditionallyAddPendingClient: void conditionallyAddPendingClient(FeedClient c, boolean cond) { if (cond) pendingClients.add(c); }
How about directly returning the result? java return this.name.equals(a.name) && this.airport.equals(a.airport);
Get the size directly don't use getAllEvents()
- Can we inject the EventHubWrapperFactory into the EventHubSystemProducer, EventHubSystemConsumer and EventHubSystemAdmin instead of class-loading them via config? It'd be much cleaner with types that way. Use-cases at LinkedIn that require tunneling can inject their tunnel-aware versions of the EventHubClientWrapper.
Please run build with sourcecheck profile
The left side should be the preferred style (annotations in an extra line).
- Are you sure this is enough? Containers, which are started by scheduler, are not part of the cluster. Therefore they are not stopped. If I recall correctly, the scheduler gets killed by destroy(), but schedulers remain running - CLUSTER is annotated by @ClassRule, therefore stop() will be call through MesosCluster.after()
Here it's OK: it really may returns an instance of anonimus implementation of ARPMH
I know we tend to always do remove/install in our code, but this is actually not needed: org.eclipse.gef.editparts.AbstractEditPart.installEditPolicy(Object, EditPolicy) will remove (and deactivate) any pre-existing policy in the role we want to install the new one.
this could easily be done when creating the repository as well.
We can add a checkNotNull here.
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
This can be removed.
Give a name to this thread, so if it hangs or blows up, the stack trace will give us a clue who called it. i.e:  new Thread(r, "Hawkular Java Agent Stop Thread").start();  I also need to think about this some more before merging since we are now making the stop() method asynchronous. We have to check to see what kinds of thread safety/concurrency issues this might cause (especially in cases where the agent is restarted, for example, and the stop is followed quickly with start. We need to make sure nothing in start is initiated before this stop thread is actually kicked off and finishes). In other words, making stop method asynchronous could have some side affects that are "bad" without some synchronization/locking put in place.
Lists.newArrayList(entity.operatorIDs))  What does operatorIDs represents?
Can you explain why protected field access are expose via public methods ? Do not change access modifiers without understanding its purpose.
why is this not private?
Hmmmm. I just noticed this change and it isn't good: from a human perspective having the fbo id alone in the logger output is of limited use. Having the name printed out is quite important. I can imagine a couple of solution: 1. we pass the fbo's URN on construction, solely for the purpose of printing it out in the log alongside the fboId 2. we store the URN in the FBO, but I'm not sure if this is going to come and bite us in the future.
This class should be immutable anyway so why not wrap the collection in the constructor once rather than every time it is returned to caller?
nit: you can merge both lines above as checkNotNull will return the given argument
Expected value should be first.
Why it's here? Please try to understand what onInstall and onUpdate are doing. If keep as you wrote: it will be a duplication.
@fuss86 we probably need to check that there were no exceptions here.
assertThat(test).isNull() there are like 2 instances each of assertNull assertTrue and assertNotNull, assertj-ize it
As Kai already stated the mime type should not be optional.
We should also be using the DEFAULT_BROWSER_ACCEPT_HEADER if we the submitted one is the empty string.
IMHO it does not need to be public
Consider a constant symbol for -1 to indicate an error value.
use correct variable name
wouldn't it be preferred to store the value of each type in lower case instead of creating it each time this method invoked ?
Weird sentence structure. Why not Illegal choice for parameter foo: bar?
The range of valid Long is wider than Integer
I don't like how this method has to use the duplicated string. I'm not sure the check is needed but at a minimum it should probably use the isPasswordHashed() method.
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
I would add: setAlertType(AlertType.INFO); So you have a default of INFO for messages that don't specify.
does not need to be public in non-public class
You forgot to add the address to the toString() as you did in the patch on the master branch
we don't need to use return in case of void result
For non-public methods checkWidget() is not required.
I would recommend an else if here to avoid comparing against a string unnecessarily.
Let's be consistent and use 0 as a reference. (But as mentioned earlier, I vote for removing these ones)
I think the attribute "create=true" should not be put in the test case, it is used the very first time to create the database.
We discussed this already, but please remind me: update() is executed, for example, when the user resize the window. Why not to avoid any form of memory allocation in those circumstances, even if it's admittedly small in this case?
I don't think that is necessary.
I think it should be return true, as well as in sqlCompatible, because returning different in non-sqlCompatible and sqlCompatible in fact makes this method dependent on this config, that you mentioned during the previous round of review shouldn't be the case .
public boolean hasValue(@Nullable String value){ if (adapter != null) { return (getAdapterPosition(value) >= 0); } return false; }  Not sure why we are instantiating a variable here.
This is not thread safe. Is it guaranteed that this will only be called in a single thread? Does this guarantee still hold if Nimbus is sweeping many products at once? We should either make this safe or make it very clear to our future selves that this is an issue we need to fix.
Please no System.out.* calls. Thank you!
do we really have to work with classNames here and couldn't use Class objects directly instead? This smells like dynamic-import again :-(
I think we should throw IllegalStateException instead of CouchbaseLiteRuntimeException as it's self described that this is in an inconsistent or illegal state that users shouldn't do. CouchbaseLiteRuntimeException should be something that LC might thrown but not expected?
use parquet.Ints.checkedCast or you could get a negative value out of this cast. <LINK_0>
Typically we use Map on the left hand side rather than HashMap
Add message to new RuntimeException
M-m-m. Can't we simplify the life for Jackson and for client afterward and return null here if properties is empty? I'm sure that we will add eventually more and more here, but there may be some cases when it is still empty.
do we need any content in this constructor at all?
It's better to log a message no matter compression is enabled or not, it's always easier to search the existence for a message than to find what's missing from thousands of lines.
idx -> index
Can this be private, or is there another use case for default attribute outside the builder's call?
Give a name to this thread, so if it hangs or blows up, the stack trace will give us a clue who called it. i.e:  new Thread(r, "Hawkular Java Agent Stop Thread").start();  I also need to think about this some more before merging since we are now making the stop() method asynchronous. We have to check to see what kinds of thread safety/concurrency issues this might cause (especially in cases where the agent is restarted, for example, and the stop is followed quickly with start. We need to make sure nothing in start is initiated before this stop thread is actually kicked off and finishes). In other words, making stop method asynchronous could have some side affects that are "bad" without some synchronization/locking put in place.
s/install/enable/ (since there is an install command)
Call to default super() constructor is implied. This is only a question of style, but it make my eyes hurt... Feel free to ignore.
please move the isEmpty methods to the scimSchema
exiting, so STDERR
Instead of reference equality, we should change the implementation to use the query field in equals and hashCode computations.
Lowering should be set to true here, so that the elevator isn't holding up unnecessary weight
Should this use RANDOM_PORT_INDICATOR instead of 0?
Put each on a separate line java .setMetastoreUris(null) .setHiveUserName(null));
Well, with the squash GH doesn't see changes and don't notify via email. I have missed this change therefore :cry:
these arrays could be static finals. That would save allocating new ones all the time.
NetworkStackClient alreay dump ConnectivityModuleConnector. Do we really need to dump it again? <LINK_0>"ConnectivityModuleConnector.getInstance().dump"&sq=package:aosp-master&g=0&l=331
Same here and above.
minor typo: SEPARATOR
Modifier 'private' is redundant for Enum constructor - needs to be removed.
simplify this
You must catch the exception catch(APIException e) { response.sendError(HttpServletResponse.SC_UNSUPPORTED_MEDIA_TYPE); return; }
Wrong way round.
If tag is empty we will have NPE here. Could we make this impl safer?
requireNonNull
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
nit: you can merge both lines above as checkNotNull will return the given argument
Wouldn't it make sense to call setImage here? Or do we have different semantics in that method and this one?
Sorry if I'm being picky, but you can just call getClass() (without 'this.')
My personal preference is to use brackets even for one line loops and condition. Not a blocker to merging.
throws
It could be - can you create a short script to show the issue and open an issue against the repo that contains it?
NAME -> HIGHLIGHT_CTX_DATA
Why return a value if you don't use it when you call the method?
It might be worth including tests to confirm that initMessage() correctly sets the processorId and doesn't call enableSevereAlertProcessing() on the ReplyProcessor if the processor is null, a test to confirm that send() throws an exception if putOutgoing(this) returns a non-null set, a test to confirm that operateOnPartitionedRegion() calls sendReply() with the correct arguments if a ForceReattemptException is thrown during doLocalClear(), a test to confirm that we call endPartitionMessagesProcessing() in sendReply() when appropriate and a test to confirm that we only call replyProcessor.process() in ClearReplyMessage.process() when the replyProcessor is not null.
simplify this
Here I would follow another approach, you get a ZIP file, and you interested only in its content, the schemas data directory providers I described above are the ones responsible to provide the location to store them, we got a ZIP or a file, we clear the current schemas directory content and drop the ZIP output or file in it. When handling the ZIP file, it may happens that the user ZIP the schemas as root or a directory, we shoudl vouch for the two use cases: 1. we have a directory inside a ZIP, we use the directory content 2. we have files as root inside the directory, we use whatever is there
Shouldn't you be calling setParam("property." + propertyName, value) to be concise with distro.properties?
can you add to Builder as well
This makes the countQuery required and will break exiting users. Why is it required? You don't check for notNull, but than pass it on to sanitize, which doesn't do a null check.
nit: this can be reused in other places, like ChannelStateSerializerImplTest#getData(int len), ChannelStateSerializerTest#randomBytes
This call will lead to an NPE if no thing type is found for the thing.
Revert this line?
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
This evaluates different value that it stays isLeftTurn will return true, in case it is slight left turn
DRY: would use this(username, password, null) instead
Do you think it is worth logging if there was an attempt to set the timeout below 2 minutes?
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
So, you delete this line and we try to run it the way discussed in #124 (but don't support it officially)?
It would probably be better to have a clear separation between the call to getSolrUrl() and the creation of a log.
why is this noncompliant?
Cache temp file string.
Why is this the case?
Remove this
It is still public. Why?
If tag is empty we will have NPE here. Could we make this impl safer?
either change the name of the state to RETRACT or the name of the class and file to REVERSE (I prefer retract)
[FindBugs] WARNING: SA: Self assignment of field KafkaSingleThreadedMessageReceiver.subscription in pl.allegro.tech.hermes.consumers.consumer.receiver.kafka.KafkaSingleThreadedMessageReceiver.update(Subscription)
@guiseco you don't need to check the validity of the position argument here, since it's based on the getCount() that you overrode above.
do you need to select et_name here?
Don't use stream apis please
use 'L'
Out of curiosity as I don't have the code in front of me, what does null signify and why do we care to have this a ternary return?
this should be CounterTargetEffect
suggestion if (this.currentTask != null) checkAndRethrow();
Is this stray? Or do you actually set it to test?
Should be added the Override annotation.
if i get it right: if response is null, we will not retry. i think we should retry even if response is null. btw what caused this in your case? so it would be:  response == null || ....
SpeedController not CustomSpeedController
hmm, that method makes somewhat sense in core java, but I'm not sure I like that behavior for selendroid. We're expecting a boolean value, but essentially we only care about either true or "true" coming across... everything else is false. Is it going to be confusing to any users? I'd almost rather add an additional else clause to check for the string of "true" or "false", otherwise raise the exception. Since users of other programming languages (like javascript or python) may have a different impression of what a truthy value should be.
Core.ID
can super be called first?
needs @Override
Why not just use the element.toString() instead? If we want to use something specific in the printing of the messager we should pass that in the arguments, and not do it in the toString. For debugging it would be much easier to just have element.toString() here.
Please make a null-ptr check.
@sebing space before { missing
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
maybe just call this.addUpdateTask(operation, key, "") and remove the overload in BoxMetadataUpdateTask
The ParameterService has a version of the getParameterValueAsBoolean() method that accepts a default Boolean value as input, which will be returned if the parameter value could not be found. If you can modify this code to use that particular method, then you don't need the manual null-value checks below.
I'd prefer to use a single long option for this: --xml-entities
Could you please make this an extra bit more specific like -SNAPSHOT? Thanks! :)
Generic type not used, remove.
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
I believe the return value of System.getProperty("os.name") should be normalized first using:  private static String normalize(String value) { if (value == null) { return ""; } return value.toLowerCase(Locale.US).replaceAll("[^a-z0-9]+", ""); }
Other two can be removed as well.
I would call the ivar and method runInTransaction, the method's giving an instruction and the current naming doesn't make that clear.
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
As this operation is optional, just say it won't be supported because it's not mandatory.
I think it is not guaranteed that changes to slot are visible within the bulkChecker which uses the mainThreadExecutor to run since the used Set implementation is not thread safe.
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
you can either remove else or add pair of curly brackets
These checks should happen within the build function when delegated to the object they are building, not a builder's set function. Don't duplicate the logic.
Pull this into a static final variable
This is not going to work as Keycloak may be exposed on a different context-path on the reverse proxy. I.e. frontendUrl could be "<LINK_0>" while Keycloak is listening on "<LINK_1>".
The warning message and the other one is very detailed and more related to transmission of activities. I do not know if it is helpful to mention a sender in the message as these are utility methods. Furthermore even if you see the message in the log file it is not very helpful at all as it does not include the path and you also do not know in what context it did happen (I guess it is the XStream Marshaller when converting activities)
I would suggest to change the name of skipRemoteGet() to something like skipFetch(). Also, change the name of the internal flag and the setter :)
this should be in the doPopulate() not in deprecatedPopulate()
"//div[text()='%s']" looks too simple to reliably prevent confusing with wrong element.
Use one pattern consistently: Either model all sync calls as asyncCall.get() or Model all aysnc-calls as sync call + CompletableFuture.completedFuture(null) I'd prefer making async the more general API and expressing the sync-variant in terms of the async one
Use type ChargeDTO in return responseEntity instead of ?
This is another behavioral change that I don't want to see in an unrelated PR.
should return a boolean
I have the feeling that we should be careful and also check for interfaces and annotations (Tree.Kind.INTERFACE, Tree.Kind.ANNOTATION_TYPE, as both of them are ClassTrees). It would however be pure defensive programming, because I can not manage to write a compiling example.
this should be able to reused. it can be a static field
Can this just return 0 if length == 0?
Maybe use an uppercase in the text: 'Thread sleep was interrupted'.
Looks like there are some spaces missing here.
I don't understand why you verify if filterChain needs to be updated with every message read. Maybe filterChain should be volatile.
Did you intend to leave this Log call?
return index == 0;
side note: createFromKieContainerXmlResource() can't throw Exception, at most RuntimeException
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
Use [filesystem's TestUtils](<LINK_0> Or, better still, move that method to the [core TestUtils class](<LINK_1>
You should change the error message here to be about AWS rather than GCR.
We should rethrow java catch (InvalidFunctionArgumentException e) { closeWithSuppression(e); throw new PrestoException(INVALID_.....); }
Why not use null instead of ""?
Why do you need this?
I think it would be suitable if some kind of padding is applied between messages, such as a newline
Please change the debug message to be the same as BearerTokenAuthenticationFilter <LINK_0>
I would suggest You to use Logy.d here instead, as we did it [here](<LINK_0>
also concat the lines
- please remove TODO - please use propper logging instead of using printStackTrace()
This can be refactored to m_isTable = "true".equalsIgnoreCase(table)
please move this initialization code to the constructor
Why only return count for m_wrapper? Don't you need add the count for all the wrap in m_bundles? This also works for class-based importers, (i.e. socket importer), right?
Can this be null?
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
nit: Suggest renaming iterations and its getter as well here
Please avoid the use of too complex locators. Please use constants.
I think you need to call setSize instead, which does things like updating the bounding box.
Why the empty string in toStringHelper("") ?
please remove this log inside a getter
What about the previous mImageReader instance ? It should be closed when detached .
nit: Could be this.conf = requireNonNull(conf);
Is there a reason to not do this in the constructor?
This should not be on fields as this is custom-role-mapper specific - not related when used as mapped-role-mapper in subsystem.
Strings.isNotEnpty()
parentheses please ;) return (number == null ? null : Long.valueOf(number.longValue()));
Must be ANY, not YOU (At the beginning of each end step)
hell no
Can you mark this @Nullable please?
can you please also change logType.getDuplicateEventsIntervalValue() to duplicateEventsIntrvalValue
Check the env variable before returning true.
Probably we should check here for the class loader of the exception class, if it's the class loader hosting the test cases it should be GuardianException, otherwise we should transfer the exception using com.hazelcast.test.starter.Utils#transferThrowable.
Do you have a test that peeks the next sequence number?
Shouldn't this close the iterator before returning the list?
:bug: Binary compatibility
the name of this method is not clear (pun not intended...) because the word 'clear' is usually used when some collection is being emptied. actually looking at the code in the clearAttachments, you are computing the attachments to remove. this makes sense, and is also consistent with the row above 'bondsToRemove.add' but is obscured by the name of clearAttachments. secondly, the last line in the clearAttachments() method is not dependent on the id that is being passed to it. so this line should not be there. it should be here below line 60. then you can rename clearAttachments to calcDestAttachmentsToRemove. this would make the flow symetric, consistent, readable.
I'd feel better with this if this method was still protected. Why was it made public in Netty 5?
is it necessary to encode duration iso standard?
updatethese to use the public API's in the tests and not the package private APIs. Applies to all test methods.
Symmetry (throw)?
urrgh, not so nice. catching exceptions in control flow. especially catching general exceptions
lambda
sed 's/value == STRICT.value ? true : false/value == STRICT.value/' (Redundant inline if)
What I'm missing here is the check if the element is null. I know that the probability is very low, but still...
acquisition of all locks should always come outside (just before) entering the try-catch. Because if something goes wrong, the finally block is going to try to unlock a lock you have not acquired. So swap lines 89-90. Do the same for the others.
nit: this can be reused in other places, like ChannelStateSerializerImplTest#getData(int len), ChannelStateSerializerTest#randomBytes
Tip: we can use StringUtils.stringToInt() here and in getWidthInt().
Rather than return a new arraylist - just return an empty iterable, e.g. return Collections.emptyList();
no need to extract this out to private method if it's only being used here. same for onClusterRemoved
Nothing to cleanup?
final List<T> sorted = ...
Don't you check for array size >=1
It would be great if we could have unit tests for all these new methods inside say PhoenixTTLRegionObserverTest.java
I assume this lazy initialization should never happen as we will always initialize this field in class constructors, agree?
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
consider merging both lines
It is perhaps just my personal meaning, but we could drop the call to the default constructor of the parent.
this is just a setter, why we need to update it?
Remove this
The super.close() method will close the executor, after which the task queues will be empty and all workers will have terminated. If we close the writer before we close the executor, we can risk racing with on-going work, can we not?
Also called twice here.
null == manager
Cool that seems like a good solution
We don't log the exception in the other log statements. I also don't think it's a good idea, it just clutters the logs for operations, we should just log the message: LOGGER.warn(String.format("Error revoking all access tokens on auth-server %s: %s", authServerHome, e.getMessage()))
This boolean does not seem to be used.
remove else
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Get it from the model now that we have one?
unused try catch block
Why this change?
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
Call to default super() constructor is implied. This is only a question of style, but it make my eyes hurt... Feel free to ignore.
Why did you remove this call?
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
Please make a null-ptr check.
can be !isDisabled()
Should we alert the user that an error occurred here?
suggestion return all.size() > index ? all.get(index) : null;
check for not null
Wouldn't it be more efficient to track the case of the first character then break and return false on the first occurrence of the other case? Saves iterating the rest of the character sequence if it has mixed case.
@ivanarrizabalaga why do you extract this bit of code into a method? Is it not better to leave it as it was before the fork?
here you can call endAction(). you'll need to set setTaskGroupSuccess to true. Look at ConvertVmCallback for reference.
Missing codes.
I would prefer a compiling code here:  void test(DataSource dataSource) { Connection connection = null; try { connection = dataSource.getConnection(); // Noncompliant } catch (SQLException e) { // do something } }
magic number
At least one error is required
I this refactoring, very nice. Could make this method protected.
Unneeded parenthesis. You probably can one-line this method anyway :)
We should not be applying rules in this method. Instead, we should return a Statement which applies the rules, so the rules are applied when the final statement is evaluated. That's why RunRules is a Statement.
we never use NULL, it is a bad practice in general.
May I suggest this?  int i = url.indexOf("/#/"); return i == -1 ? url : url.substring(0, i);  It only searches the string once, and more important, doesn't duplicate the search argument.
No need for super()
If return null, how does caller deal with that situation?
use Collections.unmodifiableList and at similar other places
Wrong method name in the error message.
What's wrong with setting the listener to null if it should already be guarding for null listeners
I would prefer not to use null ... just a empty set and then assert that its not null
checkNotNull(value, "value")
> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
Style inconsistency: space after if
String log = "..."; assertLastMessageIs(log)? for me, assertLastMessage(...) isn't clear what the assertion is doing (without looking at the method). - edit... assertLastMessageEquals(String...) I guess "equals" is more familiar than "is"!
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
Nit: parenthesis are not needed for lambda parameter The method is long, so name the parameter table
Is it correct that this class uses CryptoMigrationUtil instead of the StudioEncryption class?
Just a suggestion: Objects#requireNonNull(Object, String)
Will this also work on files? in that case, can you refactor the (File) functions to call the (Path) functions?
please remove else, code will be more readable
What is the purpose of this?
I think we will have to discuss whether or not to include the fromKafka functions in this class.
Check first that target is not null.
why are we changing the visibility of these methods?
Name is no longer used
It may be cleaner to use Objects.hashCode for a single parameter, and Objects.hash for multiple (see the warning with Objects.hash, though that doesn't appear to matter here).
replace with return this == other;
Hello @mcimbora , I think it can be worth to provide a more fine grained filtering here. To be sure that the method is not a constructor, has the @Generated annotation, and also "is one of the generated" by the planner stuff. Probably inspecting some additional planner generated annotation for the method (I I don't remember wrong for this planner generated method you added has also a planner annotation with two parameters?) or eventually exploring the return type, or some other trick. This will prevent us from loading other methods with the @Generated annotation that we don't know how to manage. Specially because when the java source is being updated, all the accepted methods are being deleted.
Should be ObjectId, as the mapping cannot be mutable.
Perhaps put the or else in the parameters. More useable  FpKit.findfirst(list, x -> isGood(x), otherwiseThis)  Could be a supplier to make it lazy  FpKit.findfirst(list, x -> isGood(x), () -> otherwiseThis)
Style issue: @Override shuld be on line above the method declaration
super.init() method never throw an exception.
public boolean hasValue(@Nullable String value){ if (adapter != null) { return (getAdapterPosition(value) >= 0); } return false; }  Not sure why we are instantiating a variable here.
there was a NOT ('!') before the check.. i think still relevant, no?
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
Deprecation was added in [1] but the commit message does not have detail. [1] <LINK_0>;a=commitdiff;h=18bcdf797dfba5e462413a6ccce9dd6d3da2025b
Use the new String(byte[], Charset.forName("UTF-8")); form to avoid the try/catch. Constify the UTF-8 Charset elsewhere for extra points ;)
No need for this.
This probably needs to be .asEagerSingleton() as otherwise it may be pruned (nobody will depend on it, it's a leaf)
Not needed?
Leftover debug line - edit not leftover, it's just that the logger is not available. Suggested saving the error string to display when creating the exception a few lines down.
Please keep this.cell near the related fields (previousFamily & cell count) below
You can remove this exception now.
Why not just Observable.fromIterable(cache.keySet())?
Lists obtained from a message are immutable. No need for extra copying.
you import ByteBuffer, no need to use the full package path
It's not needed to check null, also inside of QueryBy.valueOf has internal check if the item is not one of enum items, exception will be thrown, should be changed to something like:  @JsonCreator public static QueryBy of(String value) { return QueryBy.valueOf(value.toUpperCase()); }
Please no, let's not have compactedChain being null legal. What is it buying us exactly?
Can we set a charset? Like ASCII or UTF8?
do we want to have actual percents? not rates as everything else is in Picard?
CalDavConfig has no super class (except of java.lang.Object). Do we need a super() here?
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
Please format here. And maybe use method reference to simplify: indexToChunkIds.values().stream().map(Pair::getFirst).collect(Collectors.toList())
why is that needed?
Do we think that overByAmount will actually be a useful/actionable piece of information for users? As opposed to just saying it's too big to upload without specifying by how much?
n["+fTimeArray.length+"]("+min()+'\u2025'+max()+')';
Assuming this is noting completion of initialization, perhaps "Finished initialization."
return time >= actionTime;
use return ... ? ... : ...?
Why use only w2? Why the right shift? Likely it doesn't really matter.
I think only one impassable entity should be allowed on a Square. Exception otherwise.
Is this supposed to be <code>return "Bump"</code>?
You can use StringUtils from the commons.lang3?
For easier maintainability in the future, I suggest having curly braces for this if condition.
Also about this location, we have a cache subfolder in the data folder for all the github files, should we move it there? Then they wont be bothered with this jar sitting inbetween their configs?
this("Safety Command")
Why do you we need to keep a reference to the activity here? This will leak the app. We should use mEditState array instead.
Here too, you could use getTraceSet() and check its contents. That way, you wouldn't need the 'experiment' field at all.
Here and elsewhere, the Fragment probably shouldn't force the host to do things by getting its internals and changing them. The dependency on a toolbar is clear because of the callback pattern but exposing the toolbar directly allows any Fragment to change it. It's ok to defer but consider pushing onSearchOpen() into the host and allow it to hide / show the toolbar.
map(Queue::getActualName)
2 columns
would it be handy to also print out the other constructor argument fields here? (serializers in particular, not sure if the times are that interesting)
nit: No need to print out organizationDiscoveryIntervalMillis.
why is this public?
This is wrong. While yes, the "return true" could be made static, this is inherently meant as an instance method (thats why the TODO). We could either give it an instance field with a fixed value, or suppress the warning here...
log exception
Just return checkNotNull(id, "id").split("/");
Does this need to be a left join or would JOIN FETCH be sufficient? I don't think there would be an entry in this table if the association wasn't there.
why delegating
I would delegate to the new method directly
You can do this instead.  proxyPorts.stream() .map(port -> "localhost:" + port) .collect(Collectors.joining(",", "terracotta://", ""));
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
What's the point of adding a copy here?
In my personal experience, I've found that it's idiomatic to write this sort of code as either: java // Imperative option Map<String, Object> map = new HashMap<>(); for (int i = 0; i < accessor.size(); i++) { map.put(Integer.toString(i), accessor.get(i)); } return map;  or: java // More functional option return IntStream.range(0, accessor.size()) .collect( toMap( i -> Integer.toString(i), i -> accessor.get(i)));  But as I'm unclear on what the JUnit 5 team think of creating maps the way you've already done it, I'd wait for feedback before changing anything. :)
Missing the substitutions for the {}'s. suggestion LOG.error("Failed to parse value of system property {}='{}' to an integer. Using default value.", sysProp, val);
See ByteByReference.java
java value.trim().isEmpty()  would be more clean IMO rather than java value.trim().equals("")  WDYT?
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
i think we had talked about swapping the order of these so we can short-circuit?
You don't need this as compareAndSet will set it to true.
add: import org.ovirt.engine.core.common.utils.Pair;
I feel the call to super() is not required, as it is always done implicitly.
Shouldn't the FBOs be disposed here as well, when they are created here?
Can check isBlank()
nit: Root groups cannot be fetched from the database
You should use the annotations field here too, not the wrapped reference.
I think you should use .trim() rather than a regular expression; this will be more robust and clearer as to what it's doing
nit: I personally prefer existing out on error conditions early, to avoid over-intentation: if (getSuppressed == null) { return false; } try { ... } catch (Throwable e) { return false; }
why are we changing the visibility of these methods?
remove empty line
Could you avoid these awkward blocks by making numerator and denominator an AtomicLong?
I assume this function must only be called if the service is activated. EventPublisher is a mandatory reference, so no need to check for nullness.
Check command and status null.
CHANGE it to TypeConstants.JAVA_LANG_RECORD
1. are we showing what we observed or we expected? it looks unclear to me. 2. given that this is only used once, is it better that we just use assertTrue in l.108? 3. static?
The logic has not changed here, it is just a refactoring, isn't it?
Why to call finish?
%n
you can use instead: return Version.v3_5.less(version);
I assume this lazy initialization should never happen as we will always initialize this field in class constructors, agree?
Should we include organization here too?
Again, I think this should evaluate against the standard special path info, not the stuff for the maven package
use hasNext instead of contains (do not use toIterable() we want to check Iterator)
Shouldnt we have this defaulting to the common namespace (ICommonAttributes#COMMON_NAMESPACE) so that we can tell the user what this defaults to?
Since there are two places using "tree-item", consider replacing it by a constant just like you did on the other classes.
why not with stream API? will be cleaner
please remove else, code will be more readable
Collections.addAll(this.features, features) can be used instead of for loop
Will this always be this value?
Shouldn't this come from the builder?
could be (o instanceof Map) || (o instanceof Group)
After checking how MimeBodyPart is implemented, it might make sense to tweak this to:  java return String.format("%s; charset=%s", mimeType, MimeUtility.quote(charset, HeaderTokenizer.MIME));
> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
Might make sense to call setBaudrate here just in case the default changes in a future version.
@lautarobock what this is for? there is no super class
FYI, TimeUnit.SECONDS.sleep(seconds.longValue())
there is no need to execute initElements method, when you're extending BasePageObject
The name is now no longer accurate. Maybe don't replace the line delimiters inside this method.
Help me understand the change below more. The one on the left seems simple.
Not sure, why not use @NotNull?
extract getVmDao to getter
not need for 'this'
Can you please remove this line from assertResponse and place it for example directly to test methods? It is a side effect and is unrelated to meaning of assertResponse method - according to its name I would expect it just to check response, not setting some method variable.
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
returning boolean type is useless here because it can only return **true**, or throw timeout exception.
Now it can be simplified to Set<Set<SchedulingExecutionVertex>>.
Please copy args here too
Is this not needed anymore?
{ }
Is this important? Should we throw instead? Or just make this a debug message if it's not important? (same for seek)
It might borderline overkill, but I'm considering if we could avoid the copy here with logic like the following:  if (!groupSubscription.isEmpty()) return groupSubscription; else return subscription;  Basically relying on the the group subscription being a superset of the local subscription when it is defined.
we shouldn't need the ?test param any more
can we make this one configurable?
I meant this constructor should be private. You made constructor of LdapObjectDefinition private. Actually both should be.
Remove this
Raw type List
Can we rename sizeInBytes... not to confuse with the size of the list...
I would add a check here: if the ID contains the suffix, throw an IllegalStateException or InvalidParameterException, otherwise, there's a chance that you'll have an ID like abc-client-client, which is never appropriate.
s/B/b/
nit: I don't think you need fully qualified path name. it can just be CompletableFuture<LedgerEntries>.
This doesn't have to be public. Just use default package access since only thee cache impl in this package has to see it.
This methods should return the index of the max/min axis: x = 0, y = 1, z = 2, but it would probably be better to remove them from the interfaces.
Inline this
can be simplified with return value!=null? value : defaultValue?
Call to default super() constructor is implied. This is only a question of style, but it make my eyes hurt... Feel free to ignore.
![INFO](<LINK_0> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_1>](<LINK_2>
while you're at it, you can remove the thises.
nit: you can merge both lines above as checkNotNull will return the given argument
I don't see much point in making db lazily created. It's not an expensive operation.
These look wrong - the end times are being set precisely - so shouldn't the updated value be 1500000?
Should close kill the memspace? What if someone want to reopen the key?
Again, why nullToEmpty?
Might there be upper or mixed case "csv"?
Seems that this change is wrong (I suggested it - sorry). Also DistinctCountBufferAggregator could extend LongBufferAggregator
You can make this method private
instead of addAll(), you could just return the free vars from the definition. Same in VarDeclaration
single quote '/' and remove //$NON-NLS-1$
Isn't this just type instanceof Class<?> && ((Class<?>) type).isPrimitive()?
We can strip this down quite a bit to just java this.eventReceivers.forEach(EventReceiver::close);
this.lockVerbs (like below)
"You do not have any tapes"
same thing, while you are cleaning, other thread could store other key.
I suggest encoding the above 4 assertions in a single call: assertEquals(ImmutableMap.of("1", "hazelcast", "2", "phonehome"), map);. In general it is a good practice to check the expected output in one assertion, instead of checking its pieces separately. Also, in these assertEquals() calls the expected and the actual values are mixed up. First should come the expected, then second the actual. Of course it works this way too, but if the assertion fails, then the output becomes confusing if the expected and actual are swapped, so it is useful to always put them in the correct order.
it is not better to use Clock.systemDefaultZone() instead ?
off topic: I've been writing this as "client == null". I think this conveys just as much information in fewer characters, so by Shipley's law I should switch over. The drawback is that "client == null" is a boolean expression, and is consistent with "limit < 0" etc. . .
normally we use italic text for info icons like this: numaInfoIcon.setText(applicationTemplates.italicText(message));
Change to unmodifiableSet if we switch to a set. suggestion return Collections.unmodifiableList(tags);
as is in 718
SecurityException?
you can add log() method here for easier debugging
So is there value of having a whole class that just does such a simple thing? Perhaps a static method in a utility class is easier and adds less to the heap?
SpeedController not CustomSpeedController
This is an anti-pattern. Use a StringBuilder instead. Why not comma instead of |?
Will you expose this in JDBC too? ( <LINK_0> )
Why is this required? The test you wrote fails when I don't apply the change on PrimitiveType, but doesn't fail if I don't apply this.
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
Can you explain the why we have chosen to use synchronization here? Should we only allow single thread to execute the close method on dataStore? Should we use isClosed similar state variable as we did for init(). If there s a possibility of getting this method cleanup() by multiple threads, anyway these threads will execute this method sequentially. Since in dataStores, we have handled the close method, even at multiple calls to close() will just try to close the already closed dataStore, it will just log and handle the error over there. Is there any cases that we need to propagate DBException exception to higher layer? Since we dont propagate or throw exceptions at dataStore.close().
Minor typo in error message (should be "has" instead of "as").
this leads to a dialog that has the order of "OK" and "Cancel" inversed (most dialogs in Eclipse have the opposite order 1. Cancel 2.OK): ![image](<LINK_0>
This should be doable with Allele::basesMatch without converting the allele and the transition base to Strings.
Out of curiosity, why is the return type of this setter not void?
I wonder if this method should take the check one step further and verify not only at least one location provider is enabled but also that LocationManager#getLastKnownLocation(provider) returns a non-null value for at least one provider?
are you sure we need to use OSString ?
It is perhaps just my personal meaning, but we could drop the call to the default constructor of the parent.
I would use log.infoFormat since it is the standard way. Also, I think logging this at info level is too verbose, this sounds more like a debug to me (and if someone wants to monitor this query specifically he can lower it's log level)
Meh: you could use rs::close instead of a lambda. They're semantically equivalent--I just like the way method handles look. Not critical for merge, obviously.. :)
Don't need this keyword here - the rest of this code only uses this when necessary.
bad hashcode.
any reason for explicitly invoking super.toMap() ?
**USB**
Shouldn't this close the iterator before returning the list?
why are we changing the visibility of these methods?
If it is then do what exactly? If we don't want to do anything do we need this if(..) block at all?
consider merging both lines
Newline after the close brace
Add PageLogging
it's better to throw UnsupportedOperationException when something is not implemented yet
Windup/Discover/Java ?
It seems Math.abs() is missed. What about negative values? And also please, add {} arround the procedure.apply(...)
Maybe take the opportunity to set index = null here?
assertEquals(Foo.class, foo.getClass()). The produced Foo is @Dependent and so there is no client proxy and we can be sure the instance is the result of the producer method.
style nit: no braces around single line blocks
Let's transform message to string at once, not in the getter.
I think configurable makes sense
Session.of is particularly usefull when you don't know the object
This will fail if the testCreateRole test fails. Better leave the assertions for the tests, not the tearDown methods.
not sure if there's a reason for removing the parametrized type MarshallingResponseBuilder<T>, see that when setting the messages you loose the type. The other methods state, addMessage, and resout has the type.
why gone?
Given that this method is already dedicated to the audience claim, this change is redundant. Please rollback
foreach
Let's add a ctor for FeatureFlagBuilder(FeatureFlag f) and then make FeatureFlag immutable.
@ikhvostenkov again json, maybe this part with mocking MemberProfileJson and adding when to it could be moved into single private method that would accept just the filename as a parameter.
I think that this is not a clear way to reset values to default - I think, that there should be something like: System.setOut(System.out);
Lets use the previous cleanUp method as discussed.
should the second arg be true here?
the put will remove the previous mapping
Mark as static.
Is threads.isEmpty() necessary ? I think the foreach loop can handle the same case.
I believe that other implementations are either returning an actual String representation of the operation, or the result as String. Could you double check that?
Why change to this?
Use getLineNumber which already has exception handling.
This is not time zone?
I feel like there could be a race condition in this parked boolean, basically where it was false when we checked on add task, and then flipped in the run function, causing a task to be stuck in the queue w/o running it.
Should we add: Objects.requireNonNull(record)?
the logic would be simpler if you just delete the key for revoked when is null
+/- 1 confusion: suggestion this.startDistance = start;  that was the last one.
Since the servie is no longer set at contruction time. Wouldn't it be possible for this value to be undefined? If so, service variable should be checked.
1. Did you mean support only Firefox for _testing_ right? I assume the difference in behavior affects testing only? In that case we should keep the production code clean and apply any workaround in the test code. e.g. do an if-else based on WebDriver. 2. Yes, I think at some point we stopped using Chrome for testing. There are many other quirks between the two versions that gets in the way of comparing html. We can check if anyone is using Chrome.
This looks like testDataFormat(COMPONENT); Please see other tests for sample
why not use a constant for that?
replace with fType.add(DescriptorType.STRING); the idea with EnumSet is that as you see values you just add() them to the set, without having to care for the current contents. Then when reading you can check things like contains(), or the utility methods like isNumer() proposed above.
This will create a new object every time the method is called. Is this wanted? If not it'd be better to store the object once and always return it (static field).
It is not, this change should be reverted.
Preferably have one call the other?
You should throw a WebApplication exception with a JsonError as entity for the client to receive a valid JSON.
This should not be on fields as this is custom-role-mapper specific - not related when used as mapped-role-mapper in subsystem.
I think it's customary to add the encoding; UTF-8.. IIRC @psiroky went though the codebase a while ago adding missing encoding... might be worth checking.
should we have Objects.requireNonNull in these?
May I suggest this?  int i = url.indexOf("/#/"); return i == -1 ? url : url.substring(0, i);  It only searches the string once, and more important, doesn't duplicate the search argument.
Would prefer a tighter check here. As-is, setting to "no" or "FALSE" or "false " with some whitespace would make the coordinator be an overlord. How about throwing an exception if the property is set, but is not "true" or "false"? Or, at the very least, log a warning.
ProcessHolder is an internal class, which is not meant to be used by plugins...
Is forEach better that putAll? I suppose we also need to take care of the case when params are null.  if (params == null) { namedParameters.clear(); } else { namedParameters.putAll(params); }
I see some improvement can be done here.Is it required to define method as synchronised.Can we use ReentrantReadWriteLock and get write lock here? It will be resulted in performance improvement
EINVAL is expected for FileDescriptor.out / FileDescriptor.in. This is only expected to work for descriptors to "regular" files, and won't work if in / out are pipes or sockets (which they are, in some configs. The man-page uses weasel words to say this "EINVAL... or an mmap(2)-like operation is not available for in_fd,".
please use NotImplementedException()
minor: change SocketNetworkClient to LocalNetworkClient in line 98 and 102
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
Shouldn't this indicate the container element node somehow?
I'm still scared something stupid not using result = ~~result in your hashCode implementations.. but if you're happy.. then.... you'll be the one scratching your head _if_ the JIRAs start rolling in about V&V going crazy after a while..
This can be replaced with  java return newName.isEmpty();
You can write this shorter: int size = Math.min(raw.length, FIRST_FEW_BYTES);
it would probably be more appropriate here, since this is an async command
In success response you return json, but when fail - trying to return plain-text. It is not an good idea
I believe the order is guaranteed in partitions by the sort order of Partition which is on the partition ID.
Note that it would be clearer for this to be marked protected: the class is abstract so this constructor could only be called by subclass constructors.
rename to go.redirect.stdout.to.file
With Pin&Clone, you can press 'Z' in a view that shows trace1 but the active trace is trace2. There should probably be a method in the interface, and let the view implement it.
You should also return the value of GridQueryProcessor.idxCls to null (in case startGrid fails)
Suppose makes sense to convert value to lower case before comparing.
Shouldn't you be calling setParam("property." + propertyName, value) to be concise with distro.properties?
Neater: String.valueOf(value);
This looks like something Jack might optimize out (we're still using dx for Checker tests). Could you acquire the nulls through an inlined method and test the later constant folding? That seems more future-proof.
Same question about losing all precision here instead of during formatting %.1f
Why not extract assertThat... into separate methods: assertRoutingKeyResolver for example. If the requirement is not fulfilled, a message could be provided to be used for an AxonConfigurationException (I would argue that we could use the same message for both purposes: invoking the build method and validate method).
Should probably remove(key) if value == null.
throws RestApiException not necessary.
Please change to externalSearch =
Use Sirius logger here.
change to arg
Add reasonable toString() method, returning null doesn't seem as proper way.
please replace with verify(adminDAO, never()).executeSQL(anyString(), anyBoolean());
Add requireNonNull for lifespan. This add call will throw a NPE in that case.
I think you want to call the new method which gives servers based on glusterPeerStatus
Calling System.exit needs to be carefully controlled or it will break embedded usage. "Quitting" an embedded CLI may not mean the user wants the embedding app to exit. On the server side we do this by using a SystemExiter interface, and all "exit" calls use that. We then swap in different impls of the interface depending on how the server is being used. The standard impl that is used when we know the server was started from the command line calls System.exit. Others do not.
Vered - Good catch. s/proceeded/processed endAction is being handled only when all tasks for the entity were completed (actually, the usage of the word "all" here is not 100% correct, but let's not get into corner cases :) )
As above, I'd use String.valueOf here.
that class would be better with a builder, though I wouldn't ask changing it now
shouldn't actual <--> expected be replaced here as well ?
FileNotFoundException is a subclass of IOException
I'm not sure about the method name though. Why not "build" like in the state system analysis? Or "buildAnalysisSegments" for more clarity. After all, it is called only if it was not previously saved on disk.
Maybe this will already be immutable. And a list.
Call to default super() constructor is implied. This is only a question of style, but it make my eyes hurt... Feel free to ignore.
or maybe use key.replace("attributes.", "") WDYT? Is it be more readable?
I assume these are no longer throwing UnsupportedExceptions because split is something we want to hide (e.g., not have users worry about it at all and make it a no-op)?
@Before / @After could overwrite System.out :-P
Can we throw the explicit exception not generic?
throws APIManagementException
why is this public?
Can you make this somewhat more Guice specific? E.g. guice.stage or inject.stage or something similar. Guice is probably not the only thing that can have a stage
Let's have constructors one near another
This syntax seems way more clunky
synchronize
can builder even be null? if not, it is just getSslBuilder().build(), or in-line it.
I think we shouldn't allow it to be null. This should be @NonNull, same goes for field value as well.
setConfig too?
Debug stacktrace leftover?
Java does not contain the keyword null.
I don't like this arbitrary limit of 400. Instead, I would check whether the index of the last visible line is lineCount. How about: public static boolean isShowingEntireContents(StyledText widget) { if (widget.getTopPixel() != 0) // more efficient shortcut return false; int lastVisiblePixel= computeLastVisiblePixel(widget); int bottom= widget.getLineIndex(lastVisiblePixel); if (bottom + 1 < widget.getLineCount()) { // There's definitely more lines below return false; } // Check whether the last line is fully visible int bottomTopPixel= getLinePixel(widget, bottom); int bottomHeight= computeLineHeight(widget, bottom); return bottomTopPixel + bottomHeight <= lastVisiblePixel; } That should also be much faster since it would at worst compute line heights for the actually visible lines, and it doesn't need any arbitrary magic number.
"cwl" should be DescriptorLanguage.CWL.getShortName()
I recommend using Collections.emptyMap() instead
nit: can you put "File connector started" instead?
Same as above, please move this line under the SetViewport line and add an empty line after it.
You can use FiltersHelper.Constants.HEADER_AUTHORIZATION here.
It seems that we are no longer required to pass the session Id to the event?
Thanks for adding this!
nit: make this final
It would be great to have braces around.
Do we want to include the original throwable so it can be shown in stacktrace as "caused by"?
@paulodamaso the braces and return are not needed here
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
This fragment is similar to the one used in generateFeedbackSessionEmailBaseForInstructors so it would be good if you can extract a method to generate this fragment or use some sort of html template to generate this string to reduce the repetition.
use return ... ? ... : ...?
Can we set a charset? Like ASCII or UTF8?
You can call this.setTimestamp(timestamp) from here.
The extension itself is added as annotated type? Should this be the interceptor type instead?
Please add a check for the return of the add method to ensure that the element was added to anchors.
not needed
Let's not revert this code. The whole "release as an object" thing needs to go away, not be compounded. If this is causing difficulties in your code, let's discuss them and figure out a way to work around them such that we're cleaning this section up rather than doubling-down on the wrapped version string paradigm.
This does not need to be public. Instead, just pass the builder to the private constructor. See what we do in HtmlRenderer.
same with the return code here, you could return a boolean to indicate success/failure. the user doesn't have to use it, but the API should provide this info. Res: Done, a return type of boolean to indicate success or not
Why use a full-name import here? I don't see any conflicts.
final
Why not iterate over entries and call their toJson methods?
... that way when accessing them from the class we won't need to use "this." for example fString = string vs this.string = string
Please restore the original formatting.
Do you actually do any heavy lifting here that needs to happen in the background? If so, why do we still do controller.init() in connectToPlaybackService() which definitely is executed on the UI thread?
I think you should pass the numCompletedIterations to the last parameter of LOG.log().
Why U don't want to consider id in equals and hashCode ?
Please make it if (attribute.getValue() == null) return;. I'm not sure, that matcher.matches() would work on null value, also for cycle would fail on NullPointerException. Also, we do not usually catch ClassCastException, it's up to you.
Could you replace the sole use of Guava's Files in this class with java.nio.file.Files.copy() and then avoid fully-qualified class name?
Use the API method and pass all given ids as ListInstancesOptions.
Use a function in the enum for this, don't use this if case.
Thank you for calling out this!
Can be: java return ByteBufferImpl.create(b, offset, length);
Can be transformed into an if statement.
checking for nullable parent was added specially, cause going into project node simply has no meaning
- log warning that option is not supported by SNMP
Add Gst.checkVersion(1, 16);
Why is this behavior changed? It used to be NOT waitForWrite, but now it waits instead. Is that true?
could we change to List<Properties> or is this API fixed?
It's Comparator.naturalOrder()
just use getEnvironment()
As an aside, you can pass a boolean here. Also in content values. They get converted correctly. No need to change it though
I this refactoring, very nice. Could make this method protected.
delay is already completed.
Would be great if we can check if the envelope.getOffset() is not null.
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
By using the above naming convention, we no longer need to use this. to disambiguate which variable that we're referencing.
change it to log.error
should this be in a finally block to release in the case where an exception occurs?
ctx.close()
optional: consider returning this from setters to support chaining configuration.
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
Please move to a separate "Polishing" PR.
try block.
not needed
Better to return "";.
I wonder if we should add a new HTSGET type here. The Type isn't really used anywhere that I can think of, but it seems weird to say this has the index extension ".bai".
Needs some sort of assert to show it succeeded
Maybe [] instead of null in order to avoid NPE or check?
close already done in Util.read(..)
This same as next test in terms of logic, since you're not actually testing the "default" min range is used since a min range is set on the annotation.
where did this go?
"isSearching" should be a class level string
requireNonNull
final
0 is a legitimate option value for min. selectable choices. Why not -1?
No idea why, but the loaded_template entry on quality gate has not been removed on my box
Need to declare the adapter type here, too.
Should seconds(1.1d) return me a duration of 1.1 seconds? Or are we happy for it to return 1 second.
This check is useless as the customParams can never be null.
this implicitly strips grouping and other properties too, yes?
I suggest to keep validation in the setter for now. Something like this:  java if (token != null && !token.isEmpty()) { if (!token.matches("^[a-zA-Z0-9]{16,}$")) { throw new IllegalArgumentException("Illegal token"); } this.token = token; }
Can't this NPE as they're Booleans (i.e. objects not primitives)
Why not java static Builder builder() {  ?
java && SCMTriggerItems.asSCMTriggerItem(job) != null && job instanceof ParameterizedJobMixIn.ParameterizedJob  :bug:
log.trace
This plays the current, not the next station.
it's better to init customFields with an empty collection to avoid "==null"
Moving that bits above and allowing the user to change the decorator via a public setter means you can completely shadow what AbstractTransactionSupportingCacheManager used to du using public API. Also, if CacheDecorator is a first-class concept, you should probably expect that more than one decorator can apply at a given time. This wrapping shouldn't be the responsibility of the caller.
This code changes the existing functionality. If accessTokenResponseClient is null, clientCredentials should still be enabled. Please add an else statement containing authorizedClientProviderBuilder.clientCredentials() to ensure clientCredentials is enabled by default.
The whole if (request.getToken() != null) block should be removed because this check is now done in InMemoryMessageExchangeStore.
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
I see some improvement can be done here.Is it required to define method as synchronised.Can we use ReentrantReadWriteLock and get write lock here? It will be resulted in performance improvement
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
True. I've never seen a case with -1 as the default. 0 has special meaning in the JVM, so best to stick with 0 as the default and adjust the size to cope (add one or size 0 -> -1)
This line is probably not needed at this point.
unsubscribe()
I think that with this logic it is possible that: - hyphen become the first char - hyphen become the last char Those cases are forbidden in hostnames.
transactionId should not be null. Add a null check here.
@Override is missing - propose to mark class OneTableJdbcKeyValueStorage as deprecated - it is not used any more
Well that's a bit dumb :/ Ah well.
Throw an unsupported operation exception here.
ParseUtils.isQuoted would be good for this.
This doesn't need to be public it can be protected.
Should this use the test.blobstore.await-consistency-timeout-seconds property like BaseBlobStoreIntegrationTest?
You should throw a WebApplication exception with a JsonError as entity for the client to receive a valid JSON.
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
Can we set a charset? Like ASCII or UTF8?
I would really appreciate if you rewrite this so it doesn't use -1 as startIdx. A year from now I won't remember why we want to load from position -1.
DRY: would use this(username, password, null) instead
suggestion assertSignalEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);
UnsupportedOperationException seems reasonable here.
go inside the lambda body
copyOf does not necessarilly copy (I know name is misleading). Also we value readability, and old version is way more redable than the new. Finnaly we prefer relying on guava's collection. So I disagree with this commit.
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
GlobalDroneFactory is no longer loaded via SPI, so I should not registered.
isErrorIfHostDoesntExist => isNewHost
Should emit list of values, using setDimension(String, String[]). Also the dimension is called "dataSourcesAndDurations", but only data source names are emitted. Also if this change is done, getMetricName() method name will become confusing.
To always be safe please use context.getApplicationContext()
remove this. The formatted strings are the same, you can write a method to do the formatting.
not seeing the Locale.ENGLISH setup, also exceptions are not handled. is this intentional?
Spacing is off
why this is in vmCommand? should be in stopBase command
Same: static import lightGray from Color?
should just be return supplier.f(). In FJ we do not special on case null imput value: protecting each input parameter against null would litter the code with garbage, maybe also impact perf and, in this case, hide root issue by propagating a null value. Only dedicated APIs like Option.fromNull explicitly deal with null.
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
Both lines dealing with the provider should be moved together, following the usual pattern: if (x != null) { x.dispose(); } x = null;
Mmm actually I spoke too fast, it still fails on the command line...
if you do it [here](<LINK_0> the this cast is not necessary
we never use NULL, it is a bad practice in general.
You forgot to add the address to the toString() as you did in the patch on the master branch
Optional.ofNullable could be used?
hope it will works here as well for this class
Style fix suggestion public long getIgnoredPlayerTimeout(UUID uuid) {
it's better to start this method name with assert verb, as that's what happens inside
I think we should rather check verify(verifierWebWorkerConnection, never()).activate()
hmm, that method makes somewhat sense in core java, but I'm not sure I like that behavior for selendroid. We're expecting a boolean value, but essentially we only care about either true or "true" coming across... everything else is false. Is it going to be confusing to any users? I'd almost rather add an additional else clause to check for the string of "true" or "false", otherwise raise the exception. Since users of other programming languages (like javascript or python) may have a different impression of what a truthy value should be.
maybe log an error message here if numConnections ever goes less than zero
Missing codes.
Assuming this is noting completion of initialization, perhaps "Finished initialization."
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
I don't think this is atomic.
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
BlockPos.ORIGIN
Is there a reason why this. is used for calling the setter in all the constructors?
How about setup(Long.MAX_VALUE)? 0ms timeout only works when we use wait(timeout) for checking timeout.
Should also have tests for strong with preceding character content, and following character content. (those are areas where we've had troubles before)
Personally I prefer to set all fields using this. in constructors, but you call the shots.
uriHost is already a String. No need to call toString() on it.
Here and elsewhere, the Fragment probably shouldn't force the host to do things by getting its internals and changing them. The dependency on a toolbar is clear because of the callback pattern but exposing the toolbar directly allows any Fragment to change it. It's ok to defer but consider pushing onSearchOpen() into the host and allow it to hide / show the toolbar.
A non-void @Test method? I did not know it is valid. Not sure what the intent is though...
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
Symmetry (throw)?
please also add the GUID which is important.
I assume this lazy initialization should never happen as we will always initialize this field in class constructors, agree?
Double* variant of this class uses object == null ? null that is better
Why is list necessary? The number of elements is passed, so array may be allocated at the beginning, it is not necessary to rely on ArrayList to determine the final size of the array.
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
Should be a SamzaException with a message, not NPE.
This class is not thread safe. Using synchronized here is unnecessary and I think it is also misleading.
On Android 8 (emulated), this still does not work. When pressing the contributors, you have to press back twice. After the first press, the webview does not load the main about page again (does nothing). If you use the actual url ("file:///android_asset/" + webViewData.toString()) instead of about:blank as the history parameter of loadDataWithBaseURL, you can remove the depth variable (I think thus is the most elegant solution).
why the leading { ? typo ?
use hasNext instead of contains (do not use toIterable() we want to check Iterator)
This should probably be java if (CliLogger.ROOT_LOGGER.isTraceEnabled()) { if(satisfied) { CliLogger.ROOT_LOGGER.accessRequirementSatisfied(toString()); } else { CliLogger.ROOT_LOGGER.accessRequirementNotSatisfied(toString()); } }  The toString() may be expensive.
It turns-out this is not permitted. I now get an IllegalArgumentExcexception, saying high watermark has to be higher than low. I will add a small high watermark buffer, then.
good practice: usually actions go before WS as they are injected into it and so they are grouped together
Nit please alphabetise.
put the uuid of any identifier source associated with a log entry
It's not wrong, but it would be very nice if you could use the logger messages embedded in the _Log_ interface? So here you would have:  log.redisStopping();  Which allows the internationalization team to translate it or redefine the logging level.
Please do *not* leave authorization turned off across test methods. This can result in unexpected behavior. It should only be temporarily turned off to create (or delete) test content.
Is it done by a purpose that error thrown by activityDao.findExpired will prevent launching checkActivityRecordValidity ?
getUsername().isEqual() make the same thing ?
would be nice for the 4 to be a constant for readability
I think we should assert two more things: 1. The value of getMillis() and getDecimalMillis() is the same. 2. This is the *correct* value (i.e. it's the same as cal1.getTimeInMillis()).
The last null is interpreted as a null Flag, not as a null Flag[], and is causing some NPEs in the test suite: <LINK_0>
for consistency with other classes, use Objects.hash()
This should be part of the try-with-resources block.
would we need the lock if we used a ConcurrentHashMap and LinkedinBlockingQueue?
This supplier is potentially called twice, so the same data is fetched from the DB twice. It would be better to use MemoizingSupplier here.
pls. use Collections.emptyMap() instead.
entryId is not used, please remove
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
The options are now rebuilt on every call. Did you want to leave the door open in case we ever need an option that would change for every new connection?
s/Mac pool/MAC addresses pool
Is there a reason this class is doing this through lazy initialization instead of a BeforeMethod/BeforeTest like the other classes?
should be refactored to call detach. also isEventsEnabled should go away.
ConfigurationImpl_toString = Node configuration: {0}\nEdge configuration: {1} MessageFormat.format(Messages.ConfigurationImpl_toString, nodeConfiguration, edgeConfiguration);
nit: throw new RuntimeException(e); so if this ever happens (unlikely), the error will be more obvious in the test
what about case clearTable = true and clearZK = false
Does this need to be a singleton?
@rakeshadr is there a potential race here between setting the shutdown handler and checking if it is null?
This is easier to read as: return type.getClass().isArray() || isList(type);
I think this method can be private?
I wouldn't call classes with invokedynamic bootstrap methods "utility classes" :smile:
you can either remove else or add pair of curly brackets
Minor suggestion to change this exception to:  throw new IllegalArgumentException("g may not be null.");
How about directly returning the result? java return this.name.equals(a.name) && this.airport.equals(a.airport);
Qualify this.uri
Maybe do a null check.
do not assing parameter! nowhere!
Assertion seems to be missing?
Need to declare the adapter type here, too.
Why do the containsKey check? If its not in the map, then get() will return null.
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
I believe this method should be private
This can be static.
Shouldn't appId and SecurityToken values be URL-encoded (or any URL parameters that could potentially contain illegal characters elsewhere in this source file)? I see the default app ID has / and + in them, for example. The appId might be only accidentally working at present.
The code can be simplified to rely on autoboxing.
Collections has a singletonList method.
This is a bitwise OR ... shouldn't this be a boolean OR (||)?
A possible problem with this is that it relies on the zoom thread, and you might have an implementation that does not use any zoom list or thread (could override createZoomThread() to return null). Also, it's not clear what value the flag should have if you have completed the zoom with an empty entry list, or if the entries are all filtered out. Does it work if the build thread has done a first iteration and called refresh() but hasn't discovered any entries yet?
are you sure this should be a part of the backport?
should we add lookupCacheSize to runtimeShape?
I'm assuming this constructor is combining the two maps? If so, didn't we just get the jobCoordinatorZkBasePath from config? Do we need to add it back again?
can be !isDisabled()
This method can be implemented as return a - b;
This is another behavioral change that I don't want to see in an unrelated PR.
To improve, I think .warn is better.
Better style to revert and remove the static import.
Is it possible that there is no ACCEPT_ENCODING header in the request which would lead to an NPE here?
this.monitor to avoid confusion with the parameter of the same name optional: this whole block could be a ternary: this.monitor = monitor != null ? monitor : NullProgressMonitor.INSTANCE;
Why is this loop necessary? Don't you just need to click a single element? However, I could be wrong since I'm not 100% sure what is being checked.
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
log() here and after
Feel free to ignore: Do we really want these this there?
Should this do something along the lines of if (optional.isPresent()) throw new IllegalStateException(); in case it accidentally gets used with > 1 value ?
Symmetry (throw)?
Is this still needed? We don't add any other elements, so parent.get(anythingElse) should return null anyway.
This method should probably be synchronized.
i'd add "perform"
@Override should be on line above. Checkstyle/formatter config?
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
Operation getOperation() ?
purge takes too long, just delete
nit: if (p != null)
this whole method could be a oneLiner: return find(...) != null
Same as above: .getAllOfTypes(new VDSType[] { null });
Please add a new message to CommonApplicationMessages, instead of creating the message in code.
Maybe its just me, but this calculation looks wrong, since we are assign a = b, then b = a % b will always be 0, since a = b. Shouldn't it be: long c = b; b = a % b; a = c;
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
The implementation is the same as in HostNetworkQos, please implement in HostNetworkQosProperties.
IntermediateDataSetID has a param-less ctor I think.
Do you know anything about the expense of these methods? Will these cause RPCs to namenode?
> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
Why return a value if you don't use it when you call the method?
Why using a temporary file for reading the test dataset?
This seems like a good use of ordinal since it's lifetime is expected to match app session.
No parens on condition.
@ivanursul, I think this should be as it was... The idea is to be able to import a strongbox.xml if one is on the path, or specified as via the parameter. If there is no such specified (and there is no configuration yet in OrientDB), then load the one from the classpath (available in the strongbox-storage-api-resources artifact).
NIT: else Logging or IOException
nit: you can do mLGNames = Sets.newHashSet();
an expensive way to check if it exists ... if there's no other way, then this will probably do
Since you're already using Guava, consider using [throw Throwables.propagate(ex)](<LINK_0> here instead.
assert name != null;
you don't need this function, you can use constructor directly
suggestion return defaultIfBlank(inputStream, name);
check if it started here.
I see some improvement can be done here.Is it required to define method as synchronised.Can we use ReentrantReadWriteLock and get write lock here? It will be resulted in performance improvement
scheduleTimes --> scheduleTime
Ccan we default to a more modern version?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Not useful to have the monitor in field, you can pass it directly to refreshContent() in parameter as it will be useful mainly for the refresh
"RuntimeException" I guess this is leftover of copy-pasting from other issue. Please correct here and below.
synchronized block is not needed
This could race with the emission of run().
To always be safe please use context.getApplicationContext()
Its more specific you to create a mock of the message and then if the managementNode gets a schedule call with that instance to return the number. any() should be used in the case when the parameter can be variable things or its not specific to the test case you are checking.
Null check for leaderElectorListener
Same here, this method return void because we don't want to have nuxeo-java-client outside this class.
throw UncheckedIOException(e)?
This is not testing the frontend.
style nit: we don't use braces around single line blocks
Ok if already stopped? idempotent?
Why are we configuring drawer in this activity. This activity shouldn't have it.
Unnecessary cast.
Usually we don't pass / accept nulls. Please either use Optional, or better just simply pass the TuppleDomain.all() predicate.
should this be in some MathUtils class?
No need for super()
Minor: This message would sound alarming in logs. Possible to add more context here about what might be wrong?
Add SubChild here as well, perhaps SubChild is just persisted as a Child currently..
The status of the pre-defined hook in fixtures.xml is already ENABLED. So maybe you should update it to DISABLED and verify the same. What I do to make such tests easier to read is, first fetch the current status and verify (assert) it, then update it to a different value, fetch again and verify the new value.
If you have a translation use that if possible.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
<LINK_0>
So... what's the purpose of this...?
IntelliJ IDEA tolds me to remove this unnecessary boxing.
good catch, the missing job name was resulting in quite a few unnamed jobs in the progress view - reported by QE, found out via jstack what it was
-> RuntimeIOException
I do not know much about databases but whether this method is properly constructed? My Eclipse returns "This method must return a result of type boolean" and I can add return for firstRun of false.
Inside finally?
Why do we need to check for null here?
Exception is never thrown
typo: of -> or
return (splitTime < fTime + fDuration ? new TimeEvent(fEntry, Math.max(fTime, splitTime), fDuration - Math.max(0, splitTime - fTime)) : null);
can be !isDisabled()
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
I think I'd rather store the instance as a field than to have to loop through the projections with instanceof attempts? You can easily store the EntityInstance during populateWithEntityInstance.
How about using constant COMPRESSED_BUFFER_SIZE here?
oldValue should never be null; otherwise the merge function wouldn't be called. So, just use a putIfAbsent?
Should we better make this method package protected to only allow jackson access to it?
Put ITEM in front of OTHER_FUNCTION
Use Guava hashCode function
Not necessary to call super(). There is an implicit call to super() with no arguments for all classes that have a parent
There are now lots of different classes that provide convenience wrappers over SQL queries. Any chance this could fit in an existing one? Maybe CustomSQLiteQueryBuilder? The DAOs?
Can this be reduced to a single line?
MyTable does not support nested-projection-supported
* Why is super.reinitialize() not public? * If you want super.reinitialize() protected, this class could "open it up" instead of defining a new method: @Override public void reinitialize() { super.reinitialize(); }
shouldn't we use a setter for this?
could ringsize != -1 check be done here, will allow better escaping and inlining where not being used., e.g. avoids need to call into method below which is many lines long, and unlikely to be inlined
should be renamed to found ?
Is here not a possible NPE if getModelElementsByType or following iterator call are returning null?
nit: we've followed the pattern where the sync APIs call their next max overloads -> this sync API should call the sync API overload with Context.NONE.
Shouldn't it rather throw an UnsupportedOperationException? Alternatively, it could return new ByteArrayInputStream(buffer).
Maybe better to return null
Can you please remove the non-vm networks from networks? Maybe removeIf would be nice.
not null check would be nice here
!isEmpty ?
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
Perhaps make it private so no one will be able to initialize it outside the class? It makes sense cause regular initialization will not do much without injecting the members
Would the code be cleaner with  DetailAST node = lambda; do { node = node.getLastChild(); } while (node.getLastChild() != null);  ?
java * @param error a potentially empty error message. * @param errors the List of error messages, which @code{error} is appended to, if @code{error} is nonempty.  @damithc errors description stills seems too verbose, ideas for a better one?
BTW I think only the patch to getIconFileName is needed (cf. core/src/main/resources/lib/hudson/actions.jelly).  git ls-files -z | xargs -0 grep -lZ -- \\\(conFile\\\|rl\\\)Name\\\(\\\)\ \\\?\[\!\=\]\=\ \\\?null | xargs -0 ls -l
do we want to have actual percents? not rates as everything else is in Picard?
Can we make it 0.0 instead of 0?
boolean is never null. Please find a user where it is true.
response = instead of return?
This adds the caps a second time.
Coding conventions: Let's have the @Override on its own line please
Why exception handling removed ?
defensive copy?
I generally like to have singletons to be synchronized. ClientPrefs is only instantiated in one place anyway, and that's single threaded, so this is more of a nit.
Lets maintain the original ordering of fields: defaultNamespace, sharedTriggers, namespace. Same for constructors etc. to keep the diff smaller for generated schemas.
this(clazz, Collections.EMPTY_LIST)
log.info message is too general. When you have multiple bundles this statement may confuse you when trying to troubleshoot OSGi related issues. Instead, your message should ideally be "All required capabilities for web socket service component is available"
We should remove previous call to setOnPageChangeListener a few lines above as it will be re-set here as well.
use constant for UTF-8
these setters should not be public
Can you specify the exception/message being thrown on this call? Otherwise you could use the Assert#nonNull(T, Supplier<String>) function contained in the framework. Doesn't return the field like requireNonNull() though. :/
why is this noncompliant?
I think it should return Array here.
"name cannot be null"
While I am not denying the setter is confusing, this is not the scope of this PR to change that.
to be consistent we should introduce constant for kmodule.xml
is this endless recursion?
Hm, I wonder if "get" as a method prefix wouldn't be better than "extract". We do not see "extract" in too many API names: getSupportedScheme(Set, String). Now that I've written it do we even need "Supported" in the API name? Probably not since we pass in the exact schemes we are looking for as an argument: getScheme(Set,String) should do it IMO. WDYT?
should be edit
IMO the new function "isVlan" could be called where there is the same code to verify if the network is a Vlan, like the code above and check the files at lines: AttachNetworkToVdsInterfaceCommand (226) OpenstackNetworkProviderProxy (73) NetworkValidator (89)
style nit: we don't use braces around single line blocks
java && SCMTriggerItems.asSCMTriggerItem(job) != null && job instanceof ParameterizedJobMixIn.ParameterizedJob  :bug:
It is generally bad form in Java land to modify the fields of another class directly. You should do this via getters and setters. While this introduces boilerplate, it makes for more extensible code: maybe you want to synchronize your setters across threads, maybe you want to cache computations and invalidate them when a setter is called, etc. Most importantly, this is convention: readers of code will not expect for class field mutations to occur outside of that class, and not look for it when they are trying to understand the code.
Please add cmd.getDhcpOptions to the log message to assist with operational debugging.
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this null-check of an "Optional". [![rule](<LINK_1>](<LINK_2>
Would it also work for org.nuxeo.runtime.avro.AvroSchemaStoreService ?
Not sure why you need double quote unquoting, but this probably suffers from the same issue like the single quote unquoting above.
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
Is there any reason to add the this. prefixes? Seems redundant when the member variables are already prefixed with m_.
What's the intent behind this? Generally we want to allow this to be changed at any point. Is there something in particular that requires this with the update?
minor: you can use == here since it's an enum (or change the == RestMethod.DELETE to .equals(RestMethod.DELETE) for consistency)
You can use FiltersHelper.Constants.HEADER_AUTHORIZATION here.
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
This shouldn't declare throws Exception.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Descriptor should be never null. Better to throw exception here
Here as well, I think the two calls to this method can supply an element id.
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
how about  java private boolean needAck(Message message) { return message.getSequence() == message.getBatch().getWindowSize() }
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
probably && rabbit.isValid OR npc.isSpawned() then use npc.getEntity again
Should we log the potential error?
return Optional.empty instead of null
How about inlining it?  if (!contains(o)) return false;
spacing, code style
Prefer storing the compiled pattern as a constant for this class. Otherwise, we may unnecessarily recompile this regex.
bracket should be on the previous line
possible exception
We could probably just pass the existing ImmutableTimestampSupplier to the Scrubber - it feels awkward for this class to implement Supplier.
make "_" a constant
Should this exit after finding the first visible widget that can be focused?
not sure it is enough or not here, because we can select several nodes, but here it only try to clean the lib folder for the first selected node.
Should this stream be closed?
not so readable. looks like good candidates for parametrization
let's do it using lambda approach
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
Please change this line to: DbSession currentSession = HibernateSessionFactory.getSessionFactory().getCurrentSession();
This can lead to NPE, better to swap the check.
The path contains"/" symbol. Would that be OK?
We should return true here to ensure the menu is displayed.
I think there is a static Method on the CompletableFuture class that does exactly that
I think would be better to follow other components on how to set configurations, meaning that to configuration properties mutable and let Camel do the job of binding the parameters via setProperties(configuration, parameters);.
Better to return "";.
similar issue here. remove validation in client
I know you didn't add this, but it would be great if you could change throws Exception to throws TriangleException as it's usually best to be as specific as you can :)
It should be this class' responsibility to register listener to AmbryStorageQuotaService. Instead of returning Listener objects, this class should create the object and AmbryStorageQuotaService.registerListener(listener). This will make things simple, as the only responsibility of AmbryStorageQuotaService will be to called listener that are registered by consumers. Also the AmbryStorageQuotaEnforcer doesn't need to do anything if it doesn't want to listen.
Variable name is misleading. Maybe canUndo?
purge takes too long, just delete
change to charge_created_successfully
Then put an assert here? Just so there is an exception, that indicates that the connection was null.
I think the most likely case is that fboName is not the default frame buffer. But it's a very minor issue, so let's leave it as it is.
why not protected, use only extended
no longer used as well.
this.url = checkNotNull(url, "url");
Could use .get instead of .getOrDefault
Out of interest why do you need to do this?
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
openArticleByName is accesible from article object
simplify this
One more empty catch(){}.
I believe this assert might be better fit for all branches and the one above assertEquals("4.16.x", version); might not be needed. Thought?
is this toConfigurer needed as a variable?
Perhaps I'm being daft, is this condition backwards? Why set 'played' to false when position is greater than 0? Should it be setting 'new' to false?
I can't imagine how it would happen but technically this could throw a IllegalMonitorStateException. Maybe catch and ignore out of an abundance of caution?
If the arg isn't modified, you can use Collections.emptyList() to avoid an allocation here suggestion writeReport(output, Collections.emptyList());
I don't quite understand why this call is needed. If LazyBlocks are not loaded, the data is not read, hence no stats to update.
Here, should we return XBeeProtocol.UNKNOWN if the protocol id is not found in the table?
This needs to return a completable future, not null
how can this be null? isn't there a check in the canDoAction to block this from being null?
Here should be NOT_INCLUDE_DEFAULTS
suggestion Pattern pattern = Pattern.compile(Pattern.quote(attribute) + "\\s*(.*)");
please decrease log level to trace or better remove statement
AssertionError?
there always should be an insert source.
"This method is not actually very useful and will likely be deprecated in the future."
add Reporter.log(String.format("<br>INFO&nbsp;&nbsp; - Accepted alert <b>%s</b>", alert.getMessage());
Better to return "";.
This one needs to have context so you will need to have a method that takes an Integer object and a Character object.
Please make the constructor private to be consistent with the other controls. Instances are created via the Validation API.
Wouldn't it make sense to call setImage here? Or do we have different semantics in that method and this one?
Create a ticket to improve Sonar rules?
do we really need this? maybe sth like "testTimeTravelWorksT" would be more intuitive? the SpliceWatcher will drop these tables automatically, so you can run the test multiple times.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Starting with Java 8 you can do this: id = replacementIds.getOrDefault(id, id);
requireNonNull
If this is local host, why do we need it as a vaialble?
Why do we return the parents name instead of the name we store a few lines above?
This could also be chained.
Log message should get cleaned up to remove braces.
you could just do setConfirmWindow(null); like above method
(purity alert) This two can be written inline
name can be null, causing compareTo to NPE if its on the wrong side. In these cases maybe treat the name as though it was "".
This check is redundant because you check this in handleSelection()
Same as above: I think it is clear enough without the id variable same for below too
super.stop() should really be in a finally block.
Use Strings.isValid(styleId)
The result variable should named as result
Is there any reason to add the this. prefixes? Seems redundant when the member variables are already prefixed with m_.
possible NPE
is it the same FileInputStream used in line 78? If so, the object can be reused. I suggest to handle input streams this way: <LINK_0>
Same argument as with the DeadlineJob.
I wonder about simply adding a modifiersAST != null clause java boolean isStatic = modifiersAST != null && modifiersAST.findFirstToken(TokenTypes.LITERAL_STATIC) != null;  and then leaving the rest of the method unchanged/not necessarily introducing Scope.isInPatternDefinition Would that work?
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
You could make tryList final and perhaps inline initialisation in declaration.
It may causes two consecutive calls of onTracksChanged due to MediaPlayer L3008 in the same patch set.
@johnou this is not thread-safe... You will need todo this in the handlerAdded(...) method as CharsetUtil.encoder(...) looks up its encoder via a thread-local. So we need to ensure we call this from the same thread as we use to encode later on.
No need to do this anymore. Just set the field's value.
Should we verify that we can see all of the external IDs, even if some of the substudies have been filtered out?
Core.ID
Minor: add a space in between the message and error code
java if (mapperReference.isUsed() ) { mapperReferencesForConstructor.add( (AnnotationMapperReference) mapperReference ) }
What is the need to make issueArticles nullable? It would be easier to understand this view class if we required it. If that's totally impractical, we should consider having a separate view class to capture the difference.
Why is the modifier private? We should set same modifiers to validateDatabaseName and validateTableNamet methods.
I think canceling causing a pop-up message is unnecessary and a little wordy, but if you feel strongly about that, let's chat about it.
Returning 0 or 1 is not exactly a good way to estimate the progress of the algorithm. Can you come up with a better way?
Use Arrays.asList instead.
I am wondering if we should move the project towards scala or kotlin to make the data objects less verbose
Please throw unsupported operation exception instead, this dao is not used. We're going to get rid of it.
This method could be static since it does not depend on any local state. Same for hasCoordinatorMoved.
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
you can use method getUrlForWiki (so you don't need to add empty string for article path)
nit: we don't usually use final on method. (Also, as a side note: we don't use final for tmp variables)
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
Why we return AsyncClient here?
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
Use isZKLogAvailable() instead
you already know that it is IMAGE, don't you?
pls use querydsl instead (already in master)
@paulovmr you could use a lambda here :)
This will throw redundancy warnings in IntelliJ
assert.NotNull ?
What's the point of adding a copy here?
suggestion Assert.notNull(id, "Labelset ID must not be null.");
checkNotNull(value, "value")
Can you call CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, symbol) instead?
It would be nice to provide some feedback if this check fails. Like "The file BLABLA doesn't exist in the directory you provided. Please try again..."
feedback session's course ID -> feedback question?
You can also use something like return url.replaceFirst("^\\w+://", "");
==
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
Should be in a finally block?
Nitpick: I'd have preferred the following just to make sure that we don't handle any other request code. There is probably none we could handle right now, but I like making sure the code won't do anything I didn't expect from it:  if (requestCode == RequestCodes.JETPACK_LOGIN) { if (resultCode == RESULT_OK) { trackResult(); } else { finishAndGoBackToSource(); } }
This method should be static as well. Also, comparisons of the form "0".equals(s) are preferred over s.equals("0") since if s is null the former won't throw a NPE while the latter will. I'm aware that the rest of this file doesn't follow this convention, but there's no reason not to fix it for new patches... :)
Get the size directly don't use getAllEvents()
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
if (signed) is enough. We try not to compare boolean variables to boolean constants.
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
Use logging framework instead of printing to stdout
java * @param error a potentially empty error message. * @param errors the List of error messages, which @code{error} is appended to, if @code{error} is nonempty.  @damithc errors description stills seems too verbose, ideas for a better one?
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
You should externalize the string
Here it's used only once so it doesn't really matter, but you could have static defines for those, like private static final double NANOSECONDS_IN_SECONDS = ... would also prevent easy mistakes like one zero too many
You can use OptBool here.
If you make the EMPTY_EXPIRES, you could use it here.
context.getExternalFilesDirs required API level 19 and above, our minSdkVersion is 14. You can use following support library function: <LINK_0>
IMO this should move to the presenter in the first place.. i.e. where you call view.init( this ) add the next line that calls if(this.canUpdateProject()) { view.enableAddAssetButton( false ); }
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
@ILikeToNguyen Why the change in visibility here?
Looks good to me. Can we do something to identify other occurrences of this issue?
returning null cause null pointer exceptions
why static?
If I understand correctly, the purpose of the patch is to fix a specific problem - failure of migration because of 'refreshCaps' failure to take a lock. It is enough to take a waiting lock inside the ActivateDeactivateVmIntefaceCommand before calling the refresh, instead of locking the host for the whole migration period. You can pass 'lockProperties.withScope(Scope.Execution).withWait(true)' as the 'lockProperties' of the parameters you pass to 'RefreshHost' (the 'RefreshHost' should pass it the 'RefreshCaps').
It seems weird to me for the ConvictionPolicy to dictate when to reconnect. I think it would be much easier to manage if it was only responsible for whether or not to mark the connection down, especially if we ever intend to expose this.
use return ... ? ... : ...?
Should be hardcoded?
This method needs to be implemented in LexerATNSimulator as well as ParserATNSimulator.
This is easier to read as: return type.getClass().isArray() || isList(type);
This should be infinite time
do we need to use static on this private method? Please update javac doc
suggestion assertThat(got).contains("Description");
delete() should be executed from within the future so it doesn't through right away.
Shouldn't this be assertGreaterThanZero?
Is it necessary to do this here? The semantics of onDelete are supposed to be such that it's only called when the component is being removed from the screen in the companion app.
public isn't needed
ditto about keeping this package private.
As you already need to touch this file, I think this empty line could be removed.
@fanifieiev the same above.
what about using IntSetsExternalization.writeTo() and IntSetsExternalization.readFrom()?
suggestion return unmodifiableMap(properties.entrySet().stream().collect( toMap(Map.Entry::getKey, e -> e.getValue().property)));  needs toMap being imported statically
Should be cached or initialized in a field.
Indeed separate @Test methods are better than one big @Test. But do make sure they are really independent. From what I remember, the order of tests are not guaranteed to be the order they are listed in the file; that means the tests should be able to run in any order.
same thing, while you are cleaning, other thread could store other key.
.EMPTY_LIST;
As discussed vocally, let's get rid of this performance issue, as we don't want to create an EventEnvelope each time just to delegate the execution to its methods.
Given we're removing the only reference to the presenter.moveDown and the presenter.moveUp, it's important to remove these methods in the presenter as well and the related to code, to finish the clean up.
would it be better to throw an UnsupportedOperationException rather than return something that won't work?
why we need to check for getVm().isInitialized() ?
Please, reuse your extracted method for checking if a file is an Erlang source file.
An create on-demand Direct Debit payment request should always have an agreement ID
Let's avoid raw types, please.
Currently we know that close doesn't throw, but just to make the code future proof we can use guava Closer here to make sure that both readers get closed.
My bad, I meant to say: "to be able to **change** the page source". I will improve this exception message.
Maybe put this in the onPostExecute of the AsyncTask?
use subjectDataService.deleteAll() instead of this loop
You may want to add assert size - toRemove.size() >= 0; (my genIntellijRuns task enables assertions by default)
I think this pattern will work throughout the whole string, while we want that it only works for the suffix of the string, which is not enforced. To enforce it, it should be "_[0-9]+_g\$$" or "_[0-9]+_g\$\z" or something similar.
The message may be confusing as it talks about pushing and submitting. Perhaps for this class use: " To save changes you need 'Push' rights on " + REF_CONFIG"."
Please do check on null for all such getters. I believe we previously returned null in such case, because object was a Date, now we return primitive long which isn't an object. We should probably return Long so its serialized either as null or long value.
Maybe 'cluster.hasRequiredSwitchType()' or 'cluster.isSetRequiredSwitchType()' without passing the 'null' as a parameter.
return this ?
use return ... ? ... : ...?
I think baseUri.toAsciiString() always has a trailing / in our usage so with the current build() method I think you will end up with (for example): http://some.example:80//path/path/path?query=true changing to this.path += encodePath(path) + "/"; will result in: http://some.example:80/path/path/path/?query=true I think both of these are valid URLs, but I think we need to be sure there are no server side issues if we use either // or /?. @tomblench any thoughts on this?
return status != null && status.equals("ON"); is correct and sufficient
Check error code/description
good practice: usually actions go before WS as they are injected into it and so they are grouped together
I think the whole method can be simplified by  public Result getRpcResult() { try { if (resultFuture.isDone()) { return resultFuture.get(); } } catch (Exception e) { // This should never happen; logger.error("Got exception when trying to fetch the underlying result of AsyncRpcResult.", e); } return new RpcResult(); }  what do you say?
Do we have to care about UnsupportedOperationException here, or can we be sure that since isSymbolicLink() == true, the operation is supported? Same question also below.
you are calling stream.addLivePacketListener on the onStreamCreate but not removing it on onStremDestroy.
do we care to check the length to be positive here?
This implementation is not transitive. null elements should either be ordered first or last.
why do you want to whitelist it at the end?
please use for the positive tests the following convention: assertThat(validator.shouldVdsBeFenced(), isValid());
? should only interrupt on InterruptedExeption. Also, the waitForConfirmsOrDie() needs to be its own try block - it can throw exceptions (timeout etc), so the close() would be skipped.
Do you want to use the constant ZAWGYI_PROBABILITY_THRESHOLD  here as well?
Nit: "Creating ephemeral nodes..."
Please mark requestRouteToHost as deprecated and have it create a InetAddress for the given hostAddress and use mService.requestRouteToHostAddress. requestRouteToHostAddress does not need to distinguish between v4 and v6. Drop the addressType stuff.
Don't you think there's a need to add a constructor with final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier
Please use CommonUtils.loadResource(). It allows overriding config files by placing them into /etc/sw360
Remove the publicmodifier if this parser class remains.
wait.forelementClickable?
"return position;" maybe?
return flagdown; ?
@ivandalbosco No need to change order if we don't rely on visitor for finding "try"
What if we return an empty list instead of throwing an exception?
I'm not sure why this variable is needed here. Could be: java public static String getAttributeValueFromString(String string) { if (string.length() > 0) { return string; } return null; }  This functions also will fail if string == null. Should be something like this: java if (string == null || string.length() > 0) { return null; }
Is this parameters really mandatory? I thought its default was false.
Can be made package local
you could use id from the VmTemplate entity, this way you won't have to create new UUID from string
This test is wrong, check that the expected exception gets thrown using the expected attribute of the @Test annotation
Shouldn't GetClientForNodeId this start with a lowercase?
why rewind?
- Can we inject the EventHubWrapperFactory into the EventHubSystemProducer, EventHubSystemConsumer and EventHubSystemAdmin instead of class-loading them via config? It'd be much cleaner with types that way. Use-cases at LinkedIn that require tunneling can inject their tunnel-aware versions of the EventHubClientWrapper.
All attributes s values were -> All attributes values were
No, this. when you call methods.
Integer.parseInt
This should use a different match strategy.
measuresByTrade = measures.stream().collect(toImmutableMap(CalibrationMeasure::getTradeType, m -> m));
If we return inside the case clause, we can get rid of the res temporary variable, the breaks and the last return line. switch(format) { case LEGACY: return renderLegacySize(size.longValue()); ... default: throw ... }
Is it possible, that the context is null?
use return ... ? ... : ...?
The value returned by isPlaced depends on the mapped flag as well. It would be a lot simpler if this provider had tuples of [seqID, start, mappedFlag, usePositionDeltaEncoding, expectedIsPlaced], with test cases for each possible combination, and the test just created a new record for each case using those values, and verified isPlaced.
A line break after @Before should look better.
Doesn't look like conditions are same.
To close the topic I meant this yesterday: java EvaluationContext context = this.evaluationContext; if (!(this.localFilenameGeneratorExpression instanceof LiteralExpression) && this.localFilenameGeneratorExpression.getExpressionString().contains("#remoteDirectory")) { context = IntegrationContextUtils.getEvaluationContext(this.beanFactory); context.setVariable("remoteDirectory", remoteDirectoryPath); } return this.localFilenameGeneratorExpression.getValue(context , remoteFileName, String.class);  But now you have done fully different solution and it need its own special review. For example how about to synchronize in the RotatingServerAdvice when we reconfigure a MessageSource, so only the last one will apply its state? We are about reconfiguring source anyway, so does it really matter which one wins?
Consider using == maybe?
Why is this not return this.kind == kind ?
What is this method needed for? You want to create a fluent API?
it cannot be a constant: it needs to be a variable (like timeout) so that it can be changed per test / per class and eventually adapted for EE
@fanifieiev the same above.
Should we call the function below instead?
Is this intentional? You are forcing the value to 'true' Maybe a simple assignment is clearer
Shouldn't this constructor be package-private?
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
remove this
please move the setUser and setHost to connect (if _vds != null)
@sbespalov : What is isLsm(...)? What doest this abbreviation stand for? Layout-specific metadata, or is it something else? If this is it, could you please rename the method, so it's clearer? Thanks! :)
Would be better to just use store::remove that return the current value (if any) of the correlationID key
So m_response was never null before and now might be? Or was this a bug fix?
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
Any thoughts about returning Stream<Session> here? The one non-test usage performs a for-each on this anyways, so that wouldn't be a problem. As a nice bonus, closeSessionsByIp could re-use the logic
You can remove the one line above and rely on the below one.
scaledData, thread safety and all
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
in some cases lhs/rhs could be null, pls do the null checks appropriately
The logic of this is unclear, it seems redundant
You should throw a WebApplication exception with a JsonError as entity for the client to receive a valid JSON.
Can you add a sanity check that offset >= 0 && len >=0 && offset+len <= bytes.length. Could use Preconditions.checkArgument from guava.
rename tempVar
Nitpicking this change here - isn't this antipattern?
Extra trailing comma.
hashCode -> System.identityHashCode
be backwards compatible
Please replace this exception
Don't check these in.
just return content == 1
Missing .duplicate() on byteBuffer
Move to update please. < layout
Unneeded parenthesis. You probably can one-line this method anyway :)
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
ObjectMapper is a thread safe object. You can create a static instance and reuse it.
please throw some descriptive exception
let's make a meaningful constant for 5
Should this use RANDOM_PORT_INDICATOR instead of 0?
return array == null || array.length == 0
You could probably use the same URL as in getResultById here.
Why 2? default-max-chars.csv has a single line so it should have a single set of arguments?
How about inlining it?  if (!contains(o)) return false;
java "MetadataImpl{name='" + name + "'}";  would be simpler
rename to f
Can this be private, or is there another use case for default attribute outside the builder's call?
please remove else, code will be more readable
Should maybe be "SocketException has occurred"
Sorry! I meant we don't need to pass the options in!
Not related to the changes from this PR, but now that the ValidatorFactoryImpl is cleaner, I noticed that there are some getter methods that are not coming from any interfaces. Like for example isFailFast(), isTraversableResolverResultCacheEnabled(), getExecutableParameterNameProvider() and maybe others. Hence I wonder if we shouldn't pull then to HibernateValidatorFactory ?
use return ... ? ... : ...?
Could change the return type on method to Collection
Can we set a charset? Like ASCII or UTF8?
use return ... ? ... : ...?
why public? Are we planning to use it outside of this class?
I would really appreciate if you rewrite this so it doesn't use -1 as startIdx. A year from now I won't remember why we want to load from position -1.
Would it make sense to automatically call this method via on-persist/commit hook, depending on the event state?
What is this for? Feels like some unintended checked in code?
LOG.error
instead of changing visibility of constructor maybe you can make the static factory method SerializationUtil#createSerializerAdapter public and client code on Jet side can work on SerializerAdapter interface?
I don't think there's any reason to separate this from the constructor. It could be a different method within AffinityGroupModel, but it could be private and called from within the constructor.
Broken alignment.
Multiple method(*) methods
How does replacing a NPE with an AssertionException help ? I'd rather try to annotate the method's parameter with @NonNull and watch out for "Null type safety" warnings in Eclipse and fix them.
\>= ?
is this tear down necessary? the next setup overwrites anyway, doesn't it?
nit: you can merge both lines above as checkNotNull will return the given argument
Looks like setting RECORD_CURSOR_TRACES to false will increase the overhead of recording cursor traces, since the traces are captured regardless, and then stored in a cache shared among all threads, and the cache has to evict on all but the first put.
getNodeEnd() will return Long.Max_Value is the node is not on disk... which brings us back to the original state. And as expected, the assert in the benchmark fails.
I'm not sure this is used for anything, I need to verify.
No need of this..
The super() returns "" on null. Why should we differ?
I think we should handle exceptions with more caution. Instead of finally, this would be:  catch (Throwable t1) { try { entityManager.close(); } catch(Throwable t2) { someLogger.warn("Error while automatically closing an entity manager", e); // Maybe we could remove that t1.addSuppressed(t2); } throw t1; } entityManager.close(); // Let any exception when closing propagate, since we didn't catch any exception before
Maybe when the message consumption rate or production rate dropped significantly, return unhealthy.
actually calling .layoutData(new GridData(......)).create... should be ok here, correct? like you changed from supplier to layoutData in addFiller()
How about inlining it?  if (!contains(o)) return false;
I would add a check if instance is != null, because with this, everyone can overwrite the current instance if its not null. Or only create a new instance in the getInstance methode, if instance == null
the magic string can be moved to constants
I think that closeQuietly accepts a null parameter, so that the if would not be necessary.
wouldn't this fail if pattern was null?
Doesn't look like conditions are same.
Nitpick: It's generally safer to include curly brackets for _all_ if statements. It can help protect against a future developer accidentally introducing a bug if another line is added to the if statement. Alternatively, a more succinct way of writing this method would be:  return (dynamicTemplateData == null) ? Collections.<String, Object>emptyMap() : dynamicTemplateData;
As already said, you cannot execute the command like this. In the previsou patch set I put some ref to existing code which execute the command on the command staticc of the current editing domain (to support undo/redo, ...) You should at least try ecitingDomain.getCommandStack().execute(cmd); And check the undo/redo works.
The try-catch block is redundant here, since the appropriate exceptions are caught and logged in the startDicomOrderFiller method
I think in this case we need to init the repo with a url with a slash on the end.
return ImmutableSet.of();
If you use a concurrent map you can use: attestationValues.putIfAbsent(value.getHostName(), value);
default method visibility OK?
Consider to replace with "an allowed command".
configure is user-overridable method, and also there is no need to trigger it here
Use constants
The connectTimeoutMillis and readTimeoutMillis in the builder appear unused.
This is the only relevant one:)
return asyncHttpClientMap.remove(name) != null
I recommend using Collections.emptyMap() instead
Can it be that this.lookupSourcePositions > 0 but other.lookupSourcePositions < 0?
They are still non-modifiered?
I see you"ve moved 'reportsWebappDeployed' but what about 'retryCount > MAX_RETRY_COUNTS'?
Shouldn't this be wrapped in a try... finally block?
Guice best practices: make this constructor visible only at package level.
What is the nullness contract here? Also missing docs.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
java return bytes >> 20;
return Collections.emptySet(); ? BTW, it seems that class DummyGroupMapping is never used now, do we need scrubbed it off?
I think we need file with version 1.4. inside.
Please remove
Can't this NPE as they're Booleans (i.e. objects not primitives)
Or judge null place here ?
can use the new logAndThrow() mentioned above.
you're going to get "... Cfdefs CfDefs(...)" which may a look a bit odd - can updated after the major issue is resolved though.
should check results here, not just size
just return relation.isVehicleTypeConcernedByTurnRestriction(restrictions) (here and in other encoders)
String name = StringUtils.EMPTY;
replacing this with helper method would be great
Again, use IOUtils.
I wonder if this should be an atomic operation?
I get a NPE here, processModel.tradeManager is null.
I think that this attribute should be configured
blank
this is not correct, it's about removing template's disk, not the template from SD, i.e DELETE /api/templates/xxx/disks/yyy <action> <storage_domain id=zzz/> </action>
removeMarker, deleteMarkers: let's use the same word for both
@inverno Why public?
Please use [IOUtils.toByteArray()](<LINK_0> from Apache Commons IO. You may have to adjust the file pom.xml, which I have not checked. (The same one more times two lines lower.)
why a check for the viewer here? shouldn't this be the dropdownTable? Now that we keep the table.
Can you update the generator to remove the modifier so that the constructor stays at the package-private level?
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
Maybe we should use a logger here, and print to a different file? In case there are issues with updating and we need to diagnose.
isMatrix()? Also what about the row vector case? I've ran in to bugs in the past with subiRowVector being applied to row vector. May want to make this explicit.
Since this is INFO level, how about: suggestion log.info("Shutting down thread monitoring tables.");
Does EMPTY_SKETCH.toByteArray() result in an empty array? Currently there is a discrepancy between fromByteBuffer() and toBytes() that looks suspicious when just reading the code.
Should be size != -1 since -1 is an explicit value. If someone passes a negative value then the behavior is undefined (which is fine).
style nit: we don't use braces around single line blocks
Does this need to be public?
Can't this be further improved to just Arrays.asList(values)?
we never use NULL, it is a bad practice in general.
If we change the default value of getValueAsString we should change this one too.
Is this signum call really needed here? compareTo should already return the correct value.
Preconditions.checkArgument() would be better form.
This evaluates different value that it stays isLeftTurn will return true, in case it is slight left turn
How about "Type is not supported"?
@NielsCharlier change this to operation=mEtAdATa to test case insensitivity.
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
this could be Lists.newArrayList(deviceId);
use 'L'
Check first that target is not null.
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
I think try with resources should be used.
This means clockHand will be hot at initialization time. Intended?
No need to catch the exception here, it was already done in the overload.
Another way to do this would be to override setIsAvailable in PluginModel to be no-op. (This would allow us to get rid of the instanceof check here.)
You could make tryList final and perhaps inline initialisation in declaration.
I'm still confused. Why are we parsing as a long and then checking whether it's > Integer.MAX_VALUE instead of parsing as an integer?
I don't see why you introduced mutability here? Local variables would have worked just as well. If you really want that, please at least make the setters package-private.
Looks like it should be s/location/expiryQueueSize/
just call getWindowTitle() :)
suggestion verify(ignored.message().isEmpty(), "FileExists.message cannot be specified");  ?
add requireNonNull for bytes
why is this public?
use return ... ? ... : ...?
Fix aliases = aliases = ...
Can't the lamba just be rewritten as this::onReloadConfigComplete
let's stick to if (style.isVariableHeight()) { return true; } for this patch.
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
Take care! arg.get().toString(). Otherwise you're passing the Optional object.
What is this for? Feels like some unintended checked in code?
space
could we solve this better by overriding send() in the TracingActor? I'd like if all this trace and replay code would be in that class.
Optional should be used in interfaces. Use null as internal value.
Shouldnt this be on executor lock?
Do you think it is worth logging if there was an attempt to set the timeout below 2 minutes?
The ID is used to restore old files (from an older release) so this must not be changed!
I think we will have to discuss whether or not to include the fromKafka functions in this class.
use hasNext instead of contains (do not use toIterable() we want to check Iterator)
idx -> index
This kind of refactoring always affects client, and you always change it, and usually it is changed in 2 places(ide, dashboard). I think in this case it will be useful to extract the creation of the channel name into separate SHARABLE class which may be reused by GWT, in that way you don't need to refactor ide client when you change the format of the channel. wdyt?
use keyword "this" in these methods before member names.
you can simplify it with a single line by replacing the method's body with: return validate(hostExists()) && validate(hostStatusValid());
This test would be useless if the map had been initialized in the class.
I'd remove the whole guard, and simply return null (mSessionID MUST be set to null when the session has left a realm already - and of course it must be null when the transport is detached then too)
Please use Optional.ofNullable()
I think it's more neater to not write extra lifespan/maxIdle parameters, but instead to write them where you write lifespan/maxIdle already and just add the possibility to send a new option which defines the granularity of lifespan/maxIdle. Your current solution feels akward since you're adding two new fields and the existing ones are not used. IOW, just add one more flag to the flags parameter here and you're done on the client :)
We should only be pulling down upstream changes here.
Can this return a List<JsonPatchOperation> instead?
other methods like this put name first, then id. switch for consistency
The @Override should be on this line.
typo
This check does not belong here, this method should never be passed a null value...
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
we can do away with the local variable here @rishabh-997
format: remove extra space
delete() should be executed from within the future so it doesn't through right away.
done for patch3.
adding an extra pair of around endTime - startTime would be nice for those of us who never memorized arithmetic operator precedence, like me :)
check if u can use 'getTaskIdList'
Need to declare the adapter type here, too.
static
We might want to consider calling the new method from this one so we don't duplicate code isPublishDateInTheFuture(dateCreated, new Date()) wdyt?
Making use of Guava lib this can be simplified to suggestion Preconditions.checkNotNull(module, "ModuleMarkupScraper:getModuleTags() - Module must be valid.");  As the module name will appear in the stack trace if the null check fails, it may be enough to just do suggestion Preconditions.checkNotNull(module);
do we want eventually to have a writeTo(ByteBuffer) ?
@AlexDBlack is this normal for transforms? Have we changed anything in the data vec transforms you can think of?
catch RuntimeException
ImmutableSet.copyOf instead of Collections.unmodifiableSet
instead of just putting e.getMessage() as part of the new exception message, I think you should pass the entire e as the second parameter to the constructor of IllegalArgumentException.
This is a clear programming error, right? If so, suggest throwing NPE instead.
Shouldn't it be a (separator.equals("\\n")) ?
what if a table contain a field named filter ? use str.startWith("filter=[")
We can add a checkNotNull here.
To me, this line seems redundant. Why not pass withStudentProfileAttributes(this.studentProfile.getCopy()) in the building process
The old version displays a clear intention and explicitly exhibits the operator precedence. Please revert.
onLowMemory is public, not protected
there is no need to wait here?
Please throw exception if ! nameLookupPossibleInAdvance() and getValueCardinality() == CARDINALITY_UNKNOWN, please throw UnsupportedOperationException. If ! nameLookupPossibleInAdvance(), but getValueCardinality() returns something non-negative, the code in the hot loop could be optimized, idForNull could be assigned as soon as selector.lookupName(index) returns null for the first time.
There is a weird inconsistency. Sometimes you start the String with a capital letter, sometimes not.
Make final.
This cannot be null. Guice won't allow the constructor to be called if the reCache arguement is null, as the argument is not marked with @Nullable. Or is this null because of unit tests? If that is the case I would prefer to define a mock cache in the unit test since at runtime we always have the cache.
Rebase error - should be used Helper.getCurrentUser.
I think this should be: java setCursor(Cursor.getPredefinedCursor(DEFAULT_CURSOR));
last argument needs to be ImmutableSpongeFlyingData.class.
I would suggest answer.toLowerCase() to make secret answer validation case insensitive.
if there are errors at this point, an exception needs to be thrown. This will just ignore the errors, which will cause a confusing error later in transform. call context.getFailureCollector().getOrThrowException() after this line.
Take a look at <LINK_0>
you shouldn't need to cast to double here
No extra synchronization needed here because rowCount is already AtomicLong. Unless the intent is to not let shouldStop, rowCount, isRunning get modified concurrently since you are guarding accesses to them by doing synchronizing on "this" .
Shouldn't be more like return getConfig(STACK_DEFINITION_URLS); ? this is always different than null as you call this method, and getConfig(STACK_DEFINITION_URLS) is set with a default empty list.
A check for settings.getConstructorArgs() != null is not required if we check that null can't be passed to MockSetting.useConstructor(Object ...args) as described above.
So all HashFunctionPartitioners are equal to each other? What about the 3 different variables? Also the hashCode is broken as that uses 2 of the fields :(
Can we make logger a private static final
Is this a convenience method or do we have genuine uses for having both generateWriters() and generateAndWrite()? Put in an alternative way, why doesn't this delegate to generateWriters()?
please remove else, code will be more readable
should the message include "command _with options_:" + this.options ?
is it better to use name instead of null?
finish() is called in case of an exception but the callback.close() is also included in the finally clauses of the top level methods. This leads to closing a callback() twice which is probably not intended.
nit: you can merge both lines above as checkNotNull will return the given argument
If we log an error that doesn't have any vararg arguments this will throw an exception from what I understand.
hmm, that method makes somewhat sense in core java, but I'm not sure I like that behavior for selendroid. We're expecting a boolean value, but essentially we only care about either true or "true" coming across... everything else is false. Is it going to be confusing to any users? I'd almost rather add an additional else clause to check for the string of "true" or "false", otherwise raise the exception. Since users of other programming languages (like javascript or python) may have a different impression of what a truthy value should be.
Nit: use ImmutableMap.Builder, it's easier to read and modify, as there is no special case for the last item. I only use of() if there is one item. Same goes for the rest of this class (except the usages with exactly one item).
This exposes the unicode workaround to the public.
this.clientTags = Collections.unmodifiableSet(requireNonNull(clientTags, "tags is null"));
Need to declare the adapter type here, too.
FYI ImmutableList.of(address) is more efficient, but it's no big deal, that's just a note for future reference.
Please make this package protected, to avoid the expensive synthetic accessor.
what else? any warning or exception should be there?
combine with assignment this.outputType = requireNonNull(type, "type is required");
this will throw timeout if infobox is not visible. use wait.forElementPresent() instead, but you will have to create By variable from that selector
unnecessary null check
nice catch, I just recently wondered about our handling of singleTop
I meant this constructor should be private. You made constructor of LdapObjectDefinition private. Actually both should be.
Is there any reason that A_GR_projectName is missing there?
1. Did you mean support only Firefox for _testing_ right? I assume the difference in behavior affects testing only? In that case we should keep the production code clean and apply any workaround in the test code. e.g. do an if-else based on WebDriver. 2. Yes, I think at some point we stopped using Chrome for testing. There are many other quirks between the two versions that gets in the way of comparing html. We can check if anyone is using Chrome.
Are these errors caught somewhere else? Is there a reason that exceptions were just printed instead of being thrown previously?
We should not force all of the refreshes
<LINK_0> Let me know if you have any issues managing or adding items to the project
revert this unrelated formatting change
wait for the elements before interaction
I would probably rename this as well to binarySearchTree because I find that clearer. That's just my preference though, feel free to leave it as it is if you prefer it that way :)
I'm a bit perplexed: "dynamicStrict" does not match any field name... I wonder why this works. Anyway... Maybe there should be two different bridges here? It feels a bit strange that the name parameter in configureFieldMetadata is ignored. Same as before: I agree it can work as is, but it's more in case someone copy/pastes this code.
suggestion Set<String> result = new HashSet<>(); if (groupId != null) result.addAll(groupId.getRequiredParameterNames());
Should we wrap this with try / catch in case one registry throws an exception?  try { serviceRegistry.unregister(); } catch (RuntimeException e) { logger.warn(...); }
This could be a bit tighter as I think it should be called with account-id and the mockSecurityContext could be made to return known values for the api key and method that could be checked too? That might help assure that the correct values are being taken from the security context?
use ImmutableList
Should we add null check?
Nit: Objects.requireNonNull will ensure we never accidentally cause NPEs to be thrown.
I would just use pairId here and remove second arguments from URL.
use RelationshipType.class.isAssignableFrom(c) so that subclasses get validated too
suggestion return (original == null) ? null : original.toUpperCase(Locale.ROOT);
Please use ? ternary operator
Compare with null not necessary since null instanceof FileModelSource is false
ObjectMapper is a thread safe object. You can create a static instance and reuse it.
@Iprogrammerr Please use IsEquals from hamcrest in these two assertions
Should this really be public?
does this method need to be public?
why not use builder.append(SEPARATOR).append(value) . In this way , there is no need to remove last ":" in build method.
We could throw an UnsupportedException here.
is it sufficient to have this c'tor package private?
Please do the List changes in a separate PR. This PR should contain only benchmark changes.
variable named abstractFile does not exist, which prevents pr from building
revert this unrelated formatting change
Better use Double.isNaN(double) here. Reads better, IMHO.
It should be new TajoRuntimeException(new InvalidCastException(...).
put this on one line and add an exception message
stream isn't closed
Use Assert.assertEquals instead.
Why removing failure? It is the failure reason.
Add a private final stripeMask field that is initialized to stripes - 1. This will eliminate an arithmetic operation from this hot path.
I believe that this is the same as Objects.hash(readName, pairStatus);
I recommend using Collections.emptyMap() instead
This doesn't need to be public it can be protected.
Typo: initCardModeButtons()
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
finish() is called in case of an exception but the callback.close() is also included in the finally clauses of the top level methods. This leads to closing a callback() twice which is probably not intended.
I guess you mean to pass kryo, not to create another Kryo.
This is wrong. getFullPath returns the workspace path (e.g. /org.eclipse.egit.ui/plugin.xml). It should use getLocation(), which returns the file system path.
can't be null?
Don't we normally do null checks in builder methods? Or are we happy to wait until build is called before blowing up?
getServicePolicy shouldn't ever return null. Based on how the Python SDK functions we return a policy object every time. In the case that it is in fact empty ({"factors": [], "minimum_requirements": []}), we return a policy with all the minimum_factors set to false or 0.
Danger danger, Style objects are mutable, if someone gets the style and changes it, it will affect the static variable and all subsequent requests. Better create the style every time.
code format
would be nice for the 4 to be a constant for readability
Both here and in equals I don't think it is necessary to insert getDeviceIdentification().
I am not sure, but we tend to use the returning values of such methods as plain Lists and then eventually wrap them into ImmutableLists over and over again. So if we can declare the ImmutableList as a type of the returning value, I would do so.
Global listener catch each click. You don't need to log it.
I want to method accessor to be package private :eyes:
the instanceof check includes a null check
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
The order of the arguments is reversed - it should be assertEquals("Vds id is not empty as expected", "", result);
what about using IntSetsExternalization.writeTo() and IntSetsExternalization.readFrom()?
Maybe [] instead of null in order to avoid NPE or check?
Same question about unit conversion as earlier.
I don't think you want this default. This default setting basically says "If debug mode is enabled (IE: You're on a dev machine), the default for the superuser flag is 'on'". You probably want it to just default to "no"
How does replacing a NPE with an AssertionException help ? I'd rather try to annotate the method's parameter with @NonNull and watch out for "Null type safety" warnings in Eclipse and fix them.
The parameter can bee removed
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
I think this should be ss.findAllRepositories(streamName)
also check the gateway
This test should exercise the HBase 2 interface using TableDescriptor rather than HTableDescriptor
doc
here we need to go through Optional.ofNullable(Plaform.getProduct())
We could call: java checkNotNull("command", command);  :-)
Shouldn't that be Class<?>
please move the isEmpty methods to the scimSchema
concat empty str ?
should this be assigned to a field so that the same instance would be returned if invoked multiple times?
any reason for explicitly invoking super.toMap() ?
This can be replaced with return mDrawerToggle.onOptionsItemSelected(item) || super.onOptionsItemSelected(item);
return SUPPORTED_INPUT_FORMATS.contains(inputFormat);
No key for encryption? ;-)
The exception also needs to be modified a bit.
Can you doc what source and key are supposed to be?
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
No need to catch the exception here, it was already done in the overload.
unnecessary change
Nit: For tests it is often easier to just declare throws Exception, rather than have a long list of individual exceptions.
can we explain here why do we need such function?
IMHO it does not need to be public
if from one run to the next, you cannot find the TIDAnalysisModule, you still won't be able to reproduce the analysis results. you should probably used TmfAnalysisManager.getAnalysisModules instead of trace.get... and throw and IllegalStateException if you cannot find it.
not required for the upgrade. Please use separate JIRA and PR.
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
Can this really happen? If not why care?
Use { and } on multi-line conditional blocks.
nit: Do we use caps in other places? We should be consistent with values we expect users to replace.
It would be cleaner to directly format the instant. Java 8 has a new formatter for temporals.
space after ,
Maybe we're going at this the wrong way, and trying too hard. If you call ProjectJoinTransposeRule on a MergeJoin (which requires sorted input), and the Project does not, after being pushed down, give sorted output, then maybe the rule should just abort. Just a thought.
You may also want to verify that the dir is writable.
You should pass here message not group converted to string.
return this.parent == null ? this : this.parent;
Any worry about case sensitivity wrt to scopes?
Maybe we should derive this from Prefs.getMediaWikiBaseUri() or require the client to pass in a default protocol. I think I prefer the latter to avoid complicating this nice and simple model type.
Can you check return value and log if not found?
The remove method of the ConcurrentHashMap already performs its own synchronization, so the "synchronized" modifier is not required.
Can we revert back to ArgumentPreparedStatementSetter since OAuth2AuthorizedClientRowMapper will handle the reading of the BLOB.
I think we need to add the offset here
I might have been confused, but shouldn't we have a new handleNewSession method that takes a session Id as parameter?
optional suggestion: since we're extracting helper methods... it's mostly "false * 4" or "true * 4", so consider adding e.g. whenEverythingIsInitialized and whenNothingIsInitialized.
Might be worth having a displayName?
Still worth using Map<String, Object> commandParameters = Collections.singletonMap(LTK_RENAME_COMMAND_NEWNAME_PARAMETER_KEY, newName); It will perform better as 1. it has less fields, so will use less RAM 2. it doesn't require a hash to evaluate an object, so will use less CPU
Unneeded parenthesis. You probably can one-line this method anyway :)
updateAvialability() calls -> updateAvailability(SystemTreeItemType.System, null); Since the reports init is no longer blocking the ui there is no guarantee the system tree selected item is the 'System'. Calling updateAvialability() will update all the tabs (not just the reports) as if the system is selected. In my opinion, you should extract a method in CommonModel to update just the reports availability and call in from here.
nice catch, I just recently wondered about our handling of singleTop
omit?
nit: can be chained onto previous line's assertion
just write return stage != null ? stage.getStageId() : null; spare some lines : )
I think this would be potentially better with scheduleWithFixedDelay so that there's a guaranteed pause between runs. I'm concerned that a large data set would result in doDataExpiration taking longer than 1 second and putting pressure on the system by constantly running back-to-back.
Why is the modifier private? We should set same modifiers to validateDatabaseName and validateTableNamet methods.
remove exists variable and just return !tuples.isEmpty();
Shouldnt we have this defaulting to the common namespace (ICommonAttributes#COMMON_NAMESPACE) so that we can tell the user what this defaults to?
It is perhaps just my personal meaning, but we could drop the call to the default constructor of the parent.
All your injections can and should be private ;)
I would suggest putting a more sensible name for the channel name like "Review reminder", the name will show up in settings for people to toggle.
This isn't right given the method signature of the base method -- name should be used in some way. If you want to pass in the full path to the db file, then I think DatabaseContext needs to be redesigned.
s/B/b/
you're testing binary branching, i.e. an if. A switch is meant for more branches. java's switch can be linear or can sometimes binary search or a lookup table. Javaslang's is always linear. Please test them properly.
is this tear down necessary? the next setup overwrites anyway, doesn't it?
Instead of "Not implemented yet", I would suggest "Iterator is read-only"
@olenagerasimova it should be appendText(this.text(item)), this.itext may point to wrong value, if text(item) != this.itext
How about move the check of null into setBookmark method and invoke the method from here? So that all the places where we want to set bookmark will just call a single setBookmark method.
normally we use italic text for info icons like this: numaInfoIcon.setText(applicationTemplates.italicText(message));
The indents are still incorrect.
It is possible we will have other checks join this list. Please move it to a field.
Perhaps add further information to this exception
@ribhavsharma please take a look at [this](<LINK_0> You will have to use the clone() method while returning the value which will also fix the travis-ci build failure :)
This is confusing a bit. A redirector does NOT redirect apparently. It builds a RedirectAction, and that thing then does redirect. I think you should opt for better names here. A redirector sounds like something that actually does the redirecting but that's not what's happening here right?
A bit late now, but these should really be KafkaHeaders constants with prefixes (kafka_*).
StringUtils.isEmpty(namespace) will take care of both (not important, just FYI)
Missing codes.
\s+
this yields 2 boxing warnings, either suppress them or use Boolean.TRUE and FALSE
Is there a reason that the GapBuffer is initialized with a buffer size of 1 by default? I know this is a very vague question, but 1 seems like a weird choice to me. It reserves ram in anticipation of future insertions to save computation time, but still only allocates so little buffer space that the array size will have to be increased after one insertion. And if the first action is a deletion, this one additional character of buffer size won't make much of a difference. But I have no experience with gap buffers, so maybe I am missing something (or am overthinking this).
I added method in Utils for that
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
You don't really check much with this test. I think you can also mock cursorsCommitService. getSubscriptionCursors() and check that in response body you get what you expected.
Lines 1068-1088 are redundant.
How are you able to throw Exception without declaring it?
Minor point, but it seems like the reading should be in a separate outer try-with-resources, rather than nested in side the writer.
Not ImageJ style.
@lmontrieux Wow... Strange. I think in this manner you need to add addional {} to log message.
1. position should be able to equal count which means the end of the stream. The current logic will never be able to seek to the end. 2. Shall we throw an exception if the position is invalid, for example negative case?
Please fix indents and use assertNotNull
all these methods can be private
Why setting Token or MID imply sent = false ?
Shouldn't this close the iterator before returning the list?
no public
How about "Type is not supported"?
Why we should change behavior for the deprecated method?
add "domain = null;" to avoid problem at super.tearDown()
you can use containsKey()
I agree that the original implementation is counterintuitive, because the constructor does some work & it's unnecessary to do it for each camera permission. But: The stage relies on the CameraManager having a clean state every time the scene is restarted. Your implementation doesn't do that. Example: Imagine a simple program: When started -> Wait 10 sec -> Turn on camera On the first start wait until the camera is turned on (CameraManager.wasRunning is set to true) Then restart the scene and press the back button to pause, then resume -> the camera is turned on instantly because wasRunning had a false state. There might be more of those, so it's easier to keep the old implementation or completely refactor the whole thing.
I think this is a typo -> this.high < this.high -> should be -> this.high < other.high ??
Can we get rid of magic numbers? I really don't know what does it mean in this context.
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
Maybe a check here that getLeft() and getRight() have identical schema?
Operation can have InputStreams attached. There's a way to translate that to HTTP, we should figure it out. Or at least throw an exception if there are attachments.
elapsedNanos.
I am not sure, but we tend to use the returning values of such methods as plain Lists and then eventually wrap them into ImmutableLists over and over again. So if we can declare the ImmutableList as a type of the returning value, I would do so.
ParameterNameProvider=ClockProvider Or, better yet, let's just move to getUnableToInstantiateException(), I don't think there's much value in having the dedicated versions really.
would be good if you match the expected values in here. I would recommend bringing some of the values you defined in init to here. Those are execution/parameter specific, init should generally be a setup only.
The "brackets for single statements" cleanup in this file should be done in a separate commit, as we should not mix unrelated changes.
extra ; at end of line
This method is never called with isPage = true, so it can be modified only for posts.
Sorry, I seem to be having trouble expressing myself clearly these days. I meant to say, "Does it make sense to add resetEntity() to BuiltResponse.setInputStream()?"
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
timed --> direct
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
This is for a manual scan and should not concern itself with whether it should scan it or not, the user has explicitly asked for the build to be scanned so it should be.
It is a good idea to add all releases in a finally block, so that we never lose permits.
or maybe use key.replace("attributes.", "") WDYT? Is it be more readable?
StringUtils.isEmptry(XXX) if possible
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
If our setters in commands are going to fail-fast about single-execution, we should fail-fast here too about a null pointer being passed in for Repository. NPE right away in the constructor rather than deferred: Git git = new Git(null); git.commit().setMessage("Test").call() We should NPE on the first line of that, not the second.
why not compile once in field?
remove this line
remove when the export button is implemented
Why return a value if you don't use it when you call the method?
Sounds a bit odd, better use "Expected %1$s to be a valid email".
Is takeLast(0) meaningful? If so, it can be routed to ignoreElements(). BTW, ignoreElements() can be optimized by making it singleton and be very simple (i.e., its onNext does nothing) instead of filtering with always false.
This method is in a non-final class, so there could be code out in the wild that override this method, so we cannot change its signature
Since this is a legacy record, deleteHorizonMs is never going to be set. It seems we can avoid loading the full batch? Ditto in isDeleteHorizonSet below.
Do you know anything about the expense of these methods? Will these cause RPCs to namenode?
Not related to this fix, but can't we get rid of this extra InitializingBean operation and just getSSLContext() directly in the ctor ?
two places where partition is serialized? Not very comfortable with that - this is repeated code that needs to be kept in sync.
Include the bit in the toString(), e.g. maybe 1<<getPosition()
Consider removing the "Optional" part. Seems better to return an empty map, if not present.
should reverse order as follows: assertEquals("",html)
Use Assert.fail() instead
throw exception
please decrease severity to "debug"
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
Please use Objects.hash(...) (<LINK_0> instead of manually hash coding everything.
Why don't we instantiate the provider list within the constructor itself? It would allow you get rid of that "if" condition that always gets called whenever the getProvider method is invoked.
use return ... ? ... : ...?
Use Optional.fromNullable(marker) instead?
Why not get the TableHandle from the CassandraTable that you create in line 98?
Money is a reference type and needs to use .equals() instead of ==. Also we need to make sure calculateCost is called first. suggestion return part instanceof CombatInformationCenter && getStickerPrice().equals(part.getStickerPrice());
suggestion logger.warn("Cannot add {} with key '{}' cannot be add. Provider '{}' unknown.", element.getClass().getSimpleName(), element.getUID(), provider.getClass().getSimpleName());
this. is not required
finish() is called in case of an exception but the callback.close() is also included in the finally clauses of the top level methods. This leads to closing a callback() twice which is probably not intended.
Isn't this missing an implementation?
It would probably be better to have a clear separation between the call to getSolrUrl() and the creation of a log.
Should be immutable by making a copy.
Not that it makes a difference in practice, but the pattern we usually show in the docs is CqlSession.builder().build().
should this say throws PatternSyntaxException ?
make this synchronized.
It might look better to start the new line from the .show() instead of breaking in the middle of the arguments. Also note that you aren't breaking the lines in other places.
Don't we need to do the caching here?
:bug: surely you meant delegate.getCategoryId()?
Those two methods are similar. Consider using one.
sed 's/value == STRICT.value ? true : false/value == STRICT.value/' (Redundant inline if)
Should this link to the course?
StringUtils.isEmpty(namespace) will take care of both (not important, just FYI)
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
What is purpose of this method?
You should probably make sure this is an instance of ApplicationContext.
use return ... ? ... : ...?
Please keep this.cell near the related fields (previousFamily & cell count) below
Same code as in the method above, factor it out?
Unnecessary log.
equals() is not usefull for enum, == is sufficient.
null? why not just a () -> {} ?
Not actually backwards compatible: Existing shell steps will report UNSTABLE instead of SUCCESS.
Request.State.OPEN
on IOException|RuntimeException you could add a binary annotation of "error" -> message, as that will turn the thing red in zipkin's UI
does not need to be public in non-public class
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
I don't think you need this check. Just return size * 1024 ?
I'd rather toLowerCase() is applied after substring(), not before.
there is already a constr, which takes (id,groupId,resource, dataSource,interval) Can we use that in indexTask, instead of adding a new one ?
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
use return ... ? ... : ...?
Better to rename RoutingTable.removeWriter to RoutingTable.forgetWriter?
why this is in vmCommand? should be in stopBase command
Why not inject this?
executorService? connectionStartupExecutor? How about closeConnectionExecutor?
> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
use return ... ? ... : ...?
if you do this, better put N/A :)
Same thing here. I don't think mProducerContext != null should be a precondition -- setup() may have thrown an exception and we still want to do our best effort to cleanup by allowing super.cleanup(context) to be called.
I'd feel better with this if this method was still protected. Why was it made public in Netty 5?
I think that may have been an oversight in longSum. Try a query that results in +Infinity at the historical level and you will see why it is needed to deserialize at the broker level
As we are not exposing the original Scan directly, why to create a new Scan again here? No need
cannot be null.
java8 DateTimeFormatter is thread-safe, maybe use that instead?
No space after !. And Framework#isBooleanPropertyTrue(DISABLED_ISLATESTVERSION_PROPERTY)?
Use java.util.Objects.equals().
String.format
good practice: usually actions go before WS as they are injected into it and so they are grouped together
why is this noncompliant?
Should this be one line down after site?
no need to assign the client to a var here since it's only used once; could collapse these 2 lines to 1 instead
I think we have an instanceMainWithExit Oops, that's in picard-public - but perhaps it should be in htsjdk?
I think this will cause a memory leak as you're going to be holding onto an indefinite chain of references, so the GC can never garbage collect the request metrics objects. It would be better to create a new request metrics payload that is a copy of the current
please put each parameter in separate line :)
why rewind?
You should use a variable to store this 5, so that when you want to change it, you only have to change it in one position instead of 3.
Not sure why we check if vm can be null here, it should be verified in the canDoAction when executed, and if the VM has disks then the VM should not be deleted, so I don't think vm can be null
any reason not to combine this method with isReadOnlyPropertyCompatibleWithInterface ?
Translate this?
Why is this not returning mReferenceName?
getParent() can return null
I think here we re-introduce logic we already have [1] [2], from my point of view would be worth to extract this scroll logic into a separate class and reuse it multiple times. [1] <LINK_0> [2] <LINK_1>
Need to check Currency of the payoff is one of the currency pair?
can you make loadProperties() take configFile location as an argument and remove the global variable configFile . It seems it is not really needed and reducing global state is good in general.
can we use here some simple words like variable, parameter, instead of cryptic lc1?
java value.trim().isEmpty()  would be more clean IMO rather than java value.trim().equals("")  WDYT?
Are you sure this is from stdin? I think this is from terminal... check echo "alon" | java xxx, and see if it reads the "alon".
@dskalenko can you post me this tree? You can nicely visualize it in Checkstyle GUI: <LINK_0>
an expensive way to check if it exists ... if there's no other way, then this will probably do
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
you can either remove else or add pair of curly brackets
perhaps if not has permission?
This variable should be called something more generic instead of sort since it could be any int
what if none found? are we sure there is at least one?
use return ... ? ... : ...?
4th argument should be {3} instead of {1}
static import
I'd recommend to add process id to the name as well as there might be tasks with same name in different processes but still in the same kjar
The combination of succedded and force is not clear to me, let's discuss this; I believe this API should change.
No, this. when you call methods.
suggestion throw new UnsupportedOperationException("removeNotificationListener not supported by Jolokia");
typo
Not sure, why not use @NotNull?
please use for the positive tests the following convention: assertThat(validator.shouldVdsBeFenced(), isValid());
brr... I don't understand this ctor. it should do just this: this(new RqFake(), dispositions). why it's doing something else?
I would use InterfaceUtils.isSubtype() has a main method to confirm that it is a LocalBroadcastManager. The check !getClassConstantOperand().endsWith("LocalBroadcastManager") can still be present. It will be useful to have fallback when the complete class hierarchy can be loaded (aka missing classes during the scan).
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
nit: Can't we just use the context ? Any particular reason we have to use getContext() ?
@sebing let's use try-with-resources feature here since we're now on Java 7. Make sure to include both input and output.
Should this be assertion fail?
Shouldn't errorContainer.setVisibility(View.GONE) also takes care of notificationButtonView since it's a child of errorContainer (Not putting this for other use cases, but should get corrected for install and update as well if we do it here)
please add call to populate: addLinks(populate(connection))
failCanDoAction?
This should be at least a constant, and more probably an instance variable.
Add an IllegalArgumentException to fail-fast when the process is null
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
Request.State.OPEN
Same: static import lightGray from Color?
This is an odd way to test serialization: load it into an object and then do toString on that object. Can we not assert the fields of the LocalDate object? At a glance, this just looks like string processing, even though there's a date object in the middle.
As above: private, 100 chars, use error result instead of doOnError.
This method should be static and need not pass this as an argument to the constructor.
Can have a isRef(Expression) and isLit(Expr)
The NO_OPTION test isn't needed given you test for YES before taking action.
this will be called for each assignment twice on startup: * while warming up the cache * when events from ZK start to come in I think we should protect against this kind of obvious duplicates.
This is normally made so different implementations can override the type() method to go somewhere else in the objectstore - however you have a getType() on BACoordinator so it means no one could ever override the getType() from what I can see, maybe I miss something or maybe its not required but I do need some clarification
nit: create static variable for this empty set and return that static variable
Check for Preconditions and reduce the member variables to its canonical form as expected in the rest of the code if the preconditions are not met. Applies to other constructors of Key.
I'd prefer  public String toString() { MoreObjects.toStringHelper(this).omitNullValues() .add("id", id) .add(...) .toString(); }  What do you think @akemr?
change to List
please separate to a method, getVmTemplateDao() and use getDbFacade().
Speaking of sanity checks, is this: (100 - lastVerified) + 1 OR 100 - (lastVerified + 1)? I assume the latter, although I'm never certain on how it determines this - so maybe bracket it?
I've got a fix in a PR that [removes the watchManager](<LINK_0>, so let's just make sure that doesn't get squashed by this :)
If the o1 is diff than null, o1 must equals o2. If the o1 is null, return "o2 is _diff than_ null" ? I think this second part is wrong?
do you need to select et_name here?
why do we want to restrict it? the error messsage is relatively harmless and doesn't really alter the flow
Given the code of that method after refactoring I guess that either this one or simpleScan should go away...
Moving that bits above and allowing the user to change the decorator via a public setter means you can completely shadow what AbstractTransactionSupportingCacheManager used to du using public API. Also, if CacheDecorator is a first-class concept, you should probably expect that more than one decorator can apply at a given time. This wrapping shouldn't be the responsibility of the caller.
I would have this return an Optional<String>, and make the caller responsible for throwing an exception. Seems odd to have lambda exception being thrown from a method that parses a string.
You should use synchronized (userTuneListeners) { userTuneListeners.add(listener) } here.
Make it final static
We agree to make helper classes immutable -- hence, we should create a new object instead of returning this
this method deserves a description
I wonder whether the upper bounds should rather be: x < this.maxX and y < this.maxY as current this is inconsistent with the int version of this method, yielding for exact integer coordinates false with the int version and true for the float version (for exactly float-representable integers).
Why not just return the condtional?
Raw type?
Instead of all these null check why don't you make getContribution always return non-null? I.e. return default provider if there is no mapping
Doesn't the remove() function return you the UpdateHandler which you want to call onCompleted() on?
You're not using Result.success is the result always non-null? it doesn't seem to be the case since you're returning null in a couple of callbacks ...
It would be better to move this line to _ensureUserIsWorkspaceOwner_ method because it is part of it. You can name it as _ensureUserIsWorkspaceOwnerByName_
introducing double retrieval from thread local, unnecessary perf hit
There is no need to call super.close() on InputStream. It is a no-op method. Instead you just need to do is.close();
As the Constructor for WTab is protected, the addTab method should probably be protected as well, which would allow the class to be extended. What do you think?
Wouldn't Assert.hasText() be more appropriate?
nit: maybe merge the lines as the formatting looks a bit strange.
Maybe its just me, but this calculation looks wrong, since we are assign a = b, then b = a % b will always be 0, since a = b. Shouldn't it be: long c = b; b = a % b; a = c;
use return ... ? ... : ...?
I don't think this is correct. This looks like you are trying to use either class or style. It is entirely possible to have both. The style always takes precedent over the class.
this will need to iterate over the rows and build the Map
This should probably have a higher severity. Also, should use parameterized logging instead of string concatenation.
Should probably set a field with this value
I think that with this logic it is possible that: - hyphen become the first char - hyphen become the last char Those cases are forbidden in hostnames.
Class<?>
Same issue here, double delete user.
(int) -> toIntExact (from Math)
Not necessary.
Can combine the 2 above lines and use the constructor which accepts disk-id
nit: ~Square formatting
can be !isDisabled()
ObjectMapper is a thread safe object. You can create a static instance and reuse it.
Minor: Use this. consistently in the class.
I guess this can be replaced by a public CommandImpl(String name, String commandLine, String type, Map<String, String> attributes) constructor call, what do you think?
Dangerous to call callbacks under the inner lock.
finish() is called in case of an exception but the callback.close() is also included in the finally clauses of the top level methods. This leads to closing a callback() twice which is probably not intended.
nit: It seems a bit funky that we use static instanceof here but isInstance in unwrapAndThrow... - the methods do the same thing but we need the latter for throwIfInstance. We should standardise on one or the other, I'd prefer instanceof as createPalantirRuntimeException already uses that.
@guiseco you don't need to check the validity of the position argument here, since it's based on the getCount() that you overrode above.
This lets you chain the tickers, though I don't think we used this functionality
Add this to WireMessages localization resource
this.monitor to avoid confusion with the parameter of the same name optional: this whole block could be a ternary: this.monitor = monitor != null ? monitor : NullProgressMonitor.INSTANCE;
log()
return SUPPORTED_SERDES.contains(serdeName);
Please make sure the button is visible or clickable.
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
String.format
I think we have some constraints regarding the target URI? (e.g., exactly one? at most one?)
I think that checking tree.expression().is(Kind.PARENTHESISED_EXPRESSION) is kind of redundant here. I would remove this condition and adapt checkParenthesisedExpression accordingly (and then rename checkParenthesisedExpression).
Could you change this into assertEquals(expected, result) ?
Can we use url building here, to avoid problems with / at the end of the server.
Same as above in this class and this PR in general
Add a condition to the log.
This is another behavioral change that I don't want to see in an unrelated PR.
suggestion return Arrays.toString(value);
Inline?
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
I'm thinking to avoid having to work this out later we should probably also record the number of logical cores as well. I guess the most stable way of doing this would be counting the number of model name instances. On my machine there is also siblings, but idk if that's standard, esp on android.
refactor the test with AssertionUtil.expectAssertionError as in <LINK_0> Could you also do that for other should_fail... tests ?
println should be changed to a logging message
To follow Spring Security conventions, please change Raw password to match the variable name of rawPassword.
can you add @Nullable as method signature
Encapsulation
The synchronized can be removed.
I think we should add some text here, to explain why we're rejecting remove() call. maybe something like "this iterable is immutable, can't remove anything"
Use the getter rather than accessing the private field directly.
The constructor of DynamicStringProperty is package private. The reason is that we want people to use DynamicPropertyFactory to create instances where DynamicPropertyFactory will lazily install a default configuration source and attach to the dynamic properties, if none is explicitly installed. You might also want to make this constructor package private and provide a factory method in DynamicPropertyFactory. Or, try call DynamicPropertyFactory.getInstance() in a static block at initialization of this class. === update === After looking at the constructor of PropertyWrapper, it calls DynamicProperty.getInstance() where DynamicPropertyFactory.getInstance() is called. So the initialization of a configuration source is already taken care so it is not necessary to force it again. The constructor can remain public.
latest from today's discussion: return URL
Extract this into a method, given that it's called twice
it looks like far more deeper in the stack from where it should be - let's say that we got an event with a latter time than another one we already processed, when the code is done here it means we'll process it and will just not save it to the DB. I think it should be much higher in the stack - maybe even not to call the perform method in this class if the fetched stats are the latest
If you want, we could loop through every tile here, this should probably be removed/implemented though before this is merged
lambda?
remove(int)
Use MainApplication.worker.execute(() -> this.submitChangeset()) if you aren't going to use the return value -- this indicates that you really don't care if it errors out, and the current thread isn't going to be notified of that.
Should close kill the memspace? What if someone want to reopen the key?
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Change this variable declaration to something with meaning in the context. map is unclear here
Can use constant for "4". More importantly: if the blob is not already encrypted, the config flag "requireEncryption" is true, and cryptoService is null, upload should be skipped. (You'll see some of this logic when you merge with master.)
It's a not a big deal, but shouldn't we throw a TechnicalException instead?
Nit: No need for final.
I'd prefer to remove the field itself. Feels a bit unclean to have a field which is only valid during the execute method. It should be a local variable in execute and passed as an argument to getTagTarget. What do you think?
FYI, magic number 2 can be replaced by constant ComponentContainer.COMPONENTS_IN_EMPTY_COMPONENT_CONTAINER
Wrong JSR number in validation provider.
why null check here? ... oh, it's because super.setSelection() takes a @NonNull. Just declare list as @NonNull instead. Then suppress the warning, because we know that Collections.singletonList() returns a nonnull, even though the compiler doesn't. (This looks uglier, but it's the better long-term solution.)
suggestion if (this.currentTask != null) checkAndRethrow();
Same issue as above.
Better to return "";.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
could we refactor the above into a setUp() method and not having to repeat for each test
This will create 0 connections. Didn't you mean < ?
Is this thread-safe? I guess, maybe, although it might do extra work since not all threads will see the update at the same time. I'm also not sure if ParseSpecs need to be thread-safe; if it's an issue could you please double-check it?
I would change the 'by ourselves' into 'synchronously'
We don't want to cancel the current thread, but we should cancel the schedule if we're running on a reaper thread (rather than the schedule).
Recently someone told me that booleans are hard to maintain because you don't immediately see what the true /false really means. You could use Order.ASCENDING and Order.DESCENDING here instead.
> this [](start = 8, length = 4) no this. please
unnecessary array new: {{true}, {false}} should work here
IMHO it does not need to be public
you can use standard java NotSupportedException
I think we could reduce this constructor to a call to another constructor:  java this(configuration, null);
"%s/_job.%s.%s.log" is used in all the cancel methods. Should we make it a constant for ? It will be good to create getLogFilePath(workingDir, execId, getId) as it is common as well ?
We may want to STATE.remove() rather than clear if these deques are going to grow significantly beyond their default size, to allow shrinking.
random.nextInt(this.totalWeight)?
I hope you do not kill me, but as this is infra component it is good to know the practices... you should not allow caller to modify collection. return Collections.unmodifiableList(errors);
Please keep annotations on separate line :-) I suggest to use Java 7 utils for easier computation: if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } ValidationResult that = (ValidationResult) o; return Objects.equals(success, that.success) && Objects.equals(reasons, that.reasons);
I would ignore empty notifications and would log warning.
change variable to something more meaningful
Better to return "";.
Shouldn't this close the iterator before returning the list?
Could have @VisibleForTesting annotation. Also could public be removed?
And here. needs some validation.
Let's inline this: return doGetInputFieldsForPMMLStream(modelInfo.getPmml());
use return ... ? ... : ...?
other methods like this put name first, then id. switch for consistency
I would really appreciate if you rewrite this so it doesn't use -1 as startIdx. A year from now I won't remember why we want to load from position -1.
suggestion if (keyedStateBackend instanceof CheckpointListener) {  Since the instanceof operator always returns false for null, there is no need to have an additional null check.
since "acceptedType" is of type list i would suggest to rename it to "acceptedTypes"
write nullable on the same line or don't write it
style nit: we don't use braces around single line blocks
You may want to make the default smaller - like 0.01.
Would it make sense to automatically call this method via on-persist/commit hook, depending on the event state?
You can do it in one line. More lisibility.
Iterables.all(toolGroup.getTools(), Predicates.instanceof( AbstractToolDescription.class)); allow to return false if all items are not of type AbstractToolDescription
move 0 to private constant as you use it in many lines, it will be easier to change it in the future if needed
We definitely need to refresh the ListInfo here. This action mutates the list.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Backend does not return null, why do we need a null check here for source?
Can you add a message stating that the query can't be found in the enum, so it's easier to understand what the failure means?
I'd not expose these methods. These methods are called already when visiting CompilationUnit and the result is stored in fields, see lines 38-40 above. I'd make these fields protected, so that you can use it in the rule.
Maybe its just me, but this calculation looks wrong, since we are assign a = b, then b = a % b will always be 0, since a = b. Shouldn't it be: long c = b; b = a % b; a = c;
The value returned by isPlaced depends on the mapped flag as well. It would be a lot simpler if this provider had tuples of [seqID, start, mappedFlag, usePositionDeltaEncoding, expectedIsPlaced], with test cases for each possible combination, and the test just created a new record for each case using those values, and verified isPlaced.
Should we use org.apache.kafka.common.utils.Utils.closeQuietly ?
nitpick: redundant
you have this statically imported
You can do criteria.add(Restrictions.eq("experiment.ndExperimentId", experimentId)) I think
3-ackMessage get consolidated into one-ackMessage for the response are we ok with this?
what if we have a mount with one single volume? Following the current implementation we may assign an unnecessary capacity ratio to it. We only need to calculate and assign the ratio for volumes sharing the same mount with others.
You could make tryList final and perhaps inline initialisation in declaration.
should probably check the app name does not have any chars that are not allowed in a zookeeper node name
If you're going to break this, add moustaches {}.
off topic: I've been writing this as "client == null". I think this conveys just as much information in fewer characters, so by Shipley's law I should switch over. The drawback is that "client == null" is a boolean expression, and is consistent with "limit < 0" etc. . .
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
use return ... ? ... : ...?
why not using the super constructor? super(nodeId, nodeLabel)?
Did you format the diff with helix-style? @BeforeClass should take up a line to itself.
I think we should create a defensive copy of the Map
I don't think you want to keep this print in here and the rethrow as a cause
Shouldnt this be <= ? Is it possible you haven't pulled latest changes? I think this was changed to < 2_12_0 but <= 2_11_0 would be equivalent (and maintain the appropriate value of MAXIMUM_SUPPORTED_VERSION)
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
True. I've never seen a case with -1 as the default. 0 has special meaning in the JVM, so best to stick with 0 as the default and adjust the size to cope (add one or size 0 -> -1)
Readability is concern here, lets keep it as it is.
I think the annotations should be on separate lines
Same issue as above.
No. Remember what I said about anonymous classes?
java return (bundle.getState() & (Bundle.INSTALLED | Bundle.UNINSTALLED)) != 0;
populate with meaningful data. Version should fit to artifacts versions automatically Licence: <LINK_0>
use return ... ? ... : ...?
No need for these extra parenthesis.
Unless I'm missing something, testFinished(class) == testStarted(class) (either a test starts and finishes, or it never starts). Can we just have one method (perhaps named wasRun)?
Same: performance will tank. Need a small reusable byte[] as instance field. This should be OK, since these methods are already not thread-safe.
s/operaiton/operation
suggestion Pattern pattern = Pattern.compile(Pattern.quote(attribute) + "\\s*(.*)");
Please use curly braces for conditionals
You should use either accessors or members; my preference is all members.
StringUtils.isBlank() ? Maybe it is an edge case, but the existing logic is not specific about what can be passed to this field (null, bogus blank strings, etc.). So being more protective would not hurt
Why Integer is excluded? LongOrNarrower should contain all integers, should it?
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
We might use a NavigableSet instead if a TreeSet is used, I assume.
Why can't you just return value here?
this method should not be placed at AbstractBackendResource as it relevant to vm/template/vmpool only, it should reside in the vm/template/vmpool parent.
You could save a few lines by moving the return null into the default case instead of break.
In my opinion, we should have the type check here as well. So maybe change false to isWater(data.getType()) or something
According to the current way how those methods are implemented, it should be return false
@yesamer Hard to demonstrate with few calls, but as general rule it has better performances (and I think readability) if - instead of invoking multiple times the same _getter_ - it is invoked just once storing the result inside a method variable (in this case I would call _getCurrentContext()_ once and store the result in a _context_ variable). As a side note - in this and the following cases, the number of lines to change (and detected as changed by git) would be much lesser, and so the overall impact.
I would log something at least.
This involves a look up of the character encoding type table. Use MessagePack.UTF8
use ShellIsAvailable
Just do return "INBOX".hashCode(); Nice approach though Should be good to push once you've tidied that.
Should use the log, maybe a warning.
typo s/Enavled/Enabled
This is vulnerable to a race condition, since a mutation could sneak between the flush() and closed.set(true)
I think the logic here in the for loop is not right. For an algorithm that can handle both continuous and discrete data, if the annotation has continuous specified before discrete, and the input data is discrete, this algorithm won't be included. For example.  @edu.cmu.tetrad.annotation.Algorithm( name = "GFCI", command = "gfci", algoType = AlgType.allow_latent_common_causes, dataType = {DataType.Continuous, DataType.Discrete, DataType.Mixed} )  GFCI won't show up in the algo chooser when I use some simulated discrete data, because the first data type is continuous and it will return false.
Please, don't reload the text in onResume(). Do it in onCreateView() or onActivityCreated(); onPause() and onResume() may be called when other windows partially hide the fragment (such as the menu showing apps to open the file outside of ownCloud) even though it stays visible.
The login/logout test fails for me at this step when I'm testing on a smaller device (I used a Pixel). The test isn't scrolling to the logout button, so it fails because the button isn't on screen. It looks like something like this should fix it: logoutButton.perform(scrollTo(), click());
You could add a text here to show what the output means. You probably know, but me running this benchmark, I'd need something more verbose ;-)
I think baseUri.toAsciiString() always has a trailing / in our usage so with the current build() method I think you will end up with (for example): http://some.example:80//path/path/path?query=true changing to this.path += encodePath(path) + "/"; will result in: http://some.example:80/path/path/path/?query=true I think both of these are valid URLs, but I think we need to be sure there are no server side issues if we use either // or /?. @tomblench any thoughts on this?
Should be a SamzaException with a message, not NPE.
Calling System.exit needs to be carefully controlled or it will break embedded usage. "Quitting" an embedded CLI may not mean the user wants the embedding app to exit. On the server side we do this by using a SystemExiter interface, and all "exit" calls use that. We then swap in different impls of the interface depending on how the server is being used. The standard impl that is used when we know the server was started from the command line calls System.exit. Others do not.
After the change to using JsonElement rather than String, to fix the bug with complex keys, you are implicitly relying on JsonElement's toString method returning a valid JSON string here for us as part of the URL. This assumption isn't part of the toString method's contract. Use gson.toJson to guarantee you are sending in valid JSON in the URL. The same goes for startKey and endKey, below.
Missed space before {.
Consider returning a constant
will never be true, because of Objects.toString(null) == "null"
How about make "filter" to a constant(KEY_FILTER) in NotificationListFragment, since it's an argument key and many place need to use it. typo it may cause bug in other place.
Would be safer to do something like this.groups = Collections.unmodifiableList(group) otherwise anyone can modify the actual path trough getGroup() which is not great for a public API.
I think isDisposed should also be checked here, right?
ImmutableList.of()
It can be like: java if (o instanceof AdHocActivationCondition) { AdHocActivationCondition that = (AdHocActivationCondition) o; return Objects.equals(value, that.value); } return false;  instanceof operator check null value as well.
config is a non-primitive object, cast to Map<String, String> here before serializing and adding into the map; similar to how containerModels are added above.
Rewrite as: String methodName = element.getMethodName(); String className = element.getClassName(); int low= 0; int high= filters.length; while (low < high) { int mid= (low + high) >>> 1; Filter filter = filters[mid]; int c = methodName.compareTo(filter.methodName); if (c == 0) c = className.compareTo(filter.className); if (c == 0) { return true; } else if (c < 0) { high = mid; } else { low = mid + 1; } }
are these setters used anywhere?
If RETUNING becomes a reserved word, then the [lexical structure](<LINK_0> has to be adjusted as well.
duplicate of "cancelWindow"
Put this static method after instance methods.
static import EMPTY_SLICE and remove Slices. here. Same for other places.
use 'L'
Soft suggestion: UnsupportedOperationException could be more suitable in this context.
Could have @VisibleForTesting annotation. Also could public be removed?
I think each of these two constructors should provide examples of the querystring's they construct.
suggestion this.clazz = Objects.requireNonNull(clazz);
use new Guid(String) - this literal can't be null
I believe wasReconnected() can be called for any use of wasCreated(). Right?
You want to use FormField.getFirstValue() here and everywhere below.
Where does the 5 come from? I feel like we should just throw an exception here.
can this be readSafely instead of readBuffer so that read uses readSafely
Turn this into one or more helper methods. The simplest thing to do would be to have something that returns and List<String> or Iterable<String>. Then you could use standard Hamcrest matchers to assertThat the list does or does not contain the expected outputs. Alternatively, you could make higher level helpers such as assertSleepCount(expectedNumThrottles) and so on. Or even assertCount("Sleeping", 0) would be okay. But for more complex scenarios, you might need to check the order and count of messages. Your call on the specifics, just need something a little easier to read.
[minor] maybe resourceGroupName?
final This should probably contain this.value = value at some point... and it should only do so if isListening = true.
Is reentrancy a problem? It looks like it would be possible.
The second parameter should be "removeResourceSelfServiceUser".
Why do you use 3-argument constructor here?
Is there a reason this is package private? On a fluent builder this feels odd...
also concat the lines
you can check the cache file exists (check line 147, which checks the output report), and you can check the output for the cache warning to not be present
In general I wonder why one should instantiate an (immutable) null Password. I mean passing a null parameter to the constructor. Should this be considered a bug instead and hence throw a runtime exception? Should we update the copyright date to 2017?
I think you want logical AND, so double ampersands. Can we use !license.isEmpty && !licenseShortName.isEmpty && !licenseUrl.isEmpty() instead?
private static final int FIVE = 5
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
- [x] Why need this? Please re-consider based #768.
If item is null, the code will enter here and we'll have a crash. The condition must be split in two; it item != null, all the code is done (including the if (sendEnabled) ... else ...) ; if it's null, do nothing
One of these should be t.iterator().
Local variable not required. You can directly populate the class level variable this.servers
Use ServerUtils.isMainThread() etc.
Dito about Math.min()/Math.max().
Use [Integer.valueOf](<LINK_0> Better yet, don't use value.toString. Is the Object returned not already an Integer?
add sandbox
@ivandalbosco Is it possible to have invalid line? and as a consequence a parsing issue on file level?
@ekondrashev move this assignment to line 103 above.
either change the method name to refreshMetadataDevicesInfoIfNeeded or better yet add the if condition here.
Maybe I am confused, but this is changing from number of children to number of siblings? ast.getParent().getNumberOfChildren() != 1 to ast.hasNextSibling() || ast.getParent().getFirstChild() != ast I am not grasping the equality of this.
I think you will find that there are 1000000L nanoseconds in a millisecond and not 1000L as you suspect
What is this for? Feels like some unintended checked in code?
The flag is being set to true always, the previous statement does the right thing - Did you leave this by mistake?
hmm, that method makes somewhat sense in core java, but I'm not sure I like that behavior for selendroid. We're expecting a boolean value, but essentially we only care about either true or "true" coming across... everything else is false. Is it going to be confusing to any users? I'd almost rather add an additional else clause to check for the string of "true" or "false", otherwise raise the exception. Since users of other programming languages (like javascript or python) may have a different impression of what a truthy value should be.
Unnecessary call to super()
I would use method reference as per below suggestion String[] nodeIds = logs.stream().map(NodeInstanceDesc::getNodeId).toArray(String[]::new);
Do we have to use the configurator for fetching 'MaxVmsInPool' value? A lot of configuration values are fetched in 'VmModelBehaviorBase' (e.g. GetMaxNumOfVmSockets) - try to retrieve it once 'PoolModelBehaviorBase' if it's not too cumbersome.
All of this can be replaced with an ExecutorService
IMHO it does not need to be public
Number of instances matching search criteria ( processVariable = "var_a", "a1" ) are 3, or am I missing something?. If I change it to the following below, I get data size = 3 (which I presume it is correct): Map<String, Object> variables = Collections.<String, Object> singletonMap("task_in_a1", "a1");
Might want to call out (method name? or at least docs) that this is non-daemon since a lot of the other methods in this class seem to use daemon threads
@dskalenko when line can be null?
When there's so many function calls within function calls, it gets hard to read. Break this up into 2 statements.
This is out of scope of this PR but while you are modifying this file, could you also instead import the package and remove this fully-qualified class name?
I wonder if this change would result array allocation and extra cpu/memory consumption issues
RRRRR
Looks odd to use buffer a couple of lines above and payload() here since both refer to the same thing.
This isn't what we discussed and implies mod_cluster can no longer work in a profile meant for 6.x hosts.
Same as above: could use searchPacksAgain
The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Observable.empty() .buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } }) .test() .awaitDone(5, TimeUnit.SECONDS) .assertFailure(TestException.class) ;
already pass sprite2.getName() int ctor
IntelliJ says this is a typo and should be renamed successfulRequests with one l. I believe it blindly!
Is this check necessary? We already know evt.getDeletedTagInfo() is not null, and the call to getContentID() can not throw an exception.
Could you possible make a TextMixin for this? I think that we would use it a lot more for other widgets. With this approach, we can get rid of the HeaderPanels and such that were created, right?
Missing null check on sampleClass
Is this a programming error? Should it throw an exception? There is a similar case above.
I think we have a race here with close.  T1 check assertOpen T2 close() T1 factory.apply( slot )
This does not take a message, it takes the id of the resource that is missing. Here I would just use the no-arg constructor.
Check first that target is not null.
Can we test the other options?
Replace with logger
Can this be within the if statement above?
Why is it necessary to have Configuration and YarnConfiguration? Can this code be simplified to YarnConfiguration = StramClientUtils.getYarnConfiguration(getConfig());
Instead of Integer.valueOf(int).toString(), just use String.valueOf(int)
we should probably check in the canExecute whether we reached the end of the list
Usually we use RequestMonitor.isSuccess(). Is there a reason you use the IStatus directly?
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
The Exception is never thrown.
LOG.info("endpoint : {} , timeout : {}, connected successfully", endpoint, timeout);
This logic seems potentially fragile. What if someone accidentally types in *two spaces*, e.g. -c[space][space]test. Also, have you investigated whether there is a way to potentially use the tools/API in Apache Commons CLI to do this parameter parsing for us (instead of doing string parsing)? If we could just use that CLI API directly, it'd be better than rewriting it ourselves.
To always be safe please use context.getApplicationContext()
the openConnection() call returns a DatastoreConnection. This needs to be closed in a finally block once you're finished with the operation :-)
should we also rename this.blockSize to be this.rowGroupSize ?
CustomTransactionSigner is a StatelessTransactionSigner thus I think this override is unnecessary.
Please add java doc
Please move abortProcessInstance into the final statement, it should be done in any case. Also please delete e.printStackTrace(); - it doesn't bring any value. Also please delete fail(e.getMessage()); - unexpected exceptions should be thrown out of test method, JUnit will handle it as a failing test, printing exception with stacktrace to the log.
Where in the code updates the connectionIdToRequestInFlight queue when a request gets timed out?
checking for nullable parent was added specially, cause going into project node simply has no meaning
I don't see where it is used
This isn't right. You'll stomp all over anything passed to setAlpha and always revert the image to 0xFF. There was a reason it was an instance var that was mutable.
@Nami this is still mutable na, only not by us. It doesn't guarantee that the original input map will not change.
This helper function seems to only be used by fetchUsers and perhaps it could live as private instead of public until someone really needs it. Cheers!
Unnecessary (and incompatible); revert.
StringBuilder
Don't we want to keep this?
path
Do you think we can continue with the exceptions refactoring you started in repository level and throw these exceptions to controller level catching them with exception handling mechanism?
Is replacing separators enough? We should look into something that will work for any special characters.
small nit, can we do this check first for efficiency since it doesn't require the task history lookup?
I do not understand the need for repeating this if/else in 9 places in the code. Repeating the same logic is error-prone, IMO. It used to be in a single place earlier.
This is too broad and is swallowing exceptions that need to be propagated.
We should log this error by using our Log.e method.
IDEA says that using toArray(new String[collection.size()]) has no performance improvement over toArray(new String[0]) so the second call is encouraged.
Defining "dev-machine" string as a constant will make the code clear, IMHO, and will allow to avoid duplication.
Objects.isNull method exists for being used as lambda, direct use is just an obscure way to write value == null
While you are in this code, please take a moment to change "AF" to "file", thanks.
@ikhvostenkov please name it json
unsubscribe()
We should mutualize a hasTag (probably in stats)
Can be replaced with call to computeIfAbsent.
Why not just pass in only the message?
Please reformat: else if ((getParameters().getAction() == FenceActionType.Restart || getParameters().getAction() == FenceActionType.Stop) && getParameters().getKeepPolicyPMEnabled() == false) {
This change breaks null-safety. null.isPresent() will crash and burn.
I don't think these checks are required - the NullPointerException will be thrown down the chain anyway?
This line can go with the playerCamera line below.
I never did like these local caches in the models that Carlos introduced. :/ Besides, creating one of those is dirt cheap. I have no idea why he wanted a cache.
This message is not valid for getReplicas, but maybe it's not worth changing, since it's a trace message
rename to childItem
We should have fs.close() in a finally block. Without that, it's possible for the file.close() method to fail and we'd leave open the FileSystem we created for this stream, resulting in a memory leak. It will be a bit tricky, because we have to properly handle the potential exception in the finally block (which overrides any exception in the try block), since we want to always return the _first_ exception for either file.close() or fs.close().
FakeVertxMetrics and DummyVertxMetrics factories should be updated to reflect the new expectations (return null if metrics options is disabled)
This line now exists in the else statement as well [here](<LINK_0> I don't think this isOnline check is helpful. Because of that we have a hell of indentation here. I think shouldn't have getAsync from model 2 times. What we can do is that, we can first try to get it online, if that is unsuccesful, we can try to get from the cache, if that fails, we can use setIsloading(false)
since we expect outputKeys to be empty we could just count() after .filter() and check that it equals 0
Shouldnt we have this defaulting to the common namespace (ICommonAttributes#COMMON_NAMESPACE) so that we can tell the user what this defaults to?
constructModel already called merge up there.
We shouldn't ignore an invalid enum value.
do you want to create a new list if its null?
Spacing java for (FMLMissingMappingsEvent.MissingMapping evt : event.getAll())  The variable is better called entry instead of evt (event)
StringUtils.isBlank?
optionally: suggestion logger.warn("Unable to open URI with 'Browse' action", e);
stringbuilder?
I think this is meant to be moved within the if (executor.inEventLoop()) { block below?
Replace 1 with TokenTypes.EOF.
Embed the caught exception in the newly thrown exception
What does it mean here to decorate it with Nullable while null is actually not allowed in the following line?
So my suggestion to only allow terminate for a single selection when there is no MultiTerminate service causes a problem with multi-process. In that case, when selecting the launch, the code converts it to multiple processes and then does not allow to terminate with the launch selected because it looks like there are multiple selections. This is a pretty rare bug: 1- someone replacing our IMultiTerminate service with one that does not support multi-terminate (maybe they don't want to support it) 2- running multi-process I wanted to let you know, but I am ok with leaving this in. If someone wants to replace our service, they would have to replace this class as well.
prefer  String operation = isFile ? SASTokenProvider.CREATEFILE_OPERATION : SASTokenProvider.MKDIR_OPERATION;
IOException will be thrown if MappingMetaData is not valid json, right? (populateColumns doesn't throw, so don't forget to update its signature). Then we can rename this error code to sth like ELASTIC_SEARCH_CORRUPTED_MAPPING_MEDATA, what do you think?
Big +1 to this change. Should never silently fall back to plaintext when there's an issue using the user-declared crypto. That said, I'm not sure the CryptoModule should even be configurable. It's too tightly coupled with crypto code outside of the module. I think maybe only the ciphers and crypto parameters should be configurable.
Request.State.OPEN
we should not print the errors to standard output. use StatusHandler.log(new Status(IStatus.ERROR, GerritCorePlugin.PLUGIN_ID, e.getMessage(), e));
nit: suggestion TimeZone timeZone, String suffix) {  I know the rest of the formatting is screwed up but whatever.
Not a fan of this if within the try which makes the try completely useless if charsetMatch is null. How about a check to see if it is null before the try and returning new String(bytes, Charset.defaultCharset())?
a variable is not needed
We could call: java checkNotNull("command", command);  :-)
This should really not be public.
need to check that getVm() is not null and also use it in canDoAction and also new audit log for the user to know it was skipped. please see usage example in StopVmCommandBase and ShutdownVmCommand
I think you will find that there are 1000000L nanoseconds in a millisecond and not 1000L as you suspect
return null to make this more explicit ?
nit: isRecoveryEligible Is this only checks input? -- maybe isRecoveryEligibleForTableScans?
This is really not needed. CommandBase#1256 sets CommandEntity.commandStatus to FAILED in this case.
[minor] ImmutableList.<Segment>of should also work and avoid the cast
.toString() invocation is redudant here.
This may not fail if anything in #rename or nested calls moves to a different thread. Have you tested? I'm not sure how JUnit handles this. A simple #get call on response and a subsequent fail("Rename should have failed when it did not find the current name") would work otherwise?
remove public
this must be disposed
typo: continuously
do we care to check the length to be positive here?
Please auto format all files, so spaces are set properly everywhere
iteration over the entrySet is faster
Shouldn't we throw an exception here ?
OQ: do we want to enforce a capital letter for a first word?
please move the isEmpty methods to the scimSchema
Can't tell how this works from this RB alone. Is this going to become the logical id for the stream when you create a spec for it in the Planner? And then the physical name by default appends the JOB_NAME and JOB_ID?
Why is not the check of presence of certificate with given alias left for the next processing, like in case (principal instanceof NamePrincipal) == true?
This should be doStart as SqlHelper.resolveQuery can potentially load the SQL template from file system. See the SQL docs
I'd rather not synchronize it here. It sounds better to check in the constructor whether config is null and instantiate the default object with new ZKClientConfig() in the constructor, in which case we can remove this if block from here, or at least keep it here just to assert that clientConfigis never null. If we do it, then we can also make clientConfig final.
if i get it right: if response is null, we will not retry. i think we should retry even if response is null. btw what caused this in your case? so it would be:  response == null || ....
Lines 56-71 shouldn't be indented while they are inside if statement from in line 55?
Please assume usage of org.drools.workbench.screens.guided.rule.client.util.ModelFieldUtil.modelField method
remove public
Should probably use a Set<String> instead of a List<String> so that the intention of the code is clear by first glance.
write null explicitly rather than an empty string
StringUtils.isBlank?
there is no other (more elegant) way of getting article name
I prefer to keep the static import.
<T extends EntityAttributes<? extends BaseEntity>>?
Request.State.OPEN
If container is IWorkspaceRoot the scheduling rule must be WorkspaceRoot.
StringBuilder
wouldn't all start times be invalid then?
invoking conn.remoteAddress() could be costly.
Same question about optional above applies to here and to L159 below.
Small formatting issue here. Can fit on line above.
I think this should be a snackbar. For error we are not using snackbars because the activity is destroyed (and undissmissable dialogs are undissmissable).
And then else if this
Can the body be extracted together with commit() method to avoid code duplication?
Check for Preconditions and reduce the member variables to its canonical form as expected in the rest of the code if the preconditions are not met. Applies to other constructors of Key.
Precondition to check page Offset is positive?
I think we have a race here with close.  T1 check assertOpen T2 close() T1 factory.apply( slot )
nit: put with the previous line
In the deserializer, the provider name is uppercased before searching in the map: java String provider = providerNode.asText().toUpperCase(); String providerPlugin = EndpointDiscoveryProviderMapper.getProvider(provider);  Maybe you should do something like this: this.provider = PROVIDERS_PLUGIN_MAPPING.getOrDefault(provider.toUpperCase(), provider.toLowerCase());
Doing these instanceof checks in Java is normally considered an anti-pattern. You want to find ways to avoid it best you can using interfaces and inheritance etc. In this case I'd consider doing leveraging function overloading to make this code have less conditionals.
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
do we really need all of them here? looks like messageId is unique..
We should not use this to set the BitSet size *aclInfo.getRightsList().size()*
This comes from when we pull the body out the camel exchange right? If somebody sends in the wrong type, the exception message does not seem accurate.
can it be package private?
Should be LOG and not Log (currently org.jline.utils.Log)
in the case where the Bytes object is immutable, it would be nice to store this after computing. This way it does not need to constantly recompute for case when Bytes are used in hashset.
Does this need to be a singleton?
While we're in here, could you replace that with this: for (Object selectedObj : structured.toList()) {
Instead of making new ArrayList in the class body, could move the new ArrayList to within constructor = this.children = new ArrayList<>(children) which would exactly size every time.
final for both the variables?
do we care to check the length to be positive here?
check if volume is null and log and return.
Please, do not change method signature for backward compatibility, deprecate it if needed and add a new one.
This should not be on fields as this is custom-role-mapper specific - not related when used as mapped-role-mapper in subsystem.
Extract into a method:  final String gradleInstallationName = "Default"; GradleInstallation.installGradle(jenkins, gradleInstallationName, GradleInstallation.LATEST_VERSION);
IF EXISTS should be reflected in unparse
This annotation should probably stay, and again for parse below
Unsigned types are not used in the current implementation. So, you can omit them.
I would prefer a compiling code here:  void test(DataSource dataSource) { Connection connection = null; try { connection = dataSource.getConnection(); // Noncompliant } catch (SQLException e) { // do something } }
static final String
This method should be static and need not pass this as an argument to the constructor.
id is only used once; simplify to just return <expr> "" + x is more concise than Long.toString(x)
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
Add a check here to verify that the serialDataReceived method was not called.
I think this exception should be about a @ResultHandler annotation, is that's what's being verified in the MessageHandlerInterceptorDefinition#wrapHandler method.
This block and the next could all be implemented by the EDS. This would be safer since it could then be treated the same as other queued tasks (which may or may not be protected by a sync block).
To go up before the first "for" to avoid to call this code several times.
read about SQLiteOpenHelper onUpgrade. You'll need to do version by version upgrading, to preserve old data (we've never really had to use this method before)
You can skip this step, since sources and processors capture this already.
~~Why do types ending with a list have a constant width?~~ My bad, it's for when the _outer_ type is a list.
please remove alias setting (should be encapsulated in addManagedDevice
Tool tips can be slightly more detailed. Sometimes just a one word may not be enough.
I think you should keep the try
Inserting line breaks in log entries can cause pains when reading the logs. Can we remove the \n?
Did OSCORE specify to use ACK (and not RST) even if the message processing caused an error?
I think I prefer "Invalid key" as exception message
you're synchronized on shutdownGracefully. Is it possible we are active at this check, but then become inactive ungracefully? I'm assuming that is also synchronized? I see that the handshake case is covered below in the else{}
Shouldn't this close the iterator before returning the list?
What is this proving? If you  groovy sh 'cat /any/file/at/all'  your log will contain  + cat /any/file/at/all
I'd like to see the code further simplified if possible please. If calling Thread.interrupt() on an already interrupted thread is a no-op, then I'd suggest the following instead...  if (exception != null && !currentThread().equals(testThread)) { testThread.interrupt(); }  ...and remove the testThreadInterrupted field and the separate interruptTestThread() method. Note: this is common practice to move the possibly-null variable to the argument of equals so that a null value returns false for equals without requiring the extra != null check. For example: "nonNullString".equals(nullableString) instead of nullableString != null && nullableString.equals("nonNullString") Note: also common practice to put the cheap-check first in an if condition: if (exception != null && !currentThread().equals(testThread)) ... instead of if (!currentThread().equals(testThread) && exception != null) ...
Personally I prefer to set all fields using this. in constructors, but you call the shots.
This has to diverged internally. Mady, can you incorporate this?
It should close on its own, no need to close it.
i think we should have a else here so we dont print the cwd if the user has enabled the help option.
Consider switching this to List<Object> instead of the unspecified List type.
This is also suspicious, I guess we shouldn't need it now.
Can we rename this.policies to this.customerPolicies? This method is hard to follow with two different lists called "policies"
Put suppress warnings annotation to method and change to direct returning the getted value to avoid temporary store the return value.
Can be the className null? If not I would maybe rewrite as [1], what do you think? My point is to not nesting expression into try catch, if an exception can not be thrown. [1] java if (ScenarioSimulationSharedUtils.isMap(className)) { return new HashMap(); } else if (SIMPLE_TYPES_LIST.contains(className)) { return null; } else { try { return classLoader.loadClass(className).newInstance(); } catch (Exception e) { throw new IllegalArgumentException("Impossible to instantiate " + className, e); } }
I assume this fetches VLAN devices properly, i.e. if the iSCSI bond only uses eth0.101, this won't return eth0 right?
I think we should return a dto here and do the marshalling of the response in the IL as we do with other responses.
Typos: _parse_ and _build_.
Can we add a throws declaration to an existing public API, even if it's deprecated? We just reverted a change [1] because adding throws broke backwards compatibility. [1] <LINK_0>
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
I think the annotations should be on separate lines
The point I was trying to make is that you know this data in the constructor. You can do this logic in the constructor and simply return a copy of the binary data. Before, you were iterating through the Iterable of BinaryData each time, creating a new List object and then throwing it away to get the first item before copying it.
Nit: could you avoid static imports for non-obvious cases like this?
why replacing lockKey by lockKey? shouldn't be lockValue by lockValue?
![Codacy](<LINK_0> Issue found: [These nested if statements could be combined](<LINK_1>
Remove unnecessary blank line
Can't we do better than assert? IOexception?
Why do you use package-private access for this constructor?
Not sure why you are redirecting the name to the EditAccountActivity. That activity is not doing anything with that name anyway.
We have another NPE here
I need to hit ARROW-DOWN twice to get something selected if there's no selection yet. Perhaps select the first item then?
Should this really be public?
same question here, do we account for the colo with single replica?
Don't need to return the Arguments.
As far as I can see, the boolean is not used anywhere, so maybe it could be dropped in favor of void?
make this synchronized.
This check does not belong here, this method should never be passed a null value...
The value returned by isPlaced depends on the mapped flag as well. It would be a lot simpler if this provider had tuples of [seqID, start, mappedFlag, usePositionDeltaEncoding, expectedIsPlaced], with test cases for each possible combination, and the test just created a new record for each case using those values, and verified isPlaced.
emptyTextView can be made View.GONE?
You're probably making this public for test purposes. Instead of making such methods public, we should be having the tests in the appropriate package so that we don't need to use the access modifiers inappropriately. I say inappropriately because this method shouldn't really be exposed to applications, it should not be public.
result not object
not necessary to add "due to"
Rename this variable
what else? any warning or exception should be there?
I don't think args can ever be null, can it?
Shouldn't this close the iterator before returning the list?
i18n
Could use a mocked Model to avoid the need to tidy up.
please move the isEmpty methods to the scimSchema
Should these define the default value? If so, then addDefaults shouldn't be needed, right?
Add catch clause for OperationCancelledException and return CANCEL_STATUS.
Remove?
Avoid the scannerLock object and synchronize on KieRepositoryScannerImpl.this. I believe this will make also clearer that you're sync'ing on the same lock of the scanNow() method.
1. Did you mean support only Firefox for _testing_ right? I assume the difference in behavior affects testing only? In that case we should keep the production code clean and apply any workaround in the test code. e.g. do an if-else based on WebDriver. 2. Yes, I think at some point we stopped using Chrome for testing. There are many other quirks between the two versions that gets in the way of comparing html. We can check if anyone is using Chrome.
This is not necessary. It is done in the RestResourceController, indeed the value here retrieved is not returned
Please name it "Shortest unique abbreviation".
partitions.length is final, because partitions is final, so this doesn't need the lock. Are you adding this to get a code analysis tool happy?
I think we can just go with the  @ContextConfiguration @RunWith(SpringRunner.class) @DirtiesContext  and avoid extra loads for the the same config in each test method. I that case the outbound-gateway-parser-config.xml should be renamed to the MongoDbOutboundGatewayParserTests-context.xml
make this synchronized.
Let's add a ctor for FeatureFlagBuilder(FeatureFlag f) and then make FeatureFlag immutable.
Add and offer are the same thing for ConcurrentLinkedQueue.
Double* variant of this class uses object == null ? null that is better
wrong order
Make this as a log.error statement. And needs to have space after the ","
return new StringBuilder().append()....toString();
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
We should add blank behavior here directly. A blank value should be identical to an absent one.
define static final String TEST_STATEMENT = "select ?[2] from \"SYSTEM\".\"CATALOG\" limit 1"?
You could probably check Jenkins core version here: Jenkins.getVersion().isNewerThan(new VersionNumber("2.64")) in order to optimize the call on the agent side. and to check JNR version before it . But it's rather polishing, which may actually break some use-cases with pre-loaded JAR files
Why overriding it here? If you don't really want to add, don't initialize the variable when declaring it and use copyOf here.
I think it might be nicer to register an anonymous inner class here instead of having this expose the PathChildrenCacheListener interface. Once someone gets one of these objects from the getter above, should they be able to register it with Curator?
this throws a non-IOException. I'm not sure that's kosher given the OkHttp/Feign contract?
ZoneOffset.UTC or similar cannot be used, in order to make it more readable?
i guess u can simply use runInThreadInheritedTrx
If possible, it would be nice to test also the expected result of a call instead of just that the response is not null
Logging and throw is imho an anti-pattern since the caller will most likely log an exception that he catches.
We should mention this default value in the getter and setter
why not check for null?
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
Some linebreaks would improve readability
nit: If we make this method synchronized, then this synchronized statement is unnecessary.
Try to use CollectionUtils.isEmpty instead
We may want to STATE.remove() rather than clear if these deques are going to grow significantly beyond their default size, to allow shrinking.
While this is correct, I think it's confusing to mix StateMachine, which has its own set of guarantees (e.g., "nothing happens except if it's in enter, exit, or processmessage"; "every state is very explicit on the things that an happen in it") with arbitrary lambdas that run on the handler thread. I think it would be less confusing to define separate CMD_UPDATE_LINKPROPERTIES and CMD_UPDATE_CAPABILITIES messages, and have notifyNetworkConnected send those two before it sends CMD_NETWORK_CONNECTED. Or just have the caller (CS) call the two functions before it notifies NM that the network connected. Yes, it's a little more verbose, but it has the advantage that it maintains the invariants of StateMachine. The new commands only need to be handled in the default state I think.
Could you change this into assertEquals(expected, result) ?
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
why did you change to final here? should be outside of the scope of the patch.
can you change name of this list because 'l' says nothing to me
please remove alias setting (should be encapsulated in addManagedDevice
Just inline the variable here.
IMHO it does not need to be public
this condition would always succeed when there is a transformation, because getLayout would return the transformed layout. That is probably not what you intended.
do you want to create a new list if its null?
I think we should rename Identifiable. It sounds like an interface, but it's actually a class. Maybe just BaseModel or something like that. By the way Extensible is also probably a bad name. Maybe we should rename it into ExtendedModel or something like that.
How about inlining it?  if (!contains(o)) return false;
Should we include the label too?
Why leave the capacityMap read logic outside of the validateAndGetPartitionCapacity? Note this will diverge the behavior of the check API and real rebalancer API. So maybe, the check pass but rebalancer fails. Let's just keep them exactly the same.
If I understand this "fix" properly, we were basically creating a new appender for each test, which you're now auto-closing. Plus, you're creating a new logger for each test. Would it be possible to just have LogFixture take in a level, and auto-generate the logger name, so it does not need to be passed in, even if just to avoid copy-paste errors?
Doesn't seem as something which should be public, I would say, it should be rather private. If it is required by cancelAndDismissReloadRequiredWindow, it should be most likely improved in order for this method not being required public
Cannot render banner ad. -> Cannot render interstitial ad. AdMob console -> AdMob UI. Please apply this across all messages.
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
should this be in some MathUtils class?
this and m_ is redundant
why this is in vmCommand? should be in stopBase command
You don't have to unwrap the optional for assertEquals. I think it should work out of the box with object comparison.
can you use item here too instead of hierarchy.getItem() ?
extension can't be empty or /
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
"is handled as if"?
I don't think args can ever be null, can it?
With those 2 lines, you'll instantiate a new FilterInputStream whenever this method is asked. Instead, the generated filtered inputstream must be stored as a field and returned if already existing.
Do we need some kind of synchronization here, or will next() never be concurrently called from two separate threads?
I know this is one of the ways to read the entire contents of a file using only JDK classes, but I'm not a fan. Don't we already have utilities in the dictionary package for doing this? If not we might want to create one and use it in both places.
missing the byte order: pcapPacketHeader.order(fByteOrder);
object -> function?
1. Did you mean support only Firefox for _testing_ right? I assume the difference in behavior affects testing only? In that case we should keep the production code clean and apply any workaround in the test code. e.g. do an if-else based on WebDriver. 2. Yes, I think at some point we stopped using Chrome for testing. There are many other quirks between the two versions that gets in the way of comparing html. We can check if anyone is using Chrome.
the order of arguments in assert*() is counter-intuitive... it's (expected, actual). Technically the 'result' variables should always be second.
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
And then else if this
Unnecessary? It's being imported statically above.
Let's take this out as the user can already do jwt -> jwt.claim("scope", Arrays.asList(scopes))
I this refactoring, very nice. Could make this method protected.
If you add condition hint to card then you can improve card's usability for users. Search for example: * .addHint(new ConditionHint(LudevicNecroAlchemistCondition.instance, "Player other than you lost life this turn"))); How to add: 1. Extract checkTrigger code to Condition object; 2. Use that condition in checkTrigger; 3. Add condition hint to ability. You can use same condition hints in your another PR (#6430).
Is this still needed? We don't add any other elements, so parent.get(anythingElse) should return null anyway.
do we really need this catch block ?
Please also update step description
Never. The thread sleeps in L454 until all remote sub operations are finished. We can unlock before handling result.
Here is another one.
Is this still needed?
IMHO it does not need to be public
Perhaps it's more resource-friendly to use long[] here (value for each partition)
With the requireNonNull, the null check would be redundant... I think...
@Happy-Neko We can avoid inline this variable to the first argument in assertThat instead of declaring a variable and using it just once.
It's Comparator.naturalOrder()
remove empty line
@dkayiwa Are there any visits without patients? Should this not fail with an error?
Is the sort field used at all? I see it being set but don't see it used anywhere.
@tarilabs I usually like to check that the ServiceResponse succeeded before doing any other assertions. It helps to quickly narrow down environment issues when the test suddenly starts failing for no apparent reason.
mutualize code
Consider using Uri.getLastPathSegment()-it seems to do what you want and is probably more efficient.
Instead of hardcoding 2000 here, we can have a constant variable represent the timeout value at the beginning of QuorumPeer.java. [QuorumCnxManager](<LINK_0> is a good example on how it uses constants.
I barely understand how this is working, Content-Type is a header present in the response how can this affect cache negotiation?
This line is duplicated.
doc
1) Please catch WebFaultException (not the generic 'Exception') 2) Please rephrase the TODO in a more informative way: "'getEntity()' always throws an exception if the entity is not found. It should be refactored to make it the programmer's decision. In this context it's legal to not receive a payload for this VM, so the exception is caught and ignored."
:ant: double check of a single field.
IStateEx or IArgumentEx.
nit: if (p != null)
use return ... ? ... : ...?
You shouldn't need to call printStackTrace, the log.error should print the stack trace
Usually we use RequestMonitor.isSuccess(). Is there a reason you use the IStatus directly?
"true" is simpler :)
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
why did we use cast here? can we change it to -1L?
One of the need for acceptSession() API was to show user that it can fail. if session does not get accepted they need to do something? Either go to next session or have some code to log message about it.
this
This seems to change the flow of this test. Before it was depending on the notification arriving through the looper, now it is triggered synchronously. Wouldn't it be better to make a new test case listenerTriggeredOnCommit() or something that tests that the change listener is triggered _both_ on beginTransaction() and commitTransaction() ?
style nit: add a space after if
How does this work if the app image is loaded? Won't the test fail?
You don't need to check session.getPrincipal().isAdministrator(), as hasPermission already takes administrators into account.
return (source != null && source.isValid()) ? source : null;
Can be delayed.
Please return the break
Given that this case statement spans two lines, I think it might be time to make this switch align more with the conventional format: java switch (path) { case FIELD_NOTIFY_SETTINGS: validateNotifySettingsRequest(payload); break; case FIELD_EMAIL_COLLECTION_MODE: //   }
path
Don't need to call deleteOnExit
I thought format used "%s" and "%d"?
Please remove this line
+/- 1 confusion: suggestion return new Diamond3iIterable.Builder(origin, radius).start(radius);
The coverage is not the only important thing in a unit test. Notice that the getValue method is **100%** covered, however, I could change it to this: java @Override public String getValue() { view.getValue(); return "Wrong value!!!"; }  ..and the test testGetValue would still pass. We need to **really** test the logic of the method. See the following unit test (now, it really tests the method and breaks when the logic changes): java @Test public void testGetValue() { final String expectedValue = "value"; when(view.getValue()).thenReturn(expectedValue); final String actualValue = dateSelector.getValue(); assertEquals(expectedValue, actualValue); }
rename to a more meaningful name. :)
assertThat(build.getConsole(), containsString(customWorkspace))
Create the tool section between the layer and the first mapping. Then pass it as parameter of each createXXxMappingYYY method and in those methods, you will have the possibility to create a creation tool correpsonding to each mapping, link it to the mapping and add it to the tool section. ContainerMapping -> ContainerCreationDescirption EdgeMapping -> EdgeCreationDescription NodeMapping -> NodeCreationDescription
Why is it better to use more than one scope to test?
Shouldn't it be logged in debug only?
Same as above wrt "logging protection"
don't we need "\n" after BEGIN_CERTIFICATE_STRING?
Could be a try-with-resources.
1 -> numInputChannels ?
add null information
Missing final
Consider to use negative condition here, so it will just return false when the super CDA will return false. Also use the formatter on the if condition (add space between the if and the call to super)
suggestion Assert.notEmpty(query.getIds(), "No Ids defined for Query");
Simpler would be to call this method from the overridden initialize() method from this class. That way you will not need the templateValidate() method in the upper class at all.
can you also test the case with begin > end?
All configuration attributes should be taken from the model, not the widgets.
Isn't a LinkedList better if we don't know the size (to reduce reallocations and copies)?
No use checking if the list contains() before remove(), let's avoid double iterations.
I think this can just be file = file.getCanonicalFile();. If getCanonicalFile() throws, the assignment will not be executed.
This looks good to me. A minor nit, can we change the condition around. !IsNull looks like a double negative to me. Something like if (isNull) throw UsageAuthenticationException; // no need for else return SSOStateSerializer.serialize(tokenItem);
Static import
I think this works the way we would like to see the equals work, but take a look if you'd prefer the shorter: return Objects.equals(this.deviceIdentification, device.deviceIdentification); over all the null checking to see if the result is false, followed by returning true.
Remove extra semicolon.
Good spot! We could actually do this: java authCardDetails.getAddress().map(AddressEntity::new).ifPresent(addressEntity -> { //   });
Why doesn't Menu.java's implementation of getTextForBadge() also include this call to .subscribeOn(Schedulers.computation())?
assertThat(entries).hasSize(3); the same for several occurances below
Recommend to use ToStringBuilder
How about passing in groupBy instead of just groupBy.isUngroupedAggregate() as I think we'd want to get more info eventually out of the groupBy (for example, if it's ordered or unordered which impacts memory usage substantially)?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
replace with persistCommandIfNeeded
Shouldn't options be Immutable?
bootstrap() itself should mandate an update, right? Do we need to call requestUpdate?
other methods like this put name first, then id. switch for consistency
Add a message to checkState so that it's easier to debug if we ever hit it.
Make these methods public since they are part of the public API of the class. If we want to restrict access to the class, we would make the class itself package private.
nit: throw new RuntimeException(e); so if this ever happens (unlikely), the error will be more obvious in the test
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
Variable naming. Be consistent across the entire codebase. why sc? sock or socket?
error message should be changed to reference actual problem of "not a leap year". See existing implementations.
can be replaced with String configValue = StringUtils.removeEnd(config.getParamValue(), "%") which basically does exactly the same.
If possible, configure from properties file
Should we use Objects.equals for this to be safe? The current code assumes that the fields are not null. I see the fields are annotated @NotNull, but that just affects validation.
@clarysabel can it be extracted to a method? all SEARCH_TRANSACTIONS_QUERY queries will need to have the same scalars right?
i don't understand why this would work if input.getBaseObject had complex metrics
These two lines should come before the if. (Remove in the other branch.)
public isn't needed
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
This should be replacable by switch (solverStatus.get()), as all the actual state mutation happens in solvingTerminated()/solver.terminateEarly() as I've suggested above.
since we did not advance so the event is not thrown away really.
Does this mean any OM can talk to SCM to get blocks?
this might actually cause the files never deleted. because new temp dir will generate a new directory and it is never deleted. I would suggest using JUnit temp folder. <LINK_1> <LINK_0>
We should have tests that pass FieldAttribute.PRIMARY_KEY or FieldAttribute.INDEXED.
> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
start
Please avoid code style changes like this to existing code.
It can be written as return restTemplate.postForObject(verificationUrl, request , JsonNode.class).path("success").asBoolean()
You don't want to use an exception that extends MyNakadiRuntimeException1?
So it is allowed that user to create a read-only realm in thread A, but writeable Realm in thread B? I don't think this matches the behaviour from Object Store -- we need to ensure the behaviour is the same after we migrate to the Object Store schema, otherwise there is going to be a breaking change.
Should this be synchronizing on the span rather than this?
be careful here. The old code was done so that the loading of the Language was done within the try-catch block, allowing us to capture the UnsupportedClassVersionError (when running under Java 7 with Apex in the classpath). This change will simply break at this point without being captured and skipped.
I'm not sure why this variable is needed here. Could be: java public static String getAttributeValueFromString(String string) { if (string.length() > 0) { return string; } return null; }  This functions also will fail if string == null. Should be something like this: java if (string == null || string.length() > 0) { return null; }
Typo: reassigned
out should be closed.
url.endsWith("/") would be easier to comprehend. String comparison should be done with equals, not == or !=.
Maybe its just me, but this calculation looks wrong, since we are assign a = b, then b = a % b will always be 0, since a = b. Shouldn't it be: long c = b; b = a % b; a = c;
@bxf12315 same as above, please use assertThat.
Here should be NOT_INCLUDE_DEFAULTS
the open and closing brackets doesn't match.
Why we should change behavior for the deprecated method?
As the only callers to this (confusing) stripPath(*) are now wrapped in a Path entry, wouldn't it be better to simply reimplement stripPath with Path?
Put ITEM in front of OTHER_FUNCTION
This shouldn't declare throws Exception.
Should be SSLException instead? (HttpPanelSender needs to be changed to just re-thrown the exception instead of wrapping in IOException.)
is this check necessary?
do this before creating files
default method visibility OK?
please double check that marking the end of things are being done in the right place (that is, do it in the finally if you want to cover all exit paths).
Use constant
Log the event here? Logging is also missing when connection is rejected due to maximum number of connections. Might be useful to add that as well.
let's make it private for no
Suggestion: "--active and --inactive options are mutually exclusive."
use return ... ? ... : ...?
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
Trying to follow this. The check above has failed, so this is handling the transactional case, which means we should be in the abortable or fatal error states. If we are aborting and we can bump the epoch, then sequence numbers will be reset after receiving the InitProducerId response. If we cannot bump the epoch, does it make sense to reset sequence numbers here? It should be for the partition that raised the UNKNOWN_PRODUCER_ID error, but how about the rest?
Let's move this line below, just before the requiresFBO line.
formatting
Should be findValue() not findField(). This will then default empty schemes.
Why not in combination with above do this: setValue(value, false);
There is no need to mock api calls to implement this test.
Do we have only two types of disks? Even if we have, this code will fail when we add another type. I think we should check for LUN type before trying to update one.
unnecessary null check
It feels to me that there is much code duplication between this and DateTime.truncate
I assume this lazy initialization should never happen as we will always initialize this field in class constructors, agree?
This variable is very badly name if it's supposed to be the serializedUserReference.
also these *xx things should be constants.
Shouldn't this close the iterator before returning the list?
Unless I'm reading this wrong, if the user provide a rootPath ending with \* this will add another /, then it will add another *. We shouldn't add the slash if it already ends with *
This is wrong. getFullPath returns the workspace path (e.g. /org.eclipse.egit.ui/plugin.xml). It should use getLocation(), which returns the file system path.
It's advisable to start variable names with lower case
suggestion console.warn("Usage: \"changeShip module:shipName\"");
please replace with instanceOf (you can regenerate it in eclipse by checking the right options)
brokersResult.brokerResult looks a bit unclear. Please consider renaming to something like addResult, registerResult
toString(java.io.InputStream) usage is deprecated. IOUtils.toString(inputStream, StandardCharsets.UTF_8.name()) is recommended. This is not critical, just seems like is causing a build issue on some travis build.
When this update activity is launched, can the user back out of it? Is that okay?
It is not, this change should be reverted.
Please rename this to eObjectMatchEngineFactory or something closer to the real use.
nit: can be final Vector<URL> resources = new Vector<>();
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
Extract properties.getRest() into a variable.
"SocketServer time spent on write per key"?
I think that may have been an oversight in longSum. Try a query that results in +Infinity at the historical level and you will see why it is needed to deserialize at the broker level
I don't think this optimization of repacing .equals by '=' is correct. I suspect there are cases with dynamic metamodels where we won't have the same instance of feature on each side of a comparison...
exportAsXLS separate with .
why reload the index if you are going to close it again?
This means clockHand will be hot at initialization time. Intended?
Should be cached or initialized in a field.
should have public modifier, for consistency.
Inline?
@Serranya same here. See above.
can you please explain what do you mean by testing for "same" ? e.g. why would following not be enough?  Assert.assertEquals("xxx", extractionFn.apply("bxxxb")); Assert.assertEquals("xxx", extractionFn.apply("axxxa"));  are you trying to test sameness of "xxx" ?
please factor out into a wrapper method within the activity
Why not prefer the new one (spec) if it's set?
I am failing to see the bug. You will be iterating while (responses < commitList.length). CompletableFuture.anyOf() will be invoked for all CF which do not execute exceptionally.
file might be a directory - message will then be misleading
This should be absent()
we should return 5 here to keep backward compatibility with previous implementation
this seems like it should be exception != null or result == null
should this be in some MathUtils class?
Init should only be called one single time when constructing the controller. That is done in OnStart. Please add a space between if and (
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
These throws shouldn't be necessary for an unchecked exception
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
We should add some log to the validation process
Use .isEmpty() rather than .size() < 1
Minor point, but it seems like the reading should be in a separate outer try-with-resources, rather than nested in side the writer.
Can we unregister the node in the graceful shutdown path as well?
static?
Unsigned types are not used in the current implementation. So, you can omit them.
I think baseUri.toAsciiString() always has a trailing / in our usage so with the current build() method I think you will end up with (for example): http://some.example:80//path/path/path?query=true changing to this.path += encodePath(path) + "/"; will result in: http://some.example:80/path/path/path/?query=true I think both of these are valid URLs, but I think we need to be sure there are no server side issues if we use either // or /?. @tomblench any thoughts on this?
This can be optimized to a simple messages.get() if the underlying Collection is a Set.
We don't really need to create a new deserializer for each request.
npe if (datagram) should be: if (datagram) boss.shutdownGracefully();
Missing strings to fill in the first three placeholders: suggestion System.out.println(String.format("Received event [%s] on channel [%s] with data [%s] and event [%s]", event.getEventName(), event.getChannelName(), event.getData(), event.toString()));
Please align with other methods in this class, where extractionFn is checked outside of lambda
This won't generalize. I think you need a method to get a feature ID programmatically.
Can you extract this to a method? There is code duplication here.
baseId +diagram
May as well use static final byte[] EMPTY = new byte[0]
if i get it right: if response is null, we will not retry. i think we should retry even if response is null. btw what caused this in your case? so it would be:  response == null || ....
GitHubSCMNavigator. suggestion NamedArrayList.select(all, Messages.GitHubSCMNavigator_withinRepository(), NamedArrayList.anyOf(NamedArrayList.withAnnotation(Discovery.class),NamedArrayList.withAnnotation(Selection.class)),
if you do this, better put N/A :)
Cast.
Not sure why we are passing connectionProcessor and connectionProcessor.getRetryOptions().getTryTimeout(). If the session manager has the connection processor, it should be able to get the retry options from it anyway. Also, it's weird to see retry options in connection processor.
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
This can be static.
I think it's possible to do that more elegant by streaming one list and using iterator of another list in that stream.
What consumes this new field?
maybe the orElse should return something else except null
Can you please convert this to throw specific exceptions instead of PerunException ? Thank you.
don't you want to add a/b?
@Override
double check that the group is still here
Use localization parameters
use return ... ? ... : ...?
did you want to remove this throws IOException as well?
Why is this not based on context.getCurrentUser()?
Should we really use it by default? I agree this would be nice (and we surely will do it as of BV 1.2) but for now the spec [describes](<LINK_0> "arg0", "arg1" etc. as the default names. I feel we should stick to this for now.
IMHO it does not need to be public
It would be safer to use StringUtils if the group is null.
(or can use @Restricted(NoExternalUse.class) if this is not intended to be a public API)
Important information for admins.
As with others, I would not assert on the return value of the operation
We should change that test, it makes it cumbersome to implement rules in parallel.
We should implement filterOnlyAllowedAttributes() method to perform authorization check on list of RichUserExtSource as we have for groups and members. It will be part of Bl layers and called from here. Also, I don't know if we have authorization check on ues attributes. I believe, that right now they are accessible only to perun admin, and will need to configure it on each instance on deployment.
getSourceVmFromDb can return null..
nit: uppercase NULL
add principal name to message?
Why is this not return this.kind == kind ?
if you filter that way you will end up in streaming nulls, won't you? Wasn't your idea to filter discoveryResult != null ?
Use .setBoolean() method.
Could there be value in adding a warning statement if we detect current being 1000ms less than last? That could indicate a clock drift, which might be worth logging (although we wouldn't want to spam it(.
This check does not belong here, this method should never be passed a null value...
@mykelalvis please, rename to server. s is meaningless :)
why filter is applied only to plot names, but not to summary? we are going to show monitoring params in summary when decision maker will be ready
Can we avoid this switch/case block?
Are you sure this is right? Please double check.
suggestion return new Intent(context, CustomTabsManagerActivity.class);
I'd extract this into a method isUnset(Diff) as well. Don't we have util methods for determining whether it is an unset? They seem to be very generic and maybe should go there, if we haven't them yet.
I don't see why we need these sorts of constructors... We've never needed them before, and there's nothing special about the useLayerNormalization arg (it's just another boolean)... unless I'm missing something?
you should assert the entire Schema objects are equal rather than just checking a single field type. You can just use the schema object directly, don't need to check field by field.
please don't do in the middle of method return. use else instead. also you can always refactor the branch into a separate method if there is too much condition
You do not know if you can communicate with the bridge yet, so you should not set it to ONLINE here but at the place where you know that a successful connection has been established. I do not have the hardware, but if I add the bridge as a thing it shows Online which is obviously wrong and a result from this line.
This seems like it should handle the exceptionsl ike the RuntimeException block from above. Why make the distinction here?
nit: we might want log different message if we're ignoring due to a fatal state instead of due to a bumped epoch or ID.
TransportException is not just a wrapper for other exceptions, so where it is thrown and it's (sub)class is important, just pass it as the new cause.
Bad code. Remove try - catch.
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
If someone calls offset.reset() (topN does this sometimes) then this will be wrong. I think you need some logic to detect the offset going backwards, and resetting the iterator in that case.
Doesn't look like limit needs to be re-parsed each for loop (I realize the old code did this)
unlike other places why await() needs to have a timeout here? It seems, test will fail anyway if that timeout is reached, specifying it here is not doing anything.
@ivanarrizabalaga why do you extract this bit of code into a method? Is it not better to leave it as it was before the fork?
Should be okay to use isSessionOpenForSubmission directly here and below.
Shouldn't this close the iterator before returning the list?
why the 0 what's magic about it :trollface: ?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
Adding some checkNotNull() checks?
Same thing, using this method here may cause the getLinePixel method to return erroneous result, which may cause regressions in customers (I think code minings actually use this method extensively to compute where to draw for instance)
This doesn't apply generally to packages as they don't get annotated with this annotation the way profiles do.
* Why is super.reinitialize() not public? * If you want super.reinitialize() protected, this class could "open it up" instead of defining a new method: @Override public void reinitialize() { super.reinitialize(); }
s/public//
final ![200x200](<LINK_0>
nit: if (p != null)
Is there a reason why this method throws InterruptedException?
you should also do withRepresentationProperty(DS_ID)
should this System.out be here?
You're better off pokemon-catching these.
It seems like we would be better off making this actually return the path instead of a String. It's different than the old API, but I'm not sure I see the use of getting a string back.
Annotation values cannot be null,  @DockerFixture( , dockerfile=" ")  seems like an unlikely user mistake, and comparing to "" is deprecated. This method could just be inlined as  java !f.dockerfile().isEmpty()
String.format
name can be null, causing compareTo to NPE if its on the wrong side. In these cases maybe treat the name as though it was "".
why not compile once in field?
"due to".
Does the StringUtils.isEmpty function work here? I usually use that and expect it to handle both the null and empty cases (you'd still need to trim it I think... which brings up another issue I've been thinking about where we probably need to trim all input from the user but don't do it consistently).
We do not need to check if debug is enabled since there is no string concatenation. The check will be done internally.
There's a typo here, it should be no authenticator jar files.
Good info level, I think
Integer.SIZE here as well
Define "data-agent-conf.xml" as a constant
How does this work if the app image is loaded? Won't the test fail?
Does this method have to be public? Maybe we should use private.
Think it might be worth doing this in scanHttpRequestSend as well? In case Jso is being POSTed, etc. The method could be changed from using the msg to accepting the body.
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
normally we use italic text for info icons like this: numaInfoIcon.setText(applicationTemplates.italicText(message));
Symmetry (throw)?
What happens when mergeSortProcessor doesn't have page from every source? Does it return null?
It looks very much like those validation methods should throw an exception wrapping the list of invalid objects and not return anything. This would make it more obvious that we are in an error scenario and simplify the UploadServlet.
nit: you can merge both lines above as checkNotNull will return the given argument
I am wondering should we use a ConcurrentLinkedQueue here instead? It is a collection that provides duplicates but in a non blocking fashion.
This requires all substrings to be present, we want containsAny
I would be more defensive here. I would check if the num of containers returned by getContainers() is > 0 and if the value returned by getImage() is nullOrEmpty
Why deprecate this? Seems like it would still be a useful method, no?
Don't use a file just to store a "true". Directly pass the String here.
One more times(1).
Please rename to remoteCache0, it's too close to cache(0)
"_helixManager != null ? _helixManager.getClusterName() : null" --> "clusterName" ?
We need to enforce TCP connect timeout and read timeout, apply reasonable defaults, and make the timeouts configurable.
Can you use a more relevant variable name?
use return ... ? ... : ...?
index < arguments.size() ?
Tip: we can use StringUtils.stringToInt() here and in getWidthInt().
Should be a SamzaException with a message, not NPE.
IMHO it does not need to be public
This should also have some way for the caller to react to the error. Probably an exception?
i don't think they are all supposed to be uppercase. in fact, i think in the wiki the acceptable values are: -beta -alpha -RC -RC2 - same as the three above but with a version appended
Since this is INFO level, how about: suggestion log.info("Shutting down thread monitoring tables.");
Thanks for this patch @Chyler. This has the correct behavior, but the LOG.info below may give the wrong reason. Can this be improved to log the two cases separately?
I don't know, but isn't the class also of interest?
We should add Assert.isNotNull() check here, to make sure that the new contract between hasAttribute and getAttribute is not broken unintentionally.
There are many unneeded changes, mostly code style, in this PR. Removing this. is not needed and adds unnecessary noise to this PR. Maybe move this to another PR.
I believe this is a leftover change from your previous, unincluded PlantRegrowth rewrite. It stops plant sources from being set to air once utilized.
I mean that setBytes(1, null, 0, 1), setBytes(1, null, 1, 0), etc. should throw some exception (NPE or other) instead of returning 0 to indicate a problem.
This implementation does not seem useful, as there may be dozens of those. I would print the number of events and that's it.
t1 shows up as unused variable, please remove the assignment.
Can we move this above cGroupsCpuResourceHandler.prestart()?
IMHO it does not need to be public
I would have this test within the flow from yield method in fact, so the algorithm is pretty straightforward and the method to compute flow from yield will only do so if required... (and return an emtpy list otherwise). (In fact if I'm correct you actually don't need that test at all...)
Is this still needed if the value gets overwritten in the next line?
Isn't this problematic, since the byte-array may not be a string, and it may not even be decodeable as a string, so this could throw.
use getPermanentOrLKI otherwisw thr resolution will fail if the Enchantment left the battlefield between triggering and resolution.
nit: I'd probably put all the CLIENT_1 and CLIENT_2 things in order (which you do in the assertion)
any reason to change this? Not sure what /:denied does compared to :/denied
ditto about "indeterminate" in error messages.
I can see why this is necessary, with the change a few lines above from 'indexOf(".")' to 'lastIndexOf(".")'. However, there are two things I don't like about it: * what about, say, "model.profile.profile.di" ? (granted, unlikely, but handled by the previous version of this code) * more seriously, this hard-codes an extension that is defined in a <diagramCategory> contributed by some plug-in on the org.eclipse.papyrus.infra.core.papyrusDiagram extension point. Other plug-ins can define additional extensions that aren't enumerated, here. Rather than hard-coding this, we should look up the extensions that need to be trimmed off in the DiagramCategoryRegistry
Missing blanks around "=".
do we care to check the length to be positive here?
I think it might be cleaner to directly use bitLens and values here.
Can we check that all params are declared as classes in a single place? Now, we have to copy this check for each signature.
It looks like the delimiter is never consumed here. So down below on line 83 I suspect you'll get an extra , at the start of your oauth2part, but only if an authorization ID is present.
I don't think that these methods need to throw a checked AccumuloException. It might be preferable for them to just throw an IllegalArgumentException, since the problem is with the bad argument to the method, and not a problem with Accumulo itself.
Do we want to support all the arguments the QueryResponseTransformer supports? ![image](<LINK_0>
Might this not cause extra copying of the buffer contents when transferring data between network and storage?
checking for nullable parent was added specially, cause going into project node simply has no meaning
@maria-farooq we should provide a description to the log message
Shouldn't this close the iterator before returning the list?
I think for contacts it would be better to use Number: instead of Id:. Otherwise it looks good!
I would prefer the format to use id next to the entity type, like  log.info("{} removed attribute {} from member {} in group {}",...
It's a not a big deal, but shouldn't we throw a TechnicalException instead?
If you ever make this public this _ will break the JavaBeans specification.
Could you please catch more specific exceptions here? It's either KeystoneServerException or KeystoneConnectionException. In particular if it's KeystoneConnectionException, it doesn't seem correct to re-throw InvalidCredentialsException.
f.isFile() is better since it checks if .project isn't a directory accidentally.
Use org.apache.flink.table.utils.EncodingUtils#objectToString
you fetch vdsDao.getAllForCluster(getClusterId()) and then fetch it again in runAnsibleReconfigureGluster() (line 304) you can save it to a local variable and save the second call. Also, it seems that you rely on host 1 and host 2, therefore you can just pass them to the method runAnsibleReconfigureGluster(firstGlusterClusterNode, secondGlusterClusterNode)
Not really.
this will go to the char after '[', is that OK?
Since Rx is optional, would be great if you add a check, I've added this in Hawk.java but that can be moved to utils and used here as well.  java private static void checkRx() { if (!Utils.hasRxJavaOnClasspath()) { throw new NoClassDefFoundError("RxJava is not on classpath, " + "make sure that you have it in your dependencies"); } }
non owning side
should be named resource
Use the jclouds predicates2.retry construct. If this is a common thing to be done, consider creating the predicate and make it injectable so other classes can benefit from it.
Sorry, but I don't think this is right: IMO the new eventually calls should be exactly where the sleepThread calls were
Why do you bother with this? Don't bother catching or even the try if you aren't going to do something useful with it. It will automatically propagate to the parent.
Could you rename DirectDebitConnectorCreatePaymentResponse to remove "Create" as it's now used for both create and get
Why .getClass() versus just printing the object?
Should we add some kind of bounds check here?
This should be done in the constructor. Then you can also make the member final.
final is unnecessary here
Could you please add clear message for case when assert failed?
I think we can be more general here. If accrualSchedule.getFrequency().isMonthBased() and rp.getResetFrequency().isWeekBased() then...
suggestion localBias.keySet().removeIf(o -> segments.contains(keyPartitioner.getSegment(o)));
Same here, stage-->i is pointless.
You need to also store the lastStartTime: long lastStartTime = prevFullState == null ? -1 : prevFullState.get(statusQuark).getStartTime(); Also, lastEndTime can change for the same attribute while it's being build and below...
The constructor of DynamicStringProperty is package private. The reason is that we want people to use DynamicPropertyFactory to create instances where DynamicPropertyFactory will lazily install a default configuration source and attach to the dynamic properties, if none is explicitly installed. You might also want to make this constructor package private and provide a factory method in DynamicPropertyFactory. Or, try call DynamicPropertyFactory.getInstance() in a static block at initialization of this class. === update === After looking at the constructor of PropertyWrapper, it calls DynamicProperty.getInstance() where DynamicPropertyFactory.getInstance() is called. So the initialization of a configuration source is already taken care so it is not necessary to force it again. The constructor can remain public.
We deserve at least a DEBUG log here.
locks can only be non-null if we entered the if block and reached the line between 187 and 188 :-). At that place it is also guaranteed to be non-null. Therefore, move this code below the line 187 and remove this check.
Use the inline ArgChecker form
please don't create null instance, when unable to get instance, just throw IllegalStateException with description of what happened
just use context as synch obj
Wizard shell
Do you think if better handle the status code here: <LINK_0>, because that is the method sole responsibility to produce the correct HTTP response and thus you won't need any further logic elsewhere
You don't need the variable here. You could directly return inflater.inflate(fragmentResource, container, false)
This could be shortened to: if (isStringEmptyOrNull(searchStr))
executorService? connectionStartupExecutor? How about closeConnectionExecutor?
return (this.sslContextDependency != null) ? this.sslContextDependency.register(builder) : builder; :)
i don't understand the need for display-name & display-order
The existing return output.repeat(2, (long) getN()); should be replaced by:  try(MemoryWorkspace ws = workspaceMgr.notifyScopeBorrowed(ArrayType.ACTIVATIONS)) { return output.repeat(2, (long) getN()); }  We don't want this to be detached instead.
Remove this line too because the variable "configuration" will become useless.
If this logic is need, please find a way to reduce the code duplication. see azkaban.test.Utils#initServiceProvider
When assumption fails it emits an exception that is ignored by the runner (effectively, later part of this test method is not executed)?
root would not change and I can't think why its access needs to be serialized with other methods so why does this need to be synchronized?
I'm not sure that it will be correct to return only 400 for Nakadi Exception and 503 for everything else. I think that in reality there are more options.
Need to exit the function here if the table was null.
matter of taste, this could also be return this.profileTypeRegistry != null;
marshallCollection handles null
Should properties be setable? Also what if properties argument is null?
Would it be possible to retrieve only message keys? Not sure if that is possible here
Check for null. This might be from another PR.
Problems confirming new user email: wrong information
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
The status should never be null, instead it should either throw generic exception (including NotFound if that is what the response from the coordinator indicated).
If the delay is positive, the thread can't be reused and the code must be enqueued. Or, we have to check in UiThreadValidator' ifPropagation.REUSEis used with adelay.
Should this return false? I thought we have the theory that blank counts as false, in general.
To always be safe please use context.getApplicationContext()
Do you consider this(hostId, 1, 1); nicer here?
should be singular, VTIDSection. It's not like in French (ex. un magasin de souliers vs a shoe store).
public boolean hasValue(@Nullable String value){ if (adapter != null) { return (getAdapterPosition(value) >= 0); } return false; }  Not sure why we are instantiating a variable here.
Will it not be a good approach if we get object using function **getItemAtPosition(position)** and then check from its attribute if particular video or group of videos has downloaded ?
static import?
I think baseUri.toAsciiString() always has a trailing / in our usage so with the current build() method I think you will end up with (for example): http://some.example:80//path/path/path?query=true changing to this.path += encodePath(path) + "/"; will result in: http://some.example:80/path/path/path/?query=true I think both of these are valid URLs, but I think we need to be sure there are no server side issues if we use either // or /?. @tomblench any thoughts on this?
I don't think args can ever be null, can it?
Maybe we could also add _seq_no or so to the RETURNING clause here. As that is one of the use cases we want to enable
String.format
Let's find a better name for _bufferSize
We should return true here to ensure the menu is displayed.
dspaceCollections[i] could NPE. i.e. if your site only has like 5 collections, the limit is 100. So, 0,1,2,3,4, 5..99 would NPE. If we fix findAll(context, limit, offset) above, that would be a safer way...
I think It's needed to convert to milliseconds.
@mariebawanan I think the proper fix for this is to remove the duplicates in variables VariableTypeList instead of just filtering out the duplicates here.
this is not vdsm, should be another configuration or setting within database, but we kill this code anyway, so not that important.
It might be interesting to allow CNull here, actually, to allow for more flexible code. Setting a CNull would clear the command.
final IPath pathString = Path.fromOSString(path); is needed and pathString needs to be passed to the createLink() method below. That's why the Unit test fails.
I think something like this should be discussed in #3788. We already cause quite a lot of traffic to iTunes and I want to keep it to a minimum, so we do not get locked out one day.
ERR_DELETE_ERROR, add if there isn't one already
"Encryption failed"
Instead of collecting transaction edit logs here, we can add the count header in AbstractTransactionLog.sync() method before calling append, right? Since the edit logs are already being collected over there, we will then avoid code duplication.
Here and elsewhere, the Fragment probably shouldn't force the host to do things by getting its internals and changing them. The dependency on a toolbar is clear because of the callback pattern but exposing the toolbar directly allows any Fragment to change it. It's ok to defer but consider pushing onSearchOpen() into the host and allow it to hide / show the toolbar.
Could you possible make a TextMixin for this? I think that we would use it a lot more for other widgets. With this approach, we can get rid of the HeaderPanels and such that were created, right?
<LINK_0>
Not necessary. The web plugin should be bound in the Gerrit-HttpModule.
Instead of performing the candidate search in the get() function above, you could do it in this function and avoid the double control lookup for each candidate. And since this method returns all the info needed to return projects and project.Namekeys, the get() function could then call this one instead of this one calling get().
refs already has a meaning in git/JGit, maybe this should be named otherBranches or something similar. Same thing for allRefsExceptCurrent, maybe it would be better to name it findOtherBranches.
method.getMethod() is already clear. You don't need to extract this method. Please get back to method.getMethod()
no.
Missing blanks around "=".
IMHO it's better to explain proposal of setup debug id here to prevent occasional removal in future, like the follow: > do not remove debug id; it's needed for selenium tests
Should we do an eic?
Maybe better to return null
Better: use Scheduled.isActive()
on the catch, let's add a servere logger
I think we should prefer a setter here rather than member variable access.
It would be good to verify that each export dir contains a disjoint set of file names. This may be a good place to do this check. If the check is not done and someone make mistake it seems like it could lead to multiple entries for same file, but I am not sure.
rename to childItem
We could check the envelope first.
The value returned by isPlaced depends on the mapped flag as well. It would be a lot simpler if this provider had tuples of [seqID, start, mappedFlag, usePositionDeltaEncoding, expectedIsPlaced], with test cases for each possible combination, and the test just created a new record for each case using those values, and verified isPlaced.
Needs some sort of assert to show it succeeded
unretire or unvoid?
Does this need to be a singleton?
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
Works anyways but a bit weird to have it return an Object, would look better returning a Geometry (that's what the transformer.tranfsorm method does). Not a critical issue, fix if you like.
Perhaps also desirable to call track(Node, Credentials). (For BindingStep, just inject a Node; for SecretBuildWrapper, use the method on AbstractBuild IIRC.) @stephenc any guidance?
Simply: "return builder.parse(id);"
Please invert if condition and put shorter branches to the top in the cases like that. The following is better than heavily nested code:  if (canCastFrom){ return true; } if (!throwOnFailure) { return false; } throw ...
Can this close throw an exception? If it is possible then is is not closed.
It might be better to use Collections.emptyMap() instead of new HashMap()
Sad times, but I don't think we can easily work around this.
Shouldn't this need to be done in the refresh instead of during the creation of the controls?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Nit: this is duplicated at line 48, I would get rid of this line.
Use type.getObjectValue to print the indeterminate in the error message to help user debugging: java throw new PrestoException(INVALID_FUNCTION_ARGUMENT, "map key cannot be indeterminate: " + mapType.getvalueType.getObjectValue(session, keyBlock, i));
There seems to be a convention established to update these metrics. For e.g. replicationMetrics.updateMetadataRequestTime(metadataRequestTime, isRemoteColo, isSSLEnabled, remoteDatacenterName); Is it possible to follow the same kind of convention here (updating via a function)?
Maybe mix multiple timezones? The idea really is to trigger a failure, so let's not make it easy for tests to pass... In particular, I would use local date/times that are not ordered, but become ordered when you take into account the time zones.
(Optional) Does this need to be anything other than Collection<ServerHolder>?
You may also want to verify that the dir is writable.
hint: can we merge all these three "if" clauses? The same goes to equals method. You can break lines before "||" for better view.
why if is here?
Shouldn't this close the iterator before returning the list?
Can use Const.POINTS_EQUAL_SHARE instead of 100 here.
Maybe better to return null
typo _start_ -> _stop_
It would be better to strictly align these variable names with the method names. Since there are methods of both Resource and ResourceInfo, I would suggest to also include the class name. E.g., - resourceSetResourceInformationMethod - resourceInformationGetNameMethod
I would rename it to something like migrateLegacyPreferences to make it more clear what it actually does.
Wouldn't it be better to wrap and throw as a RuntimeException instead of suppressing with a log message?
it would be safer to take the lock first and then check-and-update the time stamp
So you have default settingsfor userId and NetworkAccessPointId and NetworkAccessPointTypeCode, if an exception is thrown but not if the url is null. why is that?
The check item.getUrl() != null is not needed.
On line 133: partitionSession = getPartitionSession(subscriptionId, eventType.getTopic(), cursor); you take topic from event type. I think it does not make much sense.
Why didn't you add it to 'ExternalRegistrationConfigurationMapper' like the other mappers?
Well, if we know the Exception so its not really "unknown" :-)
looping with a char is kind of weird?
what if cluster is null?
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
This test against methodName seems to come too late. For efficiency, it could occur after the assignment and before the reassignment. More importantly, can methodName ever be "<init>"? If the method is <init>, wouldn't node have to be a ConstructorInvocationNode? Also, the reassignment could occur within the receiver != null test.
I think this causes the authz groups to be loaded when just viewing the contentresource. I was hoping we could just rely on authz checks when viewing the ListItem and only when changes the roles or editing an item actually have to load the authzgroup/roles.
not sure if it will matter for your tests, but calling value() is not what normally updates access time. It is the Cache/Store operation that returned the value.
We should return true here to ensure the menu is displayed.
Ditto for java.util.Objects.hash(Object...)
This method should just be collapsed into createVCGeneral (it seems like all calls are identical).
The purpose of this test is to throw inside the onError block. I don't understand why you removed the IAE
This will suppress the warning for update site and category mojos, where I think the warning is justified.
Please use Vector.ofAll() instead of Stream.ofAll(). See an explanation below (at the Option.sequence() change).
Please move abortProcessInstance into the final statement, it should be done in any case. Also please delete e.printStackTrace(); - it doesn't bring any value. Also please delete fail(e.getMessage()); - unexpected exceptions should be thrown out of test method, JUnit will handle it as a failing test, printing exception with stacktrace to the log.
What would the previous code have returned?
Should add the rule to config file?
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
java return (bundle.getState() & (Bundle.INSTALLED | Bundle.UNINSTALLED)) != 0;
this method should not be public, otherwise doesn't make sense the arguments for the flush(ClientSession, String) method, as each session (editor) will have a different associated FormsContainer instance, which could not be the one set in setCurrentContainer... Can you please change it to package protected access (so no access modifier set)? Does it work/make sense for you?
Might be interesting to add some more information here, e.g. the iOS SDK also logs the OS version.
Hello @mcimbora , I think it can be worth to provide a more fine grained filtering here. To be sure that the method is not a constructor, has the @Generated annotation, and also "is one of the generated" by the planner stuff. Probably inspecting some additional planner generated annotation for the method (I I don't remember wrong for this planner generated method you added has also a planner annotation with two parameters?) or eventually exploring the return type, or some other trick. This will prevent us from loading other methods with the @Generated annotation that we don't know how to manage. Specially because when the java source is being updated, all the accepted methods are being deleted.
rename to f
code dup. would be better to move it to private saveInternal()
I think that domains.stream().anyMatch(d -> d.isAssignableFrom(lc.constraint.getClass()))) really deserve a dedicated method. It's not that easy hard to understand what it does, and a named method could be more explicit. I wonder about using direct access to the field rather than method call. Seems not coherent to use both approach, as both field sv and constraint are visible from here, I would also change the lc.symbolicValue() by lc.sv
If we expect an exception here (i.e. i see it's meant to be ignored) should the test fail() if the request succeeds?
Hmm. do we log tags? Probably a good idea but C Git doesn't.
entries.forEach(LedgerEntry::close()); entries.clear(); entries = null;
Instead, use <code>android:textAllCaps</code> property for the <code>TextView</code> in XML. This is good, if this dialog class is supposed to show some other contents where buttons do not have text in ALL Caps.
EditedStyleItem item = (value instanceof EditedStyleItem) ? (EditedStyleItem) value : null;
is logics correct here?
what else? any warning or exception should be there?
only if name changes?
Not relevant for this PR, but I'm curious: why is the TrustAllX509TrustManager necessary?
Redundant replicationSpec.isInReplicationScope().
Should we log a warning or throw an exception in the else of this if? I don't think we want to just quietly ignore a put call...
I know this is just test class, but this is what Optinal.empty() is for - avoiding necessity to sometimes use null ;-)
The object passed as the last parameter of MethodRule.apply() needs to be the test instance, not the test class. The only way to get it is to have the caller pass in the test instance into the TestRuleAdapter constructor.
I know this is just test class, but this is what Optinal.empty() is for - avoiding necessity to sometimes use null ;-)
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
This should be updated to match the new parameters.
Do you need the inOrder here? You're checking for a never and then for a single call. Wouldn't it be the same if they were not in an inOrder?
The bounds here should adapt themselves On all your controls of your two wizard page, try to use some layout data elements. For exemple control.setLayoutData(new GridData(GridData.FILL_HORIZONTAL)); Look for examples in Sirius code base (property section, wizard, dialogs)
why use domain id from parameters and not from storage object from method parameter?
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
This change looks unrelated to fluids? Seems like it belongs on a separate PR ;P
you have lost the cause e
requireNonNull
Perhaps create a named constant for the interval since it's in the asserts for several of the new tests
can you please explain what do you mean by testing for "same" ? e.g. why would following not be enough?  Assert.assertEquals("xxx", extractionFn.apply("bxxxb")); Assert.assertEquals("xxx", extractionFn.apply("axxxa"));  are you trying to test sameness of "xxx" ?
please remove.
Is this wanted functionality? Making a new list will mean that this won't refer to same object anymore, which was what was done in the original situation.
debug/trace/remove?
use the method provided in Permissions?!
if you do this, better put N/A :)
throw something if sqlCompatible
This cannot be removed. The scheduled task needs to be saved.
Should be a SamzaException with a message, not NPE.
perhaps better would be  return getRevisionFile((Run)build);
I think this might lead to unused space on the right, when one of the columns has a higher preferred width than it's maximum (because you don't redistribute the difference among the other columns).
Why don't you use String.format?
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
Use {} or inline condition, please (in all ifs here)
this should be outside the loop? Otherwise it will only check for the first brick in the list
Could you add a else with a log.debug of the statement to have some trace?
Camel case
You don't need to do this. Skip any logic that requires locale to be set if it's used, but you can rely on the @Required annotation for the rest.
Don't add a rollback handler, override rollbackRuntime, which is called by the RollbackHandler added by the superclass.
You should be able to pull the conflict overrides directly without needing to rebuild from the string array. If that's not working, there's a problem in the new serializer paths that we need to address. Ideally the following line should work: ConflictOverrides overrides = args.getAs(CONFLICT_OVERRIDES, ConflictOverrides.class) If so, the setter above should also change accordingly.
If you don't return here, this will run only after current repl dump execution? What is the order of execution in the current case?
This should probably be an error since it is fatal and that way it will be seen by apprunner
Since it is major websocket endpoint it should be logged as error
why are we changing the visibility of these methods?
Why this catch? I feel it may be related to category feature. We should write some doc here to tell more.
it looks like createMergeConflictInfo() always shows the warning, then adding the warning should be an implementation detail of createMergeConflictInfor() and the mergeResult needs to be passed to it as a parameter
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
still called smartcard here
Not directly related to this PR. But at some point, we need to update <LINK_3> <LINK_0> They say " It is the average amount of time it took for ack or fail to be called". But the latency is only calculated on ack not on fail. The original code <LINK_1> is implemented the same. I believe this is a mistake introduced in <LINK_2>
Format this file with A.S. default formatter.
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
Yeah, definitely unfortunate.
Unnecessary log.
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
'em.persist(member);' should be enough, you only need to wrap the EntityManager when needing to access methods which are not exposed on the JPA API.
simplify this
Why doing this _IT wise_? This way you affect nexus behavior in all ITs, not only in this one. This should be moved to some of the NEXUS-4539 related IT...
I think this would be clearer though more verbose:  final Schema inputSchema = getChild().getSchema(); final Schema groupingSchema = inputSchema.getSubSchema(gfields); Schema aggSchema = Schema.EMPTY_SCHEMA; for (final AggregatorFactory factory : factories) { aggSchema = Schema.merge(aggSchema, factory.generateSchema(inputSchema)); } return Schema.merge(groupingSchema, aggSchema);
Moving that bits above and allowing the user to change the decorator via a public setter means you can completely shadow what AbstractTransactionSupportingCacheManager used to du using public API. Also, if CacheDecorator is a first-class concept, you should probably expect that more than one decorator can apply at a given time. This wrapping shouldn't be the responsibility of the caller.
I think this line is too long. Did you apply the formatting rules?
And then else if this
Please consider adding the following Preconditions.checkArgument checks: * alias is not blank * cert is not blank * privateKey is not blank
This is a bad reference ownership. I feel this whole class can be part of TableWriter to avoid issues like this
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
Not sure what this is supposed to test ? wouldn't the assertion hold regardless of what removeIf did ?
suggestion if (filter.getRelationshipDirection() == Direction.INCOMING) {
rename to child or childElement
StringBuffer is so 1900-ish. and adding the ", " is I think cleaner if you add it conditionally
You can highly improve the performance of this line by calling the Vm.isCreated() method. Check issue #188 for details. suggestion if(broker0.equals(vm.getBroker()) && vm.isCreated()) {
You can use Collections.singleton.
This triggers now baseImage.getImageData() if size was not specified for Image based constructors but would lead to NPE before. For descriptor-based data this creates a second ImageData object (parent has one).
Can you do a more precise check? Comparing the string with exactly what you expect? You should check a specific blob as well, not just the first one (not sure you'll have a deterministic order).
What about to use 2 methods authorizedInternal in 1 if clause with different objects? Like:  if(!AuthzResolver.authorizedInternal(sess, "addSpecificUserOwner_User_User_policy", Collections.singletonList(user)) && !AuthzResolver.authorizedInternal(sess, "addSpecificUserOwner_User_User_policy", Collections.singletonList(specificUser))) { .. }
"Preparing to remove the following system form metacards: {}"
It would be better if we would show the user some message as toast as well!
This should be replaced by something like, as you can see for content assist for instance quickAssistProcessors.addAll(GenericEditorPlugin.getDefault().getContentAssistProcessorRegistry().getQuickAssistProcessors(...))
Instead of hardcoding path, can you check if Files.createTempDirectory() works?
ipAddress not set
Maybe add Did you mean @SqlQuery? to the exception message?
Can we log the configs that are getting passed to the connector or atleast the enablePartitionAssignment config which is a critical config that decides how this connector behaves?
Maybe we should add some not-null checks here?
Here you'd write the columnName (and no need to writeBoolean), like this:  Bytes.writeByteArray(output, columnName == null ? ByteUtil.EMPTY_BYTE_ARRAY : columnName); if (columnName != null) { Bytes.writeByteArray(output, familyName == null ? ByteUtil.EMPTY_BYTE_ARRAY : familyName); }
Remove this?
I can't imagine how it would happen but technically this could throw a IllegalMonitorStateException. Maybe catch and ignore out of an abundance of caution?
Can you explain what problem this is solving? The jira does not tel much about leases.
Looking at the usages better throw in this case.
log message is somewhat misleading, IMO
Line 626:628, collection type can be auto inferred.
Wouldn't it be easier to use Mockito here? Or is there a reason not to use it for this test?
Extra new line.
Will this work with Java 10/11?
I don't understand why you verify if filterChain needs to be updated with every message read. Maybe filterChain should be volatile.
Use workspaceId here and below
The interceptors must not try to access the TM transaction via the thread-local, only via the invocation context. So it's safe to suspend the TM transaction before calling invokeAsync.
Please use more specific JSON type names.
SA == SERVICE_ACCOUNT? avoid abbreviations
not that critical , but why not for (Entry<String,object> entry: tasksMa.entrySet() ) instead of using iterator?
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
simpler:  return (this.partitionSelectorClass == null) || (this.partitionSelectorExpression == null);
Hmmm this test depends on the ResponseStatusFromPayloadHttpCommandExecutorService fixing the response code. Even if the _real_ provider returns a 500, I'd just configure a 404 response to make sure the API works, without coupling it to that class. The ResponseStatusFromPayloadHttpCommandExecutorService tests should take care the status is properly fixed and that should be enough.
Lets use VectorUtils.of(...).
Is this still needed? We don't add any other elements, so parent.get(anythingElse) should return null anyway.
According to the docs[0], this should be called from onCreate()... But how are you supposed to get the MapView before onCreateView()? [0] "You must call this method from the parent's Activity.onCreate(Bundle) or Fragment.onCreate(Bundle)." <LINK_0>
Consistently use:  for (int i = offset; i < offset + length; ++i)  or  for (int i = 0; i < length; i++) {  in all copyPositions
final missing
Met List:  @Override public boolean inputsAreConnected() { return inputs.stream().allMatch(ConnectionAnchor::isFullyConnected); }
maybe this was the test that had a problem with NPE?
throw is missing
Just a heads up that if there's ~any chance SSD can be null here that this will actually obfuscate the underlying error by resulting in a null pointer instead.
Avoid the intermediate variable and directly assign selfID.
Shouldn't it be "in resource" instead of "of resource"?
Another lambda-ing opportunity:  source_.withSaveFilesBeforeCommand(() -> { server_.startBuild(type, subType, new SimpleRequestCallback<Boolean>() { @Override public void onResponseReceived(Boolean response) { } @Override public void onError(ServerError error) { super.onError(error); workbenchContext_.setBuildInProgress(false); } }); }, () -> {}, "Build");
you might want to return a specific validation error. Something like, "Slave host name is required" "Slave volumes is required"
getNewExceptionFuture
If I understand this "fix" properly, we were basically creating a new appender for each test, which you're now auto-closing. Plus, you're creating a new logger for each test. Would it be possible to just have LogFixture take in a level, and auto-generate the logger name, so it does not need to be passed in, even if just to avoid copy-paste errors?
Think of a unit test that would fail if OM schema changes.
I think we should go for the BigDecimals. The list is homogenous filled with BigDecimals, so we have them from the start. Am I correct @etirelli?
_nitpick_: Indentation is pretty far for the anonymous class definition.
Could lines 154 - 170 be checked once outside the loop? It doesnt seem like they would change based on the sync path?
static import
Is this placeholder correct, looks like if my search includes a ' I can SQL inject here?
String.format
studentsWhoRespond -> studentsWhoResponded
Do we need this else block?
join this 4 log statements into one
Works anyways but a bit weird to have it return an Object, would look better returning a Geometry (that's what the transformer.tranfsorm method does). Not a critical issue, fix if you like.
Please move this magic number to a static variable.
Add message to new RuntimeException
Maybe the easier would be create Date using new Date(milliseconds)?
Probably should use [Lazy holder](<LINK_0> pattern to initialize the INSTANCE field.
I this refactoring, very nice. Could make this method protected.
Don't we want to check if it's a 401 first?
What happens if we are unable to load the inputStream.. Do the messages still show? Should we be rethrowing this IOException? @JonathanGiles ?
I'd like to see what the format of the output is for JFlat. We may have specific requirements around how the JSON is flattened - so would also be good to see the customization options.
this method should not be public, otherwise doesn't make sense the arguments for the flush(ClientSession, String) method, as each session (editor) will have a different associated FormsContainer instance, which could not be the one set in setCurrentContainer... Can you please change it to package protected access (so no access modifier set)? Does it work/make sense for you?
What about using BKBookieNotAvailableException ? or something like that
Replace SizeOf.sizeOf. You statically imported it.
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
not so readable. looks like good candidates for parametrization
why not use the logger for this?
This else seems like a problem (and maybe it was the reason for not doing this earlier). I think this makes it impossible to do:  java class Foo { @InjectView(1) View foo; } class Bar extends Foo { @InjectView(2) View bar; }  We can work around this by using composition rather than inheritance. The generated code keeps an instance of the superclass injector:  java class Bar$$ViewInjector implements Injector<Bar> { private final Injector<Foo> parent = new Injector<Foo>(); @Override public void inject(Foo foo, ...) { parent.inject(foo, ...); // ... } // same for reset... }
You have two placeholders in the stream but only one argument, is this intentional?
I'd be reluctant to re-init the same FS. better to create a new instance Even better, save the values as they are now, then assert the diff between the later values and these are as expected
Can you create a constant for the -1? I'm not sure what that represents here.
Used to be fileSystem.deleteFileOrThrow underneath.
Ravi, if you just initialize this with false before the creation of the tasks then your fix will be perfect.
@ekondrashev let's inline this variable
For such small method (next one in next file too) having extra blank lines doesn't bring anything.
rename to delta
Shouldnt we have this defaulting to the common namespace (ICommonAttributes#COMMON_NAMESPACE) so that we can tell the user what this defaults to?
we want to print to ex with the stracktrace, so do LOGGER.error("Error trying to close response", e) instead.
I noticed that you use this on many places, shouldn't this be NPE instead of IAE?
Use already defined Constants
there is a potential race here: free the mac on line 102 than it can be used by other Vnic and than you do updateHost() which is a long operation during that period the freed mac address is taken from the pool i think that releasing the mac addresses better be done at the end
Also need to verify that there is only 1 object in the iteration? e.g assertFalse(iterator.hasNext)
checking for nullable parent was added specially, cause going into project node simply has no meaning
This is a pretty drastic change in the logic here and I'm not sure this is what we want to do. So before your change, this would first check if locationGP has text and if it does, try to load that location. Then if locationGP didn't have text or the the location specified by locationGP couldn't be found, it would try to get the default location by calling the private getDefaultLocation() function. If none of those methods returned a location, it would try to get Location 1 (whatever that is) and return it. With this change, this will check if locationGP has text and if it does, it attempts to return that location. If locationGP does not have text (the check on location == null is actually redundant because at this point, we know location is always null), it will call the private getDefaultLocation() function. The function will then return the result of either getLocation(locationGP) (if locationGP has text) or the result of getDefaultLocation(null, locationGP) (if locationGP does not have text. In other words, I could simplify the logic in your change to something like this: java return StringUtils.hasText(locationGP) ? Context.getLocationService().getLocation(locationGP) : getDefaultLocation(null, "");  I don't think there's much to gain from trying to simplify this method much more than it already is... At a certain point, methods get too "simple" and the logic becomes hard to follow.
Please replace all tabs with spaces and indent consistently.
Remove throws Exception
I would probably split this up and check the token type prior to getting and checking for credentials. It's a personal preference, though.
You need to pass the auth option along when doing the resolving, also consider the options in the call
missing dot!
Can you please also make this block contribute the the dynamicRegistration map?
We have too many nested try/catch/finally blocks here mixed with throws statements. Could we simplify this?
Can you break this block of code into smaller sections by adding newlines in between - just to help with readability.
If position() gives anything other than 0 then this will give a LimitReachedException won't it? Did you not mean capacity - position?
check for isDestroyed().
The cursor iteration block can use a try-catch-log-finally, so we can see errors if read fails.
Use Assert.fail() instead
if it isn't too much change, lets get rid of SecurityServiceCallback
Is the background loading the only reason, why the loading is done in the constructor (and via a separate thread)? I would have thought that compared to loading the content for the view, getting these few entries should not be too expensive. Did you measure how much time would be lost for this one-time initialization?
why this is in vmCommand? should be in stopBase command
static importa
This should be fine on the previous line.
use Map interface instead
Request.State.OPEN
Let's rename locationModule to just module. Then we can bind SessionPropertyProvider inside the module. (The name is already bad, as it's no longer for location. I missed that when converting to Drift.)
isn't it cleaner to keep this function as append?
path
why an iterator ? it gives you the ability to do a foreach on visibleMarkers
I would put the "magic number" into a static var.
Please move this logic here: <LINK_0>
return getExpirationTimeStamp(0L)
Instead of growing this already big class, shouldn't we move the token management piece to a separate, thread-safe class? Would also make unit testing easier ;-)
is this class going to be created by the user?
Do we need some escaping mechanism to guard against the possibility that 'table', 'column' names might contain special characters (like "(", ")", "'", etc.)?
Again, these should not pass validateInputs()
You can use Version.v4_0 constant. Also, space between "if" and "(".
the steps 35, 36 and 38 are not neccesary
Should this be synchronizing on the span rather than this?
which exception are you avoiding?
toString() is not overriden in GridClientClusterState. I think it's better to use here state.state().toString()
This check is redundant because you check this in handleSelection()
instead of calling String.trim() multiple times here use map(), e.g.  Files.lines(p).map(String::trim).forEach(...)  You could also filter there too, e.g. .map(...).filter(s -> !s.isEmpty()).forEach()
This check does not belong here, this method should never be passed a null value...
nit: do you need AuthMethodPickerActivity.this or could it be just this?
Same as above here: use .isEmpty() rather than .equals for the empty checks.
why the 0 what's magic about it :trollface: ?
The givenBattleState is still odd, it probably should at least return a builder(). You can make list values non-file and use @Builder.Default to initialize them to empty lists. Also consider using @Singular which I think will default the value to an empty list if not specified. Using @Singular on the attacking and defending units properties, you could instead write:  MockBattleState.builder() .attackingUnit(givenUnitCanNotBeTargetedBy(mock(UnitType.class))) .defendingUnit(givenUnit()) .defendingUnit(givenUnitIsAir()) .build();
Add a message to checkState so that it's easier to debug if we ever hit it.
Can you make these variables final and they can be used for both methods?
yeap You can do something like final String hostFolderPath = new StringBuilder(File.separator).append( host.getHostname()).append( (!folderPath.endsWith(File.separator)?folderPath + File.separator:folderPath) ).toString();
This method can be private
If you read the code behind ByteBuffer.allocate there is a lot of overhead to these calls. If this Builder is going to be efficient then I would suggest writing the methods explicitly: java // little-endian return with(new byte[]{(byte) (data ), (byte) (data >> 8), (byte) (data >> 16), (byte) (data >> 24)});
Please consider creating a utility method such as the following to DRY out this code:  public static <K, V> void putWhenNotNull(final Map<K, V> map, K key, V value) { Preconditions.checkArgument(map != null); Preconditions.checkArgument(key != null); if (value != null) { map.put(key, value); } }
Throw NOT_SUPPORTED
Do the methods need to be static?
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
is this class going to be created by the user?
Don't you think that set in a static field will be simpler?
This isn't right. It shouldn't return a lock if acquire returns false.
double 's' at the end?
The not-null check is redundant, as this case is covered by the instanceof check already.
log me?
I assume this lazy initialization should never happen as we will always initialize this field in class constructors, agree?
Yeah, I think it makes sense. IIRC, netty swallows the throwable silently, so it's difficult to figure out what's wrong.
This would be false if newlyDisallowed && prevDisallowed && !tetheringActive What does "status" actually represent in this parameter ? If it represents whether tethering is disallowed, maybe just newlyDisallowed would be appropriate ?
This should be done conditionally. In other words, consider two columns: col1 - primitive column defined as MV int/float/double/string (simple array of primitive types that Pinot supports). Something like "CompaniesWorkedAt".  [ "val1", "val2", "val3" ]  col2 - complex column defined as MV. Something like addresses which is an array (struct) or array (map).  [ { "k1" : "v1", "k2": "v2", "k3": "v3" } ]  The second is a complex column whereas is first is standard primitive. Now the AvroRecordExtractor and AvroUtils.convert() would have returned the second as an array of Map/HashMap for our sample data  "dimension_***" : [ { "item_id" : { "string" : "some data" } }, { "item_id" : { "string" : "some data" } }  Now since schema for "dimension_***" column indicates it is an array of primitives, we need to extract the actual value from each HashMap. In such cases, it is also true that map size would be 1 but that alone should not be the condition since map size could be 1 even if the object is actually a complex one. So we should convert from Map to primitive only if the schema says so.
Extraneous debugging statement?
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
could we make the getStructuredKeys method you've added on ChargeEntity public and use it here to get the basic keys?
Silent failing
This is bytecode equivalent to using the for-each syntax on an array.
See earlier question.
We should write a real test cases for dropping connections.
If the error happen that early, can you map the error in early phase before mapping page result?
I am not sure if this solves the problem I was raising. Eclipse only creates a single instance of BndContainerInitializer. Not one per projects. So the constructor is only called once and the model listener is only added once. This change calls addModelListener multiple times. But since the method wont add if already added, it is not harmful. However, I think the cleaner solution is to make an onWorkspaceInit call in the constructor to add the model listener rather than piggy backing on the initialize call which is called many times.
suggestion boolean notInGraphAtAll = candidatesForDeletion.isEmpty();
is there any sense in making a request to the exchante when this failes ps. we use logging systems you know, but just logging an error and pretending that everything is ok and we can go on with the execution is unacceptable
you don't need validator here. you already have the errors (getErrors()), just use it. and remove validator dependency. no more cyclic dependency ;)
Let's not use JP types as input for the model compiler, only for output. This is because in the future we'd like to emit JP code at the very end, therefore during the processing we should only use types owned by us.
Is this line necessary? The radio group should already be visible.
you moved and changed these methods in the same commit, can you please separate such changes to separate commits. It is much easier to follow that way.
Move this if block after all if blocks.
Unable to update the index. %s is not a supported file path.
Please don't remove this mechanism for changing the color. Here we make sure that changes of the colours modify the individual views, e.g. night mode switches to day mode.
this can be static
I think it would be better to use schemaName.tableName.familyName.columnName kind of syntax. Basically, what ever part is most specific, you can use as the parameter name. For example, if schemaName="foo", tableName="bar", and the others are empty or null, then it would be tableName=foo.bar. If you could use the SchemaUtil functions to get the display name, that would be good. Maybe have another one for getColumnDisplayName
Please auto format all files, so spaces are set properly everywhere
Why is it 3 here? What happens if RF = 2 or 5?
Why do we use iterators? I know the base class does, but why in the first place?
Only need to create one Admin for this whole method, not two per data table. Docs say they're lightweight, but no need to churn.
I'd add an assert that the template is not returned.
Likewise don't need the if statement since the optional value will return empty.
IMHO it does not need to be public
I'd just pass e, so the stack trace also gets logged.
To do the check you should not use permission but resolvedPermissions. So Arrays.asList(resolvedPermissions).contains(WRITE). And you should not check Write, which is a high-level permission containing many low-level ones. You should instead check for the presence in the list of the low-level permission like WriteProperties which are the ones actually checked by code in AbstractSession.
You can replace this by: java return input.entrySet().stream.collect(Collectors.toMap(entry -> entry.getKey(), entry-> base64StringToSerializable(entry.getValue())));
It would be nicer to extract it to an init method (e.g. initEditors())
The value returned by isPlaced depends on the mapped flag as well. It would be a lot simpler if this provider had tuples of [seqID, start, mappedFlag, usePositionDeltaEncoding, expectedIsPlaced], with test cases for each possible combination, and the test just created a new record for each case using those values, and verified isPlaced.
AbstractSnomedRefSetImporter.createComponent(String) already initializes the UUID property (probably also applies to core components, not just the reference set members). It could be removed from all classes implementing applyRow.
Iterate over all the terms in map.baseTerms
you can use containsKey()
Can you also rename the other instance methods named compile? The only usages are in CompilationTestHelper and ErrorProneTestCompiler.
Anything we can assert here?
4 spaces
This if-block seems strange. Is there missing something?
Actually I think 8k is too small here for est. size. It may force the ArrayList to grow slowly from 1 to 2 to 4 entries as the diff is built. Perhaps do: Math.min(32*1024, args.settings.maximumDiffSize) as the estimate?
no need to write "VmHandler::" in the log, the logger already write the class name (also for the other logging below)
Kasun, why you are still having above code segement ?? Have u clean the code before sending a pull request ???
log and throw
Likewise here. Removing a PassengerData from an Entity should unmount the passenger.
you can simply use Predicates.notNull()
Doesn't account for this odd behavior: > If the first few arguments (up to four) are specified simply as values without identifying the arguments, they are assumed to be, in order, x, y, z, and r. Thus, the following two commands are identical: > /gamemode creative @a[x=10,y=20,z=30,r=4] > /gamemode creative @a[10,20,30,4] Edit: applies to entire function, making a working version
Why would you pick a linked list here instead of an array list? Since you know the number of qualifiers upfront, you can even initialise the array to the exact size you need.
but you didn;t ask it to leave a CID file...
We could avoid cloning here? (The message is not modified by the view?)
hopefully the close isn't necessary?
The original exception is not being propagated
Why do we need extra comma here?
Can we have some meaningful messages to accompany the tests please?
NIT: else Logging or IOException
Should be a SamzaException with a message, not NPE.
throw new IllegalArgumentException() -> throw new IllegalArgumentException("Unable to match provided fields with columns.") or something along those lines
i think this logic works to identify the given resource group is static or not. But a much cleaner way would be, if we mark each segment of ResourceGroupId being static or not when we create them via group.expandTemplate call, then we can easily put the flag here. And no need to rely on the context. i.e. this line will become something like this group = parent.getOrCreateSubGroup(id.getLastSegment().getValue(), id.getLastSegment().isStatic()); And i think to make this happen, we may need to change the segments in ResourceGroupId class from string to a class Segment which looks like this: class Segment { String value; String isStatic; }
This method has RequirePOST but no permission check.
Use ExpectedException here too.
I think this is incorrect - we shouldn't be placing files for variants of the same blueprint in the same directory. Can we add a pre-install command to create run.dir earlier than would otherwise happen?
Update log messages to refer to timer instead of commit, here and elsewhere in this class.
The other examples all use ASCII table output - is there a reason for switching to CSV or has this just been left in after testing?
again same.. why getters for local variables?
I don't understand the purpose of this test. Shouldn't you assert that fileInput.globalVariables() has 1 symbol of kind CLASS with empty parents property?
I never did like these local caches in the models that Carlos introduced. :/ Besides, creating one of those is dirt cheap. I have no idea why he wanted a cache.
use return ... ? ... : ...?
Why return a value if you don't use it when you call the method?
minor: you can return Collections.emptyList() instead
@excaliburnan throw an appropriate response, so it can be handled the right way. Maybe add the response code. It's good to know what the response code is because when the session id is expired we want to know this because a relogin is then required.
< 0 doesn't seem like a great overflow check, maybe be more explicit?
Throw an Exception on _else_ and check explicitly for the udp enum. Just in case we add a 3rd enum type, which should never ever happen...I just like being explicit :-)
Space after comma.
Those looked like good tests? Why remove them? Hash collision?
Exception#printStackTrace goes to stderr by default.
please move this if to the beginning of the for loop (after line 47), consider to add an info log "Disk {alias name} with type {} is not supported with disk profile"
One thing to consider here is the cost of the map lookup on every IOP. You can ask the IOStatisticsStore for a reference to the atomic counter, and use that direct. I'm doing that for the output stream, reviewing this patch makes me realise I should be doing it for read as well. at least the read byte counters which are incremented on every read. bytesUploaded = store.getCounterReference( STREAM_WRITE_TOTAL_DATA.getSymbol()); bytesWritten = store.getCounterReference( StreamStatisticNames.STREAM_WRITE_BYTES);
Where is the aggregation?
return null to make this more explicit ?
nit: put with the previous line
Yes, even if we add empty set of tags the entry is treated as accessed. I don't think it's correct.
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
I think most of the callers of normalize() convert the String you return to a BytesRef. So maybe it would be better to drop the extra utf8ToString() call and make this method return a BytesRef directly?
use return ... ? ... : ...?
If we continue to use a StringBuilder here, we should use it in a way that makes sense.
Should this use a parameterized message? java logger.warning("Connection exception encountered: {}", exception);  Right now this will likely log the exception message twice.
this could be private, or is it used on other classes?
Let's move this line with the FBO-related state change. Just double-check if it needs to be before/after setupConditions();
log the param too so we know if it is on or off?
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
getLong?
Why would we want to silently fail here? Why not throw an exception on any update operations to tombstoned relation metadata?
checkState
We shouldn't ignore an invalid enum value.
I will be nice to have more meaningful error message. E.g. "Text condition must not be empty string." or smth else which explain the problem with comparing actual text and the empty string.
1. what about creating the device/mocking vmdevicedao? 2. when you do, please add assertion that the device.readonly is false also. 3. please add verify() that shouldUpdateReadOnly() is being called.
What's the intent behind this? Generally we want to allow this to be changed at any point. Is there something in particular that requires this with the update?
Extract private void checkLeftInTargets(final List<Target> expected, final List<Target> actual)
I don't know why you are missing out of versionId handling. Are you deferring in other places?
This should be Repository.class. The method is supposed to return the list of adapterTypes, i.e., the types to which this adapter can adapt objects to.
java * @param error a potentially empty error message. * @param errors the List of error messages, which @code{error} is appended to, if @code{error} is nonempty.  @damithc errors description stills seems too verbose, ideas for a better one?
Although Java allows this, It will really help code readability and future refactoring if we need, if you could avoid accessing these internal variables outside.
Can you also rename the other instance methods named compile? The only usages are in CompilationTestHelper and ErrorProneTestCompiler.
assertThat( query ).assertThat( query ) ?
Missing blanks around "=".
Can you also rename the other instance methods named compile? The only usages are in CompilationTestHelper and ErrorProneTestCompiler.
Why don't you want to do this in constructor? I see you use static configuration as a dynamic, but I think it doesn't right too.
no need to handle failure (rollback, log, etc..)?
I believe this method should be private
file needs automatic re-formatting
same here as well - on failure to stop vdo service, activate and move host to original status
use Arrays.asList(...) for short lists.
@cvrebert don't we need to stop the container in finally block? What if some method will produce unexpected exception?
It's wired the method getXXXList does not return a list but a set instead.
Why do we need this method?
please log in error
Use IASTUnaryExpression instead of CASTUnaryExpression.
If values is a set, I think you could determine hasNull beforehand if you've already scanned values for empty/nulls, and avoid scanning again
Make this method static - it doesn't access any object state.
This is still wrong for HTTPS. S3Proxy has both a getPort and getSecurePort accessor. You should probably just create this URI once after s3Proxy.build().
Missing final
This is called automatically.
Set this only if session details not null??
Suppose there are two interfaces:  public interface NamingServiceV2 extends Service { default void testMethod(org.apache.ignite.internal.processors.service.inner.implV2.Param param) {} } public interface NamingService extends Service { default void testMethod(org.apache.ignite.internal.processors.service.inner.impl.Param param) {} } public class NamingServiceImpl implements NamingService, NamingServiceV2 { }  so, metric names will be: void_testMethod(Param) void_testMethod(o.a.i.i.p.s.i.i.Param) How should I understand which method the metric refers to? Also, there are possible names collision on different JVM's. Possible solution - use mtd.toGenericString() as metric name. However, this will have poor readability.
One other thought. All 3 tests share the same fundamental logic for inspecting the results of splitting. Would it make sense to create a private function that takes a Stream<StringHandle>, a Format, and the String[] array of file lines and is called from each of the three tests to perform the inspection common to the three tests? If that's possible, that would make maintenance easier (with the cost of having to break out separate tests if we ever discover a need for different inspection down the road).
Can we also have a test for LUCENE -> NATIVE -> LUCENE
Suggest adding an assert that the only task name in the list corresponds to the last invocation of setTaskName(...).
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
:+1: like here, ..isNull() makes it clear that you're checking that the last message is null
If instead throwing an exception when policyParameters[3] == null you log the error. I think it will return a NullPointerException when you do credentials = (byte[]) policyParameters[3].
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
You can do away with the added complexity of a negative check when you have both if and else. You could remove the "!" and just swap the two clauses.
Extra parentheses.
This case is not so uncommon. I reported it because developers do mistakes in all weird ways. And this type of mistake causes confusion. If you push to plain git repo then you will get an error. Gerrit should do the same. Throw an error. So please don't give up :)
As a separate refactor, it might be nice to introduce a constant for the name: java @AggregationFunction(value = SumDataSizeForStats.NAME, hidden = true) public final class SumDataSizeForStats { public static final String NAME = "$internal$sum_data_size_for_stats"; ...
this should probably fail on receiving interrupt
nit: Appending a char instead of a string with one char would perform a little bit better suggestion result.append('\n');
This log ends with a period, the corresponding does not, they can be unified. Perhaps these messages could be more "parsable" visually. What do you think of the following? [Signal(id)] Created consumer for {}. [Signal(id)] Deleting consumer for {}. (and so on)
Just do getAndSet(null). Then shutdown the returned value.
I think here you can do something like steps.stream().findFirst().orElse(null); If findActions receives null, return a Collections.emptyList();
Same nesting questions
I don't see a test where this is used (should be an invocation throwing an exception which is not caught )
why did you change this?
assertEquals(Foo.class, foo.getClass()). The produced Foo is @Dependent and so there is no client proxy and we can be sure the instance is the result of the producer method.
use return ... ? ... : ...?
why this is in vmCommand? should be in stopBase command
entry.getKey() could be replaced by key
You can make this method private
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
I think we might want to choose a slightly smaller tolerance (0.001-0.005 is fine, I think). 0.0001 was probably overkill though...
style nit: no braces around single line blocks
Is this the same as the old code? How come it looks like it has more lines.
off topic: I've been writing this as "client == null". I think this conveys just as much information in fewer characters, so by Shipley's law I should switch over. The drawback is that "client == null" is a boolean expression, and is consistent with "limit < 0" etc. . .
Here you should check the result metadata first and only if it is not INT, directly call super. transformToIntValuesSV() which will do the type casting. Same for other methods. You don't need a separate switch inside the method.
why the braces removed?
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
This is where the if statement should be for checking the property for allowing for corrected times.
I'd recommend to add process id to the name as well as there might be tasks with same name in different processes but still in the same kjar
Use the whole path IPv4.Availability.PUBLIC
Please move listener to desired mode
getUsername().isEqual() make the same thing ?
I don't think refreshing here is sufficient. The way I understand it, if the job is sleeping, cancel() will not call cancelling() and the refresh won't happen.
i would put in threads.lengths as initial capacity micro optimization
add java doc explaining the packageName is used for finding the package and if it is not found it is created. method name should be reflect this. Maybe this should be split up into separate fucntions
Since it's present in all configurations, consider moving this object creation to the top of the method to occur unconditionally.
serialized.getInput()
if (
suggestion LOG.warn("Default pool is empty; assigning all tablet servers to the default pool");
Special case for null?
Are we sure that bricksForTask will never be empty? otherwise builder.length -2 would cause error
the return statement is redundant here.
checking for nullable parent was added specially, cause going into project node simply has no meaning
I'm not sure that catching NPE here adds a lot of clarity. If you really want to do it, please rethrow a new NPE, not a RuntimeException (we are clearly in a case of a null pointer exception).
The logic of this method should return true if any part of the range is covered by any part of the Block's revision range. Currently it only returns true if the entire range is covered by the Block's range
In the plugin.xml, you said TmfTraceStub and now you make the check for CtfTmfTraceStub, that is not coherent (even though I think it will fail elegantly).
@Bertram25 We can pass String.format statement below on this line without reaching the line length limit.
Is it possible to make a check if we need to migrate outside a transaction. Transactions on init are pretty dangerous in multi-process scenarios, since they most likely happen on the UI thread.
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
LOG.error("Error in runAllParagraphs()", e);
necessary?
What are these annotations ?
Should use parameterized logging instead of string concatenation.
Reverse the condition (i.e. make it a guard clause) to reduce nesting.
map(Queue::getActualName)
You shouldn't need to call printStackTrace, the log.error should print the stack trace
Is the test for encoded wrong credentials missing?
assert that calling .next() again returns null?
be backwards compatible
"belonging" -> "which belong"
If it is then do what exactly? If we don't want to do anything do we need this if(..) block at all?
also assert the cause attributes
Should we add: Objects.requireNonNull(record)?
This is neat! We'll have to remember to use it elsewhere!! :smiley:
why causeOfDeath is empty ?
I am not sure if 503 is correct it this case. It indicates that something is wrong with server. In my opinion 403 will be better.
missing space after if
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
{} for blocks
This is not needed. In super.tearDown(), all the replaced stuffs are restored automatically.
what if the acl is not found? we should skip metadata update in this case and return false?
it should be  java if (TFM_AdminList.isSuperAdmin(player.getName()))  Correct me if i am wrong
Please format here. And maybe use method reference to simplify: indexToChunkIds.values().stream().map(Pair::getFirst).collect(Collectors.toList())
Could you please assign the URL to a local variable before opening the connection? This helps while debugging problems.
Pattern compilation is relatively expensive operation. Could we make this pattern into private static final field of the class?
Why don't instantiate the provider list within the constructor itself? It would allow you get rid of that "if" condition that always gets called whenever the getProvider method is invoked.
Add the @Override annotation, and change the implementation to call emptyIfNull() if you accept my suggestion in ListObjectsResult
Thanks for digging in to the cause. I know I wrote some of that code, so sorry. In this case I think 204 None is an acceptable compromise.
revert this unrelated formatting change
Consider adding an additional layer of abstraction for this block. This has very similar lines as the other two methods.
don't we want to copy the name from the model to BE?
call forEach at once, without stream()
Please copy args here too
This is not working on my system as I have **space** in the path:  java.io.FileNotFoundException: /.../tc9.0.x%20(trunk)/.../org/apache/juli/logging-non-rotatable.properties (No such file or directory) at java.io.FileInputStream.open0(Native Method) at java.io.FileInputStream.open(FileInputStream.java:195) at java.io.FileInputStream.<init>(FileInputStream.java:138) at java.io.FileInputStream.<init>(FileInputStream.java:93) at org.apache.juli.ClassLoaderLogManager.readConfiguration(ClassLoaderLogManager.java:469) at org.apache.juli.ClassLoaderLogManager.readConfiguration(ClassLoaderLogManager.java:309)
Add message for this requireNotNull
@rakeshadr is there a potential race here between setting the shutdown handler and checking if it is null?
System.out.println("...... and path id (optional).......
We should add blank behavior here directly. A blank value should be identical to an absent one.
Should make a variable for the random since it could be called multiple times and this isn't exactly the least expensive thing in the world
it would fit easily one line
Probably don't want to mask the original exception. Can you pass it to the constructor?
Would be nice to wrap this up in an ImmutableMap so that we guard against further mutations on the map. new Checkpoint(ImmutableMap.of(offsets)))
what's wrong with the original condition? IMHO you shouldn't assign a value to the timeout parameter ...
Avoid the scannerLock object and synchronize on KieRepositoryScannerImpl.this. I believe this will make also clearer that you're sync'ing on the same lock of the scanNow() method.
This is not necessary as it is null by default.
Unneeded empty line here.
I would lean toward grouping the sub-expression after || with parentheses rather than relying on the reader's operator precedence knowledge.
toTraceId already returns a string, on need to call format()
I don't have strong preference here. - Shall protected or package-private enough here? - Or, on the other hand, with these two methods made to the public, we can avoid several test codes using INSTANCE_DN_KEY and RESOURCE_DN_KEY directly. Not a must in this PR, though.
Not worth debugging for this QS
I would love to have a java.nio.Path method too!
you could just do setConfirmWindow(null); like above method
Is this line removed by mistake?
If the first constructor is used then both oldSeqNum and newSeqNum are not explicitly initialized i.e. they are set to zero. Seeing "0..0" in the string representation of this object is less useful than seeing "aPSID..bPSID". Include the IDs always in the toString and additionally include the old/newSeqNum if they are set?
Spaces after commas
@Nami this is still mutable na, only not by us. It doesn't guarantee that the original input map will not change.
This (And other filters) need their type as well. The reason being we could have a TagValueRegexp with a filter like .* and a FieldRegexp filter with the same filter and want them to hash to something different. For this and other regex filters, you can omit the pattern from equals and hash as those are just compiled versions of the filter field. It's ok not to use the parsed version even if someone puts a space in front or back.
assertThat(list).containsExactlyInAnyOrder(item1, item2, item3...) can simplify this
Does this need to be a singleton?
You don't need it in every Exception since you have a finally clause that will get executed at the end.
Can you factor out psInfoFactory.get(db, pId).getAuthor() into a variable? I think it would be better than to have it in 3 places now.
This should be a triggered ability of the enchantment, not a trigger gained by the creature
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
Code formatting issues.
Bad indentation for this method.
this is not vdsm, should be another configuration or setting within database, but we kill this code anyway, so not that important.
There is a singleton for OK Status: Status.OK_STATUS
No need for final parameters?
@aertoria Can you change all the variable names in test method to not have _1
Wouldn't it be easier to use Mockito here? Or is there a reason not to use it for this test?
Same question about maintaining type information.
let's include the entire XMLStreamException in the IllegalArgumentException
Need to declare the adapter type here, too.
BigtableFilter should probably have a com.google.cloud.bigtable.data.v2.models.Filters.Filter member variable. That would likely mean deprecating the current constructor that uses com.google.cloud.bigtable.data.v2.wrappers.Filters.Filter, and use a com.google.cloud.bigtable.data.v2.models.Filters.Filter in a new constructor. Also, please add a BigtableFilter.getFilter() which returns the models.Filters.Filter and use that getter here.
The old file should be fully overwritten. Is the old size really needed?
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
style nit: missing braces, since a while we use braces around single line blocks, change this only for new or modified code
We can use actionClass instead ofthis.actionTypes.get(alias).
Please use try with resources
not null check here too
Same as in DiagonalBulletLeft class.
out is being closed but not in.
No special need for final and please use interface. No need to know implementation. I would even recommend to use ImmutableSet from guava for safety.
This is wrong map, one from change info and not one from revision info, that you need. The right one would be the code that you have removed: RevisionInfo revInfo = info.revision(revision); if (revInfo.draft()) { NativeMap<ActionInfo> actionMap = revInfo.has_actions() ? revInfo.actions() : NativeMap.<ActionInfo> create(); }
stopThread is for other threads to communicate in, and this shouldn't change it. Move the call to disconnect to outside the stopThread loop, to cleanup when the thread is exiting. Move the InterruptedException catch to the outer try, nothing to be done other than skip call to onConnectException and reconnect sleep.
extra space
Could you break this statement into multiple for readability?
Minor suggestion. Can reduce one line code. :-) for (Cell cell : cells) { if (isMergeQualifierPrefix(cell)) { return true; } } return false;
These 14 or so lines - the various superclass fields - are already set via super(builder) and should be removed here. <LINK_0>
can be removed now
should we at least assert that it's a well-formatted timestamp?
The super.close() method will close the executor, after which the task queues will be empty and all workers will have terminated. If we close the writer before we close the executor, we can risk racing with on-going work, can we not?
empty hashmap.
Instead of creating a couple of extra Timestamp objects, move this as the first line in your if statement and just return true, like this:  if(divBy > 1) { return true; // As in this case, we've already got the correct value in ptr }  Also, another good optimization would be to check the last four bytes being non zero without creating a Timestamp object. You could do this like this:  int nanos = PDataType.INTEGER.getCodec().decodeInt(ptr.getBuffer(), ptr.getOffset()+PDataType.LONG.getMaxLength());
entries.forEach(LedgerEntry::close()); entries.clear(); entries = null;
probably no need to collect: filter and foreach should be enough.
@Override
If you see opportunity it would be great if you could refactor the methods with many parameters.
Nit: wouldn't it be safer to check that it's not equal to "https"? No other protocol would/should work, so maybe it really doesn't matter in the grand scope of things but it fits the error message better.
an expensive way to check if it exists ... if there's no other way, then this will probably do
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
nit: The mocked environment creates 3 nodes (by default) that you can use so you don't have to create them. You can get them with env.getCluster().nodeById(..).
If you're at it you can change it to: return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NAME_ALREADY_EXIST);
Isn't this the number of mappers? Can the reducer get it instead and compare with it?
Shall we just warn the user instead of throw exception for this case? Also change line 120 to be: double effectiveRate = (double) e.getValue() / numTasks;
You could print a result for println here and a different one for print later, so the output would be: println: X ms print: Y ms
Missing null check on sampleClass
My personal preference is to use brackets even for one line loops and condition. Not a blocker to merging.
If you need to manually clear it at the end of the test, then you could have as well used a manual System.setProperty along with a @After call that does a System.clearProperty... or not?
isEmpty
If this is null, can't we keep it null? That way you can disable the folder watching if you're not interested in it. The startMonitor method below also checks for the return value of this method being null. I guess null would then also be the default.
StringBuilder
Modern Java does not need StringBuilder any more. Simply use += to build a regular string, this is fast. It may even be possible to use StringUtils on an array of longs, but I'm not sure about this.
Should this use a try { } finally? Otherwise other Throwables leak.
This should be EntityNotFoundException#byName instead of EntityNotFoundException#byId
Is this better than Assert.assertEquals?
Avoid using admin credentials
This looks like different logic. You only have one serial read. putChar also writes two bytes into the buffer. This seems weird in the first place. We could maybe jut write:  return ByteBuffer.allocate(2).order(ByteOrder.LITTLE_ENDIAN).put( new byte[]{serial.read(), serial.read()}).getShort(0);
setGameState( BOT_VS_PLAYER ). make final int
maybe mention the field type?
Bad code. Remove try - catch.
You can just early return by checking leader == null.
Should this one be turned into Throwable as well?
The logging statement contains no {} so we should remove the subjectMap argument.
If you are in Java 8, it is nicer to use .then.
String log = "..."; assertLastMessageIs(log)? for me, assertLastMessage(...) isn't clear what the assertion is doing (without looking at the method). - edit... assertLastMessageEquals(String...) I guess "equals" is more familiar than "is"!
Test for last four digits as well?
why the hard-code?
Similarly here; use request body.
please rename to performOpenMoreOptions
Can contentType be as an empty String otherwise ?
hmm, that method makes somewhat sense in core java, but I'm not sure I like that behavior for selendroid. We're expecting a boolean value, but essentially we only care about either true or "true" coming across... everything else is false. Is it going to be confusing to any users? I'd almost rather add an additional else clause to check for the string of "true" or "false", otherwise raise the exception. Since users of other programming languages (like javascript or python) may have a different impression of what a truthy value should be.
I think this should be an await with a 5 min timeout, we don't want to leave threads stuck if the initialization takes too long.
shouldn't the state be set in the MockReplicaId here? Same as the helix version, this needs to check if ReplicaId is an instance of MockReplicaId, cast and set I think
Guava has a nice ByteStreams.exhaust(stream) for this. (Then there's also no need for the PMD suppression.)
Change toString method to include both
any reason for explicitly invoking super.toMap() ?
Just realized that in SQL, we directly exposed the system.stream format of names to the user. This is slightly different from the Java fluent API where we are changing to use logic streamId to uniquely identify a source in the program. Let's discuss to settle this one.
also should be warning
Is this still needed? We don't add any other elements, so parent.get(anythingElse) should return null anyway.
We want to move away from real dependencies in unit tests. Would it be better to have a test in AuthenticationServiceMockTest that tests dataflow and wiring, and have this test be in Integ Tests instead?
java List<FeedbackResponseAttributes> responsesExcludingSelf = responses.stream().filter(response -> !response.giver.equals(response.recipient)).collect(Collectors.toList()); return calculateResponseFrequency(responsesExcludingSelf, questionDetails)  Maybe u don't want to repeat yourself :P
do you think debug is enough to report this problem? I would use warn.
extra ()
you can use Schema's isNullable and getNonNullable methods to help out here.
i think java return vv -> connection.getContext().runOnContext(handler);  Would have the same result and it avoid 1 extra lambda
I see that address.getHostString() can return null, at least in theory (although it seems to be a pathological case). Do we want to defensively prevent against NPEs here?
if it existed in containers, is it not sufficient?
NaN if outputRowCount is 0
We should either do a info log to inform users that we are still waiting for the operation to complete or we should timeout at some point.
ExecutionException wrap the actual cause on loading the file channel. so you need to unwrap this.  if (e.getCause() instanceof IOException) { throw (IOException) e.getCause(); } else { throw new IOException("Encountered unknown exception on opening read channel for entry log " + entryLogId, e.getCause()); }
Are you sure this is right? Please double check.
since we use instance variables for most part to construct BlobId, may be you can introduce a privateMethod which takes in non-instance variables and version to construct BlobId is the specified version
Since this is essentially an error case I would maybe expect it to throw an exception instead of returning null?
In the deserializer, the provider name is uppercased before searching in the map: java String provider = providerNode.asText().toUpperCase(); String providerPlugin = EndpointDiscoveryProviderMapper.getProvider(provider);  Maybe you should do something like this: this.provider = PROVIDERS_PLUGIN_MAPPING.getOrDefault(provider.toUpperCase(), provider.toLowerCase());
Why not in combination with above do this: setValue(value, false);
why couldn't we return results before the analysis is completed?
Should just return properties.get(), the containsKey() call is redundant.
is comparator actually allowed to be null? It looks to me like it isn't (it has to be DefaultComparator if not set explicitly)
I think this can just be LayoutInflater.from(context)
What if who.name is an empty string? Is that OK? If we need to avoid empty names, this could be caught by: if (who != null && !Strings.isNullOrEmpty(who.name)) {
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
I don't think you need this new String
I wonder if it might be better to only check the time if we've yielded... unless we're spinning really a lot, it shouldn't delay thread termination (which is really what this is primarily for) by too much. OTOH, it's possible that nanoTime() is effectively acting like an onSpinWait() in this case; the total time spent spinning will be probably significantly higher than on the version of the loop without this call... something to think about anyway.
Shouldn't the exception bubble up in these cases? Fail fast fail hard!
Should this constructor one just delegate to the new one with Function.identity()?
Is it a conscious decision to throw an unchecked here?
As said in previous review: Add here a condition on isSequenceElement, the below code is unnecessary if isSequenceElement == false
Why is this check required? super.getEntity() should always be instanceof NetworkView, if this is a subtab of the networks main tab.
For this API, the file name received in parameter should be complete, ie include the .xml extension since this method could eventually be called from anywhere.
The avg size puts the 1/2 of the items as small items, would this bar too high? Especially we put all the partitions belong to the same topic into small group, so it's more than 1/2. Should the threshold set to 1/3 or 1/4 of the total items?
We better not have the supported/unsupported versions hard coded here. Please check whether discard is supported using the FeatureSupported class.
Maybe /accessTokens/ should be a constant defined in this class? Not a show stopper - just a thought
Just a FYI - I've only recently learned (credits go to @nbradbury ) that by setting the callback to null here in the setNegativeButton method call will lead to the same effect (closes the Dialog), probably adding some clarity to the code as well
This error should probably be logged.
remove unnecessary checks
Should we use Collections.emptyMap() here to use a singleton instead of creating a new instance?
id is the unique element in a HTML page. Therefore, there is not need to have a chain to locate it. Check if there are similar case in your PR.
Define "data-agent-conf.xml" as a constant
Why that read() has to be under lock? We only need to protect usage of the "position" field (or even make it atomic instead) and let actual read() / write() concurrency to be taken care of by underlying FileChannel.
Can be moved to if block above
It would be nicer to provide an alternative constructor of ComputeDiffsToMerge without criterion and let this constructor create the default criterion (which is null at the moment). I'm not in favor of the null value as default and would prefer an instance of a default class.
Can we forward the underlying http exception message instead? Sometimes the server sends useful information there. "Http error code considered fatal" doesn't really provide anything useful.
Maybe add an assert as the other definitions are using it?
this line can be removed
unnecessary array new: {{true}, {false}} should work here
Can we add a log message with the iteration number, size of workload, and computationSpeed before each iteration? This could help authors debug their optimizers. (Since the computationSpeed doesn't change, we could log that once, on initialization if preferred.) Maybe we can even log this once on start and once on exit?
i didn't see change in the config.sql to make this value per-version, so it's not ok to call it with version if its 'general' config
Can be simplified to return false;.
This (the whole method) could keep the same indentation char.
Add an IllegalArgumentException to fail-fast when the process is null
s/vdsGroupId/clusterId
It has been wrong before your commit, but as you touched this line could you use {} instead of string concatenation?
We do the same ternary operator above - how about breaking this out into a seperate function.
Does this capture every state that might be encountered? Would it be possible to receive a Disconnected or an AuthFailed event and is there something that might gracefully handle them? The code for this change looks good to me outside of these questions.
If the first constructor is used then both oldSeqNum and newSeqNum are not explicitly initialized i.e. they are set to zero. Seeing "0..0" in the string representation of this object is less useful than seeing "aPSID..bPSID". Include the IDs always in the toString and additionally include the old/newSeqNum if they are set?
This pattern is captured in Optional's [ofNullable](<LINK_0> method, so in this case the body of the method can be simplified to  Optional.ofNullable(gitRepo)  Similarly for other methods in this class. Let's get rid of the boilerplate :)
Why do you have to include this test data for reason concept? Is it required for this test?
Why is this necessary?
Can you reduce the nesting depth here?
Yes, that is correct.
I've got a fix in a PR that [removes the watchManager](<LINK_0>, so let's just make sure that doesn't get squashed by this :)
I am just wondering whether this snippet should not be surrounded by try-catch (as it was previously)
Is it suppose to use config.m_getOutput as path for target file?
Given line 132, don't we know that metadata is a HashMap? Given that, why bother with this check?
Variable initialization can be closer to it's first usage.
I like the approach; but I'd like the TLS 1.2 and allowed CipherSuites to be only limited to API 24 (higher API levels might want to use TLS 1.3 for example)
static import
Why not pass regionInfo instead of table, then encoded name and replica id?
log exception
wouldn't it need to sort the list in this case, too? (I wonder if using a self-sorting list here would not be the better solution.)
I thought all of these were changed to com.ichi2.anki JSON classes to avoid the try/catch since we just throw RuntimException anyway? #5550
Class name is not needed when calling method on same class.
if output is not connected, will your parsedRecords will be zero? Same for validRecords. They should be incremented if there is no exception.. Why have two different parsedRecords and validRecords when they are same?
Returning 0 or 1 is not exactly a good way to estimate the progress of the algorithm. Can you come up with a better way?
Should we skip doing this if scrollIntoViewPending_ is already true so there's no way for requests to stack up?
Is the trim() necessary? If so should we update our reference to username to the trimmed value?
What do we check in this TC? And what should two "viewProfile" methods do?
Why call setScrollBar() twice? (L157)
1. Should this be continue? If not, if the 2nd parent is not uninteresting but the 3rd parent is, the 3rd parent won't get added. 2. Put braces around single-line "if" statements [1]. [1] <LINK_0>
ugh again ..
I think this can also be  java applyCollection(CharSeq::of);
I don't understand why you don't use the sonarUsersGroupId and have simply the query:  "SELECT u.id " + "FROM users u " + "WHERE u.active=? AND NOT EXISTS " + "(SELECT 1 FROM groups_users gu " + "WHERE gu.user_id=u.id and gu.group_id=?)"
unknown_... would be better. No point in making it longer than it has to be.
Could we add something like: if(System.getProperty(PROP_UUID) != null) { return System.getProperty(PROP_UUID); } Then product creators can disable by setting the property to whatever value they want.
why is the lower bound 0? Should it not be at least 1?
Let's explicitly check whether numBlockOwnershipByEvalIdForWorker contains workerId. Same for storeServerMetrics().
Is this change required now that we have the default method in the interface?
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
Apache commons is already present; can replace with if (CollectionUtils.isNotEmpty(contentParts))
If anonymous Authentication is disabled, this might be null so we shouldn't throw an Exception here.
Maybe we should derive this from Prefs.getMediaWikiBaseUri() or require the client to pass in a default protocol. I think I prefer the latter to avoid complicating this nice and simple model type.
Should use parameterized logging instead of string concatenation.
Should be a single call to removeQuotaFromCache that receives list of quota ids.
can this be readSafely instead of readBuffer so that read uses readSafely
I would put the "magic number" into a static var.
extra space
Well, if we decide to go this way, than it would be better to reuse accept(File) instead of logic duplication.
add style as parameter to initLayerIcons
Can we inline getArguments().providerInfo below? (Trick: use Ctrl + Shift + N)
consider making the label and anchor text different
This may not fail if anything in #rename or nested calls moves to a different thread. Have you tested? I'm not sure how JUnit handles this. A simple #get call on response and a subsequent fail("Rename should have failed when it did not find the current name") would work otherwise?
Do you want to hash allowedOrigins.hashCode or just allowedOrigin? The latter is more consistent.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Code style
& is not correct need to use &&. if data[0]==null then data[0].equals(Boolean.TRUE) will through a null pointer
You need to send cookie here.
It'd be nice to use a constant for this, e.g., NO_ENCODED_LENGTH?
public class AccessTokenAuthenticationRequestFactoryFactory extends ConfigSingletonFactory<AccessTokenAuthenticationRequestFactory> { @Override protected AccessTokenAuthenticationRequestFactory createInstance(ServletContext sc) throws Exception { AccountStoreResolver resolver = getConfig().getInstance("stormpath.web.accountStoreResolver"); return new DefaultAccessTokenAuthenticationRequestFactory(resolver); } }
Please avoid calling findImplicitlyCalledConstructor() twice (once in hasImplicitlyCalledCtor(), and once here). It's an expensive operation.
doesn't seem right, should be something like "{\"foo\":0,\"additionalPropertyExampleKey\":\"string\"}"
Why aren't you using 'createNic(..);
shouldn't we capture the close operations in final statements?
I don't mean to be annoying, but when I deal with big loggers.. it's a lot easier if this was a single logger.debug call easier to identify on the logger output... and on user's environments even more. A lot of our users are using logger aggregators now (e.g. splunk).. so it would be a lot easier with a single call here.
We should not wait for Active here
Style-nit: Parens aren't necessary around the conditional.
put all getData() at same place?
I think this can be truststorePasswordAlias instead of the string?
I don't think it's a good idea to swallow an SQLException. If you can't throw it or print entire error trace for some reason, at least get error message from 'e' and append it to warn log.
These tests should also check the name and url are showing up correctly in the TaskData.
Why adding unneeded braces?
It is not, this change should be reverted.
The selectSQL method is called for normal data extraction, there is already a separate method to handle visitors, the problem is that one of the various wrappers between GeoServer and the datastore is not passing down the visitor and thus breaks the optimization.
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
Why removing this? This whole test class is about testing the backward mechanism on deleted lifecycle state and it's not intended to test anything else. I think your test would be better in the property trash service test class.
Can you reduce the nesting depth here?
UTF_8 is one thing that can be really useful to have a static import, for readability.
use return ... ? ... : ...?
This will get in an infinite loop if it ever happens :-1: If we want to ignore the interrupt we need to set a boolean and then reset the interrupt flag after we are outside of the while loop.
We should remove previous call to setOnPageChangeListener a few lines above as it will be re-set here as well.
I think it is better to log the WindowData, such as windowSize and startTime and endTime of the window.
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
vcore is a unit of cpu. If we are using memory instead of mb, we should use cpu instead of vcore.
player state setter mag niet public --> zie branch #145 (clear DB als player gewonnen is en removeCurrentPlayerFromDB als player verloren is)
Maybe better to return null
Please make it public
Please check whether it's possible to just filter the given set without creating a new copy, this will improve performance.
How about inlining it?  if (!contains(o)) return false;
could we rename this violatingStatuses... or something like that?
Using logging would be definitely better, and maybe the exception should be rather rethrown (even if wrapped into RuntimeException)
This is not going to work here as a Long can never be larger then MAX_VALUE for a long or smaller then MIN_VALUE for a Long. Technically I think there may be a bug in getInt if the number is larger then a Long can hold.
We can move this audit log to the common method. As this is common code for all ACL requests. auditAcl(OzoneObj ozoneObj, OzoneAcl ozoneAcl, OMAction omAction, Exception exception)
Should we have a version of createStubSecureCredentialsStore that takes a String argument and use it in the rest of the tests?
You could make tryList final and perhaps inline initialisation in declaration.
can we remove the version completely?
Good job!
Exception would crash the app. If file is null it will probably fail also.
the rpcs use shouldLoadMetadataIfNotExists to check to load metadata, but this method also calls shouldLoadMetadataIfNotExists again. Is that intentional, and why do we need to check again?
suggestion
while this has been an if-else previously, can we please convert this to simple statements editable = ... setEditable(...)
The setup of updatedKeyStorage is not needed if fireOnlyUpdatedPanes is false.
The initialization of length needs to be done only once and not all the time getClonedStream() is called. If we would like to handle file length changes it does not work (IIRC) as the file size could change also after the file input stream has been created. So, I think this line could be moved above after file = new File(outputFile); Or is it because you don't want to handle FileNotFoundException twice? But reset the size all the time... Hm WDYT?
two questions regarding this logic. 1. Why isn't this  synchronized(lock) { while(paused) { // not sure why this has to be a "while" and not an "if" wait(); } // hard delete code }  Why are you taking the lock twice in a row? Code looks a bit more complicated than it has to be. 2. Why are you using the same object (in essence the same condition) to notify() both the requirement to pause/unpause and the fact that pause has completed? I don't know if there is a correctness issue but it makes the code confusing. Why not use a ReentrantLock with two Condition instances attached to it?
assertThat(violations.isEmpty()).as("Violations are empty!").isFalse(); assertThat(violations.size()).isEqualTo(1);  =>  assertThat(violations).hasSize(1);
Money is a reference type and needs to use .equals() instead of ==. Also we need to make sure calculateCost is called first. suggestion return part instanceof CombatInformationCenter && getStickerPrice().equals(part.getStickerPrice());
This should be updated to match the new parameters.
![MAJOR](<LINK_0> 'Severity: MAJOR') Invoke method(s) only conditionally. [![rule](<LINK_1>](<LINK_2>
Ticks don't line up. Should allocate 4 here. Use the 2-argument constructor.
Does this need to be a singleton?
This is comparing for equality values of two different enum types, which should never be equal. Did you intend to use org.ovirt.engine.core.common.businessentities.storage.StorageType.GLUSTERFS?
we could use reduce instead of fold, like:  java return Stream.rangeClosed(1, n) .map(BigInteger::valueOf) .reduce(BigInteger::multiply);
that will fail when we only have 2 arguments in the request, because line 3 is expecting 3 arguments and line 17 only handles less that 2. i mostly do it the other way arround, so if(args.length==2) return call(pc, Caster.toString(args[0]), Caster.toFunction(args[1])); else if(args.length==3) return call(pc, Caster.toString(args[0]), Caster.toFunction(args[1]), args[2]); else throw new FunctionException(pc, "StringSome", 2, 3, args.length);
add style as parameter to above 2 methods
I suggest to resolve these two references separately, you can have two methods: Optional<Image> aboutImage Optional<AboutItem> aboutItem after that the code should be less complex
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
still think that we should log when there is a not found mapping
this method should returns domain OrgUnit not a jsonObject
@rakeshadr is there a potential race here between setting the shutdown handler and checking if it is null?
Typo: Try use inputFormat -> Try using inputFormat
I think this lines are not required, but never mind.
there are constants defined for these strings.
If position() gives anything other than 0 then this will give a LimitReachedException won't it? Did you not mean capacity - position?
Can you explain a bit more about this?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
Please include clientTelemetryEnabled in toString() API
formatting
use return ... ? ... : ...?
\s+
The Exception is never thrown.
Should this be CF_METRICS_METADATA_NAME ?
the open and closing brackets doesn't match.
There is also StringUtils.removeStart for that
consider (!NOT_CLASSIFIED.equals(classification)) to avoid possible NPE
random? really? I would have used idFor(). public ObjectId insert(int objectType, byte[] data) { return idFor(type, data); } public ObjectId insert(int type, long len, InputStream in) { return idFor(type, len, in); } or something like that. I forget which of the insert methods is the "bottom" of the call stack before punting to the InputStream version that is required, but I would implement both in terms of idFor and return the actual SHA-1.
Still this line can through nullapointer exception. Need to check all scenarios before sending pull request
you may add the error message as an additional third argument here, in order to give the users a chance to understand why that is
Please use "something <operator> null" convention
IMO there is no need to have a string concatenation here. you can just initiate the string with the SQL query itself.
I just learned that addItems actually only adds the group item for the thing (and its groups), but not the items for the channels (which is done through enableChannels). I wonder if we should hence find a better name for the method? Something like "createGroupItems"?
Maybe divide in double?
why this is in vmCommand? should be in stopBase command
We have different conventions. Please see the spaces around brackets and method parameters, and brackets on new lines. The checkstyle plugin would crash the build. Did you try to run "mvn install -P run-its"? It would take quite long time to complete the build, cca one hour.
if you do this, better put N/A :)
It's a not a big deal, but shouldn't we throw a TechnicalException instead?
can this be called from multiple threads? If yes then there is a concurrency issue. fParameterProviders needs to be handle thread safe in this class.
This is another behavioral change that I don't want to see in an unrelated PR.
newWindow is false in this case only (the perspective stack has a selected element). You'll need to calculate this even if there's forcedPerspectiveId set.
This implementation looks correct to me, but I think it should have its own unit test, to be sure, and to prevent regressions. I think testing all the boundary cases for arrays of length 1, 2, and 3, would be sufficient to cover all possible cases. (i == 0, i == a.len-1, and 0 < i < a.len-1)
could we make this log line have structured key/values while you're here?
Do we need to ack?
Can just use diamond operator on RHS
Looking at the docs for Future, I think this should throw TimeoutException if !done.
why?
move setUpToolbar()?
Yes this is the first thing i tried. But when I tried to empty the previous mails I couldn't get it to clear. If this works then fine for me.
Why not in combination with above do this: setValue(value, false);
In lines 41 and 42 you're using o.get("port").isString().stringValue(). Pay attention that method JSONObject#get not as simple as it may seem. I think it would be nice to move o.get("port").isString().stringValue() to the local variable. Also it would made these two lines much more simpler for reading. WDYT?
Change Object to String
Do we need to check if manager is null? If not, maybe we should remove geofence manager check?
Have you checked that the test fails if the this assertion fails?
addAll or stream?
It looks like right now when a connector is made diagnostics aware, There is a lot of boiler plate the connector needs to do to parse out commands and parameters. We could consider creating a library or utils that helps diagnostic aware connectors to reduce this boiler plate. We don't need to do this right now. Something to consider for future enhancements.
Can you please remove this line from assertResponse and place it for example directly to test methods? It is a side effect and is unrelated to meaning of assertResponse method - according to its name I would expect it just to check response, not setting some method variable.
Might be clearer if you actually check that sampleRowKeys.size() and bundles.size() are 1. Also a check on the estimatedSizeBytes will make things clearer.
This look similar to cleanUpStagedAndActiveSession method is there a reason to have different paths?
so it records stopped time only if all workspaces are stopped? Shouldn't it be all user's workspaces?
Not that it makes a difference in practice, but the pattern we usually show in the docs is CqlSession.builder().build().
Should not use the language asserts, they tend not to end up in the runtime.
Should be checked by a filter instead. See the MessagesWithBodies filter.
optional nit: File::getName
Why setting Token or MID imply sent = false ?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
I would suggest You to use Logy.d here instead, as we did it [here](<LINK_0>
Minor: Or code conventions typically favor this style:  try { ... } catch (Throwable t) { ... }
It looks like we create executor, but never shut it down. Do we even need an executor here, since we're only dealing with a single Runnable?
Moving these fields breaks all current mods that use this event.
IMHO it does not need to be public
How about inlining it?  if (!contains(o)) return false;
Should be in finally?
if super() is already storing the viewer, do you need to store your own copy?
Should we only assign the external ID if it changes?
Shaerable??
No space between STARTS and WITH??
Shouldn't you rather log directly?
unrelated change
use return ... ? ... : ...?
Who is calling cleanup? Better if it is done by Junit after/afterclass annotations.
I think there is some findbugs issue with not using {} not sure.
can you make "9" a constant as we use it most places
Please align with other methods in this class, where extractionFn is checked outside of lambda
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
The @Override should be on this line.
Change to .trim().split(" *| *") and remove bellow trims.
Don't we normally do null checks in builder methods? Or are we happy to wait until build is called before blowing up?
No need for final parameters?
It should throw exception
This only runs on Gtk3. How about trying to set this to not run on gtk2 instead? would this work on cocoa/win32?
Use ServiceRegistry.getRequiredService(...) here, as it is impossible that the service does not exist.
this should just be type != Schema.Type.STRING (you can compare directly for enums). It is not valid for it to be an array. If it is, it means the field is an array of arrays.
no System.gc() before/after?
IIRC it should be a string, can you verify, please?
If it got deprecated in Gtk3.10, then it should still work between Gtk3 to <Gtk3.10. You may wanna put this around a version check instead perhaps?
What about handling the case where the ASTValue is NOTHING? It should be legal to assign a variable to be nothing, as in, "x is nothing.". Also, is it legal to assign a variable to an object? For example: Fred is a person. X is Fred. (If that's legal, garbage collection becomes harder, so it's probably not legal. But if it's not legal, then the code here will silently do nothing, whereas I think it should give a runtime exception to the user.)
I don't see why we need these sorts of constructors... We've never needed them before, and there's nothing special about the useLayerNormalization arg (it's just another boolean)... unless I'm missing something?
do you want to create a new list if its null?
Would it be possible to fix workspace object as soon as possible in the chain, so we would avoid ifs like this in the code later?
You should use ThreadContext.putAll() here.
the definition can move to the else block
This test case seems overcomplicated. All what is not necessary should be removed : (generics, try catch, etc).
what if the account id, container id is 1? I think its probably better to do something like "current id + 1" so you are sure it is different
Close the client () :-)
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
Inline
This should be a translated message. And instead of Window.alert use our ErrorDialog type.
I'd rather toLowerCase() is applied after substring(), not before.
hmmmm.... how is this done for this specific session? nevermind... I think yo can just call getData with refersh and the soft timeout will set for you, no?
sb.length() > 1, please
I think that 500 ms looks like a decent default but should be adjusted based on output rate and desired consumer responsiveness.
This is a little bit asymmetrical with the comparator. The test for equality only considers the port name. This is a trick to support removing an TtyDev from the internal list by its name only. The comparator, instead, considers first interface numbers. However, the Java doc states: > It is generally the case, but not strictly required that (compare(x, y)==0) == (x.equals(y)). Generally speaking, any comparator that violates this condition should clearly indicate this fact. The recommended language is "Note: this comparator imposes orderings that are inconsistent with equals."
Hmm, shouldn't we break the processing and return the error? If we fail to submit search for one server, we may not return correct results ...
use method reference here?
IMHO it does not need to be public
why do you call this? It will be called anyway by default.
1. You could just make calculated limit a field that you set in the constructor instead of reading it here. 2. If you don't do that, I would make it final here. 3. Would it make sense to have a lower default value, like 100? All of these are trivial and probably not necessary.
missing @since tag for new API
why would server be null?
Ugh. Why do we have updatePresenceStatusForXmppProvider(pps) and updatePresenceStatusForXmppProviders() that implement the same logic twice? :/ I know that's not related to the PR, so I don't expect you to fix it
Perhaps put sendError(ex); after the branch (since it is the last statement in each "leg" of the branch.
This evaluates different value that it stays isLeftTurn will return true, in case it is slight left turn
I feel like this test and the above test have switched titles.
++i please :dancer:
this can be an info
This is strange, I don't think we can get constraint violation for relationships when setting a property? When removing I guess we could violate a existence constraint, but that's anyway not checked until commit. In general it feels like here are way more catch clauses than necessary...
why not make "update" a constant too?
we can set variable directly here.
When I did expunge(true) on a jboss7 entity, I saw logging of:  2014-01-28 22:18:47,089 WARN brooklyn.management.internal.LocalEntityManager@2524e205 call to stop management of unknown entity (already unmanaged?) JBoss7ServerImpl{id=mPXYvab1}; skipping, and all descendants  This is because Entities.destroyCatching will also unmanage. So you want an if-else, to only do the mgmt.getEntityManager().unmanage(entity) in the else block.
![CRITICAL](<LINK_0> The Cyclomatic Complexity of this method "quote" is 14 which is greater than 10 authorized. [![rule](<LINK_1>](<LINK_2>
I think here we re-introduce logic we already have [1] [2], from my point of view would be worth to extract this scroll logic into a separate class and reuse it multiple times. [1] <LINK_0> [2] <LINK_1>
you need to check that keyValueSeparator is not -1 (ie no = in the line)
style nit: no braces around single line
Decompose this into multiple lines for clarity.
wait.forElementVisible returns WebElement, so you can assign the value to avatar here and then remove the line below completely
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
The try-with-resource pattern automatically handles the ResultSet and PreparedStatement objects, but the Connection, "dbConnection" in this scope, still needs to be closed with "DatabaseUtil.closeAllConnections(dbConnection);"
As above (also below) Also nit: 60_000L (if just 60 and TimeUnit.SECONDS?)
This is not semantically correct, the Location header should point to the location of the created resource, not to a different resource. Since multiple resources are created, it would be better to use null for the header, and instead put the list of locations in the response body.
Message seems to be unused. Remove this line?
we don't use braces around singe line blocks
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
I think it would be cleaner to add a createClientConfig(Stirng username, String password) method and then just have this current one call that one with empty strings.
this cast could be avoided thanks to the changes on generics on MultiIterator
Should close kill the memspace? What if someone want to reopen the key?
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
new ArrayList<>(Arrays.asList( should just be Arrays.asList(. you may have to do a Ctrl F and replace all.
Shouldn't we return context.createImageData(width, height); ? Same question one method below.
See my question above regarding using mocks.
Check for Preconditions and reduce the member variables to its canonical form as expected in the rest of the code if the preconditions are not met. Applies to other constructors of Key.
Use IWorkbenchCommandConstants.EDIT_CONTENT_ASSIST here (also in other places).
Please add a constructor LikePredicate(Expression value, Expression pattern, Optional<Expression> escape), we should avoid @Nullable parameter in the constructor.
Unsigned types are not used in the current implementation. So, you can omit them.
:+1: like here, ..isNull() makes it clear that you're checking that the last message is null
needs to consider customAttributes?
It should never be null
ditto putting this in terms of Short.MIN_VALUE
please remove else, code will be more readable
Just using plus + operators would be easier to read (and actually perform a little bit better). Also, inline this prefix.isEmpty() ? key : prefix + "." + key to the caller would save a method dispatch.
Why not initiate the subnet to new ExternalSubnet() and get rid of this check?
Why not just define the new question index as -1 like what we do in JS file instructorFeedbackEdit.js.  javascript const NEW_QUESTION = -1;
Don't have the project open ATM, should there be a null check? Can the field go for "view mode" directly if a populated readonly property is set (I don't actually know if this is possible currently with V8)?
here we need to use instead this pattern: java java.net.SocketAddress addr; if (channel.hasAttr(REMOTE_ADDRESS_OVERRIDE)) { Attribute< java.net.SocketAddress> attr = channel.hasAttr(REMOTE_ADDRESS_OVERRIDE); addr = attr.get(); } else { addr = chctx.channel().remoteAddress(); }  Calling attr(key) while it is not set will have the side effect to create the attribute. Attributes cannot be removed.
Can we store it precalculated?
validIifes is unused.
constant or lineseparator from system?
Does it make sense to do a containsKey(uniqueId) instead, or are there cases where we would have a null service instance?
Would like to see a check that these docIds are correct.
Is there a reason that this is package protected rather than private?
Same here, correct the error messages.
on receiving snapshot_end, applySnapshotSync applies the entries of the shadow streams. We may want to move the callback to end there?
Although we need to figure out how to propagate interruptions, this will now cause a problem as it this method is called from within tryUpdate which is recursive and propagating here means the next attempts will also fail for the same reasons. We need to figure out how to retain the fact that we were interrupted and propagate the interruptions outside the whole thing.
in VmGuestContainerListModelTable. you had quite thorough null checks for each column/field. If they are necessary please add them also here. Otherwise if you are sure none of the fields will ever be null you should remove it from the VmGuestContainerListModelTable.
just use string concat instead of format
instead of path separator create new path to make it generic
try using stream api for filtering
return status != null && status.equals("ON"); is correct and sufficient
if (sigatureAlgorithm == null) throw new HttpException(ErrorResponseCode.INVALID_ALGORITHM);
Maybe we could spice this up a tad to throw in another nice aesthetic change?
If I'm reading this right (and I may be missing something!), it seems like we're never actually _cancelling_ these futures, right? We're just waiting for them to finish on their own?
Don't call getMethodName twice. See the implementation. It is slow method!
This println shouldn't be here, really
style nit: we don't use braces around single line blocks
Please move abortProcessInstance into the final statement, it should be done in any case. Also please delete e.printStackTrace(); - it doesn't bring any value. Also please delete fail(e.getMessage()); - unexpected exceptions should be thrown out of test method, JUnit will handle it as a failing test, printing exception with stacktrace to the log.
Google Java style always uses braces for if and while statements
style nit, put the { up with the if clause
please don't swallow exceptions. Re-throw up the chain.
Can we use awaitility instead of sleeping?
can we refactor to reduce copy-paste with fromList?
looks like equalsignorecase is redundant as we are lowercasing both images anyway
1. position should be able to equal count which means the end of the stream. The current logic will never be able to seek to the end. 2. Shall we throw an exception if the position is invalid, for example negative case?
This is incorrect. If ps is null, you'd still need to close fos. You need to rearrange the try block to acknowledge the existence of two resources - nesting is the usual approach.
Who uses CR as a line delimiter nowadays?
this will generate a lot of log messages if printed every 5ms. We should increase sleep time to a few hundred ms and maybe move this to trace / debug level?
Nit, I don't think this error message is appropriate. I remembered @lei-xia reviewed this in the previous ticket, this path invalidation is not an error in the server. So keeping info (or warn) may be good enough.
This construction looks like handOffCallbacks.get()...
you can either remove else or add pair of curly brackets
for(String line: output){
Not sure about the emoticon. Could we use something more neutral, like a tab?
checking for nullable parent was added specially, cause going into project node simply has no meaning
Two thoughts here, both 'nice to have' (it's also ok the way it is). 1) Since you're already cleaning up, maybe it's unnecessary to hold _result as an instance variable? 2) Perhaps fenceNode() should already return FenceOperationResult and not FenceStatusReturnForXmlRpc?
damn. Common.getProjectCache().get(change.getDest().getParentKey()) is faster here (avoids a database query), but its not promised if the client were offline. maybe we should just promise it will be there if we ever get offline support implemented.
This IMHO introduces a rather surprising piece of global state into the translation. What about extracting a relativeTo(namespace) method that returns the appropriate Function?
isTraceEnabled is not necessary here ?
Space after if. Same HC/ICS stuff as above.
"Finish calculating assignment." Usually, we don't like pasting code details in the log. Consider what if we change the method name in the future?
Can you move the Config to ConfigKey instead?
This test is not needed since the event bundle is filtered regarding the events defined to trigger the listener in its descriptor.
@ILikeToNguyen Why the change in visibility here?
Remove this printStackTrace please. By wrapping the exception in a fetcher exception the exception will keep its stack trace and print it to the LOGGER
No need to change this; just an FYI. We put in quite a few of these early in AS7 days, but they can be just an assert delegate != null; If this is null it's a programming error, not a mistake in user input.
this variable name is misleading, it contains not only the commandData but also Ne field (see also other ApduTest classes)
I think we can remove this line.
double in. And please use workspace instead of ws as you use in other places
Extra newline
Could be a try-with-resources.
- this should delegate to call two functions above. - also, here name would be a bit confusing from displayName. Maybe @rongrong could provide suggestion.
Here too, I think a DateUtil that goes from BigDecimal -> Timestamp makes sense. We may want to support that as  PDataType.TIMESTAMP.toObject(finalResult, PDataType.DECIMAL)  as this would be symmetric with the Timestamp -> BigDecimal conversion we support.
Note to myself: That's the first time I see this method being used in a plugin.
Why do we need this ? Should be done by DublinCoreService
Nit: For defensive programming, I would prefer String.stripToNull(region); Please update for similar invocations.
It seems busy to stream/map the list into a list and then join into a string. We can go straight there java .put(TESTER_NAMES, testnames.stream() .map(ProjectTesterImpl::maybeQuote) .collect(Collectors.joining(",")));
why is the language just set to english? it seems that no matter what you pass in for language, your language is just going to be english
y not use @Test (expected...)
Why do we need frontend changes when we don't plan to expose Jobs in webadmin within its own view like other entities (hosts, VMs, ...)?
this.monitor to avoid confusion with the parameter of the same name optional: this whole block could be a ternary: this.monitor = monitor != null ? monitor : NullProgressMonitor.INSTANCE;
Can we do something better than just printing the stack trace while you are fixing things? :)
Is this very time sensitive? We release "2", wait 20ms, then release "main". So on a slow machine (e.g. buildhive) the thread for main could record its message before the thread for 2. If that's the case, can we make this less time sensitive (if necessary by increasing pauses and marking as groups="Integration")?
Absolute or just path?
We have a removeConfiguration so let's not allow null value here?
There are some project types that are not AbstractProject like Build Flow and literate, that could potentially be triggered by a gerrit event and have dependencies. I know there are other assumptions in this trigger about AbstractProject that causes problems in these scenarios but those should be fixed as time goes on (hopefully) and maybe we could try to avoid those problems here. Can we find a better class or interface to check for that also has getTriggers?
You already set this CopyVolumeType with shared by default. Consider simply to add in if statement to set it with leaf if it is sealed
We can just use == instead of equals:  if (type == BOOLEAN || type == DATE || isVarcharType(type)) { return value; } if (type == BIGINT) { return ((Number) value).longValue(); } if (type == INTEGER) { return ((Number) value).intValue(); } if (type == DOUBLE) { return ((Number) value).doubleValue(); }
minor: doc
reminder: use DeleteImageGroup and extract to revertTask.
use enum name() instead of toString()
No need for final parameters?
see if we can change this method in instanceDao to accept instanceid (I bet instanceid is what get used in db query anyway). This way we don't have to load instance on the line 132.
equals should also check dimension ?
NPE at line 72. ColumnarRow.toColumnarRow throws for null argument
Can you add a debug log when this happens? will be useful when we're monitoring post-production release
Instead of collecting transaction edit logs here, we can add the count header in AbstractTransactionLog.sync() method before calling append, right? Since the edit logs are already being collected over there, we will then avoid code duplication.
nit: following replacement avoids instantiation of a new HashSet object on each call to this method. suggestion Set<String> currentlyTerminating = currentlyTerminatingMap.computeIfAbsent( category, ignored -> new HashSet<>() );
you should use a local variable instead of reallocating the argument, IMO.
Shouldn't this close the iterator before returning the list?
Just using plus + operators would be easier to read (and actually perform a little bit better). Also, inline this prefix.isEmpty() ? key : prefix + "." + key to the caller would save a method dispatch.
Possible deadlock: remove this call to sleep(). It's possible that no events will ever arrive.
This could be even if (dedicatedTransport != transport)
Concatenation of e.getMessage() is redundant
I think there's a method in Runnables that returns a do nothing runnable
I don't think this is possible. If we have valid values for dirCacheIndex and workingTreeIndex, n must be at least 2.
if i get it right: if response is null, we will not retry. i think we should retry even if response is null. btw what caused this in your case? so it would be:  response == null || ....
I would prefer to use same code as in method getProjectRelease  final Set<String> releaseIds = project.getReleaseIdToUsage().keySet(); for (string releaseId : releaseIds) { ...
instead of transport!=null, could we use globalConfiguration.isClustered() ? when reading the line, it seems like we are avoiding a null pointer exception (like protecting) for an eventual transport null instead of something that explains that indeed it needs to be clustered to check it's a coordinator
Exception#printStackTrace goes to stderr by default.
i18n
You don't want to move them all to hamcrest?
Is the background loading the only reason, why the loading is done in the constructor (and via a separate thread)? I would have thought that compared to loading the content for the view, getting these few entries should not be too expensive. Did you measure how much time would be lost for this one-time initialization?
In read path mostly both cells will be either KV or BBKV. In write path we have BBKV now? I think some patches did that for master branch already. we create the ChunkCell or so. Is that reverted? Pls check. So better to do both KV check and then both BBKV followed by other 2 options? Te perf tests u did now was giving all cells are KVs right? is it possible to test for both cells as BBKV also? That will be better. May be a JMH test? The split of private methods came good now.
rename to bit
rename to hostCandidate
Another question, this is something I am not sure. No true or false passed in here as 3rd parameter in line 962. THe function signature has not default value. What value would be then for this invocation of fireDataChangeEvents?
Using "/" directly is not portable. Java has a system method to get the directory/path separator character.
This will run every minute while Jenkins is connected to Gerrit, I don't think that is good, nor what you intended.
You could make tryList final and perhaps inline initialisation in declaration.
you dont need this line You can simply do Metrics.newHistogram in the line below
I would prefer to use String.valueOf(value)
Replace with retVal = wish1.getIndex().compareTo(wish2.getIndex());
Here have to be 1 self link
should this be "sroffset"? ^
Ahh sorry. I understand now what you were mentioning yesterday. The ListenableFuture<FeatureQueryResult> has a doneLoadingListener which you can use to: - Display or not a loading UI - Get the feature layer extent once loaded
Use constant?
nit: I prefer the other ordering for <= or ==, it's easier for me to read "n is greater than or equal to 0" than it is "0 is less than or equal to n".
nit: can we log the stacktrace here? IMHO it's better for debugging.
Why an array? List<String> is just as fine
remove the explicit initialization?
I think we can remove this line.
KualiDecimal objects are immutable, so it should be safe to set this variable to the original total directly. Also, I would suggest avoiding the doubleValue() conversion, to avoid the risk of having the calculations messed up.
The super() returns "" on null. Why should we differ?
String.format?
In another case, you tested hasNext. I think it's better if you do that and throw a NoSuchElementException rather than passing null.
the tree is necessarily a NewClassTree here, so you already know it's going to be of the good kind. You can drop the if.
I guess you are putting it twice. Here and in line 181.
It is OK to leave it and prevent the user from specifying 'LOCATION' when they use a CREATE EXTERNAL TABLE statement.
I am not sure if inlined version is better
cache?
simplify return
Is the old method, <code>updateFeedbackQuestion</code> still used in the code?
II think this code was also inherited but it might be clearer if the scope of this block was reduced to activity.getResources().getResourceName(item.getItemId()) and we just do a null check on resourceName.
(again, threw)
Do we really need to keep these here for backwards compatibility (i haven't checked)? It seems like even if we support the old mode of having this set on the entire project that this would be represented by a 'refs/*' entry instead? Perhaps this is just needed until the new UI is merged?
There are a couple of copy-paste lines here and there, could you please refactor it a little bit? e.g. extract the reader.readEvents-reader.commit loops to a method. The assertion part (listFiles, checking the count, removing from the expectedLeftFiles, checking the emptiness of it) might be possible to extract too, to improve the readability of the code. (e.g. void assertExpectedLeftFiles(String... expectedFileNames))
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
null checks?
I think we should close the StringReader after unmarshaling.
Can we revert back to ArgumentPreparedStatementSetter since OAuth2AuthorizedClientRowMapper will handle the reading of the BLOB.
Why are you making storage and adding it to cube even if there isn't one?
I think we should create a defensive copy of the Map
@domhanak TL;DR: simplify to assertThat(mavenRepository).isDirectory(); Just 3 nitpicks about assertj usage: 1. The whole point of SoftAssertions.assertSoftly is that you don't have to thing about calling assertAll at the end (it does it [internally for you](<LINK_1> 2. You don't event need soft assertions for doing multiple asserts on one object, you can just do java assertThat(x).assertionMethod1() .assertionMethod2()...;  3. The assertion isNotNull() is redundant, because most assertj methods that rely on object being non-null [call it automatically](<LINK_0>
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
testStr1 is not used in the test case anywhere.
Might be worthwhile to also factor this out into a method getInstructor to be consistent with getStudent below.
well, of course I can read the code and understand, but - still, maybe enum is better.
Extract if conditions into named structures (variables or functions), like isThread, ... ? (Especially the last one is difficult to comprehend)
Hmmmm... if evaluation is not the cause, maybe it's best just to throw an ExtensionConfigurationException and get rid of the ScriptEvaluationException subclass (if it then becomes unused).
instead of creating a new StringBuilder object, you could maybe do something like: text.append("Date: ").append(date.toString())); (you might need "\nDate: " depending on what the line situation is)
Use an else for this (or throw an IllegalStateException maybe?)
Just a note that FetchSessionHandler is used by the consumer too, so we will either need two separate implementations or make sure it works just as well for the consumer too.
Not important now, but I wonder if we should consider consolidating these core initializers into one so we only have to iterate over the beans once.
should be part of Build or base class
why not using addAll?
The entire emails is the join link?
How about an early return again? This will not indent the code of the whole method and thus enlarge the diff...
Does this one need to be changed to '...' too?
Better to use step(1)
Immutable?
I think we should go for the BigDecimals. The list is homogenous filled with BigDecimals, so we have them from the start. Am I correct @etirelli?
As it's a nullable field, null protection would be good just in case: if (occurrence.isValidated() != null && occurrence.isValidated() != validated)
Why are you checking the members inside the compute block? I smell race conditions since the membership change does not have to lock this map.
I'm not a fan of this solution - it creates an additional coupling between the different commands. How about the following approach - we should only update the status if the image is on a DATA domain: [pseudo code] StorageDomain sd = getStorageDomainDao().get(image.getStorageDoaminIds().get(0); if (sd.getStorageDomainType().isData()) { // update status to illegal... }
It seems like we can add two storage domains at the same time
This is actually adding functionality, since in 3.0 only system-disk is bootable. I think method should have an oldAPI flag, and in such a case break on the first system-disk and skip non-system disks.
Should this be a write lock because we might delete the page if there is not enough space?
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
Iterator could return multiple items erroneously and pass.
extract the repository here before calling createRepositoryOperation and change the signature of createRepositoryOperation to accept a Repository then you don't need getRepository() and extractRepository() and also the next change on top of this one doesn't need to subclass the concrete handlers anymore.
Not sure why we allow null for the event list when the monitor gets cancelled, but not for the link list?
If we remove the null check, will it results in NPE? (Line 74)
Don't use exceptions for control flow!
I see, what I'm more pointing to is that we are testing multiple/all aspects of firingGroups per test rather than testing on behavior at a time. For example, it's considered a best practice for tests to have only one reason for why they would fail. If for example the firing group size were to change *or* if the displayName were to change, then this test would fail. At a more concrete level, isolating the behaviors makes it easier to see which parameters control which outputs. Hence I'm suggesting to pivot the tests to group and isolate the tests that verify display name, size, etc.. and do so independently.
Style-nit: We don't use curly braces around simple loops.
I tested streaming using this same parameter in the old stack and the new one and both behave the same way. Both got 2 batches, one containing 3 events and the other with debug message. Does this test actually exercise or prove that the fix works?
java if (next == null) { return fromIterator.next(); } else { final TYPE result = next; next = null; return result; }  I find this better to read.
The ListenerList implementation already takes care of this. Remove the "contains" test.
Fix warning: suggestion KeyedMultipleInputTransformation<OUT> keyedTransform = (KeyedMultipleInputTransformation<OUT>) transformation;
Replace with SubMonitor.convert
rulesList will never be null, widget#getVisibility always returns a list instance.
Better also check first Desktop.isDesktopSupported().
I think this should stay protected. Non-subclasses have no business calling this.
Please revert back to seesionFactory.getCurrentSession()
This causes the warning Plate is a raw type. References to generic type Plate<T,S> should be parameterized.
This is a duplicate. You already introduced a WineryPropertiesDefinition variable properties at the top of the if which is unused.
ders more. pls find all and scrub
I realize it's a first cut, but I wonder if we should map some basic headers (method, path (uri), Accept) ??
one more 'L'
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
Was this detected by findbugs?
Same as before: the logic of filtering out NonBinding attributes probably should be external to this implementation.
Instead of iterating through this once to add to the map then again to check for duplicates - could we just check if it already exists here and do the logger warn in this initial iteration?
Add a break to this if? Then, this condition is not needed.
Try:  java final List<PoolBagEntry> bag = connectionBag.values(STATE_NOT_IN_USE); int removable = bag.size() - config.getMinimumIdle(); for (PoolBagEntry bagEntry : bag) { if (connectionBag.reserve(bagEntry)) { if (bagEntry.evicted) { closeConnection(bagEntry, "(connection evicted)"); removable--; } else if (removable > 0 && idleTimeout > 0L && clockSource.elapsedMillis(bagEntry.lastAccess, now) > idleTimeout){ closeConnection(bagEntry, "(connection passed idleTimeout)"); removable--; } else { connectionBag.unreserve(bagEntry); } } }
Minor: Or code conventions typically favor this style:  try { ... } catch (Throwable t) { ... }
unretire or unvoid?
Hmmm are we sure we want to depend on the Channel monitor... for property access it may be preferential to use properties as the monitor object
Collections.addAll
This will not include the line break. Probably should append('\n')
IMHO it does not need to be public
All these count -> COUNT / from -> FROM are unrelated to this commit. I would suggest to do it in a separate PR :)
should just be inside try block
this line is gone, why?
can we make this an error please
Typo: attemp_t_ToUpdate
Use == for enums.
Do we want to make the change inside mkAssignments(String scratchTopoId) so we can count errors during the rebalance command as well?
This won't work on blockdevice. Take a look at how the StoreMigrator does it.
We need to rework this method (replaceAntiCsrfTokenValueIfRequired) to ensure that we are able to extract tokens even if not previously registered (i.e. use ExtensionAntiCSRF.getTokensFromResponse with loginMsgWithFreshAcsrfToken, instead of getTokens and getTokenValue)
Docs (<LINK_0> you must always check isConnected() before initia...
Why change to create?
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
this should be moved out of the try/catch at all filters
Please add an assertion for an enclosed type: java.lang.Thread.State
URL Decode would be necessary for parameter name and value
please remove else, code will be more readable
The original goal of caching file info is to make read faster by caching the fileInfo for read when we created the ledger, so here we probably need to put fileInfo into both write cache and read cache. And we need to increment refCount by 2 because we put that FileInfo into both read cache and write cache
I'm also missing some brackets here to comply with our normal code style.
In case of invalid partition spec, we should throw PartitionSpecInvalidException
isUnauthorized 401
Should we prevent setting the executor while the connector is running? Otherwise we get concurrency issues with hasInternalExecutor flag. Is it even necessary to have this setter instead of setting it in the constructor? Then we could make the executor field even final. atm we are accessing the executor from different threads without appropriate locking or making it volatile.
Note File.toURL() is deprecated and known to cause issues (though I don't quite recall which ones). The recommended way to do this is through File.toURI().toURL()
Missing assertTrue?
!regions.isEmpty()?
> Saving a passive user's data will always have a user entity with an empty password No it doesn't look like that's the case in the lines I noted above. If you change a user to 'passive' it allows you to set a password, but now without the validation.
can be private. It will be passed to the asyncTask since it's a subclass of this class
The same about formatting.
You should have this loop also under the childStart loop
You probably a want a * after the \\s for a more flexible syntax. Looking at the legacy open Cypher specification, space is also allowed between the : and the label identifier when creating indexes, though not when doing index lookups via the START clause.
I think it would be better to use IgniteUtils.resolveIgnitePath. It works on TeamCity and local run 100%, not sure about your code.
If you add condition hint to card then you can improve card's usability for users. Search for example: * .addHint(new ConditionHint(LudevicNecroAlchemistCondition.instance, "Player other than you lost life this turn"))); How to add: 1. Extract checkTrigger code to Condition object; 2. Use that condition in checkTrigger; 3. Add condition hint to ability. You can use same condition hints in your another PR (#6430).
Maybe do the commonColumns same way you did in upgradeOutcomeTableRevision2To3 for consistency? Not a big deal just one way or the other so that they match.
it is better to extract these endings into some list and iterate over it, it will be more readable
Default size not necessary.
Replace it with something like this: LOG.info("Waiting for resources to get allocated for request {}, no retries will be issued since host affinity is disabled", request);
Does it really make sense to have a plugin with multiple secure-stores ? What would be the rationale behind it ?
create instance of this object when requested not in constructor
Please bring the braces back.
There should be a null check here if it doesn't accept null values
Should there be a check to make sure the asset is non-null before modifying it?
Shouldn't this code run even if mHasWifi is false?
nit: it's more readable in these situations to do:  if (inputSchemas.isEmpty()) { return; } // rest of logic  doesn't make much difference here, but is more true if the logic within the block is longer.
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
There are a few other mocks higher up in this method. This can be moved to be with them.
nit: you can merge both lines above as checkNotNull will return the given argument
Using "/" directly is not portable. Java has a system method to get the directory/path separator character.
nit: extra space after .
Not sure what is going on here, as String.format always takes at least two arguments? "Select" is being picked up as an actual class and not treated as a string for some reason.
You will now log an error, where before was a warning (if the service is not found). As we actually declare that this function expects failures and treats them internally already, I would claim that we should rather have only DEBUG, INFO or at most WARN level here - I'd prefer DEBUG.
These first two test methods are identical except for the slice creation, and can be replaced with a single method and a data provider.
Remove the public modifier.
2-times the same thing?
Checking whether text is null seems properly defensive. If text is not null, I believe that text.getData() is guaranteed not to be null, so that part of the check is unnecessary.
I'm not sure how I didn't notice this before, but this test is a lie. PropertyCacheFile can't be instantiated without a configuration, it will throw an exception. The whole reason the cache is empty is because destroy is never called to commit the changes made because we play with Checker directly instead of going through a 'normal' lifecycle. We specifically set the configuration with the line checker.configure(createCheckConfig(TranslationCheck.class));. So it is a lie there is no configuration. Also if there are no violations, cache is still filled with all files checked. Is this test relying on some code coverage? If so, let's rework this test around that. If not, let's make this into a more normal workflow and test all contents of cache.
It seems that 'checkBondModeForNewOrModifiedBond' has the correct functionality and should be used in both of the case (its name should be 'checkBondMode(..)'). Just in the case of 'modifiedOrNewBond == null' you should add method for getting the 'existingBond'.
Is this if necessary?
LOGGER.info? Maybe LOGGER.warn?
It would be better to use a class that has fields: status and body instead of Tuple.
Please use ""
This piece of code to create an Authenticator is duplicated 4 times, but it's not relevant to the test. Can we make the test cases shorter so that we can see easily the differences between them?
Avoid variable names like event1
There is something wrong with the button text. You set it to default here but it's not set to R.string.replace_bearing when we record bearing (only if we create the widget from scratch and there is an answer).
let's move this logic out into RecordsRetrievedContext. getRecordsRetrieved either returns null or records depending on the event type stored in the context.
Let's check if the catalog name matches the name in the handle and return empty if not.
- Points to Pixel conversion needed.
This log message seems deceptive. This class is about quota statements not alerts.
Can we set a charset? Like ASCII or UTF8?
There's no point to else here...
An empty loop can be written as while (vcfReader.read() != null);
Request.State.OPEN
String.format
use return ... ? ... : ...?
previously, we checked that they are 4 elements but now we are checking for 3 names. Shoudln't we check for 4 (or 5 if I understood well and a new request has been added) also or put the 4( or5) names and use a containsExactly?
Sorry missed this on the previous pass. DEFAULT_REGISTRY_NAME is the default value for REGISTRY_NAME_PROP so this line should be removed and line 124 should be  String registryNameProp = System.getProperty(REGISTRY_NAME_PROP, DEFAULT_REGISTRY_NAME);
pass in the metric registry
Make this a debug log. if (log.isDebugEnabled) ...
1. There's no need to load the snapshots if the disks checks hasn't passed succesfully, same way that we don't load the disks if the vm is locked. 2. you should load the images for each of the disks IIRC, take a look on what's being done on ExportVmCommand and handle synchronization with other flows like preview/restore/stateless run.
Is this really what you want? If you get an exception, you'll be returning null for a query on a record that exists, but that can't be parsed.
RocksPageStore will be in a bad state after restore then initialize.
the open and closing brackets doesn't match.
Better to just add a throws to getPolicy and not catch IOException if you aren't doing anything with it.
must be immutable :  if (null == this.map) { this.map = .. } else { throw new KasperException(..); }  if you can add this also on the CollectionQueryResult it would be really appreciated :)
also a good candidate to introduce a constant
Can we have a more meaningful message here? For instance, I think it would be better to specify that there are no activities for this client because its encoded key is null or because the client does not exist at all. If one looks only at the message he receives, he could believe that the entityId is good, but that there are no activities in the system. At least this is the way this message looks to me, at a first sight. What do you think?
Type for Field + config.field + must be String
i think ovf can be null (looking at previous code)
No need for a mock.
It repeats above, doesn't it? Eliminate duplication please.
Is null a legitimate result when using the old InvokeOnPartitions?
Out of curiosity, why is the return type of this setter not void?
Why don't you use formatCurrentTimeForId() here like the line 217 below? Likewise for the line 115. We can pass the time as a parameter to that function for general cases rather than just current time only.
Nit: while you're at it, this "this." is not necessary, I think.
destinationIds also needs to be hashed by content: suggestion return Objects.hash(sourceId, Arrays.hashCode(destinationIds));
Addition of this member variable looks unnecessary, and can be un-done I think?
check if you can use fluent api to add the storm tag
These are from the org/json library. Edits to this are really not recommended.
by doing this, you override data provided by user in bond.slave, missing info should be added in the BE.
!isEmpty ?
public seems not required
Just style, but I like wrapping conditionals in () for this statement. In my view it improves readability in the ternary operator that is already somewhat tricky.
It can/should be private (and remove @Restricted(NoExternalUse.class)).
better return a null object (new Pair(this, null)) or throw UnsupportedOperationException
Excuse me, I want confirm with you about "A suggestion for a follow on change would be to add any permissions only projects as candidates even if they are not yet parents since that is likely their sole purpose: to become parents." here can I understand "to add any permissions only projects as candidates " as to delete Line 54?
Don't use default shell, dialog has one.
Remove the public modifier.
let's change this if to - if (Guid.isNullOrEmpty(storagePoolId) || !FeatureSupported.refreshLunSupported(DbFacade.getInstance() .getStoragePoolDao() .get(storagePoolId) .getCompatibilityVersion()))) end eliminate the else cluse from line 105.
lowestTimeAxisOffset is used above. Looks like a bug in findbugs.
per the style in rest of this file, add a space after "if": s/if(/if (/ and same for similar if statements below
I think the order of entries in these maps are undetermined. You probably want to sort both the expected and actual to ensure this does not randomly break in the future.
Use context.getApplicationContext() to ensure the class can't leak any shorter lived contexts that might be passed to it (it's always fine to hold onto the application context, since it's expected to be around for as long as the process remains alive).
just return _props.get(key); in this method
This should be done in execute()
pls log the "else" cause of this if
if there is unhandled exception it will cause that opengrok will need to be restarted, isn't it better to check for Exception or Throwable?
We need to test the regular constructor without a custom serializer.
use HttpStatusCodeException
Simply default: return null; and removing line 129 would be a bit shorter and more regular.
I agree with Mike. We shouldn't deprecate the old constructor.
Technically this is doing needless byte to char conversion. E.g. were it a multi-byte encoding, then decoding is not worthwhile. My original thinking on HeadHandler was to have the principal buffering at the byte-level. E.g. a BufferedReader(InputStreamReader, /*tiny*/200) atop a BufferedInputStream. Then when all the needed readLine() calls are done to just read() and discard from the BufferedInputStream - probably not a byte at a time but with say a very small byte[1024] buffer. (Using readLine() here would defeat the goal of avoiding needless heap allocation.)
Can be transformed into an if statement.
Again, on purpose to avoid the array list
As above: private, 100 chars, use error result instead of doOnError.
This handler is not used at all, please remove it.
if you do this, better put N/A :)
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
If source is null, it's probably better to throw a NullPointerException.
import it directly -> import static org.carlspring.strongbox.net.MediaType.APPLICATION_X_GZIP_VALUE;
The thread pool should be initialized only if stats are enabled.
why not use "assertTrue(allEObjects.hasNext())" right here instead of using this boolean?
I would recommend putting these strings visible to the user in strings.xml
Replacing the 2 loops by  java result.putAll(getSuite().getParameters()); result.putAll(m_parameters);  seems a better approach for me.
fileContainsStarImport is more accurate.
This looks fine, but we should be consistent with how we are exposing parameters from our libraries. I would vote for either: a) Exposing all parameters with the names that they have in the underlying Java classes, so that people know what to expect, or b) Same as (a), but always exposing certain properties with standard names (eg. startDate, endDate, location). With this in mind, I would favor simply exposing all parameters as they are named, modifying only onOrAfter=startDate and onOrBefore=endDate and locationList=location @djazayeri did you have other visions for these libraries and how they expose parameters?
Same issue with usage of WRITEOPENW as in RemoteSageFile class.
What do you think changing the name to memory. We do not know whether it is in kilobytes?
This builds the set on each lookup. It should be built once and then used.
you can skip the exception, no? just set header and error here?
The local var is useless, you can remove it.
no longer necessary, after changes in xml.
Same here. Add clarifying parenthesis
Do Java 7 construct, to be sure the file reader is closed properly?
and may be this one as well
Since this method uses a Transciever to respond, should it be named 'serve', not 'read'?
This inner block down here belongs up with the first block which starts setting productsChanged. The lower if block makes changes based on that state and should no longer be flipping the value anymore.
For this API, the file name received in parameter should be complete, ie include the .xml extension since this method could eventually be called from anywhere.
this works, but filter(...) would be simpler  from("...") .routeId("AuditFcrepoRouter") .filter(not(header(JmsHeaders.IDENTIFIER).startsWith(simple("...")))) .to("direct:event")  Also note that the fcrep-camel component has CONST values for the JMS headers
Huh?
ByteArrayInputStream implements Autocloseable shall we use try with resources for resource cleanup rather than closing the stream in the finally clause?
Hi Martin, I'd rather do that in a later change. I tried to do it in this change but too early and it led to too many modifications, so I prefer to postpone it. I think we have a weird interaction between MergeMode, that we seem to use in the UI to set the markers on Diffs once they have been merged and the DifferenceState. It seems very likely that setting the DifferenceState to a proper value (either MERGED or DISCARDED) would allow us to not use the MergeMode in the UI to compute the icon to use on a merged diff. I want to take the time to consider all that fully.
Do we need to do another lookup here? We have the consumer already, is there a reason we're not just translating it straight away?
String key -> String columnQualifier, and also update its subclass
Pass null as a listener, it will dismiss the dialog.
since this persist is triggered by the maxRows config, would it make sense to persist the one having the maxSize ? as the oldest one may have very small number of rows.
if i get it right: if response is null, we will not retry. i think we should retry even if response is null. btw what caused this in your case? so it would be:  response == null || ....
space after if.
Replacing the 2 loops by  java result.putAll(getSuite().getParameters()); result.putAll(m_parameters);  seems a better approach for me.
wrapping
Should this be try with resources? I don't see the reader closed
spurious change?
Does it need to be package private? Can't we make it just private?
if you do this, better put N/A :)
Can be possibly moved to shouldShowLog of PageData class so that all the checks for whether a emailLogEntry should be included is located in one place.
This step is same for standalone as well as domain ;-)
nit - for me creating ke is unneeded. Create the exception directly as the argument
This involves a look up of the character encoding type table. Use MessagePack.UTF8
I don't think this is used. But, for the future, if you need to access an outer class from within an inner class, you can use OuterClass.this from within the inner class.
We don't allow setting the label. This appears to be our external ID for this entity.
You can use CollectionUtils.toImmutableList
The duration variable should be qualified with the this keyword.
shouldn't we have an array of configs (just like the others)?
Could you add info in the docs on the valid output formats?
Please use ? ternary operator
Spatial reference is always null, hence, drop this variable is use null below.
Perhaps we could compute time.milliseconds() once at the start of this loop and pass it down to selectReadReplica?
Same as above, maybe I misunderstand something
public isn't needed
Looks like this returns a string, not a boolean.
It is better to use System.lineSeparator() instead of \n to be the same on all OS
please include the VM's ID as well
It's better to use i18n
Should include other properties to break ties here
Probably should crash if bad format string
isnt segmentsMapToFind? (not Maps)
here, the result of the IF is the same in all iterations of the loop. So the IF can move outside the loop. And the json-stream stuff can be extracted into a helper method to make this easier to read.  if (config.useJsonStreams) { helper-method; } else { for (JSModule m : modules) { previous-stuff; } }
Do Java 7 construct, to be sure the file reader is closed properly?
Would you please explain why clear() need to call ?
Returning ISelectionListener from this method blocks the possibility to add predicates in a "chain" like  addPredicate(p1).addPredicate(p2)  What was the reason for this change?
This task should be idempotent, which I think it is so long as DataSegmentMover.move does nothing if run on a segment that has already been moved.
In line 151, there is same call. Why don't you define this as method to avoid duplication of code? e.g. private boolean isFdnDirectDialSupported()
If we're no longer using a translator to translate the owner, then the owner translation should move outside of the if(translator != null) block. And since there are no other entities being translated by a translator, then that block can be removed completely.
We should have a final fallback here if dateStopped and getAutoExpireDate are both null... (not sure if that should ever happen, but both fields are allowed to be null in the db so it's *possible* it could happen). I would just fall back to dateCreated (since it is the one date that is guaranteed never to be null).
Use here Collections.singletongMap(..., ...)
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
I think we want the is\* methods to just check the token type and nothing else.
put some context to wrapper exception.
Should be SqlTypeCoercionRule ?
Looks like a DriverException is being hidden behing a NullPointerException.
May I suggest this?  int i = url.indexOf("/#/"); return i == -1 ? url : url.substring(0, i);  It only searches the string once, and more important, doesn't duplicate the search argument.
Can we inject this feature directly ?
I think here we could just us a file-handler just the configuration is less complex and slight less overhead as there is no WriteHandler.preWrite() invoked. Really not a big deal though.
The value returned by isPlaced depends on the mapped flag as well. It would be a lot simpler if this provider had tuples of [seqID, start, mappedFlag, usePositionDeltaEncoding, expectedIsPlaced], with test cases for each possible combination, and the test just created a new record for each case using those values, and verified isPlaced.
Equals and hashcode should be generated by Joda-beans
unnecessary parenthesis?
same thing here, it doesn't need to suddenly start working after the first experiment, plus is this test strictly necessary, considering it's subsumed by attemptsExperimentAgainAfterEnoughTimeHasElapsed
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
Missing randomDiscard param.
Replace this with The number you have entered (<Number>) is too small, it must be at least 0
hmm.. i dont get how is this method impacting anyway since you are not using this method return value.
instead of building loadService in the constructor just a create MutableSupplier (see code in the ltr plugin). Make your QueryBuilders accepts Supplier<LoadService> and call the set method in createComponents when you have everything needed to build your service class. That's not particularly better but it allows to keep dependent services final in your class.
The way MkContainer works, is that it sets up a fake HTTP server on the local machine. For each HTTP request that it receives: 1. A corresponding MkQuery is stored that corresponds to the request and and queues it internally. The container.take() method obtains each MkQuery from that queue in a FIFO-fashion. This means that each HTTP request should correspond to exactly one invocation of take(). If there are no more requests made (you called take too many times), it will throw an exception. 2. It responds by using the MkAnswer(s) that you've specified when invoking .next(), prior to calling start. If you need multiple requests and responses, you call next() multiple times with the exact answers that you need. If it runs out of requests, it will respond with HTTP 500. In this case, you only made one request, in commits.create(input), and are only checking its method. So no need to call take().method() twice to check the same thing. You can always store the reference returned by take() if you need to use it multiple times (e.g. to obtain its body, then its method):  java final MkQuery query = container.take(); String body = query.body(); int method = query.method;
Consider using VariablesPlugin.getDefault().getStringVariableManager()
There's no order guarantee. Use a Set for comparison, or sort the lists.
Please correct the capitalization of the debug statement (i.e. Client), and possibly remove *refresh_token authentication*.
& is not correct need to use &&. if data[0]==null then data[0].equals(Boolean.TRUE) will through a null pointer
nit: this is a slightly nasty way around the line length issue.
I would retain the existing indexOf body to to avoid indirection in the most common case.
Is this what we want here? If so we should have it as a Log method then.
It is not, this change should be reverted.
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
selectedElement for better readability
toSingleton collector?
Platform.exit()
THIS!!! THIS IS THE PROBLEM!!!! Look, it needs to be Integer.parseInt
This would be better as:  java if (projectsAdded.add(targetProjName)) { IProject targetProj = ... }  That is, use the boolean return value from add to decide whether to add the JavaProjectSourceContainer instead of a separate contains check.
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
You can remove this line. It is probably just for debugging.
Perhaps 'Not unpacking {file name}... 'would be better - this gives the impression that there are no unpacked variables in the file - but this may not be the case - config could be overriding this.
Should be able to do a multi-id query using something like criteria.add(Restrictions.in("groupId", groupIds)) Current method allows for nulls to be included in the returned list too I think
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
> return new String[] { resource + "/.default" }; [](start = 7, length = 48) Should this use the DEFAULT_SUFFIX constant above?
hmm, that method makes somewhat sense in core java, but I'm not sure I like that behavior for selendroid. We're expecting a boolean value, but essentially we only care about either true or "true" coming across... everything else is false. Is it going to be confusing to any users? I'd almost rather add an additional else clause to check for the string of "true" or "false", otherwise raise the exception. Since users of other programming languages (like javascript or python) may have a different impression of what a truthy value should be.
I'm not certain what the correct thing to do here. If there are multiple groups in flight and the outer observable is unsubscribed, do we want to unsubscribe the open groups, enqueue onCompleted elements on them but let them run, or something else? Window has this anomaly as well where the unsubscribed outer may never deliver an onCompleted on the inner windows and thus they stall.
Don't you just want to delete anything at the location, if the value and type don't match does that matter?
Please change to !message.trim().isEmpty()) {
looks like you missed these
What happens when the path is set to a different path? Shouldn't initializeTune(path) be called after setting the path? <logic
Do we mark main tables only? Or do we have to mark indices as well?
ImmutableSet.copyOf instead of Collections.unmodifiableSet
I can't remember why it needed this? And I get paranoid about it since I spent months tweaking the multi server configurations to not break.
See my question regarding using mocks above.
Both JDK client and Netty client have to do the same logic for converting response byte array to string. It would be better to put this in Core utils somewhere to reduce duplication and if there are any fixes or updates to this logic, we don't need to update in two places.
I think you want to pass in the errorListener to super
Add a case where a course is not in recycle bin? -> it should fail
Could the content of this method be moved to MigrationService to keep MigrationForm free of program logic?
not all listener
@vmaletta 6000 can be a constant in all tests
should this be in some MathUtils class?
Do we need this? The java doc for "yield" says, its rarely appropriate and used for testing or debugging.
Doing it this way will not update the actual Pod spec. I think we need to add this in createOpenShiftDeployment()  PodSpec podSpec = new PodSpecBuilder() .withContainers(container) .withVolumes(getVolumesFrom(volumes, workspaceID)) .withTerminationGracePeriodSeconds(OPENSHIFT_POD_TERMINATION_GRACE_PERIOD) .build();
"SocketServer time spent on write per key"?
NPE when req == null
You can use CollectionUtils.toImmutableList
'e' is not logged
Please iterate using entrySet
Better to log the error
Please refactor DbFacade.getInstance().getLunDao() to a method...
Don't need to start at zero every time, keep a static var holding the last returned value. A from-scratch search will need to be done every launch which avoids any issues with uninstalled mods.
To me this would either be easier to read if it were written imperatively, or if we consistently statically imported things: .map(domains -> filterKeys(domains, not(in(partitionColumns))))
It seems like we can add two storage domains at the same time
You're missing 64 here. <= would be better.
How about inlining it?  if (!contains(o)) return false;
Extract variableTree.symbol() instead of calling it 3 times.
With set() and find() now bypassing Square and using Entity directly, should we have get() return List<Entity> ? That way the Square class won't have to be public, it'll be an implementation detail.
There are maps that don't allow null keys and (stupidly) throw an exception when you try to check for its existence. You need to account for them here. suggestion try { return map.containsKey(key) && super.valueMatcher.matches(map.get(key)); catch (NullPointerException ex) { return false; }
Move the jsonGenerator.startObject() method call here, so the subclasses aren't responsible for creating this. It is confusing this way.
Is this check susceptible to funny business? what if I do source = Paths.get(".") target = source.resolve("foo").toAbsolutePath().normalize() then will target.startsWith(source) be true?
Minor: java.lang. unnecessary here
StringBuilder
Shouldn't this close the iterator before returning the list?
Checking a non-checked (RuntimeException) usually requires a special reason. What is the special reason here for checking NPE?
>So I guess simply passing the startTime is the only necessary change? (the ones I made in the monitoring.js file) Yes, I think this is the primary improvement in this PR - if you could remove the other changes that would be great (modulo the v1.0.1). However, I'm not sure I'm convinced that this alone fixes #215. I'd like to have @Suryakandukoori dig in a little more before merging this PR, although he's tied up with some other tasks this week.
Collections.addAll
let's check item is not null before accessing it (and make a call to AppLog if it is)
Logic: Similar change to LazyFluentIterable#first()
We have a removeConfiguration so let's not allow null value here?
if you do this, better put N/A :)
Same thing here with this catch block
I think an additional MongoDbFactory ctor would be useful too.
Please add an entry to the issuecategoryregistry instead of just using a string literal here.
this function should receive generator object
(optional) could inline the value of m
Remove this :)
this should maybe be encapsulated to avoid leaking executionState class in the check class.
Can you make this a public static final constant instead? (And maybe use the same constant in the RequestMapping on line 37 too?)
If it's not good to use level(...) this time, let's remove my commit. Or please rebase it into your commit it if the changes are fine :)
I think CDA is not the place to set values
This might throw exception
The author in the header should still be displayed. Please only remove the author from the actual page, not from the blurred header.
Shouldnt this be <= ? Is it possible you haven't pulled latest changes? I think this was changed to < 2_12_0 but <= 2_11_0 would be equivalent (and maintain the appropriate value of MAXIMUM_SUPPORTED_VERSION)
can we add this. in front of setting these fields
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce this lambda expression number of lines from 21 to at most 20. [![rule](<LINK_2>](<LINK_0>
I think we have a race here with close.  T1 check assertOpen T2 close() T1 factory.apply( slot )
@eg04lt3r rename to interruptsThreadAfterTimeout
String.valueOf
Please re-format this method in your IDE, I suggest using the Eclipse code formatter located at config/engine-code-format.xml (If you're using IntelliJ IDEA, you can install the "Eclipse Code Formatter" plugin.)
same as previous patch (keep its own check). I know its tempting to REMOVE LIIIIIINES, but let's not get crazy :P
order of operands
Hi, I suggest you to use strings instead of StringBuilder, like it is done in CleanUpTest1d5.java . It improves the readability and the performance. A concatenation of literals is compiled as a whole literal so nothing can be faster.
@xupyprmv shouldn't it be sections now?
I was thinking in having REST operations that involves multiple servers under a separate resource: /rest/v2/cluster and keep the server resource to target each individual server only @karesti has also some ops that need to affect all servers to gather info. <LINK_0>
I think we can remove this line.
consider a assertSupported(BlockTypeStrategy) as altenative to all the instance of checks
defensive copy?
Move this binding to StorageModule.
So the issue was that they had _case in an identifier? Should you be testing for _ afterwards as well?
Could you, please, explain, why verification the command palette had been removed?
Log and throw is generally considered an anti-pattern. You can perhaps just throw the exception without logging in instances similar to this.
You could think about extracting the listener to a local variable: java final ChangeListener<Boolean> tabListener = (observable, oldValue, newValue) -> { if (newValue && !repositoryManager.isRepositoryLoaded()) { repositoryManager.triggerRepositoryChange(); } }; this.mainWindow.getApplicationsTab().selectedProperty().addListener(tabListener); this.mainWindow.getContainersTab().selectedProperty().addListener(tabListener);
Why not use ZooKeeperMasterModel.getDeploymentGroup()?
nit: for src code readability & more explicit error message java Preconditions.checkNotNull(p.getParent(), "Path for page %s can not be root", pageId); Files.createDirectories(p.getParent());
Then should we just use it to save the update items?
Avoid using localhost and obtain is as a parameter from instantiating class.
Again, these should not pass validateInputs()
Use UTF-8.
Is it possible to throw a more specific exception?
Is x != null && targetSqlType == Types.NULL valid?
Before, if there was an error, it would setToolTableJson(null). Now you don't set it at all. Do you want that? I don't know the answer, just raising the question. In theory, without understanding the whole flow, it seems like if there were already a value in that fiel, it would get cleared before your change, and now it doesn't. This happens in at least 2 other places (ran across this one first). Checking that this is as intended everywhere. Could very well be the bug fix :) But I'm still concerned about old values not being cleared.
Missing braces
What about return VdsmManager.getInstance().getHostByName(serverName); host is not needed.
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
Maybe a check here that getLeft() and getRight() have identical schema?
When using suggestion Assert.assertThat(testRealmResource().users().search("a", true), Matchers.hasSize(0)); Assert.assertThat(testRealmResource().users().search("apollo", true), Matchers.hasSize(1)); Assert.assertThat(testRealmResource().users().search("tbrady", true), Matchers.hasSize(1));  the output on failure shows the search results which is better for debugging potential failures.
if a column was missing, should we ever match it in this case? fn.apply(value) looks a little bit unusual as value is really an element from the Range of the function and not Domain. may be it should be...  return new BooleanValueMatcher(false);  @xvrl ?
Is this really more readable? (IMHO it's not)
Since we are changing I think it is better to use Collections.emptySet(). Like in fromMappingPrism
Actually, in what way does this change relate to adding a new status command? Because this change affects all other CLI commands perhaps it deserve its own separate commit. Anyway, just making sure this change landed here voluntarily and not as a result of mingling with another context...
@vilchik-elena Style: I would have created a variable for (ExpressionStatementTree) statement).expression()
deviceIdentifcation => deviceIdentification
Enclose your blocks with if ... { ... } else {
This should be a triggered ability of the enchantment, not a trigger gained by the creature
Can StringUtils.fromUtf8 be used?
Should create an empty Properties using new Properties(). The single parameter is used for default.
given that class is declared package private, public modifier here looks redundant. Consider either declaring class public or removing public modifier from constructor
Should go into @ After method to make sure it clears authorizations even if an assert statement fails.
Not sure idPos variable is really needed here
This method enforces AdminConfigImpl binding, while it should be possible to inject custom instance of it. Now injecting custom implementation results in duplicate binding exception.
what if storageDomainDR.getJobId() != null, won't we need to use storageDomainDR.getGeoRepSessionId and storageDomainDR.getStorageDomainId instead of getParameters().getGeoRepSessionId() and getParameters().getStorageDomainId()
This turned out great, I think it's really easy to understand exactly how we get retries to work properly with this code.
This can't be true, as Math.min() would return max if nsz would be > maz. :-) I think you really meant to write: if (buf.length == valid) { if (buf.length == max) throw When buf.length == valid we have to grow the buffer to read more data from the file, but we can't grow the buffer because growing it would put the buffer larger than the maximum size the caller wants this method to read and return. Yes there is a small issue here where the whole file might fit and we haven't seen EOF yet, but if we read once more we would see EOF. We can work around that by checking for EOF before throwing: if (buf.length == valid) { if (buf.length == max) { int next = in.read(); if (next < -1) break; throw ...
add this selector to UI mapping at the beginning
How did you convince your IDE that primaryIP is definitely not null here?
Locale.getDefault().getDisplayVariant() works for me but getScript() returns an empty string.
Wouldn't it be more efficient to just create patient dao once?
detach?
notEmpty check?
(optional) likewise
I'm not quite following what you are doing with the Entity Builder here. It seems like you are using it primarily to convert each TypedEntity returned in this loop to an Entity. If that is the case, you should be creating a new Builder for each TypedEntity and then doing your duplicate comparison within this loop. As it is currently written, it seems like you are just overwriting properties as you iterate through the TypedEntities.
Instead of hardcoding 2000 here, we can have a constant variable represent the timeout value at the beginning of QuorumPeer.java. [QuorumCnxManager](<LINK_0> is a good example on how it uses constants.
subMonitor.newChild with 1 tick
Why write it back to the field on every call? In any case, it must be done while the lock is held; otherwise we're back to the possibility of a concurrent update.
If this is never going to happen, why modify this to be less chatty?
Could we consolidate these catch clauses? Or is HornetQException a RuntimeException?
This is pretty dangerous because alerts bigger than 1MB will break the emitter
isBySegment is always called with false as the default argument, maybe remove the parameter
Consider using Assert.notEmpty() and/or Assert.hasText() instead of the three checks in the isTrue block. Otherwise, nothing wrong with this. Something like this may be a little cleaner:  Assert.notEmpty(configClientProperties.getUri(), "Config server URI is undefined"); Assert.hasText(configClientProperties.getUri()[0], "Config server URI is undefined.");
I think that may have been an oversight in longSum. Try a query that results in +Infinity at the historical level and you will see why it is needed to deserialize at the broker level
It would be great if we could have unit tests for all these new methods inside say PhoenixTTLRegionObserverTest.java
The uri should be determined from the app id (which is set at compile time). Otherwise this will always lead to the settings of the release app.
Add newline before return.
static ?
This methods should return the index of the max/min axis: x = 0, y = 1, z = 2, but it would probably be better to remove them from the interfaces.
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
new byte[0] is kind of ugly. Maybe another method that doesn't take it?
Does this need to be a singleton?
Minor: You could use TextUtils.isEmpty(config.getUnauthenticatedStartPage()) here instead if you like - it checks for null or empty string.
There is only one bit left between FLAG7 and LAST_FLAG. It makes sense to define ITypeMarshalBuffer.FLAG8 and use it instead of SECOND_LAST_FLAG.
this shouldn't do anything?
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
VmNetworkInterface already has a constant VALID_MAC_ADDRESS_FORMAT which you can use.
Why do you wait?
Does recording duration of 0 modifies stats in case of failure (I recall 0 might be meaningful data point because there is count metrics in TimeDistribution).
Should we add: Objects.requireNonNull(record)?
This line is now unnecessary because disposedOperators is updated in disposeAllOperators before throwing an exception.
@sebing we have compilation problems here as well
Can we remove this?
Better: append this unconditionally, and only append the other part based on the condition.
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
Please don't introduce labels, as I removed them in anoher pull request because sonarcloud complains about them (and not just sonarcloud)
better do this in a doOnNext above rather than in this map
If you want you could build the whole string directly as: String s = bids.stream().map(snapshot::getBundle).map(this::represent).collect(Collectors.joining());
initialization to null is not required.
I don't see why we need these sorts of constructors... We've never needed them before, and there's nothing special about the useLayerNormalization arg (it's just another boolean)... unless I'm missing something?
![MINOR](<LINK_0> Remove this unnecessary cast to "LaunchManager". [![rule](<LINK_1>](<LINK_2>
Replace these the filter() and map() with .map(m -> m.get("configuration")).filter(Objects::nonNull). This will avoid double hashing/searching in the map. Same below for "bundle_location"
IMO, we should directly pass bundle, instated of intent.
this check is again done in getTaskCategory(..) and is redundant.
Spacing
Here you should check the result metadata first and only if it is not INT, directly call super. transformToIntValuesSV() which will do the type casting. Same for other methods. You don't need a separate switch inside the method.
As the Constructor for WTab is protected, the addTab method should probably be protected as well, which would allow the class to be extended. What do you think?
why catching Throwable here?
We should also take care about casing - maybe less is better? Main file directory not set. Check the preferences (linked files) or the library properties.
Deprecation was added in [1] but the commit message does not have detail. [1] <LINK_0>;a=commitdiff;h=18bcdf797dfba5e462413a6ccce9dd6d3da2025b
s/numnParts/numParts
remove empty line
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
Since the subject isn't initialized until the callback returns. Won't this most likely lose the race and cause an NPE? I think this could be solved by making an AMLoginInfoTask subclass that provides latching mechanisms like AMSubject and Subject. So the code here would look something like (super approximately): LoginInfo info = new LoginInfo(); info.execute(); info.await(); assertThat(info.result(), ...); // Even more approximate if (info.legacyAuth()) { Subject subject = new Subject(username, password, null); subject.execute(); subject.await(); assertThat(subject.result(), ...); } else { AMSubject subject = new AMSubject(username, password, null); subject.execute(); subject.await(); assertThat(subject.result(), ...); }
Should this really be public?
I'm not positive that updated won't be called with a null for the config parameter, for whatever reason. It's safest to simply return in that case.
simplify return
what is ".jor" ? can we make it as a constant variable a meaningful name?
Given that this is a map attribute, when is this value ever FALSE? Why not use DiscarcAttributeChecker.UNDEFINED?
should check if viewer is disposed at some point
It should be a runtime exception.
Another option would be for WarningAction.onAttached to call Run.setResult automatically. On the other hand I can imagine wanting this drastic effect to be explicit.
I know I have a split opinion. I'd would take a stance that this constructor should be used only when we start writing in V2. Until then, its confusing why the callers are sending in defaults. This makes the caller assume that toBytes() will serialize in V2, which is not. We have to come up with some standardization wrt this new version upgrades in general.
Nit : you don't need this local, you could just inline the member in the next line. (it doesn't matter)
This is unrelated to the current PR, but seeing -argument looks strange from a UNIX perspective, where usually we use two dashes for long args and one for the short version (e.g. -v, --version). Could we change this to suggestion "--push-endpoint", cheWebsocketEndpoint, "--runtime-id", String.format( "%s:%s:%s", runtimeId.getWorkspaceId(), MoreObjects.firstNonNull(runtimeId.getEnvName(), ""), runtimeId.getOwnerId()), "--cacert", certProvisioner.isConfigured() ? certProvisioner.getCertPath() : "", "--registry-address", Strings.nullToEmpty(pluginRegistryUrl)));
I'd prefer to remove/deprecate AsyncTracer in favor of proper APIs to support what we want to measure. <LINK_0>
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
perhaps if not has permission?
Whoa, this looks wrong. The query doesn't have a native query and it returns an empty result set. I think that probably, this query should return an error, because it represents a kind of query structure Druid can't do right now (aggregation on top of a non-aggregating subquery).
Should be a SamzaException with a message, not NPE.
This if condition is already covered by the one below.
In general, I think we should start the tasks that need to be started, and then stop the tasks that are supposed to be stopped. The other way around could potentially introduce latency.
Does this need to be a singleton?
Why is the runtime tracking two layouts (i.e. layout and latestLayout), remove latestLayout and just update the this.layout as you discover layouts with higher epochs.
* There is nothing random anymore in the value of this variable, so the name is wrong. * We have a relatively small set of cases to test, I don't see why going though so much Java code to edit in memory a VSM via hard to read and duplicated logic. Simply craft a VSM with the 8 possible combinations and make the test simply call validation on it. * The test does not cover all the cases.
nit: Doesn't matter much because these are just examples, but I think it would be more clear to use the methods on the options builder instead of using an opaque properties object, like Option.Builder optionsBuilder = new Options.Builder().server(Options.DEFAULT_URL);
Please consider using org.eclipse.debug.ui.DebugUITools.launch(final ILaunchConfiguration configuration, final String mode)
lets make this an internal server error
please put in a separate method or rename this support method accordingly
checking for nullable parent was added specially, cause going into project node simply has no meaning
Shown on the UI so should be i18n aware.
This could benefit from checking for IndexOutOfBoundException.
Could you please move this message to the ThingStatusDetail of the updateStatus call below? This way users will see it in the UI directly.
Why not directly call a canDeleteInstance(input) ?
Ignition should be boolean value. If it's not, we can just ignore it.
This can get weird since we could be inside a SchemaRefreshRequestDeliveryCallback which is already executing in Cluster.executor, this will submit another task to Cluster.executor. This gets even weirder if the schemaRefresh was triggered by schemaRefreshRequestDebouncer.deliverEvents in Cluster.maybeRefreshSchemaAndSignal. This leaves us with a situation where we have:  a. A response submitting SchemaRefreshDeiveryCallback in Cluster.executor via maybeRefreshSchemaAndSingal b. SchemaRefreshDeliveryCallback submitting Runnable to Cluster.executor: c. Runnable calling controlConnection.refreshSchema which submits a nodeListRefresh d. NodeListRefreshDeliveryCallback submitting a Runnable to refreshNodeListAndTokenMap in Cluster.Executor.  If Cluster.executor only has 2 threads (dual core or less system or configured that way), wouldn't that starve the executor since in a and c we are waiting on completion of whatever is being submitted at that time?
No big deal but think readTree accepts JsonParser too.
Really complicated micro-optimization nitpick: there is a separate get and add call - that's at least 3 lookups. We can reduce this if we introduce a boolean addOneIfAlreadyExists(Tuple) method to TupleMask as a variant of add() that does this in one step. Or maybe leave it as it is :)
we should check mMediaUpoadHandler != null before accessing its methods here, as they are only created in onStartCommand, I believe there's this slight possibility onCreate is called and then onDestroy gets called immediately afterwards (without onStartCommand being called).
Here errorMessage needs to have single quotes escaped. The permission error ('You don't have permission to upload media to the site'), for example, causes an error. errorMessage.replaceAll("'", "\\\\'") should do it. We should probably do this everywhere we're sending string literals from Android, since a translated String may contain a single quote even if the default one doesn't.
Looks like this now should be withing if (result && this.fullStatsEnabled) as well.
I don't want to have us get in the habit of manually building JSON strings. We can use the JsonObjectBuilder from the javax.json package, or we can build maps and pass those to Jackson (ObjectMapper) directly.
Use isEmpty() to check whether the collection is empty or not.
IIRC anonymous users will crash here because they have no user account to get the prefs from.
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
I'm wondering whether it's worth to also extract this into a field, like is done for trees. This method isn't on a hot path as far as I can tell, but having the symmetry and separate code might still improve readability of the code. What do you think?
Do you think it would be better to find a way of doing this without sorting a collection on every call?
Mb it is better to use common format for toString method? <LINK_0>
You could replace everything from line 140 with this: Exceptions.expectException(RollbackException.class, this::commit); } catch (Exception e) { log.error("Unexpected exception in transaction 1", e); tm.rollback(); Rollback exceptions will be reported by the main thread, and unexpected commit/pre-commit exceptions will be reported by the fork thread.
maybe use dnsServerAddress.isEmpty()
Why it is named by testLoadYamlFileFromDirectory ? Does it mean it will include all .flow files in the directory?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
can you include the e.getMessage() in this log message for easier troubleshooting? Otherwise, we will only see a stack trace I think if the exception is not caught.
What about handling the case where the ASTValue is NOTHING? It should be legal to assign a variable to be nothing, as in, "x is nothing.". Also, is it legal to assign a variable to an object? For example: Fred is a person. X is Fred. (If that's legal, garbage collection becomes harder, so it's probably not legal. But if it's not legal, then the code here will silently do nothing, whereas I think it should give a runtime exception to the user.)
We should only set the field when the key is present in the manifest, otherwise we will have to alter code in two places when the default behaviour for detectNdkCrashes changes to true.
why did you remove this ?
unecessary test : less is more.
better return a null object (new Pair(this, null)) or throw UnsupportedOperationException
I believe we added a guard class to the sdk that will do this exact check.
StringBuilder
nit: suggestion LOG.info("Cleared the metrics store and metrics system in {} ms",
Should be the responsibility of service/requestman layer after Hibernatization
How about inlining it?  if (!contains(o)) return false;
Use a constant.
This can return null if the port is not a valid UML-RT port (in particular, if it is missing its RTPort stereotype application for some reason).
don't update fields in one object in the constructor of another object.
Extract this into a method, given that it's called twice
just use an EnumRenderer in the view instead of localization in the model (and modify Enums.properties...)
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
Looks like if we pass null instead of new char[0], the content assist will auto-activate.
Request.State.OPEN
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
can we also include a test where we set includeInsights to be true?
Unclear if this has been a convention throughout Lock Watches, but the decomp - in particular, rejecting a success from post-leader election without a snapshot _here_ - seems a bit unexpected. I'd prefer this just return the version, and updateVersion take care of that filtering. It looks like you do that anyway in updateVersion!
In other switches IllegalArgumentException is thrown, which I think is a better fit to here.
IDEA says that using toArray(new String[collection.size()]) has no performance improvement over toArray(new String[0]) so the second call is encouraged.
You can consolidate these into a single try e.g.:  try (ByteArrayOutputStream baos = new ByteArrayOutputStream(); GZIPOutputStream gos = new GZIPOutputStream(baos); ObjectOutputStream oos = new ObjectOutputStream(gos)) { oos.writeObject(obj); conf.set(key, new String(Base64.encodeBase64(baos.toByteArray()), "UTF-8")); }
assertEquals(Foo.class, foo.getClass()). The produced Foo is @Dependent and so there is no client proxy and we can be sure the instance is the result of the producer method.
you could be more specific and check instance of Function0 maybe?
No writes to stdout
Did we mean to remove the subscribeOn here?
modify it as it was implemented in ENG-10264
Let's keep the old code here or let's try to move this method in the IndirectClient?
Should not it be [less than 20](<LINK_0> ?
this doesn't look like new code... was it reinstated after a merge or something?
Couldn't this just be configurable?
Yea that seems good.
@dskalenko when line can be null?
Why not simply times damage and range by either the blue fire multiplier, or 1 if they don't have blue fire? This seems so much more pointlessly complex.
Why bother locking if the size returned is immediately going to be invalid? aka, some other thread may have already changed the size.
finish() is called in case of an exception but the callback.close() is also included in the finally clauses of the top level methods. This leads to closing a callback() twice which is probably not intended.
Just a note that FetchSessionHandler is used by the consumer too, so we will either need two separate implementations or make sure it works just as well for the consumer too.
isEqualTo -> isEmpty?
Moreover, I think even we need this mock, it should be used for testAvoidingRedundantWrite() only. As for the other test method, they should be still using the original assignment store class.
You would need to error out or S3 service to error out, not to delete with Set()
Why is this hardcoded to 4 threads? Should there be an option to control this?
Could also use DataTypes.STORAGE_UNSUPPORTED here, once we support interval storage the test would then reflect the change automatically (otherwise we'll forget about this "temporary" skipping)
TogglzEndpoint.java:[58,63] lambda expressions are not supported in -source 1.7 <LINK_0>
Think @sandeepSamudrala mentioned in the another pull request. Should add location to the resultObject.
This can be small D double
Is this a specific exception? Or an internal issue? If it is not an internal issue, we should not throw RestAPIException.
checkNotNull
s/Started/Starting
No need to cast a Player to a Player here.
Why do we want to return here ? Even if we retVal is null, we can initialize retVal here and the list can be added with the output of fPostListenersByPartId.get(listenerPartId)
If we're going to refer to this later while making assertions, a more descriptive name might help readability. Something like putFailure here and closeFailure below, maybe?
Swap the equals condition.
I don't think it's the job of this class to invalidate a valid offset_s. If the user wants to handle timestamps in nanoseconds using long, the user should check its own overflows.
Operation can have InputStreams attached. There's a way to translate that to HTTP, we should figure it out. Or at least throw an exception if there are attachments.
I Don't like this at all: the superclass is now doing different things based on the subclass. Prefer: factor out into an abstract method where each subclass does their own thing.
why do we need to make this method final and none of the others?
we still need this snapping logic if the window is not divisible by the step size
- log warning that option is not supported by SNMP
Unless I'm missing something, this assignment never has any effect, because it's immediately overwritten inside the buildTree() call, so we can just remove it. Pushing this even farther: it's not at all clear to me that we even want a currentPoint instance field. Seems like it would be better to make the following changes: (1) change the buildTree overload with three arguments so that the last argument is the current point (not just its X coordinate) (2) add a P argument to setCurrentPositionFor() and pass the current point to it That way we don't need this piece of class-level state at all, which seems like a better/more robust design.
use Log.error ("something {}",e.getLocalizedMessage());
Why use getSearchKey rather than getDisplayValue?
I think better to use string concatination, as info log level this might called lot many time and string concatination has better performance the String.format. Another place where place I could think we can make more use of make logging, if present the file full path instead of file object.
assertFalse(...);
I would like ot be extra safe here and it becomes smth like OS.GTK3 && !OS.isX11. This way I would be confident it would not have effect on X11.
Check what happens with an empty file: Looks like on replay, both openFile() and closeFile() calls are skipped since there are no recovery entries for that file.
Can you please merge duplicating code here? Something like:  java final Subscriber<T> parent = after ? new BoundedAfterSubscriber<T>(child, capacityHint, predicate, prefetch) : new BoundedBeforeSubscriber<T>(child, capacityHint, predicate, prefetch); child.add(parent); child.setProducer(new Producer()  ); return parent;
It would make more sense to invert the names (the one with BUTTON1 is used after... call it stateMask2)
similarly
close streams
The initialization of length needs to be done only once and not all the time getClonedStream() is called. If we would like to handle file length changes it does not work (IIRC) as the file size could change also after the file input stream has been created. So, I think this line could be moved above after file = new File(outputFile); Or is it because you don't want to handle FileNotFoundException twice? But reset the size all the time... Hm WDYT?
If shouldSchedule() and shouldRun() are overridden, the if is not necessary here.
Not sure this is finally correct. I think this may still execute measure... two times for the same FileStore. Consider no value known initially, then Thread A: Starts future F1 Thread B: executes future F1, puts lock in map, calls measure... Thread A: times out on the get() on F1, return fallback Thread A: comes again with the same FileStore, still null Thread A: starts again a future F2 Thread C: executes future F2 Thread C: obtains lock from map Thread B: returns from measure... Thread B: sets value Thread B: unlocks Thread C: sucessfully locks the lock, calls measure... Thread B: removes lock from map Thread A: times out on get() on F2, returns fallback Thread C: recomputes the value, eventually puts it into the map Probably should check before line 239 or at the beginning of measure whether there's a value known by now. Same as why my code checked again while the lock is being held.
No need to have endIndex as field.length() as field.substring(startIndex) is sufficient. You may want to do the same change for the next line.
Should be moved into a private method that makes the above find() more readable.
@sbespalov : What is isLsm(...)? What doest this abbreviation stand for? Layout-specific metadata, or is it something else? If this is it, could you please rename the method, so it's clearer? Thanks! :)
lets make this an internal server error
Add SubChild here as well, perhaps SubChild is just persisted as a Child currently..
should this be a logger call instead of printStackTrace?
I like the use of Map.Entry here. Nicely done.
Why are you using a Queue here? And then by extension a LinkedList?
Will this always be this value?
Give a name to this thread, so if it hangs or blows up, the stack trace will give us a clue who called it. i.e:  new Thread(r, "Hawkular Java Agent Stop Thread").start();  I also need to think about this some more before merging since we are now making the stop() method asynchronous. We have to check to see what kinds of thread safety/concurrency issues this might cause (especially in cases where the agent is restarted, for example, and the stop is followed quickly with start. We need to make sure nothing in start is initiated before this stop thread is actually kicked off and finishes). In other words, making stop method asynchronous could have some side affects that are "bad" without some synchronization/locking put in place.
I think you could avoid to use this to reference the fields in the unit test, because there are no name conflicts.
Maybe assert that #put() returns null
use TWR to close
And then else if this
Should be a SamzaException with a message, not NPE.
This block only compares AttributeAccessItem objects to themselves. It should compare them to the AttributeAccessItemDto objects from the corresponding indexes of attributeAccessItemDtoList.
There are a few checkstyle errors left:  [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedFilterDialog.java:24: 'if' construct must use '{}'s. [NeedBraces] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedFilterDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./core/src/main/java/de/danoeh/antennapod/core/preferences/UserPreferences.java:1064:51: WhitespaceAround: '{' is not preceded with whitespace. [WhitespaceAround]
Why not static? (This can probably move to MySqlUtils anyway.)
Nit: For defensive programming, I would prefer String.stripToNull(region); Please update for similar invocations.
Shouldn't we be moving the elevator while we're moving the clamp?
Alternatively you could have a static constant Set<String> and do a contains(). It would go nicely when we can use a Set.of.
In here, we can check empty/null case of tag and provide a default tag. "NO_TAG" would be ok.
avoid increasing visibility?!
Why singular?
Do you want to also log the client name?
coding style:  try { ... } catch (ClassNotFoundException e) { // Don't mind... Attempt next class loader |
Minor: Please add whitespace before the final argument.
View.edit(model) should not add new listeners to model object. This should be the responsibility of associated presenter - for example, in GlusterVolumeSnapshotCreatePopupPresenterWidget: @Override public void init(final GlusterVolumeSnapshotModel model) { super.init(model); model.getForceCreate().getEntityChangedEvent().addListener(...); } View.edit() is responsible for populating UI from model data and can be potentially called multiple times. Model listener registration therefore doesn't belong here, but in AbstractModelBoundPopupPresenterWidget.init(model) method override.
suggestion prefUseSaf.setChecked(NewPipeSettings.useStorageAccessFramework(ctx)); prefUseSaf.setDefaultValue(Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP);
lots of loc here :) this method was only present for toString ordering
4.2
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
Please refactor to different methods
Single statement blocks do not require braces.
I don't see the benefit of this. It does make it less obvious that it is the same object having cancel called and being set to null below.
Should it be logged at the error level?
java && SCMTriggerItems.asSCMTriggerItem(job) != null && job instanceof ParameterizedJobMixIn.ParameterizedJob  :bug:
Can I suggest the following to be more consistent with the other code in this file? It's more or less equivalent to what you have: java return File.createTempFile("swarm-client", ".pid", temporaryFolder.getRoot());  Since this uses a different name each time it's invoked, we'd need to pull it out into a local variable within each test, to be passed to each Swarm client we create.
Doesn't seem as something which should be public, I would say, it should be rather private. If it is required by cancelAndDismissReloadRequiredWindow, it should be most likely improved in order for this method not being required public
handle null case (same for rest below)
I'd break this up as java StringBuilder sb = new StringBuilder() .append(formatExpression(column.getName(), parameters)) .append(" ").append(column.getType());
No need to wrap the value, it is already a CompletableFuture<Long>.
:+1: like here, ..isNull() makes it clear that you're checking that the last message is null
Is there a serde test for this?
Is there any value in asserting that these commands come in the right order? Although the implementation is a List I guess it protects against changes to duplicate checking or something doing an insertion into the wrong place in future. Maybe something like: if (latch.getCount() == 2){ latch.countDown() } else { fail("Wrong order")} for start and similarly with a 1 count for the stop event. WDYT?
Hello @mcimbora , I think it can be worth to provide a more fine grained filtering here. To be sure that the method is not a constructor, has the @Generated annotation, and also "is one of the generated" by the planner stuff. Probably inspecting some additional planner generated annotation for the method (I I don't remember wrong for this planner generated method you added has also a planner annotation with two parameters?) or eventually exploring the return type, or some other trick. This will prevent us from loading other methods with the @Generated annotation that we don't know how to manage. Specially because when the java source is being updated, all the accepted methods are being deleted.
s/any(List.class)/anyList/
lets return empty string "" to avoid hypothetical NPE in future code.
why not just getResourceManagerRoot().toPath();
Since the connection getting passed as a parameter to this method, it shouldn't close the connection inside this method. Need to close the connection in the original place where it originally (create and )close the dbConnection.
Also verify here that the created folder does not exist after the rollback. Also maybe check that the active transaction was cleared?
This is a local, shouldn't be a field.
Replace with specific exception types.
Avoid logic in this class. This is inconsistent with other collection fields. You can't do an update with this field set to null. Also, why a tree set?
unnecessary parenthesis?
Unnecessary (and incompatible); revert.
what it calls on partition seems questionable
we should probably set an upper limit to this?
just FYI, this if block could be replaced by switch statement since it's for Java 7
We should also verify that call to Elastic that sends the data is actually made and that it contains the results that were given on inputs. In the end, that's the most important action of your class, so it should be tested.
I don't see the difference between testWriteAdvHandle and testWriteAdvHandleWithFixedLedgerId. I image you need to verify the different behavior between without and with ledger id. but the test cases don't actually do this validation.
i18n
nit: put input.getId() in new line, and also other calls to addOperatorToStreamGraph.
Please change to "clear tokens from local token cache for the user".
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
Add a message to checkState so that it's easier to debug if we ever hit it.
I see what you're trying to do. So we can assume things such as the following will be processed correctly, right?  1 2337032 rs1129171 C T,<NON_REF> 480.77 . BaseQRankSum=0.218;ClippingRankSum=0.103;DB;DP=45;MLEAC=1,0;MLEAF=0.500,0.00;MQ=60.00;MQ0=0;MQRankSum=-1.344;ReadPosRankSum=1.046 GT:AD:DP:GQ:PL:SB 0/1:19,26,0:45:99:509,0,330,565,407,97 2:9,10,13,13
Checking whether text is null seems properly defensive. If text is not null, I believe that text.getData() is guaranteed not to be null, so that part of the check is unnecessary.
You're not actually testing that patch() did anything good. Instead of calling fetch() here you should use [MkContainer](<LINK_0>, which will give you an ability to assert, that an HTTP request was actually sent with the required JSON
do we need to sleep(1000) here? can we make this test sequence more deterministic rather than depending on time, to reduce flakiness?
Why not simply return Arrays.hascode put add offset 31 which is recalculated every time?
Why do we need this ? Should be done by DublinCoreService
Is this still needed? We don't add any other elements, so parent.get(anythingElse) should return null anyway.
This is fine, but even better would be to also catch any ToolError (e.g. a typechecking error) and print the error message on standard error.
This method makes a huge assumption that the user invoked the command as "-option value arg" when really they can also say "-option=value arg". And it doesn't take into account the -- that stops option parsing.
Use Arrays.asList instead.
It makes sense to introduce UNCPathConverter.isUNC(IPath) method that operates on path directly without calling toString().
Please use braces {} for this even if it's a one liner, to follow the project code style
Is it by intention that you set the status outside of the "synchronized" block? Before you set the status within it...
Not 100% sure if we want to swallow Errors - should this just be Exception?
I think it is better to return an empty collection instead of null.
Use new lines.
Could inline syncGet() in getCacheEntry() and use that here.
This is only valid because the empty version is defined as "0.0.0". But AFAIK it could have been "0" as well. So I'd rather use a "0.0.0" (or "1.0.0") constant here.
return (source != null && source.isValid()) ? source : null;
Hello @mcimbora , I think it can be worth to provide a more fine grained filtering here. To be sure that the method is not a constructor, has the @Generated annotation, and also "is one of the generated" by the planner stuff. Probably inspecting some additional planner generated annotation for the method (I I don't remember wrong for this planner generated method you added has also a planner annotation with two parameters?) or eventually exploring the return type, or some other trick. This will prevent us from loading other methods with the @Generated annotation that we don't know how to manage. Specially because when the java source is being updated, all the accepted methods are being deleted.
Please remove pvk.
This JobConfigUtil.generateJobIdAndName should be in the planner. You can add a function directly there like planer.createSingleJobConfig(). This will be better handled in a single place.
try prefix is used to distinguish this method from public toMessageClass(). I find it better than innerToMessageClass() or something. I use try prefix for such methods as Bob Martin does in his great book, Clean Code.
Let's add a constant for the install application operation code.
Suggestion: Please change this method to be called isDiskType(DiskStorageType diskStorageType) and use it also for Cinder
Can we use already-defined constants for the following three strings?
Does this need to be a singleton?
nit: if (p != null)
relevant non-logging code change here ^^^
Please fix refreshAuthz(sess) implementation, it's not 1:1 replacement of above removed code right now.
return operatorsToDeploy.isEmpty() && operatorsToUndeploy.isEmpty();
PercentType is a DecimalType and for DecimalType calling toString() is the right thing.
Nit: this consistency.
One could express this block a bit more succinctly:  FutureUtils.forward( jobManagerRunner.getResultFuture().thenApply(DispatcherJobResult::forSuccess), jobResultFuture);
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
Since this block is repeated in above, shall we move it to a separate private method?
What about creating own separate methods in client for starting solver and terminating it? It would be more intuitive and user friendly from my point of view. Also it would show what parameters are mandatory for each action.
The local var is useless, you can remove it.
Magic number. Please run checkstyle/pmd/findbugs and fix all violations.
.take(limit) is the default in RxJava, limit is an alias (but in ReactiveX world, the normal term is take, so lets use that)
Instead of this constructor using the other, I would make the other to use this constructor with a null linkUrl. What do you think?
could you remove the tab and use spaces for indents?
don't wrap at .
Use Arrays.asList instead.
you moved and changed these methods in the same commit, can you please separate such changes to separate commits. It is much easier to follow that way.
format this as:  a -> a .globalGrouping() ...
You could combine this into the for loop conditional using && and removing the negation.
those 2 lines can be united
Class<?>
In general if you throw an exception you don't log an error (or it will be logged twice, once here, once when the exception is caught). Instead add your log message in the exception you throw. throw new IOException("Couldn't cast object read from config with key " + key,e);
buffer size 1, why?
remove this... openFileInput(fileName) should be sufficient and using an Application context is often an anti-pattern
The AllCleanRule should do the work of lines 158..159, so you can skip this code.
Here it breaks the format.
Minor thing: "referer != null"
can this use increment util?
It may be better to return an empty string here instead of null. Unless others look into this code, we may be pushing the null pointer higher. Thoughts?
Do we want to turn this on by default in elide-standalone, or did you mean to wrap this in an if block?
spacing
Sorry, I forgot about one thing! This will no longer be enough, there's VERSION_1_8_0 now. I think a better condition would be: ctx.version.lessThan(ServerVersion.VERSION_1_7_0) || ctx.version.inRange(ServerVersion.VERSION_2_0_0, ServerVersion.VERSION_2_2_0), but feel free to write the condition on your own.
please review code formatting
Needs to shut down the scheduler.
The value returned by isPlaced depends on the mapped flag as well. It would be a lot simpler if this provider had tuples of [seqID, start, mappedFlag, usePositionDeltaEncoding, expectedIsPlaced], with test cases for each possible combination, and the test just created a new record for each case using those values, and verified isPlaced.
directly return generationOptions.isAutogeneratedScript()
I'd inline result variable: DOUBLE.writeDouble(out, strategy == null ? Double.NaN : strategy.calculateEntropy());
I think this method should either: 1. start with if (rec.getReadUnmappedFlag() || !rec.getReadPairedFlag() || rec.getMateUnmappedFlag()) return false 2. or make it explicit in the javaodoc that it's only legitimate to call this method on a read that is paired with both it and the mate mapped
Please log the content's Identifier and relationship name too.
nit: just simplify to throws Exception
Should be IllegalStateException.
I don't know, but isn't the class also of interest?
better return a null object (new Pair(this, null)) or throw UnsupportedOperationException
Why this get deleted? Your code depends on this function?
ping
typo!
I think there should be a comma here not a plus
notification? i think that makes it more clear what is happening than notice
overflow = ((xl ^ yl) & (xl ^ zl)) < 0;
I don't think args can ever be null, can it?
If these values can never be null they should be stored in int not Integer.
Why change to this?
Is 20000 a github limit?
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
you control all the source here, I think it's fair to assume non null + you have Preconditions.checkNotNull
This method needs a more descriptive name.
Looks correct. I think you can just do result[1] |= shard() << 6; since bytes in an array by default are zero.
Debug stacktrace leftover?
Should this be a new Exception class?
rename to f
is this line useless?
Let's also remove the print statement to stdout
if we fail here we have a stale VM version in hand. we should roleback
return HConstants.EMPTY_BYTE_ARRAY; ?
calling is.close() might produce exception. Please define: private static void safeClose(final Closeable c) { if (c != null) try { c.close(); } catch (Throwable ignored) {}; } and use it instead of InputStream.close() method
Request.State.OPEN
I see you came back around on this. I think it is nice since then you know know what constraints there are based on the command type :)
I think this would be easier to understand if you would combine the last two line into a single line: if (Project.DashboardType.fromId(id) != null) { I was first confused why you need to re-set the type.
Assertj has a fluent API. You have to do assertThat(events.size()).isEqulTo(1);
Don't really need this check which lets you inline the getInterfaces() call into the for
FIXME: All front facing strings go in strings.xml.
I think we shouldn't just catch and silently ignore? Would be nice if we could somehow alert that there is a malformed URL.
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
minor, is it method scope for Visible For Testing? If not please change it to private.
Ye, but it causes a PMD warning.. :P I will fix it, that will be easier. ;) <review, layout
do we care to check the length to be positive here?
I'm not sure that it will be correct to return only 400 for Nakadi Exception and 503 for everything else. I think that in reality there are more options.
I don't think the process deploy should fail in the case of temp file deletion fail
@bkmeneguello Are you sure that <code>!=</code> is correct?
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
FYI this is moving to @Restricted(DoNoUse) in recent cores because it has been renamed. If you update the core the new name is doCheckLabel.
Should this be set for the whole migration?
Please create a utility method getWorkflowConfigurationParser that contains these 3 lines ^, and also use it in makeDefaultScheduler.
My personal preference is to use brackets even for one line loops and condition. Not a blocker to merging.
Check args?
Preconditions.checkNotNull(is, "Input stream required to create temp file for %s*%s", prefix, suffix);
no need for the temp variable - just return mapper.convertValue(...)'s result
Could this be merged with what we have from line 85?
This indentation and formatting should remain the same.
It has been wrong before your commit, but as you touched this line could you use {} instead of string concatenation?
Since this will appear on client side, my only concern is the date format that may not match what is expected by the user. Also, for the UI this is just a string to be rendered, no further logic since no further information is provided (e.g. type or format).
do not forge to test the isActivated() flag: it is as important than testing the node count... withTopologyService(1, XX topologyService -> assertFalse(topologyService.isActivated()));
Shouldn't you rather log directly?
pls use querydsl instead (already in master)
null check seems unnecessary, given the yoda condition
I think the index for get should be 1.
long hashCode; try { hashCode = (long) keyBlockHashCode.invokeExact(keyBlock, position); } catch (RuntimeException e) { throw e; } catch (Throwable throwable) { throw new RuntimeException(throwable); }
this method should not be public, otherwise doesn't make sense the arguments for the flush(ClientSession, String) method, as each session (editor) will have a different associated FormsContainer instance, which could not be the one set in setCurrentContainer... Can you please change it to package protected access (so no access modifier set)? Does it work/make sense for you?
Sure it would be slightly faster, I guess, if the method is looked up at proxy creation time. I wasn't overly concerned about it since this is a debugging class. I'm ok if that's a follow-on improvement, too.
use hasNext instead of contains (do not use toIterable() we want to check Iterator)
Is this still needed? We don't add any other elements, so parent.get(anythingElse) should return null anyway.
nit: don't need this return false; line
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
boolean includeTextDetails = true; and send that value in the call below.
nit: wrap statement in {}. Since we have Guava now you may be able to shorten this to: return Objects.firstNonNull(req.getCharacterEncoding(), "UTF-8");
Did you validate that this renews?
I think that this method deserves to be protected and tested.
please name variable message , it will looks better.
"if(" --> "if (" there are other instances of this, too
In static methods rather do it like this: java LoggerFactory.getLogger(WeatherUndergroundJsonUtils.class).debug(...);
Can you not use a for-each loop here?  for (JsonElement jsonEle: doc.getAsJsonArray()){ // stuff }
We shouldn't need separate methods for create/update like this. Do what we can in one, pull the unique bits back into the callers for the rest.
Could you please log the transaction ID here, instead of the entire transaction?
You can probably remove this
rename to contribution
wrong arg order
Same here with not needing the local variable.
hmm, that method makes somewhat sense in core java, but I'm not sure I like that behavior for selendroid. We're expecting a boolean value, but essentially we only care about either true or "true" coming across... everything else is false. Is it going to be confusing to any users? I'd almost rather add an additional else clause to check for the string of "true" or "false", otherwise raise the exception. Since users of other programming languages (like javascript or python) may have a different impression of what a truthy value should be.
I think we might need to ask the Metamodel for whether this is a managed type at all. Could be a class unknown to the persistence context.
Point of style: when the if statement is 95 % of the method, perhaps the method could be refactored so that only the return needs to be indented. Alternatively, the whole block could be turned into a new method (Properties createProperties()), which is even cleaner.
Same again with the log level, can you set this to w? Also can you change that message to something like "couldn't list assets at font path" so it's less ambiguous, it's not really failing to load fonts if you get me!
Nitpick: might be better to use constants for these.
This seems unnecessary. What advantage is there here versus before ? Both guarantee the order is respected.
Typo: Somehow an extra 'And' got introduced here
Move this line down. We don't need to instantiate a new object if it's not an IContainer.
suggestion if (highAvailabilityEnabled) { taskAssignor = new HighAvailabilityTaskAssignor<>(clientStates, allTasks, statefulTasks, assignmentConfigs); } else { taskAssignor = new StickyTaskAssignor<>(clientStates, allTasks, statefulTasks, assignmentConfigs); if (!lagComputationSuccessful) { ((StickyTaskAssignor) taskAssignor).preservePreviousTaskAssignment(); } }
hashCode -> System.identityHashCode
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
If we move MessageTest to the internet package (and rename it to MimeMessageTest, which is what it is), these can be package-local. Also please annotate @VisibleForTesting
Yeah, definitely unfortunate.
is it possible that among the possible NakadiBaseExceptions there would be an authorization exception? I'm not sure if authorization is checked earlier in the code path, but if that's the case, we should handle this one specially. Could you please check that?
With set() and find() now bypassing Square and using Entity directly, should we have get() return List<Entity> ? That way the Square class won't have to be public, it'll be an implementation detail.
This can be handled by waitForRunningTaskToComplete accepting a callback function to be executed that can contain the following code.
Nice to add default to switch stmt or convert to if-else if there are only 2 states
Please don't extract that into other methods, it makes the tests hard to read. Either you multiply the test classes, each one of them having only one test method and one setup, or you use classes with many test methods but then, each test method must be readable at a glance and not rely on other methods located elsewhere, because it makes the intention of the test unclear.
why did we change this. SchemaResource should be unrelated to MLRegistry. We require having topicName + ":v" for schema registry to work with
Are we keeping this public method for a reason? Isnt this a remote param now or are we keeping both?
Don't call toString()
Missing a space between if and (
Also add an assert for multiple values in a hashmap.
build.create call is duplicated
should break request.toBuilder().header(HttpHeaders.AUTHORIZATION, authHeader).build(); into it's own method as you call it twice and the long chain is a little hard to read
return new Job(name)
For PropertyChangedEvent, "args" will always be an instance of PropertyChangedEventArgs. Therefore you can also cast "args" directly, for example: String propName = ((PropertyChangedEventArgs) args).propertyName; Above should simplify the code a bit. It's up to your consideration, as for me the instanceof is just unnecessary complexity. BTW, we have a BZ exactly for this issue: <LINK_0>
I think we should store ignoredRegions instead of ignoredLineNumbers. Single lines that need to be ignored can be stored as <LineNum, LineNum>.
<field name>_COLUMN
To always be safe please use context.getApplicationContext()
Just stuff all this logic in "getAllowedCategories" so you have no if statement here. Then the case statement just has return pickRandomInsightCategory(getAllowedCategories(marketingInsightPool, marketingSeenCategories),random);
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
I don't think we should throw an exception, let's just return null.
Second parameter of Status is the pluginId. Why to pass path here?
Maybe better to return null
let's change the order in the ctor - its clearer when the source is before the dest :)
Must return false on broken/non-applied effect.
requireNonNull
I dont think the care setting and order class matter, so i would not filter on them
May we detail the logger message a lit like > error in registering flow trigger <PojrectName_FlowName> in Quartz,
what about : this.myField ? This isField method should probably return the referenced symbol.
Why not update it in setZoomRatioInternal()? Is it because of float rounding error?
these 3 lines are common in closeXXX() and can be moved to close()
Should be a SamzaException with a message, not NPE.
remove the explicit initialization?
:ant: Deserves a functional test.
should be int y
Replaceable with Iterators.transform()
Maybe just return map.computeIfAbsent(x->create())?
Needs to be internationalized.
what about using org.apache.commons.lang3.BooleanUtils.toBoolean(String) here?
Don't we normally do null checks in builder methods? Or are we happy to wait until build is called before blowing up?
check unnecessary
Is there a possibility that jetty.home is not empty, but jetty.base is? In that case, jetty.base will be left empty.
Wouldn't these arguments need to be a Map (name to value) rather than a list?
Add catch clause for OperationCancelledException and return CANCEL_STATUS.
You can use m_flc.checkCounter(timestamp) directly.
use ConcurrentUtils.withLock()
size is calculated here. Do you want to change sizeCached to true?
You can use a foreach loop of the form for(BibEntry entry : entries).
There is a lot happening here. It would be nice to break this up into multiple statements to improve the readability. Something like this: java ClientRegistration clientRegistration = context.getClientRegistration(); boolean isClientCredentials = AuthorizationGrantType.CLIENT_CREDENTIALS .equals(clientRegistration.getAuthorizationGrantType()); if (!isClientCredentials) { return null; } OAuth2AuthorizedClient authorizedClient = context.getAuthorizedClient(); if (!shouldRequestToken(authorizedClient)) { return null; }
we can also specify initialCapacity for metricValues
Can we set a charset? Like ASCII or UTF8?
Looks like this returns a string, not a boolean.
Closed channels are automatically removed from a channel group. This line can be removed
extension.toString()
typo?
use hasNext instead of contains (do not use toIterable() we want to check Iterator)
we tend to like initialization like this: final A a; if (cond) { a = something; } else { a = null; } This make very clear when a is set to null;
For this for cycle you can use your newly created method isAlternativeBean as well right?
You could keep this declaration after the throw Exception, so you don't do it if the exception is thrown. Really minor thing.
simplify this
mmm not sure if it is gt 120 characters.
See above about title, file_name, and content being required parameters.
why is the lower bound 0? Should it not be at least 1?
For null values, we just do not supply those properties in the autoGenerationOption
Also include the values here?
Mappers can be stored in static final variables instead of rebuilding these each time.
I think all of the stuff that modifies the response needs to happen outside of the thread after start is called. Otherwise, the method will have already returned, so I'm not sure what would even happen if you modify the response.
Can we make this package private instead?
Arguments should be switched.
Did you consider assigning the cache field to a local variable and return it instead?  Cache result = cache; // Do double checked locking return result;  According to [1], perf gain can be 25%, wonder if this still holds for modern JVMs [1] Effective Java 2nd Edition Page 284
If we expect an exception here (i.e. i see it's meant to be ignored) should the test fail() if the request succeeds?
maybe we can also log this as INFO for debugging purposes?
My personal preference is to use brackets even for one line loops and condition. Not a blocker to merging.
Why this change ?
It seems like we shouldn't need to override this, since it should work the same for all columns.
suggestion assertThat(filter.beforeRequestMessage).contains("/hotel");  This is analogous to the aforementioned .startsWith() change. Please apply to all affected methods.
I think we should add filtering for returned resources for VOADMIN and VOOBSERVER role. They don't have to get resources of other VOs, just because they have same service assigned. It doesn't have to be part of this pull-request thought. You can create new pull-request with this specific change.
According to encodeColumns(), it seems we need additional Integer.SIZE bytes for encoding List<Pair<Integer, Double>>.
Not 100% sure if we want to swallow Errors - should this just be Exception?
This change breaks null-safety. null.isPresent() will crash and burn.
How about inlining it?  if (!contains(o)) return false;
How about declaring this 1048576 as MAX_AGGREGATE_SIZE or something and then use that here.
I guess we can simply make it either java RegisteredProject project = projectConfigRegistry.get(wsPath).orElseThrow(() -> new NotFoundException("Can't find project"));  or java RegisteredProject project = projectConfigRegistry.getOrNull(wsPath); if (project == null) { throw new NotFoundException("Can't find project"); }
This code also does not respect devices in single-SIM mode (i.e. phoneCount == 1) where there are both pSIM and eSIM slots, but only one can be active at a time. This case still needs to be accounted for using the old logic.
This is hacky and might be error-prone. Since it is always a leaf node, it makes more sense to parse the string with path splitter "/" and return the last section.
lol well, I suppose a location of 0N 0E is a good first-approximation (or rather 0th-approximation) of your actual location!
so do not resolve groups and no recursive as you going to search it anyway.
I think that may have been an oversight in longSum. Try a query that results in +Infinity at the historical level and you will see why it is needed to deserialize at the broker level
shouldn't need the throws declaration?
I don't think these checks are required - the NullPointerException will be thrown down the chain anyway?
it also need to be checked that token not expired at the beginning and expired only when expected time passed.
Does this line have any effect? Can it be removed?
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
null == manager
Returning ISelectionListener from this method blocks the possibility to add predicates in a "chain" like  addPredicate(p1).addPredicate(p2)  What was the reason for this change?
Is this closing bracket in the right place?
extra ;?
Not sure where that 37 comes from. I suppose it's because it's the first prime number above 31. Just multiplying by 100 would have made the trick here, not sure it's worth trying this hard.
might be more logical to swap the order of the two lines above (install java, download tarball, unpack tarball)
does this method need to be public?
In this case I don't think it matters, but I think in general as we write new tests with operations we shouldn't use the constants. It's mainly a regression check to ensure the operation names don't change in the constant value.... ...though I should probably bring this up on wildfly-dev and not this PR :)
Using "/" directly is not portable. Java has a system method to get the directory/path separator character.
Save the null check: !"".equals(model.getEntity())
final ?
is there a race condition? since runParagraph is a loop, what if we abort para 1 but there threadpool thread runs para 2?
I think you should pass the numCompletedIterations to the last parameter of LOG.log().
This should probably be done using a progress dialog instead of showing the entire activity as loading. You can do that by extending ProgressDialogTask in the FollowUserTask class
checking for nullable parent was added specially, cause going into project node simply has no meaning
Can path become null? Better to switch to avoid NPE
there is a getInt variant
public static otherwise sonar will complain.
We have a removeConfiguration so let's not allow null value here?
isTraceEnabled is not necessary here ?
Shouldn't you be doing in this DAO in the query?
I will be nice to have more meaningful error message. E.g. "Text condition must not be empty string." or smth else which explain the problem with comparing actual text and the empty string.
nit: missing newline
To make this more bulletproof, can we use the variant of waitFor() that takes no arguments? The Jenkins test harness puts a timeout on each test, so if the code under test has failed, the test would eventually time out. In contrast, this approach has an implicit assumption that the CI system will be running at a particular speed, and I'm not sure that we can rely on the Jenkins project's CI system to have any particular performance guarantees.
do you really mean "master cluster"
I would prefer to use String.valueOf(value)
Unnecessary (and incompatible); revert.
List instead of ArrayList maybe?
this is not needed right? when we get here, it can only mean we were unable to read the file. Does this also cover file not exists scenario?
any specific reason we have a separate function for this? I would suggest creating a generic function that takes in the column number as a parameter, then both these functions can call that one with the appropriate column number
no need for this change now
do we care to check the length to be positive here?
going to assume a potential illegal argument exception here, too, if adSpaceName=""
now you have even two negative conditions. Please swap the if contents
I see some improvement can be done here.Is it required to define method as synchronised.Can we use ReentrantReadWriteLock and get write lock here? It will be resulted in performance improvement
Maybe good to add a limit to the total number of events that can be queued (suppose the send takes a while because of network issues and lots of events queue up in the meantime, leading to high memory usage)
nit: Add a message in case it ever fails (e.g.: including left and right actual lifespans)
checking for nullable parent was added specially, cause going into project node simply has no meaning
tabs
Findbugs reports this, as you ignore the result of read(). Please add it to findbugsExcludeFile.xml to ignore it (or you can use return value to check if the read was successful here, not necessary though).
please condense the logging to one line and only one debug or trace level. like  logger.trace("address: {}, name: {}, canonicalName: {}", hostAddress.getHostAddress(), hostAddress.getHostName(), hostAddress.getCanonicalHostName());.
I think it would be nicer if we removed the intermediate OptimizeTableAnalyzedStatement and instead directly build the request classes. WDYT?
Can we please mock the Future?
Should we really use it by default? I agree this would be nice (and we surely will do it as of BV 1.2) but for now the spec [describes](<LINK_0> "arg0", "arg1" etc. as the default names. I feel we should stick to this for now.
@theJenix look at this
I think this will cause a memory leak as you're going to be holding onto an indefinite chain of references, so the GC can never garbage collect the request metrics objects. It would be better to create a new request metrics payload that is a copy of the current
can you rename the static loggers , remove "m_"?
When would the offsets be unsorted? Is this more of a precaution or is it common? Is it again the small file optimization?
why this action has to be sync?
Setting the style isn't needed for this component as this is the default already.
Why an event ID is built around project UUID?
I think you want logical AND, so double ampersands. Can we use !license.isEmpty && !licenseShortName.isEmpty && !licenseUrl.isEmpty() instead?
use return ... ? ... : ...?
set it to the appOptions by default. If it's still null, set it to a new instance.
Exception#printStackTrace goes to stderr by default.
Feels like skipRead should always be true here, but it looks like it's not really used.
how about making the if-tree in here smaller by checking for value instanceof Number (instead of all the individual number types) and delegate to the numberValue method (which should be moved to this _"BOXED FACTORY METHODS"_ section by the way)?
Can you also rename the other instance methods named compile? The only usages are in CompilationTestHelper and ErrorProneTestCompiler.
These checks should happen within the build function when delegated to the object they are building, not a builder's set function. Don't duplicate the logic.
Can you make these 5 seconds a constant like the other timeouts?
null check?
If storeThread == null concurrent tryCommit() or deregisterVersionUsage() may change its value between get() and set(), they are not synchronized like this commit() method. It looks like compareAndSet() should be used here too instead of set() or something else should be changed.
Instead of warning here, I'd prefer this method to return true/false to say whether it was removed. If it wasn't then the caller can do the logging. The log message does not relate to what this method is doing. The call in ControlledDynamicWebAppClusterImpl presumably doesn't need to do this logging as we'll get exactly the same check when that calls getCluster().undeploy(target).
As a reply to your TODO in line #126- Seems that your code ("moveMacsFromOldMacPoolToNewOne();") should be moved to line 92. And should be in the same transaction with "getStoragePoolDao().updatePartial(getStoragePool());". Line 91 includes the update of the dc mac pool. So in case of a failure (crashing of the engine for example) after the mac pool update and before moving the macs to the new pool, the dc will be in inconsistent state and needs to be reverted.
This looks like the update method is always calling code to create a new address. I feel like it should call the saveAddress method you have in the developer dao?
This is pretty inefficient, the way you would normally do this in JGit is: while (baseUrl.charAt(baseUrl.length() - 1) == '/') baseUrl = baseUrl.substring(0, baseUrl.length() - 1);
You should instead be asserting that UserService.getUserActivationKey returns the same user and not this dao call
Make these Locatable.
Remove the public modifier.
final
This evaluates different value that it stays isLeftTurn will return true, in case it is slight left turn
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
should that be <= 19?
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
Should also have tests for strong with preceding character content, and following character content. (those are areas where we've had troubles before)
How about putting the condition in the 3rd param to avoid duplication?
Is this line removed by mistake?
These methods should have an @NonNull annotation for the return. public @NonNull Builder setDomain(@Domain int domain) {
@hmcl I think issue pointed out here is the loop that we have to go through all the types for every request? . Is this only for queryparams? or are we trying to find type in other cases too? . If its query params wouldn't it be safe to assume the values could either be string or int
should this be StringUtils.empty?
We can extract urlByDownloadId.getValue() as a fileUrl and also reuse it in the new DownloadFile
Should this get a trailing newline too?
StringUtils.isEmpty(namespace) will take care of both (not important, just FYI)
s/resetMethod/restMethod
PMD/Sonarqube: Avoid concatenating characters as strings in StringBuffer.append
why? just don't set _vds, and if _vds is null then do not enforce. I think we talked about this. Always use the engine interfaces.
@Override would be better on a separate line.
temp dirs all over the place
rename to p, prop, currProperty
Couple of things here: (a) we can use Preconditions.checkArgument/checkState - less verbose (b) When throwing exceptions, I think it's good practice to include useful information. What dimension? What's the shape of the array? Without that, I need a debugger to get that information, which adds a lot of time required to fix it...
UUID.fromString can throw IllegalArgumentException. There's no reason that we should be attempting to convert the correlation id from the server since there's no reason that it has to be a string. That's not a bug that you introduced, but removing the catch all exceptions clause will allow a new, potentially app crashing failure mode that didn't exist before. Your change is correct. But now we should deal with the failure mode that shouldn't have been there in the first place.
Missing checkCallable()
a bit of NPE's will happen inside of combine on the first exception
what it calls on partition seems questionable
Should be Reflections.getAllInterfaces(Class) to get interfaces on superclass and so forth. Returns a List<Class<?>> instead of an array, but should be OK.
why final variable? :-)
folder.listFiles() will return empty array if no files in the directory. We do not need to do a null check here since testFolderPath must be path to a directory
If these database names are static then this makes it hard to do parallel test runs against the same account/server. In sync-android we generally append the current epoch time to database names to make them unique. This is probably outside the scope of the PR but it might be worth separately auditing test code for this.
Money is a reference type and needs to use .equals() instead of ==. Also we need to make sure calculateCost is called first. suggestion return part instanceof CombatInformationCenter && getStickerPrice().equals(part.getStickerPrice());
I think we should just return the options and not set them on the attribute.
Should we make this intermediate commit point *configurable*? I'm hoping committing every 10,000 is a sane default, but just wondering out loud if it's worth making this a configuration setting.
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
Style-nit: We avoid { on if/for/while/etc. when there is only one statement in the body.
Needs to be in an else-clause, otherwise you'll count twice (newChild() and worked()) and thus reach 100% before the last path.
I think general convention has been TODO(b/146423022) instead of Bug: 146423022. It may be better to change all occurrences to TODO(b/<bugid>) format.
Can we use empty map instead ?
Collections.addAll(this.features, features) can be used instead of for loop
suggestion logger.warn("Cannot add provider '{}' because it already exists.", provider.getClass().getSimpleName());
@llorllale I don't like the fact that we cherrypick attributes from the XML and create a JsonObject only with them. I think this method should have one line: java return new JsonNode(xml).json( this.storage.xml().nodes( String.format( "//repo[@coords='%s']/hooks/hook[id='%s']", this.coords, this.num ) ).get(0) );  So, simply parse the XML content into JSON and let MkHooks.create(...) worry about creating the Hook with the right attributes/contents. Could you do this? What do you think?
Use Flux.just
add a final enableCpResolving field to the class instead
if rowsize is always positive the check for -1 is not necessary
If I understand this "fix" properly, we were basically creating a new appender for each test, which you're now auto-closing. Plus, you're creating a new logger for each test. Would it be possible to just have LogFixture take in a level, and auto-generate the logger name, so it does not need to be passed in, even if just to avoid copy-paste errors?
Is this method empty now?
Shouldn't this be: FailureItem.of(FailureReason.PARSING, "CSV file does not contain '{}' header: {}", TYPE_FIELD, charSource));
deadlocked_monitor would be more typical. I'd suggest expanding the help a bit too so users will get idea of the difference between these two metrics.
Personally, I would make this a static constants because all caps usually implies that by convention.
Instead of collecting transaction edit logs here, we can add the count header in AbstractTransactionLog.sync() method before calling append, right? Since the edit logs are already being collected over there, we will then avoid code duplication.
finish() is called in case of an exception but the callback.close() is also included in the finally clauses of the top level methods. This leads to closing a callback() twice which is probably not intended.
Consider using getClass().getSimpleName() instead of this
I wonder how null actually gets in here. IMHO we should fix the root cause of it first. Still, it's valid to make it fail-safe here.
Do we really want this protected?
'null' must be first operande
When concatenating the log message it would better to pass every parameter into the Objects.... rather than concatenating the string which is inefficient.
ImmutableSet.<DruidServerMetadata>of()?
Please remove " to access OpenHab"
ditto constructor
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
OPTIONS could be more suitable here, since we don't want to transport the whole value
This is comparing for equality values of two different enum types, which should never be equal. Did you intend to use org.ovirt.engine.core.common.businessentities.storage.StorageType.GLUSTERFS?
I'd personally find this easier to read without the negative, i.e. code < 4000 || code >= 4100, but it's not a big deal.
spurious change?
I would just use ASC and DESC like the standard hive syntax
again IBM-specific i would go with "IBM specific"
getCells() can never be null
I know this is just test class, but this is what Optinal.empty() is for - avoiding necessity to sometimes use null ;-)
You called setMustExist(true) twice here. At least one of those is unnecessary.
do we care to check the length to be positive here?
what happens if default sub Account is invalid?
I don't think this is what we want to do. If a user enters 27M, then they would expect to see it as 27M, if they enter 2Y3M they should see 2Y3M. That is not to say that we shouldn't normalise the periods, but the name should reflect what the user has entered. I checked with @anujgup and this was his view too.
It is not visible for testing actually : it is visible so the value can be set by instantiators of the Check class (ie the platform) and so should be public and without the annotation.
This can be simplified suggestion if (BlockStorage.hasBlockInfo(block)) { event.setCancelled(true);
should have nonnull annotations: public @NonNull View getView(int position, View convertView, @NonNull ViewGroup parent) {
1. Did you mean support only Firefox for _testing_ right? I assume the difference in behavior affects testing only? In that case we should keep the production code clean and apply any workaround in the test code. e.g. do an if-else based on WebDriver. 2. Yes, I think at some point we stopped using Chrome for testing. There are many other quirks between the two versions that gets in the way of comparing html. We can check if anyone is using Chrome.
finish() is called in case of an exception but the callback.close() is also included in the finally clauses of the top level methods. This leads to closing a callback() twice which is probably not intended.
I think it would be more readeable if you would return here DbUser instead of setting the private user attribute, in method which has "get" prefix. Could be confusing. Then pass the DBUser to userDbIsSet method.
We have different conventions. Please see the spaces around brackets and method parameters, and brackets on new lines. The checkstyle plugin would crash the build. Did you try to run "mvn install -P run-its"? It would take quite long time to complete the build, cca one hour.
please move the setUser and setHost to connect (if _vds != null)
Qualify this.uri
Wouldn't !( value.getValue() instanceof DeclaredType ) || ... be a better test?
Name is no longer used
Replacing the 2 loops by  java result.putAll(getSuite().getParameters()); result.putAll(m_parameters);  seems a better approach for me.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Is it sufficient not to compare getId() because TrackInfo#equals already considers mId? (ditto for others)
@slubwama why not use visit.date_started < CURR_DATE() so that you get all unopened dates
If this is null, can't we keep it null? That way you can disable the folder watching if you're not interested in it. The startMonitor method below also checks for the return value of this method being null. I guess null would then also be the default.
I'm wondering whether this is a bit too coarse-grained. With this change, even if somewhere deep within a generic type there is an uninferred type argument, only the primary annotations are checked. Let's take a type @A M<@B C, @D ?> where the second type argument is uninferred. With this change, only @A is checked. Wouldn't it be better if also @B is checked? The first type argument isn't affected by the failure to infer the second argument. What happens if you remove lines 157--159 and 164--174 from the patch? Methods like isContainedBy already check for uninferred type arguments, so maybe only the check in isSubtype was missing? Then you wouldn't even need the new containsUninferredTypeArguments method.
%n
String log = "..."; assertLastMessageIs(log)? for me, assertLastMessage(...) isn't clear what the assertion is doing (without looking at the method). - edit... assertLastMessageEquals(String...) I guess "equals" is more familiar than "is"!
Minor: Or code conventions typically favor this style:  try { ... } catch (Throwable t) { ... }
sessionsWithTimeout is a Map within ZKdb, so adding sessions to it is equivalent to persisting them. I think you could also remove the addGlobalSession() method completely, because it doesn't do anything special than forwarding the call to addSession().
remove assert fail since expected Exception is used
close the streams in finally block
I'm updating this PR since I would like to merge it before tagging the next release. Thanks for the fix btw!
removed
I'd suggest to also check if the file exists in the file system before adding it here.
You can remove the one line above and rely on the below one.
Should these return a completed state to prevent NPEs?
@sbrannen This would probably warrant another issue, but I think that line and column may need precondition guards to ensure they are positive (> 0) numbers, as it personally makes little sense to me for line and column numbers in source files to be anything less than 1.
I'd prefer having each group in a single line, e.g.: "Id: %s Name: \"%s\" Active: %s Members: ..."
This should work the other way around, POM settings should take precedence over settings.xml
Probably, there is something wrong with idenations.
@prondzyn you can return numberth element of the collection
Note: this is not a very robust way to code it, since the JSON string you create depends on the name we use for a constant in Java. I do this too, but only in places where the string does not matter (so I just need a readable representation for the enum constant). In your case, the string is already defined by the JSON format, so one should better not rely on the Java name.
Lets pull library.get(i) and newMessage.getLibrary.get(i) into a variable at the top of the loop.
this variable name is misleading, it contains not only the commandData but also Ne field (see also other ApduTest classes)
you could use IOUtils.closeXXX methods instead. This should clean up the code a bit
this method (clue of your PR) always returns null. Write tests, check if they fail, and then implement a new feature.
Final.
No need for return here
This entire method is redundant. What you should do is implement updarteAllInBatch(Collection<T>) in MassOperationGenericDAO in a similar fashion to updateAll(Collection<T>) and then call it from there. There's no point in having this type of method in all the DAOs.
We should have fs.close() in a finally block. Without that, it's possible for the file.close() method to fail and we'd leave open the FileSystem we created for this stream, resulting in a memory leak. It will be a bit tricky, because we have to properly handle the potential exception in the finally block (which overrides any exception in the try block), since we want to always return the _first_ exception for either file.close() or fs.close().
you can either remove else or add pair of curly brackets
consider writing this (and similar peers) single line tests: assertEquals(Integer.MAX_VALUE, makeReader("077F7F7FFF").readVarInt());
you can rename the binding classes perhaps ?
this imply hostedEngineVm may be null. shouldn't other flows consider the same ?
It's better to use != RELEASE_PROD, so that the feature will appear in Beta and Alpha.
If you'll eliminate the lock, accept method will contain just "this.value = value;" statement
Actually, this could be way more expensive than copying the map twice. For each map entry, we could write the map as many times as the value of the entry. And the logs in notifyAcquiredResource could be misleading. It would look like the job acquired some new resources when calling on the already acquired resources.
Pull this uri logic out into a separate method and then call it from these methods
off topic: I've been writing this as "client == null". I think this conveys just as much information in fewer characters, so by Shipley's law I should switch over. The drawback is that "client == null" is a boolean expression, and is consistent with "limit < 0" etc. . .
Hello @mcimbora I believe the changes and the approach is good, but the invocation to the ValidatonService and this logic here should go in the Presenter
should we assert that this value will never be positive ?
Test for last four digits as well?
This was wrong before. Can you change to:  if (!childExpr.evaluate(tuple, ptr)) { return false; } if (ptr.getLength() == 0) { return true; }
These checks should happen within the build function when delegated to the object they are building, not a builder's set function. Don't duplicate the logic.
and same here: you need to pass result._source instead of just result
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
Please keep the getter and setter closer.
you are passing 'true' to 'exitStatus' in case of FAILED as well.
Would it make sense to flip the statement here ?
not clearing the session?
One can also treat the stages as a queue, and pop as you go. That'll eliminate some memory usage and the counter, and totally prevent multiple uses.
better unify the different states to be logged here in order to ease debugging. Something linke "Tried to get item as {}"
Wondering why this one has 6 more zeros?
I feel like the previous code was better, since we still create a new map for our own internal data structure. What does the new code fix? We could change this code a little bit to be something like:  if (parameters != null) { glueParameters.putAll(parameters); }
If possible, move this to a common controller.
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
Shouldn't need this check. FetchHints.EDGE_REFS should only be applied to vertices. And won't in, out, and label be in the search result anyway.
try to exploit map and co for this method
Again, we probably don't need this much sample data - if it works with one & two fields, chances are it's going to work with 3+.
Please restore the original formatting.
LOGGER.error(e.getMessage(), e);
Please add the permission needed => "Requires 'Administer' permission on the specified project"
Non-refactoring change
use return ... ? ... : ...?
See above in PublishExecutor and SubscribeExecutor
I feel the variable names are a bit confusing. I'd like to rename them: numWorkersToSync -> numWorkers (or numExistingWorkers/numRunningWorkers) numWorkersToRelease -> numWorkersPrev (may differ according to the previous one) How does it sound?
I think this means we're still using featureManager instead of installUtility - is that right? Which would mean we don't automatically get dependencies as only installUtility does that
(Nit) Using intermediary variables for readability (not sure if long is the correct data type): suggestion long minutes = TimeUnit.MILLISECONDS.toMinutes(millis); long totalSeconds = TimeUnit.MILLISECONDS.toSeconds(millis); long seconds = totalSeconds - TimeUnit.MINUTES.toSeconds(minutes); return String.format("%d min, %d sec", minutes, seconds); }
Interesting, so this one is unlike the edit page eh? I'd align them (at this point, whatever way you prefer).
nit: if (p != null)
We need to consider arrayOffset()
Why is only a remote unlock acceptable? I know right now we don't actually need local unlock commands because we only use them for remote tx cleanup, but would it complicate things to allow them anyway?
This is a pretty drastic change in the logic here and I'm not sure this is what we want to do. So before your change, this would first check if locationGP has text and if it does, try to load that location. Then if locationGP didn't have text or the the location specified by locationGP couldn't be found, it would try to get the default location by calling the private getDefaultLocation() function. If none of those methods returned a location, it would try to get Location 1 (whatever that is) and return it. With this change, this will check if locationGP has text and if it does, it attempts to return that location. If locationGP does not have text (the check on location == null is actually redundant because at this point, we know location is always null), it will call the private getDefaultLocation() function. The function will then return the result of either getLocation(locationGP) (if locationGP has text) or the result of getDefaultLocation(null, locationGP) (if locationGP does not have text. In other words, I could simplify the logic in your change to something like this: java return StringUtils.hasText(locationGP) ? Context.getLocationService().getLocation(locationGP) : getDefaultLocation(null, "");  I don't think there's much to gain from trying to simplify this method much more than it already is... At a certain point, methods get too "simple" and the logic becomes hard to follow.
please remove else, code will be more readable
More extra whitespace. Mea culpa.
We should not be applying rules in this method. Instead, we should return a Statement which applies the rules, so the rules are applied when the final statement is evaluated. That's why RunRules is a Statement.
should it be internationalized like others buttons?
Let's checkNonNull() the params of the builder, which must not be null.
Is there an equivalent regular expression on the desktop client that this is copying?
Can we also return what schema version doesn't exist in http response? This information will be useful for clients.
Why is this necessary? Couldn't we write the test w/o it and then directly fail if shutDownCluster is being called?
Nested try here too.
It is not so important but still defaultAttributeAnd -> defaultAttributesAnd
I don't think we do a very good job with this, but I think AppLog.v might be more appropriate here since it's probably too valuable during debug. I also find it interesting that you chose AppLog.w over AppLog.e while handling the error, I think it [has the lowest priority overall](<LINK_0>
Shouldn't the FBOs be disposed here as well, when they are created here?
Can you replace IDs with names in this log message?
I think the logic should be more like:  if (context.isRoot()) { fetch root object } else { if (field is attribute) { fetch attribute } else { fetch relationship } }
Broken alignment.
Assertion could be moved to testSendAndReceiveNeverFastt test method and we could have a 2 tests one which test with tempQueue = false and one with tempQueue = true.
Unneeded parenthesis. You probably can one-line this method anyway :)
Following Postel's Law I think we should not throw an exception here but just ignore attributes that we don't understand.
Aren't you just supposed to remove the deprecated annotation and not change the method code? Because it was already delegating to the the DefaultComparator anyways, i think this deprecation was invalid
Should this test include deleted survey versions so we can verify that the includeDeleted flag actually works?
_because the ~the~ source_
suggestion
How do you know which part of code tries to add a cube there?
Since the CameraX instance is being replaced by init(). Do we have any reason to allow resetting this to false? We should probably check that it is set to "true" before trying to deinit() or we might run into a NullPointerException.
do we care to check the length to be positive here?
What about extracting this block of code into a private method? Ideally, public methods should be like pseudocode (no conditionals, fors, etc.).
I believe the Streaming API would be much nicer here: java categories.stream() .flatMap(category -> category.getShortcuts().stream()) .forEach(shortcut -> { ... });
Add the original ClassNotFoundException as cause.
Would be a good spot for warn log entry, since the old value of this.address would remain unchanged on exception.
For consistency across the project, please remove the final keyword from this local variable.
Missing checkCallable()
Is this the "recommended" way of checking the blob type?
Could write this as  final List<Integer> list = Arrays.asList(1, 2, 3);
No exclamation marks
It would be more Java-idiomatic to not modify the input variables (they're actually often declared final)
Please remove as this is related to the fix required in #6610
assertThat(statistics).hasOnlyKeys("key");
![MINOR](<LINK_2> 'Severity: MINOR') Missing curly brace. [![rule](<LINK_1>](<LINK_0> ![MINOR](<LINK_2> 'Severity: MINOR') At most one statement is allowed per line, but 2 statements were found on this line. [![rule](<LINK_1>](<LINK_3>
Add a severe logging message here describing the issue to server owners (and maybe tell them they will need to downgrade for now).
It seems like we should use the wrapper returned by getPathWrapper() as the default for both the bam and its index, instead of just the bam?
space after cast parens
How about making this a constant at the beginning of TestUtils ?
This is going to log the reactive stream Subscription
final
Multiple getIndicatedServerNames() maybe clearer, if get once and stored in a local variable.
Can you explain the why we have chosen to use synchronization here? Should we only allow single thread to execute the close method on dataStore? Should we use isClosed similar state variable as we did for init(). If there s a possibility of getting this method cleanup() by multiple threads, anyway these threads will execute this method sequentially. Since in dataStores, we have handled the close method, even at multiple calls to close() will just try to close the already closed dataStore, it will just log and handle the error over there. Is there any cases that we need to propagate DBException exception to higher layer? Since we dont propagate or throw exceptions at dataStore.close().
You can use params.contains("sponsor") to check if the parameter is available. Using that, you don't have to deal with the exception anymore.
I feel it is better to move these logs inside recogniser.initialize() method
<= -> <
Can you mark this @Nullable please?
Again, "owningCommunity" isn't a concept in DSpace. These variables (in this method) and this error should be renamed to say something like "parentCommunity" instead.
Same here, this line is too long
I'd suggest we (a) tell the user exactly what we didn't find and (b) don't speculate too much on possible causes. e.g.  throw new ContainerIsTaintedException("Container ID " + container.getId() + " has no " + DockerContainerLabelKeys.REMOVE_VOLUMES + " label.");
Would file.getName().endsWith(".java") work OK? And I guess if the case is a concern, maybe file.getName().toLowercase().endsWith(.java).
default: // do not change priority and category
does it mean we should remove one of them ?
I presume this part was a straight port of the old one.. I forget the precedence of ipv4 vs ipv6
nit: spaces around + I'd also change / to use OS-specific path separator, i.e. [File.separator](<LINK_0>
change the message - "Not all bricks are available for this volume"
ERROR->NOT_FOUND
This line and the next 5 lines could be replaced with return timeCompare;
could we do kerSerde.toByteBuffer(key, tableBuffer, offset + Ints.size, keySize) by having a method inside keySerde like boolean toByteBuffer(key, ByteBuffer, offset, size) that would avoid the copy done here.
Should we better make this method package protected to only allow jackson access to it?
And then else if this
it feels like read and write access to this.readPos, this.markPos, and others should be protected
Although we need to figure out how to propagate interruptions, this will now cause a problem as it this method is called from within tryUpdate which is recursive and propagating here means the next attempts will also fail for the same reasons. We need to figure out how to retain the fact that we were interrupted and propagate the interruptions outside the whole thing.
Why set a reference copy to null?
Use {}? logger.warn("Blob metadata record not found: {}", blobId.getID());
Why is the if necessary?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
We're running this code based on whether ACTIVE_TASKS_ROOT exists in ZK, but we're never actually reading from that path during this migration. Just double-checking, is that intended?
This check (and the one above) are going to break DEX preverification. Can you instead move these to a util class, similar to this:  ... if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { OreoUtils.setColorSpace(options, colorSpace); } ... } .... import com.facebook.annotations.DoNotOptimize; @DoNotOptimize private static class OreoUtils { void setColorSpace(...) { options.inPreferredColorSpace = ... } } }
Is not this a global change? Any test must be written in such way that it does not affect other tests.
I think the annotations should be on separate lines
Can you explain what your doing here? What do the following variable do: comparison, b, and one?
While digging further into this sorting, I found out that java.io.File implements Comparable and would sort Files correctly depending on the operating system. So, we could even just say Collections.sort(files);. However, we can also change the method scanDirectory below instead to do the sorting already: java File[] candidates = dir.listFiles(filter); if (candidates == null) { return; } Arrays.sort(candidates); ...  Using File instead of String here has the advantage, that we don't need to create new File instances on our own.
Put ITEM in front of OTHER_FUNCTION .
Seems to be a hard coded string here in the title
let's remove this
Simply use snapshots instead of 'dsnapshots'.
Looks ugly and potentially a source of future NPEs.
I know this has been here before but this can easily exploited by holding normal shears or even a multi tool in your off hand and then using a normal Wind staff. It would probably be better to check if a wind staff is held in any of the two hands, you can use isItem(...) for this.
Not necessary
Maybe good to add a limit to the total number of events that can be queued (suppose the send takes a while because of network issues and lots of events queue up in the meantime, leading to high memory usage)
"Only after paragraph run we should see the new output ~" -> "Only after running the paragraph, we can see the new output ~"
And then else if this
Lets remove final for now
%n should be used.
This can be better written as  LocalDate tradeDate = trade.getTradeInfo().getTradeDate() .orElseThrow(() -> new IllegalArgumentException("Trade date should be populated"));
just return _props.get(key); in this method
False means Acl passed is already existing, in this case we return false. So message ACL not set is meaningful here or do we need to reword this?
Like, super.onFailedToRecycleView, this doesn't seem to do anything. Why call one super and not the other? Ditto for below?
Consider writing as regular while loop for readability
You shouldn't need to call printStackTrace, the log.error should print the stack trace
Why change to this?
java8-isation [forEach][map|flatmap]
Remove.
Can you replace this with STREAM_ID.addAndGet(this, 2)
Wrong mapping, only the mapping of line 83 should be kept.
Hmm, maybe we can move this check into the KafkaConsumer's catch block before close also.
If this is null, can't we keep it null? That way you can disable the folder watching if you're not interested in it. The startMonitor method below also checks for the return value of this method being null. I guess null would then also be the default.
Where does the 5 come from? I feel like we should just throw an exception here.
nit: if (p != null)
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Why U don't want to consider id in equals and hashCode ?
What happens if we are unable to load the inputStream.. Do the messages still show? Should we be rethrowing this IOException? @JonathanGiles ?
typo
I think we should address CBO factors holistically instead of having very specialized session properties. What do you say if we create a dedicated configuration with factors, e.g:  public class CboConfig { // cost weights private double cpuCostWeight = 75; private double memoryCostWeight = 10; private double networkCostWeight = 15; // filtering coefficients private double joinUnknownFilterCoefficient = 0.9 private double defaultUnknownFilterCoefficient = 0.9 ... more coefficients here ... // TODO: normalization factors (derived as in <LINK_0> private double joinCpuCostNormalizationFactor = ... private double joinMemoryCostNormalizationFactor = ... private double aggregationCpuCostNormalizationFactor = ... private double aggregationMemoryCostNormalizationFactor = ... ... }  What do you think?
be backwards compatible
let's add a valid :abc parameter in here too, not only invalid bait
Put in try catch block and call InjectableBehaviourObjectStore.resetAddNotificationModifier in finally block.
Would be nice to expose to the command line the option to not concatenate all the merged interval names. In the use case which prompted this, a TON of sites (think whole genome gvcf with bp resolution) are often merged into a single interval, which then has an outrageously long concatenated name. These concatenated names often don't carry any useful information, and can make the resulting interval list extremely large.
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
Can we set a fault with some info on the command somehow? Also, no need for the time - the log itself should contain it
style nit: missing space after 'if'
In this snippet cast gives a compilation error:  void test1() { class A {}; class B extends A {}; class C<T extends A> {}; C<A> c = new C<A>(); C<B> cb = new C<B>(); c = (C<A>)cb; }  This one is correct:  void test2() { class A {}; class B extends A {}; class C<T extends A> {}; C<? extends A> c = new C<A>(); C<B> cb = new C<B>(); c = cb; }  Sometimes it is very annoying, for example, if I want to store and operate a List&lt;MyImpl> but have to return List&lt;MyInterface> (MyImpl implements MyInterface), I cannot return the list as is, it does not cast. Still, there is a sense in it. ConnectionWizardPage does not mind accepting any implementation of IConnection, but it should be unambiguously stated with <? extends IConnection> (or with a type parameter).
Given line 132, don't we know that metadata is a HashMap? Given that, why bother with this check?
Need to set one environment here?
nit: if (p != null)
@vmaletta 6000 can be a constant in all tests
this method (clue of your PR) always returns null. Write tests, check if they fail, and then implement a new feature.
Let's put requireNonNull around this.
lookup in the multimap here
same as others: log should have Exception as arg
The default toString on the List doesn't do the same thing?
Why didn't you add it to 'ExternalRegistrationConfigurationMapper' like the other mappers?
@Suseika hm.. looks like code duplication to me. how about this:  if (valid == null || !valid.password().equals(pwd)) { } else { }
these new methods should use getAttribute(tag.getBinaryTag()) when possible to avoid redundant conversions
not sure why we need this. Why not just call this from the OperationController?
shall we have try-with-resource?
This block was previously inside a loop. Now it is outside the loop. Doesn't that affect how this works?
Does this really needs to be fully qualified?
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
prefer to have // given // when // then sections
About 2/3 of the tests fail for me, including this one, with: java.lang.AssertionError: android.content.OperationApplicationException: wrong number of rows: 0 Do they pass for you?
Please use Optional.ofNullable()
Or consider getBlock2Status
assertEquals(excpected, actual)
What happens if a checkpoint fails? Wouldn't cancelAfterCheckpointId <= checkpointId be more safe?
Using the static method to start will be hard to unit test.
This check is redundant because you check this in handleSelection()
how do you handle "BEGIN" here?
You forgot to seek.
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
No need to do that here, just observe the result of calling add below and throw when false
Other getValueAt used parseTree.getColumnCount() should this be the same instead of 6?
Should we better make this method package protected to only allow jackson access to it?
Returning an empty string when an invalid position is passed could hide some bugs. What do you think about skipping this position check so an ArrayIndexOutOfBoundsException occurs if an invalid position is passed?
Map instead of concrete type
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
please use Cluster#hasGateway
Is this method used?
String constants should be in strings.xml.
These can not work , the value is the same
I think we need a docbook and/or schema doc update that "" means no serializer (and String is the default).
Request.State.OPEN
Put main at the end for consistency with the other code.
These checks should happen within the build function when delegated to the object they are building, not a builder's set function. Don't duplicate the logic.
File name should be initialized to the file to export
(ListView)  can be removed
Two-arg constructor
We normally prefer functional interface when the logic is simple. So this can be rewritten to: node.isDistinct().map(distinct -> distinct ? builder.append("DISTINCT ") : builder.append("ALL "));
This is not how it should be. This should be:  if (log.isDebugEnabled()) { log.logDebug( message ); }  Do not use "if (debug)" because this is hardcoded and will never be enabled. Do not use "setLogLevel()" because you're overriding the system administrator's configuration.
I don't like that this bulk is repeated. Wouldn't it be possible to extract a method for this?
Can use Ds3DocSpecEmptyImpl here. Also, is there any reason your creating 3 doc-specs instead of re-using one?
Nevermind, I see it is the Future.get() that throws the InterruptedException.
why not put image?
I would change this like to return Utils.copyAttributeToVirtual.......
We don't need to clean up data in our tests - we assume the data will be thrown out.
Are we concerned about this happening synchronously? Or is this in an area whose parent context is already asynchronous?
is there a reason we don't just use the groupKey as the cacheKey directly?
Can we add a check so this only applies to the version negotiation requests, and propagate the exception otherwise?
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
Writing this as if(!closed && lockLevel != 0) instead of the negated disjunction allows for easier recognition of exactly when this condition actually holds.
No. You look more like wanting to fail here. So just throw. No printStackTrace
please remove else, code will be more readable
Constants on the left.
Should be LOG and not Log (currently org.jline.utils.Log)
Let's rename "e" to "ignored" Please use fail() <LINK_0>
what is this text "TOO_MANY_BASES" good for ?
You can early return here
Braces
The call to httpMetricNameTokensHandlerTimerContext.stop() on line 78 won't get executed. Additionally, there are other, existing returns in the method that cause the same problem.
nit: Could use server.activeLocalPort()? <LINK_0>
Shouldn't this close the iterator before returning the list?
StringUtils.isBlank() ? Maybe it is an edge case, but the existing logic is not specific about what can be passed to this field (null, bogus blank strings, etc.). So being more protective would not hurt
Replacing the 2 loops by  java result.putAll(getSuite().getParameters()); result.putAll(m_parameters);  seems a better approach for me.
We don't need this if else if we set the lastMeasuredTimestamp in the constructor
I would throw instead of just logging it.
Two things here. First, I started a ConnectorUtils class to try to capture common patterns so we don't duplicate the same code across a bunch of connectors. This pattern where you just create the maximum # of tasks all with the same input config seems like it might be a common one for sink tasks that don't care about topic/partition mapping at all and don't need to split up anything else in a consistent way. It might be nice to just move this in there. Second, since these are all really the same config anyway, we might as well use the same object and just return it N times -- no need to create a bunch of copies. If the framework needs to modify anything, it should make sure it does it in a safe way that allows reusing the same object (if for no other reason than connector implementers are likely to make that mistake even if we disallowed it). In fact, this entire class might just be possible to define by providing a generic base class taking the right type parameters, e.g. something like  public class HdfsSinkConnector extends StandardSinkConnector<HdfsSinkConnectorConfig, HdfsSinkTask> {}  We'd need a better name for it, but again, if this is a really common pattern and we can remove all this boilerplate code, we should do that.
Can we refactor this block? It seems off throwing a trimmed exception inside a catch block of a trimmed exception.
This might throw exception
you also need to encode the sampling header here.
shouldn't it be getValidationMessages()
ha! this is a new construct for me. I thought that.id is a private field ...?
Can we do a safety check here?
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
I'd put notEmpty there
I don't know what has been @sjka intentions and I agree that this could be removed... ... but didn't we have a discussion in another topic where you / Kai argued that we cannot rely on correct usage WRT to the nullness annotations for code that is called by third party ones (e.g. binding developers etc.)? So, if we don't trust non ESH framework developers that he uses annotations classes correctly, isn't that exactly what you want?
ch is always >= 0 :-)
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
I don't think the variable updatedPatchSet if useful here. atomicUpdate returns what the update method of the AtomicUpdate class returns... which here is always null.
@excaliburnan I would not go for an ioexception here, maybe IlligalArgumentsException
Is this really a 400 or is it a 500?
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
We should set connection and socket timeouts here. By default there are no timeouts, so in case of network problems this may hang forever, which is pretty long. ;-)
I am proposing this. In the constructor of JSONMetricsContainer, parse all the JSONMetric and organize them to buckets/lists of metrics: - valid JSON Metrics - invalid JSON Metrics - delayed Metrics Your getValidMetrics() should simply fetch the list of valid metrics. Is that possible to do?
Add SubChild here as well, perhaps SubChild is just persisted as a Child currently..
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
ImmutableMap.of(
suggestion List<LayoutTemplate> templates = Arrays.asList(lt, lt2);  Just a suggestion to make it shorter :)
let's write to the log too as per <LINK_0>
could clear the state directly, there is no need to store them into a list.
should this be StringUtils.empty?
don't duplicate code
How about inlining it?  if (!contains(o)) return false;
I think you need to rewind the copyBuf reader's index, otherwise it might only print the part of the buffer that's unread.
I see some improvement can be done here.Is it required to define method as synchronised.Can we use ReentrantReadWriteLock and get write lock here? It will be resulted in performance improvement
Same thing: there should be a check for null value here
This seems to be a recurring pattern. Should we pull up into an abstract parent and then let subclasses merely handle serve(req,res,true/false)?
This is wrong.
This string needs updating.
I don't see why you introduced mutability here? Local variables would have worked just as well. If you really want that, please at least make the setters package-private.
Can you please add className to error message?
This is awkward as a singleton. Strongly prefer new .... In particular, it makes it possible to edit the singleton state without going through Network which makes the code harder to explore and reason about. Instead, expose a getter or, better yet, have Network offer the register methods directly and forward them internally.
Since you're already calling initMocks(this), you can annotate all your mock objects with @Mock and remove all these mock() calls.
Doesn't look like conditions are same.
![MAJOR](<LINK_0> 'Severity: MAJOR') Method has 7 parameters, which is greater than 6 authorized. [![rule](<LINK_1>](<LINK_2>
Same remark, SSLR token should not leak from PyToken api. IMO we should mark the token() method in PyToken as deprecated : this method is there for issue location but should not be used in checks to not leak SSLR API in checks.
Why do you wrap it with an ArrayList and not just return registry.refreshTool(... directly?
Do not use union() to merely set the min value. Use setMin() instead. suggestion BlockRegion region = new BlockRegion().setMin(mins.get(i)).setSize(size.get(i));
Shouldn't the collection be added as given and the existing items be "moved" to the new positions?
Initialize this map. With an empty map.
unused try catch block
1. The code that tracks memSize needs to not run when the resource profiling is not enabled. 2. You don't seem to handle mutation of the strings. What happens when the string is replaced?
rename to type
Is there a reason for not writing it like this: java WebSocketImpl websocketImpl = (WebSocketImpl) server.getConnections().get(0)
Don't do that in test code, change the throws clause of the test method itself.
We shouldn't completely re-implement fetch. Just have fetch() call fetch(null) and keep one implementation.
other methods like this put name first, then id. switch for consistency
Wouldn't it be easier to use Mockito here? Or is there a reason not to use it for this test?
There shouldn't be any changes in this file. Please revert.
Why add empty string?
1. Did you mean support only Firefox for _testing_ right? I assume the difference in behavior affects testing only? In that case we should keep the production code clean and apply any workaround in the test code. e.g. do an if-else based on WebDriver. 2. Yes, I think at some point we stopped using Chrome for testing. There are many other quirks between the two versions that gets in the way of comparing html. We can check if anyone is using Chrome.
I think you could use here a try-with-resources here to simplify the code a bit:  try (Partition root = SIDriver.driver().getTableFactory().getTable(table)) { return root != null ? root.subPartitions(true).size() : 1; } catch (Exception ioe) { throw StandardException.plainWrapException(ioe); }  If I'm not mistaken the catch block will also catch an exception on root.close()
This will prevent changing to null, which should be allowed
can you please explain why to put false? the absent of property is a good marker... what is it used to?
early return with NULL.
nit: you can merge both lines above as checkNotNull will return the given argument
@zcervink lines 60-64 were related to setting settings.xml in preferences, and now this code is useless, so please remove it.
<LINK_0> handled the case when metadata was null, does that check need to go here also?
This method can be implemented as return a - b;
assertThatStatisticsAreNonZero should include assertThatStatisticsArePresent (and then you don't need to call it explicitly)
this method should be explicit about the encoding that the resource will be decoded as. ( utf-8? ) or the system default? I worry about internationalization issues with this method. we should force utf-8 (unless for some reason we don't want to do that?)
Is this still needed?
intelliJ says loc is not used
For readability. Same for other checks suggestion Preconditions.checkState(arguments.contains(column), "The arguments of transform function '%s' should not contain the destination column '%s'", transformFunction, column);
checking for nullable parent was added specially, cause going into project node simply has no meaning
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
requireNonNull
Braces
I think we should probably move this if block inside the try-catch. I hate it that we have to catch array boundaries errors like this, we have done a sloppy job, but that's what we have right now.
change to package
We have two same if statements (!keepChildren)  I think we shouldn't introduce new if with the same condition.
functionEvaluator should not be null
If opening is true, doesn't it mean it's still opening but not done opening yet?
Looks like out will be closed a second time in the finally block.
Unchecked cast
Well, @jglick-style violates the recommended code style
please use asGuid() instead of Guid.createGuidFromString(), - it will format bad-request-400 if id is not convertible in to UUID.
I would inline them
Shouldn't this close the iterator before returning the list?
You're using translated() and casting the parameters to floats? Call translatef() instead, or use doubles instead of floats.
What exception could t.cancel(true) throw - is it just being cautious? No harm having the try-catch I guess.
left over from some test?
By the way, I would like to remove postfix of ET at the all apps, but let's handle it later in a separate minor PR.
If you removed Optional from shardDeltaMap, this check can be simplified as: java return createPageSource(shardUuid, Optional.ofNullable(shardDeltaMap.get(shardUuid)), deltaDeleteEnabled, bucketNumber, columns, predicate, attributes, transactionId, columnTypes);  Same for the below one.
Shouldn't this close the iterator before returning the list?
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
one more :-)
just return _props.get(key); in this method
Add CheckForNull.
The DateTime.now().plusDays(4).toLocalDate() seems like a "magic number" that isn't really clear where it comes from. It would be better to set a value to the expiration date inside the testBoletoExpirationDate method to explicit it or compare it to some constant
What is the benefit of this? Are we interested in how often exactly the slicer is called? For the client, yes, I can see the point of this (unexpected/unnecessary API calls could be expensive). But I don't see how/why we care about calls to the slicer?
Please do the List changes in a separate PR. This PR should contain only benchmark changes.
Shouldn't this close the iterator before returning the list?
I don't get this part. Why would an empty boolean query match all queries? What is your reasoning here? Given that you are adding _isEmpty_ could we not keep the exception. If anything I'd rather have it not match anything.
nit: you can merge both lines above as checkNotNull will return the given argument
^ I think this one needs to be unsigned
can you also append operationTimeMs ?
I think it's safe to remove these
add the following line to clean-up. SWTBotUtils.deleteProject(PROJECT_NAME, bot);
why Class.forName? why not just create a static final instance?
lambda?
This method does not utilize the rows cached conditions which get cached during SecurityRow.evaluate(). This will result in conditions getting create at least twice for non-mutable cases, but for mutable cases we will now create conditions every permission check. Could the mutable flag be encoded into the Decision.decision bit such that the row.eveluate could return the Decision along with if the decision is mutable? I think this would require you to create three more constants for the mutable instances of the following: static final Decision DECISION_ABSTAIN = new Decision(SecurityTable.ABSTAIN, null, null, null); static final Decision DECISION_GRANTED = new Decision(SecurityTable.GRANTED, null, null, null); static final Decision DECISION_DENIED = new Decision(SecurityTable.DENIED, null, null, null); But if you do encode the mutability into the Decision object then you would not need this method here or the looping above to determine if the row decision is mutable.
Missing a space between if and (
discussed a bit more, we're going to make both key-values, and make sure to split on just the first colon
map(Queue::getActualName)
Should close kill the memspace? What if someone want to reopen the key?
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
why 10? Is it important for test? Or would 2 be just fine? My point is: maybe, if we're not having so many nics, we can instantiate them nicely without for loop. Reconsider this everywhere in this class. If there's no actual need for 5 instances, use only such amount, which makes difference. if you need loop, please extract creation of existing interfaces into separate method. Also extract creation of nic with/without implementation details.
Possible deadlock: remove this call to sleep(). It's possible that no events will ever arrive.
Style-nit: Same as with setCommitter(name, email) overload.
You can return the actual type DTO type.
And here timeout is 65s? why?
Mappers can be stored in static final variables instead of rebuilding these each time.
This message is not valid for getReplicas, but maybe it's not worth changing, since it's a trace message
better will be uri.getHost() instead of uri.toString()
suggestion console.warn("Usage: \"changeShip module:shipName\"");
Little nit, but could do int len = 0 if(sdPipe != null && ((len = sdPipe.available()) > 0)) { byte[] buffer.... No need to call sdPipe.available twice in succession.
suggestion APIUtil.handleException("Unable to delete the label. It is attached to an API");
Isn't the replacement assigned anywhere?
Why is it public?
Let's use a constant for the string value on both places.
damn I forgot that possible NPE
We can't do this from the Parser. The attribute value can be property-placeholder or SpEL. Hence that validation or even just default CacheEventType.valueOf() from the setter is enough. If end-user provides a bad value we end up with the exception. Or even just rely on the Spring's ConversionService magic!
Would it be an overhead to calculate sizeInBytes() for every call?
now that we've moved the code to populate, there's no reason to get the VM reference. Can you change back to the way it was before?
Assuming that no filtering properties apply?
Magic number. Please run checkstyle/pmd/findbugs and fix all violations.
Please use Optional.ofNullable()
i haven't looked at all the edge cases, but can buffer.length - end ever be less than 0? if so, i suspect this could throw. is it worth wrapping it in a Math.max(0, ...)?
Bad code. Remove try - catch.
Minor nit ... since the if block returns, there is no need for an 'else' block, so it'd be better to do this:  if (root != null) { return root.type; } return type;  or, better yet:  return root != null ? root.type : type;
We have a removeConfiguration so let's not allow null value here?
It think it'd better to have singleton GSON instance in static field
There may be some possible responses such as a 403 that is not the expiry case. If that included a Set-Cookie this would miss it. I wonder if we should check for the header earlier and then not worry about response codes?
Isn't this one always true in case the other one is false?
Can we move this out to a class static variable?
Since each person's ID is different, the list can be optimized by returning true for hasStableIds(), ex:  @Override public boolean hasStableIds() { return true; }  Explanation [here](<LINK_0>
Is forEach better that putAll? I suppose we also need to take care of the case when params are null.  if (params == null) { namedParameters.clear(); } else { namedParameters.putAll(params); }
Could you extract this actions in separate method?
can we check the action from the intent here? it's common practice to:  if (intent.getAction() == ...) { }
These empty implementations can be removed I guess
These strings need to be externalized
Returning an empty string when an invalid position is passed could hide some bugs. What do you think about skipping this position check so an ArrayIndexOutOfBoundsException occurs if an invalid position is passed?
export the ID in different var
Should this be "Recieved info"? Or should it be deleted?
loadOfflineUserDisposable
Is the leading empty string necessary in the concatenation?
Use a concurrentHasMap, then you can remove the synchronized on the public methods.
Shouldn't we add this only in case of async actions? Maybe check if action.isAsync() == true, in addition to jobId != null check.
Consider using Uri.getLastPathSegment()-it seems to do what you want and is probably more efficient.
This doesn't set account to null in case the condition isn't met.
Can you keep the method order closer to the previous revision, so that the gerrit diffs can match them?
nitpick: why not just call .values() like you did in the for loop below?
Please create a utility method getWorkflowConfigurationParser that contains these 3 lines ^, and also use it in makeDefaultScheduler.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
This change just caught my eye as it seems mostly unrelated. What was the motivation here?
values().stream().anyMatch(value::equals) ?
This lambda can also be eliminated.
Should be a SamzaException with a message, not NPE.
Shouldn't this be wrapped in a try... finally block?
Can't we ensure that we always set a List in the context and just do a cast when we get it ?
Collections.emptyMap() could be used here
I think you should add proper custom error message in this case.
Probably don't want to leave this in as well as some other println's you have, although it's just a test, so not a huge deal.
Logically it looks correct, but it's not quite readable. Maybe we can rename shouldAcquireVF => passthroughHotUnplug and skip the second variable? Additionally if we extract a method out of the acquiring it will be visible that we acquire a VF only for passthroughHotPlug
Not very readable. Also, did you consider DictionaryBlock constructor that takes idsOffset instead of copying the array?
Here we're waiting for the experiment with name "Experiment".
This is unused, so why make it?
change controller to getController()
I'd rather do it this way:  if(type.equals(DATE)){ .. } else if (type.equals(TIMESTAMP)) { .. } else { throw exception }  Then you can remove checkState. This way is less prone to errors when adding more clauses and builds in error check logic.
No, this method should not throw interrupted exceptions.
This else seems like a problem (and maybe it was the reason for not doing this earlier). I think this makes it impossible to do:  java class Foo { @InjectView(1) View foo; } class Bar extends Foo { @InjectView(2) View bar; }  We can work around this by using composition rather than inheritance. The generated code keeps an instance of the superclass injector:  java class Bar$$ViewInjector implements Injector<Bar> { private final Injector<Foo> parent = new Injector<Foo>(); @Override public void inject(Foo foo, ...) { parent.inject(foo, ...); // ... } // same for reset... }
I guess if we get the filter before the for loop, it will still be valid? And so we avoid loading it per each thread.
Why is this not also ANY_ENTITY_TOKEN?
By defining a encode and decode function to the Format enum itself, this switch statement can be eliminated which improves performance. Also the error handling should be improved, like e.g. catching the not-found enum.valueOf exception and turn it into a user friendly "Format 'foo' not supported" exception.
final is useless here. Also, consider this.  java try { callback.onSuccess(sessionStore.read(AuthEndpoints.NAME).getAccessToken()); } catch (Exception e) { callback.onFailure(e); }
Can we set a charset? Like ASCII or UTF8?
Simpler proposal: registerResourceInCrossReferencer(sessionResource); It should be equivalent, but putting the adapter at the resource level instead of on one of its root elements (there can be several roots now) feels a little safer.
You certainly meant "java.io.tmpdir"
It is like a hack. Probably reset() would be a better choice.
I would inline expression here.
style nitpick Lists.newArrayList() is the preferred way of creating lists.
If you want to save a little code, you can use "ArgumentVerifier" in org.threadly.utils. It was designed to be a way to save jar space by reducing duplicated code.
I'd just go ahead and return false here. The logic you have here doesn't prevent trying to parse when the input value is null or empty. And when you have that fixed, go ahead and merge at will. :smiley:
remove finally {
We won't detect if newProperties contains a property that is not in oldProperties. Shouldn't we? Why don't we just do oldProperties.equals(newProperties)?
Let's rename locationModule to just module. Then we can bind SessionPropertyProvider inside the module. (The name is already bad, as it's no longer for location. I missed that when converting to Drift.)
Should this stream be closed?
Use FileUtils.listFiles here as well?
Rename to floppyStats
Arg may not always have a shape. We might have some place holder logic we want to put in here. At least checking for null shapes before you do this would be good.
Use parameterized logging instead of string concatenation.
just curious why here returns new JSONObject, however, in previous test, null is directly returned?
This appears to me to be a redundant check as it is already done in updateActionAvailability so the action would be disabled right
Never call Optional#get() without doing Optional#ifPresent() first.
I still don't think we can use a LinkedList here. If it is possible for multiple threads to call emit with the same key concurrently, then we need a concurrent structure or some kind of synchronization to guarantee consistency. 2 concurrent adds could for example lose an update.
Collections.emptySet() (or similar) would probably be nicer?
you don't need that line, verifyTitleUrl is already checking that. See point1
I would have supported any array but it's good enough with String[].
also use a map here (this is likely to be extended I guess)
Please verify that the correct inner exceptions are received. Example: <LINK_0>
set your feature as transient
why was this removed ?
I suggest using "ComparisonChain.start().compare(o1.name, o2.name).result()" - Location.name can be null.
Use startProgress and stopProgress to avoid displaying an empty dialog
Add an assertion to check the hardwre id.
this class should probably also init current in the constructor, then we can just do if (current == null) { throw new NoSuchElementException() } here
I this this(url,new HashSet<>()); would better. What do you say?
change to IAdaptable
please log in error
Can you get just the crn from the database?
why the braces removed?
Make static
Move the private method below the public instrument() methods?
more specifically, it's going to try and use writerFor(JavaType)....but that's just a nit
Similar to FeedbackMcqQuestionUiTest.java above, not sure why this method is used here
I don't see much point in making db lazily created. It's not an expensive operation.
In lines 41 and 42 you're using o.get("port").isString().stringValue(). Pay attention that method JSONObject#get not as simple as it may seem. I think it would be nice to move o.get("port").isString().stringValue() to the local variable. Also it would made these two lines much more simpler for reading. WDYT?
I think you need to add an import for the Installation model
how about inline the isPayloadValid field ?
If I understand this change right, these changes need to be _necessarily_ deployed to the server first and then the front ends? If that is the case, we need to make sure we remember this fact. It seems like we can _read_ both versions - but write only in the latest version.
this variable name is misleading, it contains not only the commandData but also Ne field (see also other ApduTest classes)
We don't have to find the editor since it is already provided by the event, and we can use HandlerUtil.getActiveEditor(event). For now we can just return 'true' from isEnabled, since it's only active when the text context is active. A new method should be added that checks whether it supports zooming. Currently this means we would have to have an AbstractTextEditor in our hands. We can still consider to add an ITextEditorExtension7 interface later.
I think file an issue for using intl for the header which can include formatting of the subject.
I'd propose you use an attribute pool instead of sId, as typically there would be one or 2 edges for a given ID, that _could_ overlap (at least we don't want to prevent that kind of logic). And there can be very many many edges. Because the state system scales well vertically now does not mean we have to have a tall one, we'll reach MAX_INT in no time!
declaration and assignation in one line. This is too c-ish
The url doesnt give a sense that the request is to get "metrics". May be something like this? /v2.0/:tenantId/metrics/shard/:shard
The other formats are actual formats (HTML or MD) whereas simple is just plain-text. Maybe instead of simple, it could be txt or text for plain-text?
I would say that it should return ColumnType.STRING since it's always going to be a String.
Shouldn't it be ACTIVITY_RESULT_IMAGE_TAG_ADDED? (or maybe it can be removed?)
The below code is sufficient for handling the future completion:  java if (future.isSuccess()) { originalSubscriber.onNext(connection); originalSubscriber.onCompleted(); } else { originalSubscriber.onError(future.cause()); }  For cancellation, isSuccess() returns false and cause() returns CancellationException
This method needs the same processing that happens in addJavaOption.
How about a test where it fails if no barcode files are found? How about a test if not all the tiles were found? My apologies if they are already there.
off topic: I've been writing this as "client == null". I think this conveys just as much information in fewer characters, so by Shipley's law I should switch over. The drawback is that "client == null" is a boolean expression, and is consistent with "limit < 0" etc. . .
use the setter
BAD_REQUEST != NOT_FOUND
Reschedule?
Please rename your variable to tempPassword (we use camel case). Remove parenthesis between the ternary expression.
suggestion Deadline.fromNow(Duration.ofSeconds(10), 5L);
static import
don't we want to add something about role?
please use static imports
I don't know how this BuildTestParticipant is setup, but can we have here a check for the error on project before/after change (assume the source is an interface with default method, it shouldn't be compilable on Java 7), or to know that a *full* build was triggered (and not incremental one)?
Why an existing CorrelationData.id can't be used for this return purpose as well?
Compressed file is put to temp with random name. The download completed successfully and the zip folder is located : /tmp/10d3a94a-34d7-4e8d-aafb-b6df7e601eca5107900615026729283.zip
use java.util.Objects
This exception makes no sense to the caller and it will always be false. If you are just sanity checking, throw an AssertionError.
Not sure, why not use @NotNull?
These are from the org/json library. Edits to this are really not recommended.
Sort of nit but should this be TTransportExceptionType?
I think we can merge this case with Screen.COURSE_DASHBOARD.
isn't the default 2?
Little nit, but could do int len = 0 if(sdPipe != null && ((len = sdPipe.available()) > 0)) { byte[] buffer.... No need to call sdPipe.available twice in succession.
This is an indirect way to test container sorting. Could we instead write this test without a dep on FirstFitDecreasingPacking and just pass a Set of containers to sortOnContainerId and assert the returned ordering? That way we can directly test the utility method without going through the FirstFitDecreasingPacking code, which should be tested in it's own test suite/class.
That's what I meant. But now that I see it I'm asking myself why we don't use diff.getPath here, it returns the old path in case of a delete. It would be useful to be able open a file that was deleted in a commit but was later restored. Could you change it to just use getPath and also change it in Action#run? Sorry about that :).
:bug: this should probably be using Run.getCharset. (As noted in <LINK_0>, it is hard to test these things realistically.)
suggestion final UomId stockUOMId = inventoryLine.getM_Product_ID() > 0 ? productBL.getStockUOMId(inventoryLine.getM_Product_ID()) : null; inventoryLine.setC_UOM_ID(UomId.toRepoId(stockUOMId));  simplified the method call
Then should we just use it to save the update items?
It might be better to rename PerformanceMonitor line 75: java PerformanceMonitor.startActivity("rendering/copyImageToScreen");
it seems filter here is unnecessary, can be removed
why was this removed?
1. There's no need to load the snapshots if the disks checks hasn't passed succesfully, same way that we don't load the disks if the vm is locked. 2. you should load the images for each of the disks IIRC, take a look on what's being done on ExportVmCommand and handle synchronization with other flows like preview/restore/stateless run.
Do we really want to confirm every command that the handler receives?
To always be safe please use context.getApplicationContext()
suggestion String[] tagItem = tagList.get(i).replaceAll(" ", "").split(":", 2);
Just return checkNotNull(id, "id").split("/");
if credentials are provided and incorrect, maybe we could trigger the error ?
Has this actually changed to include the value? Why does only the agreement_id include this?
No need for a null check here, instanceof would allow both the class and null check as one.
Unnecessary "else" blocks, just return
I think it would be suitable if some kind of padding is applied between messages, such as a newline
We can use TextUtils.isEmpty instead of directly checking for empty string. We also need to localize the string. I suggest adding a new string resource, probably something like wordpress_as_site_title to make it clear how it's used to give information to the translators.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
OK. sounds good. Anybody step up and tell me where to put the code and parameter, and I will happily do the work :)
@bkmeneguello Are you sure that <code>!=</code> is correct?
I think this try-catch is not needed anymore
return Collections.emptySet(); ? BTW, it seems that class DummyGroupMapping is never used now, do we need scrubbed it off?
I think that may have been an oversight in longSum. Try a query that results in +Infinity at the historical level and you will see why it is needed to deserialize at the broker level
This check does not belong here, this method should never be passed a null value...
You are messing with Exception!
I don't think you need this new String
Is this actually possible? Under what circumstances?
Shouldn't this throw VersionUpdateException? ;)
Should have the id where to start from
Do these exceptions get logged elsewhere? And confirm that this is the right type for the error
Code from line 137 to 154 can be extracted as a private method (createLegacyFile) to be reused in the testFindLiveVersionFile test and also to leave the test shorter and cleaner
Does the segment delete need upgraded locks?
Null check needed here. This suggests that articleMetadata.getRevisionDate() should return an Optional so we don't have to remember, but as mentioned in <LINK_0> it would be better to do this consistently across all ArticleMetadata fields.
0L
following the change above, i'd expect this one to look as: assertTrue(validate.isEmpty())
Still valid.
this.monitor to avoid confusion with the parameter of the same name optional: this whole block could be a ternary: this.monitor = monitor != null ? monitor : NullProgressMonitor.INSTANCE;
Could check it's null and return to avoid nesting.
assertEquals(Foo.class, foo.getClass()). The produced Foo is @Dependent and so there is no client proxy and we can be sure the instance is the result of the producer method.
this variable name is misleading, it contains not only the commandData but also Ne field (see also other ApduTest classes)
Can't we do this just once in the constructor?
child
the open and closing brackets doesn't match.
See org.eclipse.sirius.ecore.extender.business.api.accessor.ModelAccessor.eDelete(EObject, ECrossReferenceAdapter, Predicate<EReference>, boolean) and org.eclipse.sirius.ecore.extender.business.internal.accessor.ecore.EcoreIntrinsicExtender.eDelete(EObject, ECrossReferenceAdapter, Predicate<EReference>) It seems that without the predicate, the previously ignored reference will now be removed.
Exception is not logged or thrown
This doesn't go well together with @Nullable for the parameter.
nit: Should we make metricsQuery non-final and change it here (e.g. metrics=addMergeAggregator(metricsQuery)) and then let the normal flow resume?
remember to 0-size arrays when doing toArray(). PMD will enforce this.
rename to val or v
You could replace lines 933 to 945 as follows to make use of short-circuit evaluation:  if (file.isFile() && ((suffix == null) || (file.getName().toLowerCase().endsWith("." + suffix)))) { files.add(file); } else if (file.isDirectory()) { listFiles(file, files, suffix); }
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
these error messages should use the name of the expected property. keyField
Where all is the outer setAddress method used? The AMQP Properties section is part of the immutable bare message so we shouldn't in general be setting the 'to' address in it or creating the section if they weren't present. Exception might be made during cases like protocol conversion, but it seems like it should be explicit rather than a side effect that might see unintended use as here.
is the mini cluster required? starting a mini cluster takes time and prone to flaky failures. Would be nice to avoid using it.
remove public
unrelated bug fix?
add some message when throwing exception
I would divide this method into 3 methods. One for final aggregation, one for partial and one for mappings. Then you could remove Parts. Parts is not passed anywhere so you don't need such entity.
Instead of setting both, you can call this(okHttpClient, okHttpClient.dispatcher().executorService())
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
We will be creating this array quite often, from constant input. Perhaps it should be done once, statically?
One more thing, we added a recent change here to setSoTimeout to initLimit * tickTime to align with what leader is doing. We should add it here as well.
ImmutableSet.copyOf instead of Collections.unmodifiableSet
(nitpic) 0.0f is float, you mean 0.0 (double)
Change toString method to include both
condition could be inversed and in fact the for each can be applied no matter what, if empty, this is a noop. Thus, no need to collect.
No need to call Integer.parseInt(getUuid()) more than once.
you cannot loop only one time on the full entryset?
This code block is duplicated within the test, it can be extracted to a separate method.
You are open a stream object without closing it never. Maybe you can use the try-with-resources statement here and avoid / handle the unhandled IOException here.
* this line should be above 'lunIdSanStorage' item * 2 -> 3 (and 'lunIdSanStorage'/'quota' items should be modified accordingly...)
Use the caching util.
use the logger instead of printing stack.
Please use Optional.ofNullable()
This change is still incorrect
toString is never null, you want to test if it is not empty.
@cuenyad Replace logAndThrow
I'd suggest to change this to  logger.debug("Registering new service {} at {}:{} ({})", description.serviceType, instance.getInetAddress().getHostAddress(), description.servicePort, instance.getName());
DAYS is unnecessary here.
What about: java if (fulltextStoredInBlob && fulltext != null)
I would use a matcher to avoid pattern recompilation.
This one also doesn't seem to really need to be nullable.
I'm going back and forth on this but actually I think it's best to push this into the Assignor as well, and not *just* because it's more symmetric. I see two arguments for doing it this way: 1) the PartitionAssignor doesn't necessarily know anything about ownedPartitions 2) even if it does, it will not know about updates (such as metadata/subscription change, missed rebalance) while the ConsumerCoordinator's subscriptions.assignedPartitions is always up to date. To address 1), I think it is reasonable to assume/force a **Cooperative** assignor to have some knowledge of ownedPartitions especially since we are ok to assume it will be able to handle the "adjust assignment" logic. And regarding 2), we could actually just pass along the current assignment to the PartitionAssignor prior, or as a separate PartitionAssignor.cooperativeSubscription(topics, assignment) method that is called in cooperative mode instead of the above. One upside of setting ownedPartitions in ConsumerCoordinator is that the PartitionAssignor no longer needs to know/save its own assignment. However what we lose here is the ability for the PartitionAssignor to react to anything other than the currently owned partitions.Imagine we have a heavily stateful app and a consumer misses a rebalance. It's partitions get assigned to another consumer but there's so much state to restore it doesn't get very far before the first consumer manages to rejoin. The first consumer's state is up to date while the second consumer is very far behind, but only the second consumer will join with a non-empty ownedPartitions so it is more likely to get the partitions again. (this scenario requires a more advanced assignment strategy than we currently employ, but even the current sticky assignor leverages this information to improve stickiness where possible) @guozhangwang @hachikuji
It's recommended to ask the workbench for the display: PlatformUI.getWorkbench().getDisplay()
I have a concern here, we introduced PLANNER_AVAILABLE as local private constant, while WorkbenchFeatures.PLANNER_AVAILABLE is still used in org.kie.workbench.common.workbench.client.authz.WorkbenchTreeProvider.createPermissions
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
naming
right left type declaration could be omitted.
return LanguageUtil.LOCALE_CACHE.getUnchecked(this.locale);
I'd suggest wrapping all of these methods with "if (logger.isErrorEnabled() )" blocks (or the equivalently-named method for the log level) so that we don't create a new I18n instance when the logging is not enabled.
And then else if this
Add SubChild here as well, perhaps SubChild is just persisted as a Child currently..
It's better to put the value at the end rather than delimiting it: java "Duplicate property: %s"
do we care to check the length to be positive here?
If it is then do what exactly? If we don't want to do anything do we need this if(..) block at all?
This can be rewritten as: java boolean exemptionEngine = request.getGatewayAccount().isRequires3ds() && Optional.ofNullable(request.getGatewayAccount().getWorldpay3dsFlexCredentials()) .map(Worldpay3dsFlexCredentials::isExemptionEngine) .orElse(false);  However, I wonder if we actually need this flag to consider whether or not 3DS is enabled. Presumably it's just going to be used inside the template and we can nest it inside a check that 3DS is enabled.
You want to use assertEquals instead?
You're missing 64 here. <= would be better.
you could do here itself if(getWindow() == null) { return; }
Also check [this](<LINK_0>, you should deep copy instead of clone in setters
@Sami32 You removed result.append(", Sample Frequency: ").append(getSampleFrequency()).append(" Hz"); - I disagree. Remember that even though you already have the sample frequency from DLNAMediaAudio they are separate values and one can be used one place and another another place. We should see both values when debugging, if they are different that would be a bug.
Icky. Can't you pass it in the ctor instead?
I think we need file with version 1.4. inside.
Or consider getBlock2Status
This checks if the name of the datastore is same as the filename. What if I have this file in my datastores already, but I gave it a custom name instead of a default filename-based name? Shouldn't we check for the whole path to make sure it is the same file?
why is this public?
createThrottle or something indicating that an instanciation will occur
Is the check needed in the first step of the upload? Ideally, it can be moved to the last step.
might be better to use the enum.id() (which you might want to add as getter) here. Also, the age old question in software maintainability: should each if better be a polymorphic method on the class itself that takes the byte buffer? Not sure, but I I would prefer using the enum id as first step, to avoid trivial bugs.
I think that we discussed this one before. We can remove the init() method from OperatorImpl if we pass source and context as parameters to the constructor of OperatorImpl. i.e. change createOperatorImpl(operatorSpec) to createOperatorImpl(operatorSpec, source, context). Or you are planning to fix it in another PR?
set Added to false & check that removed is false
this is not needed
If getNextMergedRow() return null or a full row, then we don't need to translate from !isPresent to null.
why increment "fileCount" twice? Already for loop is incrementing right.
Indentation should be deeper. These are easier on the eye (the break is less jarring)  java protected static Object invokeMethod(Class<?> definingClass, String methodName, Class<?>[] parameterTypes, Object invokingObject, Object[] args) throws Exception {   java protected static Object invokeMethod(Class<?> definingClass, String methodName, Class<?>[] parameterTypes, Object invokingObject, Object[] args) throws Exception {
Possibly a better choice: Arrays.fill(password, (char)0);
I don't know that you can make this generic. I don't think there's a guarantee that the response body for different providers will be the same, e.g., maybe somebody will call the field access_token and somebody else might call it accessToken. But maybe I'm wrong and this part of the standard. Did you test BitBucket and verify that it still works?
Maybe change this variable name to indicate that this is a widget (errorMessageView maybe)?
remove adding location, now only motech id needs location. The OpenMRS module doesn't support additional identifiers with location required.
nit: can we consolidate producerFencedOnCommitTxn to the more-general commitTransactionException? I.e. if you want to fence on commit, you just register the commitTransactionException as a ProducerFencedException
Debugging leftover?
Prevent from inlining. We do not want this to be inlined and constant folded.
Double* variant of this class uses object == null ? null that is better
Change those to static imports
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
This value can be static, no need to look it up every time.
Binding twice to the same InstanceStatusOverridesView class.
Since the scheduler poller could run between the create and this get, we can't assume that this optional will be present. Should probably add the isPresent check
Can't we do a schema check to catch non-integer columns early? Also, will an out-of-bounds value in the "partition" column trigger an exception, or will the BitSet just grow automatically? If the latter, we should add an explicit check and fail on an out-of-bounds value.
change 0f to 0 since other setTranslationY or setTranslationX is 0?
use return ... ? ... : ...?
Should we add: Objects.requireNonNull(record)?
It is not so important but still defaultAttributeAnd -> defaultAttributesAnd
The methods in here will need to use client.couchDbClient.get(...) etc otherwise these will break when it merges to master because of #133
Better use isEmpty
Why is this being cast to Boolean? The returnValue field is primitive and the waitForResult() method returns a primitive as well. It feels like they should all agree on what the type is.
Why this.directReplyToContainers.clear() isn't good in the end instead ? OTOH:  @Override public void stop() { synchronized (this.directReplyToContainers) { this.directReplyToContainers.values() .stream() .filter(AbstractMessageListenerContainer::isRunning) .forEach(AbstractMessageListenerContainer::stop); this.directReplyToContainers.clear(); } }
> In Java the / operator has a higher predence that the cast operator. actually, no, [cast has higher precedence than division](<LINK_0> <LINK_1>
Should we return an explicit IStatus.ERROR instead? * It would avoid potential NPEs on the client side. * It would make it clear that this method should not have been called on an ResourceStrategy which explicity says it does not handle this method.
shorter, more complete and more readable (IMHO): ZipEntry e = new ZipEntry(relativePath.replace(File.separatorChar , '/'));
Please remove this. There is no such method defined in interface Node
return null to make this more explicit ?
![MINOR](<LINK_2> 'Severity: MINOR') Catch a list of specific exception subtypes instead. [![rule](<LINK_1>](<LINK_0>
Thanks, but do me a favor to change to the following.  if (c.isAnonymousClass() || c.isLocalClass()) { throw new IllegalArgumentException( String.format("%s can't be an anonymous or local class.", c.getName())); } if (c.isMemberClass() && !Modifier.isStatic(c.getModifiers())) { throw new IllegalArgumentException( String.format("%s must be static if it's a member class.", c.getName())); }
I don't understand why you verify if filterChain needs to be updated with every message read. Maybe filterChain should be volatile.
Test that if you unchecked the weight checkbox and you are able to submit even though the weight is empty?
Missing @since
Its a small detail but referring to DeviceGroup as s (in the POST and PUT methods) threw me off a little. I was expecting a survey when I saw it in line marshallToDto(s)
reorder
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
I meant, we don't need a separate method. Lets do the things in power.
This call has the side-effect of actually changing the position of the pointer in the stream which may be unexpected by callers. You should save the current position, get the latest sequence number, and then restore the current position after.
why is this public?
I'd prefer to use getHostName() to ease correlation with other issues and logs
Nit: the style guide would ensure the correct spacing between if and (.
should be <= ?
can we define these as CONSTANTS? do we have these contants defined in stack in another placem so we can reuse?
These 3 lines seem to be duplicated in all unittests. Can you extract it into a @Before method and have the node and phoneHome initialized as fields?
please remove
Why not just simply "command.setVM(vm)"?
using log template is preferred
I think we should store ignoredRegions instead of ignoredLineNumbers. Single lines that need to be ignored can be stored as <LineNum, LineNum>.
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
Looks like there are some spaces missing here.
this can never happen now, can it (assuming you are checking for bytesWritten < size).
There's a bunch of formatting issues. Make sure to use the IntelliJ style guide
variable name here says flux but is a mono
Shouldn't be protected as this method is used only in tests + shouldn't be something editable no ?
Can you also rename the other instance methods named compile? The only usages are in CompilationTestHelper and ErrorProneTestCompiler.
Shouldn't this close the iterator before returning the list?
"assert false" will always fail. I expect this is because this is a state that should never be reached. If that's the case, throwing a more explicit IllegalStateException, with a message, would probably make things easier to debug in case it breaks.
You missed the for loop before this (line 903)
Just curious as to whether this is desirable over HttpLoggingInterceptor set in OkHttpConnectionFactory?
Please use for closeable objects a try-with-resources statement. Your code would be cleaner and better to read and maintain.
why not null as value?
for this case, i think it's better to use notebook.getNote(noteId) since the latest note will be in memory always
@szczepiq Is this really needed? [MockingProgressImpl.mockingStarted()](<LINK_0> filters already for MockCreationListener.
If file not found exception is thrown (when file not exists, correct status), Internal Error Exception is thrown and everything fail. In this case we need to set perunNamespaces map to empty one and continue.
There is no need to declare a variable, use simply:  .withResourceProjectPath(file.getProject().getProjectConfig().getPath());
it looks like far more deeper in the stack from where it should be - let's say that we got an event with a latter time than another one we already processed, when the code is done here it means we'll process it and will just not save it to the DB. I think it should be much higher in the stack - maybe even not to call the perform method in this class if the fetched stats are the latest
The raw data shouldn't be removed here. The raw data is allowed to contain invalid routing data.
You're not using these conditionals to avoid appending the boost info or the minimum should match.
assert return value
should rather use astRewrite.createMoveTarget(..)
@prondzyn Let's use UnsupportedOperationException instead, to avoid importing from commons-lang library.
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
I don't think you need to do all this. Just add a method public void init(T data) { render(data); } Are there places where you need to call this Dialog where you don't have this data available i.e. you need to call init without any parameters and it needs to reuse the data that it was initialized with? If not, then the init(T data) approach should work just fine.
Missing duplicate
should call clear() on timeStamps and values ... this will cause null pointer exceptions when calling add after clear
We have different conventions. Please see the spaces around brackets and method parameters, and brackets on new lines. The checkstyle plugin would crash the build. Did you try to run "mvn install -P run-its"? It would take quite long time to complete the build, cca one hour.
You may want to use ObjectUtils for this null check.
suggestion /* package */ Intent buildIntentForUri(Uri uri) {
Won't this fail if there's another test running in parallel and using client listeners?
"consider changing the plugin filename"
With Open As Experiment the experiment has the same name as the trace when there is only one trace selected. So this condition can go through right away because the original trace is already opened. I suggest to closeAllEditors as the first step of 4_11 and 4_12. Then the condition will really wait for the experiment to be opened.
this seems to be redundant, because there's no superclass for JdbiFactory which has a method with the same name.
assertEquals(excpected, actual)
Think @sandeepSamudrala mentioned in the another pull request. Should add location to the resultObject.
this values should be Long
is calling removeClientListener thread safe?
This is not required since you are checking for null in view
Is it a good idea to include this logic into ManagementCenterService.resolveFuture, so it would return a JsonObject with the result? I can see that it's used in other requests, like ChangeWanStateRequest or ClearWanQueuesRequest.
Nit: superfluous as the equals will say got null below
Could we please do not mix doReturn when and when thenReturn?
why not process all files?
Can we throw an exception instead?
is there any reason why we're getting local styles and then super's styles? (instead of the other way around) ... if you look at getAttributes, it first grabs the super's attributes and then calls onGetAttributes ("local" attributes)
could use writeInt(Float.floatToIntBits(v)) to avoid code duplication.
Feature should work without any property set. But should be turned off in case of property set.
Use getSelection(). getStructuredSelection() is not available on older Eclipses. EGit is supposed to work on Eclipse Luna.
I think better to use string concatination, as info log level this might called lot many time and string concatination has better performance the String.format. Another place where place I could think we can make more use of make logging, if present the file full path instead of file object.
Can you change the method name to getExecution? That would be more consistent with the naming pattern we've been using in the service methods.
I would either inline this method, or give it a more precise name, like initializeContextPath
A regular integer will do fine. The connection handler is single threaded.
put all parameters on one line: input.readBytes(Slices.wrappedDoubleArray(samples), Math.min(count, samples.length) * SizeOf.SIZE_OF_DOUBLE);
I think it would be faster to use a bitset operation (not) to invert and then call the constructor taking an OpenBitSet
please final your Field and UUID variables. glad the reflection trick worked for this test.
Since each person's ID is different, the list can be optimized by returning true for hasStableIds(), ex:  @Override public boolean hasStableIds() { return true; }  Explanation [here](<LINK_0>
This evaluates different value that it stays isLeftTurn will return true, in case it is slight left turn
you may add the error message as an additional third argument here, in order to give the users a chance to understand why that is
this should be either separated or runtime exception
as this isn't static, you should use lower case cache
could have a loop for the -r opt, where it tries -p,-e,-s, and -s -e. Could also have a loop for the -p opt. This would try all combos, I think the current test misses some combos.
hardCoding is not a good practice. You should try to calculate on the go or atleast have instance variable which tracks this value (which is set in setupTest())
1. i don't think this should be based on the "potential" of the host, rather the DC its in. 2. also, if my DC is 3.0, you shouldn't let me create a useless V3 storage domain since the host i selected is 3.1. i wouldn't be able to do anything with it until i have a 3.1 DC. 3. while at it, I'm guessing this line is buggy and would cause quite a headache if a 3.2 vdsm would be released, collections.max would return 3.2, and the getSupported(3.2) will return an empty/NPE/etc. on a 3.1 engine.
Please replace 2 + 1 with 3.
latch
suggestion LOG.warn("listOffsets request failed.", e);  Thanks! (minor suggestion to make the log message more typical)
Alternatively, you could use bitwise OR.
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
Why the difference here?
Should this also check if the schema is already present in the manager as the latest version? If so, then return?
Nice fix. I'd suggest just one improvement - let's add two methods: - RingbufferContainer.isStaleSequence(long sequence) - RingbufferContainer.isTooLargeSequence(long sequence) We can then reuse these methods in the operations and in RingbufferContainer#checkBlockableReadSequence. Otherwise, I always get confused when checking the sequence - should I check the tail or the head, can it be equal to the head or strictly less and so on and so on.
Do we need this here? I think onResume() is called when the activity is restored. Therefore the settings will be reloaded. So I think we can remove the logic from both the onViewStateRestored() and onSaveInstanceState() right? Or am I missing something here?
Nit: Could you flip the conditional here to check for existence instead of non-existence? suggestion HttpURLConnection conn = (HttpURLConnection) (options.getProxy() ? lobURL.openConnection(options.getProxy()) : lobURL.openConnection());
Remove this
It would be better to check return msg.getFlags() != null && (msg.getMessageStar() || msg.getFlags().contains("starred"));
We should check the connection status, like 404, 403, 500, etc.
Eclipse is warning that the argument r is unused. I guess this should be changed to r?
why I need variable that is used only inside a scope of if?
exception on compareOffsets is eaten here. User won't be able to see it
"Modifier 'private' is redundant for enum constructors"
will it work fine if the path is not encrypted ?
Can't you use Locale.ENGLISH?
Maybe better to return null
Could you add the path /artifacts/ to <LINK_0> and reference that instead? Then search&replace in other methods.
Add statusToAdmin.
From the point of async store, it is not necessary to have the *function* serializable but the resulting entry. So the check does not belong here. The same holds for compute commands.
I would have put this into its own column. You only have 41 characters defined thus far on a line, and we usually have an 80 character wide terminal.
This indirection binding->name->binding looks bogus to me. Can you explain what it achieves? In particular: if "resolved != pkg" then we should be seeing two unrelated packages (regardless of the name) and then using resolved instead of pkg would give wrong results, no?
This function always returns null? That doesn't seem right.
This can be replaced with assertThatThrownBy(() -> message.doLocalRemoveAll(partitionedRegion, mock(InternalDistributedMember.class), true)).isInstanceOf(PrimaryBucketException.class); to make things a bit neater.
Please use ? ternary operator
Makes sense to swap FLAG2 and FLAG3 since volatile functions are less common than the varargs ones.
I believe the order is guaranteed in partitions by the sort order of Partition which is on the partition ID.
To always be safe please use context.getApplicationContext()
The Exception is never thrown.
Should be: new ArcGISTiledElevationSource(getString(R.string.elevation_image_service));
forgot to commit the printStackTrace()
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
\>= ?
Integer.valueOf(...) instead.
please move the setUser and setHost to connect (if _vds != null)
bad name of method <LINK_0>
Possibly use floor() to ensure that it floors/make it clear it floors.
Please use ternary operator ?.
If this array isn't meant to be modified aftewards, you can now use ImmutableList, which will have better read performance (and no potential synchronization issues).
True. I've never seen a case with -1 as the default. 0 has special meaning in the JVM, so best to stick with 0 as the default and adjust the size to cope (add one or size 0 -> -1)
Minor: We might not need to set response here. We arent using it anywhere.
handle case where baseline branch isn't set
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
These two are redundant now - shouldn't the test for the new logic be in a different test?
Did you consider to make this return Color instead of Integer?
not related to the try block
Please add message entity here by describing the error.
why not resource.getType() == IResource.FOLDER as above for ROOT ?
Can use Objects.requireNonNull instead.
The synchronized block should include stopThread = true and close.notify() before thread.interrupt.
This can be removed.
Declare templateStream hear, as a local variable.
would this also do the same?  Collections.sort(classes, (c1, c2) -> c1.equals(c2) ? 0 : c1.isAssignableFrom(c2) ? -1 : 1);
Why do we continue without checking whether startKey is < purgeRange endKey?
Suspicious call to getUsages() which is not used later (And is recalculated instead)
corenode ref again
why this is in vmCommand? should be in stopBase command
I would not silently ignore one passing a null parameter. In other words, i would remove the if check and assume that the condition is not null. If it turns out to be null, better for the caller to automatically get a NullPointerException than chewing it quietly.
Shouldn't 0 is January 1, 1970 UTC, assuming the millis are epoch millis (count from 1970-01-01 UTC)
Same here. Instead of adding 3 numbers code creates an array, does boxing etc. It is not an optimization neither in style nor in performance.
This can be a stream - filter - collect expression.
Consider tracking the number of list items on the parent block so that we can do better with number prefixes (i.e. 1., 2., 3., ..)
Same i think?
I'd make these numbers constants
Why are you building JSON by hand?
Couldn't you put the xpath expressions in statics rather than compile them multiple times?
This should be done in execute()
Is a plain "else" block also needed here to at least log the cases where no PaymentWorks processing is needed?
I'm kinda ok with 1. although fully share your dislike it introducing APIs About 2. I guess I get where it's heading, but not fully understand it yet, so cannot be sure
suggestion: What are your thoughts to add a postcondition here to check that sum of aggregated results is equal to the run count?
"error".equalsIgnoreCase(...)
suggestion addRole(new UserRoleEntity(role));
Class<?>
Would it helpful to just write to an in-memory buffer? These files are typically smallish, after all, so we do not care about heap usage much, and then we do not care at all who is flushing when. If and when commit is called, write the entire buffer to the temp file (if you are lucky this will be a single block), make sure it is synched, then do the atomic rename. I also think we should add a flag to XmlFile allowing callers to opt out of expensive consistency guarantees, with the default being strict mode. Run.getDataFile and SimpleXStreamFlowNodeStorage.getNodeFile could then use the lax mode, accepting the risk of corrupted data in exchange for better performance. You can even guide callers to make this decision explicitly by (say) deprecating existing XmlFile constructors in favor of ones taking a boolean flag.
Either this should delete disk also, or it's not removeDisk (and probably belongs elsewhere).
Use spaces instead of tabs.
Icky. Can't you pass it in the ctor instead?
Should be ordered below onCreateView().
Could use an enhanced for (avoids the explicit hasNext/next calls).
Still wrong index... It really must be dependent on the TmfEventTableColumn, we cannot assume that the received 'columns' list is either in creation or visible order.
For consistency, I suggest to write this forEach in the same way as loop above.
**/XCUIElementTypeButton
![Codacy](<LINK_0> Issue found: [Method names should not contain underscores](<LINK_1>
:fire_engine:
Change to StringUtils.isBlank?
As we are not exposing the original Scan directly, why to create a new Scan again here? No need
Would you mind to remove the double brackets (way....)? Also for the above statement
When concatenating the log message it would better to pass every parameter into the Objects.... rather than concatenating the string which is inefficient.
I'm unsure this is sane  moreover, I'm certain this shouldn't be silenced
Not sure that it's good. If path is not setup - this.dir will be still null - and we just pushing NullPointerException one level down.
I would love to have a java.nio.Path method too!
Can we use the [try-with-resources](<LINK_0> syntax here (both for the statement and the connection)?
This equals implementation should include attributes from the Command super class.
1. are we showing what we observed or we expected? it looks unclear to me. 2. given that this is only used once, is it better that we just use assertTrue in l.108? 3. static?
calling super not needed
The fix here should be to assign sortBy[0] to the result of the invocation below, that was not assigned to anything, instead of creating manually a specific implementation of SortBy
Why did you move that code? It changes semantics, so there should be a reason for the code motion.
When you write data to parcel, it is analogous to serialization, so we also need to deserialize the result to get back the NarrowFilterByDate instance in [creator createfromparcel](<LINK_0>
increase to WARN
This will throw an exception if there are no strings in the vector. I would honestly just space separate them and not worry about the hanging space at the end.
nit: missing space after 'if'
The Logger should just be defined statically on the class
This won't work if assignment is done with member access: this.myField = new CopyOnWriteArrayList<String>(); While going through parents, you have to check that, you are coming from the variable() side of the assignment, and not the expression() side. Checking only for IdentifierTree is not precise enough, and you don't really need to check for it later. It's only the starting point.
Hi, I thought about changing back the name because all the classes in the AElement hierarchy use double dispatching mechanism and it looked like a convention, and the double dispatching mechanism is more clear according to Michael. This class is the only one for which the second equals method isn't used anywhere, and I'm not yet familiar with the complete codebase so I thought it was error prone to change the public api of the class, that's why I changed back the name and made the change so that the equals(Object) calls the correct method. I do have the merged equals method in a branch. Should I make a pull request from it?
does this need to catch all exceptions?
Is this SCM-specific?
Move this "setRequiredAttributes" before loging in newMembers cycle.
This is wrong. getFullPath returns the workspace path (e.g. /org.eclipse.egit.ui/plugin.xml). It should use getLocation(), which returns the file system path.
- log warning that option is not supported by SNMP
rename to simple
This DateFormat object never changes. Maybe make it static final in the class scope and save a bit of performance?
I think this pattern will work throughout the whole string, while we want that it only works for the suffix of the string, which is not enforced. To enforce it, it should be "_[0-9]+_g\$$" or "_[0-9]+_g\$\z" or something similar.
Why do we need explicit checkpoint here?
Request.State.OPEN
java TimeUnit.SECONDS(30).toMillis()  is more readable
Missing assertTrue?
if everything is correct, we don't have Origin.MONITORING any more
StringBuilder
Also added a try with resources here.
Is commit improving only the heap size or does it help performance also?
Can be replaced with: hosts.stream().map(VDS::getName).collect(Collectors.joining(",")); ?
if format string is non-empty then String.format(..) can not be empty, so Strings.emptyToNull(..) is probably not doing anything. did you want to do following instead?  String.format(format, Strings.emptyToNull(value));
Use the stream with try with resources
Spe
We can do it in a follow-up change but I'd strongly recommend using the ident gitattributes facility so we always embed the git commit hash in the user agent: <LINK_0> That should be fairly straightforward to do.
Qualify this.uri
What has showing repo groups have to do with showing unborn head? Perhaps "showUnbornHead" needs to be renamed. But actually I was wondering if the groups should also be shown elsewhere (repo selection dialog).
This setting should not be enabled by default since headers may be C++-specific and not protected by #ifdef __cplusplus
Another issue I noticed while trying this out: getDefaultLSLocation() can return null (e.g. if the chosen language server is not found in your PATH), in which case the next line will throw a NullPointerException. So we need to add a check here.
The "brackets for single statements" cleanup in this file should be done in a separate commit, as we should not mix unrelated changes.
Whenever an exception is swallowed, We should log it otherwise it will be hard to debug. Can you please log the exception that is swallowed here?
IF EXISTS should be reflected in unparse
This can return void. We can now remove the if from if(rename... and the log about falling back to copy/delete in handleFileMessage(). Also, the logic in renameTo() that deletes an existing file can be removed and the if tests and associated throw s can be removed also, since Files.move will throw an exception.
This is probably ok, because TumorType instances are not really modified after they are created. But potentially, this sharing of the children (the copy will refer to the same objects which are the children of otherTumorType) means that a remote edit to the child TumorType will alter "my" children (the copy's children).
How about reverting negation?
please remove else, code will be more readable
This resource needs to be managed and disposed when appropriate. Sometimes we use org.eclipse.jface.resource.LocalResourceManager. It also might be appropriate to change the org.eclipse.e4.ui.internal.css.swt.definition.IColorAndFontProvider interface so that it becomes responsible for managing the resource, if that can be done.
If I understand this "fix" properly, we were basically creating a new appender for each test, which you're now auto-closing. Plus, you're creating a new logger for each test. Would it be possible to just have LogFixture take in a level, and auto-generate the logger name, so it does not need to be passed in, even if just to avoid copy-paste errors?
the return value is not used. I suggest removing it and throwing an IllegalStateException if a message type needs to be handled, but there is no mapping to a handler.
Why do we need to use reflection? Can we just cast view to SearchView?
Again, this change probably shouldn't be a part of this pull-request, since it seems to be related to ExtSources and purpose is debugging it.
1. Did you mean support only Firefox for _testing_ right? I assume the difference in behavior affects testing only? In that case we should keep the production code clean and apply any workaround in the test code. e.g. do an if-else based on WebDriver. 2. Yes, I think at some point we stopped using Chrome for testing. There are many other quirks between the two versions that gets in the way of comparing html. We can check if anyone is using Chrome.
This will forward the child's requests and will hang because the child doesn't receive an element and nobody is requesting more. I'd instead write this:  java Subscriber<T> result = new Subscribeer<T>() { ... } child.add(result); return result;
Are those for debugging or you want to keep them? We didn't log those info in other methods
Maybe it'd be a personal taste, but using stream seems simpler to me as follows:  dataKeyRanges.forEach(keyRange -> { final Map<Integer, Pair<K, K>> blockToSubKeyRangeMap = blockResolver.resolveBlocksForOrderedKeys(keyRange.getFirst(), keyRange.getSecond()); blockToSubKeyRangeMap.forEach( (blockId, subKeyRange) -> { blockToSubKeyRangesMap.computeIfAbsent(blockId, integer -> new LinkedList<>()); final List<Pair<K, K>> subKeyRangeList = blockToSubKeyRangesMap.get(blockId); subKeyRangeList.add(subKeyRange); } ); });
1. Removed @throws IllegalArgumentException when alias is null. as it is not required to declare throwing a runtime exception. We haven't declared this in other places e.g. Database class as well. 2. Remove an extra empty line before if(alias == null) {. 3. Add a space between if and (alias. Should be if (alias == null). 4. Add . (full stop) at the end of "alias is null" -> alias is null. 5. Do the same for the other methods.
Would some message be a little helpful here?
Could be inlined here by using test()
It would be nice if we could skip that when statistics are not enabled. System.nanoTime() adds some overhead.
What about the VolumeVO uploadVolume and the GetUploadParamsResponse uploadVolume , that also use getImageStore , will you also also handle the null returns there?
is this guaranteed to be the case in S3?
BigtableFilter should probably have a com.google.cloud.bigtable.data.v2.models.Filters.Filter member variable. That would likely mean deprecating the current constructor that uses com.google.cloud.bigtable.data.v2.wrappers.Filters.Filter, and use a com.google.cloud.bigtable.data.v2.models.Filters.Filter in a new constructor. Also, please add a BigtableFilter.getFilter() which returns the models.Filters.Filter and use that getter here.
if the disk doesn't exist you'll fail with NPE here, please first verify that it exists.
Could you please elaborate on this condition - it seems a bit suspicious -> it seems like we perform "unfollow" action after the user clicks on follow when it's a feed
any reason for explicitly invoking super.toMap() ?
This piece of logic is misplaced here, redirected messages should also be built by a MessageBuilder
Tangentially, we should likewise install the backup service as ACTIVE, so that it toggles to NEVER instead of ON_DEMAND as well.
Shouldn't this close the iterator before returning the list?
The value here is null right? If so why we try to print the value? I think it should say Empty userID. Also, can we use StringUtils?
This is common enough that there's a util for that and is used extensively: suggestion Utils.closeQuietly(retryWithToleranceOperator, "retry operator");
Should log a warning here
My personal preference is to use brackets even for one line loops and condition. Not a blocker to merging.
Would it be more robust to also wrap the whole if statement in a try/catch? My understanding is that we never want to throw an exception after we've updated the positions in pollForFetches(). > If an exception is thrown and the callers decide to capture and continue, those records would never be returned again, causing data loss. For my edification, what else can the caller do to not lose data in this scenario?
I find this strange. It means the response code column in the log can be a non numeric value.
There may be some possible responses such as a 403 that is not the expiry case. If that included a Set-Cookie this would miss it. I wonder if we should check for the header earlier and then not worry about response codes?
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
Need to verify no interactions with log
This should be Status.NOT_FOUND.
i++
Make "LOCK" to be a constant instead of hard coding here.
I would change this "#get()" to something more meaningful, like "there is nothing here, use has() first, to check"
This validation needs to be changed....The RVV's are maintained as local-rvv (local to the node/member) and array of remote-rvvs (all other members). The RVVs has to be taken for corresponding member from both dumps and compared.
this double check for lombok annotation + specific lombok annotation seems pointless, just keep the second (specific) check. Moreover, since we have a property with ignored annotations... why don't we use it? a user may setup the property and it will be ignored here. Also, this class should probably not extend AbstractLombokAwareRule anymore. We have a configurable set of annotations that suppress the warning, defaulting to ALL lombok annotations, yet we only check for lombok.NoArgsConstructor... Maybe directly extending AbstractIgnoredAnnotRule and settig the default property to lombok.NoArgsConstructor? Or, to avoid a breaking API change, keep extending it, but override the default. For 7.0.0 we can change the class hierarchy.
is this auto generated by Eclipse of intelli-j? :) Have you considered using ObjectUtils.objctEquals? See VmDynamic.java for example. IMHO, makes the code cleaner.
where did this go?
remove this and following our.println?
throws IOException is not needed; remove it
Since you're already calling initMocks(this), you can annotate all your mock objects with @Mock and remove all these mock() calls.
For consistency we should rather do nothing if the list is empty. That's how all other containers currently operate and I think changing that only for those two elements is misleading. Rather, we should find a way to define an "empty" license or an "empty" developer which will lead to the creation of that empty element. Such decision should only be applied when the spring boot parent is used as well as we don't want to generate such elements for all projects (typically those who are not using our conventions).
there is no other (more elegant) way of getting article name
Bad variable name! Variable names should be clear enough. Rename it.
Might make more sense to actually show usage of a fixed date: ZonedDateTime.of("2016-...").
Not necessary. The web plugin should be bound in the Gerrit-HttpModule.
Did you test this? Why is it different from the lines above (LocationDto, TextEditDto, etc.)?
This should be simplified to just: >return value;
Move the creation of the pointables object to the constructor. In the evaluate, just reset or clear the pointables variable.
i think this logic works to identify the given resource group is static or not. But a much cleaner way would be, if we mark each segment of ResourceGroupId being static or not when we create them via group.expandTemplate call, then we can easily put the flag here. And no need to rely on the context. i.e. this line will become something like this group = parent.getOrCreateSubGroup(id.getLastSegment().getValue(), id.getLastSegment().isStatic()); And i think to make this happen, we may need to change the segments in ResourceGroupId class from string to a class Segment which looks like this: class Segment { String value; String isStatic; }
I think this one could be private
Wouldn't it make sense to call setImage here? Or do we have different semantics in that method and this one?
This sometimes leads to IllegalStateExceptions. That's why I switched to startforegroundservice recently > The startService() method now throws an IllegalStateException if an app targeting Android 8.0 tries to use that method in a situation when it isn't permitted to create background services. > <LINK_0>
This will loop forever if the user sets a negative size.
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
I think you want logical AND, so double ampersands. Can we use !license.isEmpty && !licenseShortName.isEmpty && !licenseUrl.isEmpty() instead?
May be worth asserting the exception type in that case ?
Is this very time sensitive? We release "2", wait 20ms, then release "main". So on a slow machine (e.g. buildhive) the thread for main could record its message before the thread for 2. If that's the case, can we make this less time sensitive (if necessary by increasing pauses and marking as groups="Integration")?
use return ... ? ... : ...?
I wonder if we should have a static method somewhere getAbsoluteUrl(String) and call that instead, making the code ever so slightly higher level. Config.APP_URL + is a lower level operation and I don't like that it is being repeated in many places.
why not process all files?
Can you leaves these timings unchanged as currentTimeMillis()?
Please format the parentheses throughout the file, as you would have requested me to do.
be backwards compatible
Can you not combine these if's to reduce the nesting a bit?
are a.exitstatus and a.pid meant to be variable interpolations?
These two lines should come before the if. (Remove in the other branch.)
Shouldn't this return a Page<T> instead of a List<T>?
extract as a constant
If anonymous Authentication is disabled, this might be null so we shouldn't throw an Exception here.
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
if the variables are no longer class variables, remove the prefix m
This confuses me. L837 is doing a similar check on "currentElement" as is being done here on "path". And the newRemaining.size() > 0 check is redundant.
use sparse array
We can drop final PostModel post = event.post; at the top of this method.
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
This condition would effectively exit from the loop at the first iteration, so it will hurt performance.
This would change accordingly, as well as several other spots in this file...
is there a better name than 'remote' - something like 'toSandboxMode' or 'toContainerMode' - something on the lines.
These are from the org/json library. Edits to this are really not recommended.
do you really want to catch all exceptions? Based on the implementation of convertFrom1499XML I would narrow this to NumberFormatException, as this is the only reasonable exception I would suspect here
since already saved it in 'vmGuestAgentInterfaces', please use it as the second argument. in addition, why not to have this in called from updateGuestAgentInterfacesChanges() ?
This technically isn't needed since cont will be null in this case you will enter the cont == null block
Could use this::updatePartionInfo
Same code as on line 92.
Here, you can simply call the other constructor: this(Integer.MIN_VALUE, Integer.MAX_VALUE);
how about making the if-tree in here smaller by checking for value instanceof Number (instead of all the individual number types) and delegate to the numberValue method (which should be moved to this _"BOXED FACTORY METHODS"_ section by the way)?
It would be better if we add a "getMetadataProperties()" method to the JobContext interface. Then it is not the scheduling service's responsibility to fetch it, but the JobEngine. Better separation of concerns that way.
if you do this, better put N/A :)
can use the new logAndThrow() mentioned above.
This should be an ImmutableList.Builder<Path> There are several examples of doing this here: <LINK_0>
Something else that I missed. I know it's not that important, but we don't have to set the type when creating new objects any more. We can just use the diamond operator new HashSet<>.
@original-brownbear oh, I see, it's \u00ea
is the VM null too perhaps? maybe just move the condition from line 63 up?
Isn't there some simple little library for generating JSON output? This seems icky, who knows whether item.getItemID() returns something nasty containing backslashes and whatnot...
But we've already passed gogoduckconfig to gogoduck so we don't need to set the threadcount separately as well..
too long
Can we pull this out into a isGoodPath helper method or something?
Please add message entity here by describing the error.
Unfortunately using checkInitialized() and sCameraX in this way won't guarantee thread safety. We might need to consider synchronizing access to sCameraX. You may want to move this synchronization into checkInitialized and have it return the CameraX instance. Then only operate on the local-scoped CameraX instance.
Why are you building JSON by hand?
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
@inverno Why public?
Needs defaults
I don't think this is safe -- won't it mask other types of errors that have nothing to do with connectivity? And do so indefinitely since we'll never pass those ConnectExceptions along? We do want tasks to fail eventually, we just want them to retry for some time if they can.
Static factory instead?
nit: spaces around + I'd also change / to use OS-specific path separator, i.e. [File.separator](<LINK_0>
Perhaps cache that set in a static field?
Include the file:// as constant.
We should extract this logic in util project, maybe in the ImpersonatedCredentialsFactory class?
Do we delete the local file after we process it?
Request.State.OPEN
I would use Duration.CUSTOM, so the effect should be discarded if Wood Elemental has left the battlefeild. With WhileOnBattlefield you get multiple continuous effects active at the same time when Wood Elemental has left and returned to the battlefield. P/T result probably would be correct.
this case throw an exception if the attribute is not found and we can chose between the <then> or the <else> condition.
also a good candidate to introduce a constant
use assertEquals.
please use configuration to have per version values (it will save doing the per-version checks)
Please update this implementation.
Move these to tests and use stepverifier.
@lautarobock I believe there is a need to forward exit call on the Pass instance corresponding to the index.
Rename variable!
Add java player.addStat(StatList.getBlockStats(this)); player.addExhaustion(0.005F);  As those are the lines in the parent classes method that we still want.
Just double checking: Was it intentional to go from 10K ms to 1K ms?
Why call setScrollBar() twice? (L157)
This is a rather complicated hack to try to keep using stream api against all odds in EGWalker. I would try to get rid of Pair class and do a proper old loop.
Any reason for not using a for loop here?
We have on UtilsMethod a is set for collections
final params?
Can we have one more route, from stream:in to direct:greetings? This places emphasis on the point that the two endpoints don't need to know about each other.
Coding style :(
Should this be handled as a SearchHandler? That way the generated API docs include this automatically
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
I see some improvement can be done here.Is it required to define method as synchronised.Can we use ReentrantReadWriteLock and get write lock here? It will be resulted in performance improvement
Don't call build in every iteration. Build the list outside.
Add final keyword.
This looks like the new implementation, you should leverage current one by calling existing method with some transformation.
nit: spaces around + I'd also change / to use OS-specific path separator, i.e. [File.separator](<LINK_0>
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
We could rename the test method into executePredicate.
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Request.State.OPEN
This breaks stubs, use function.getName instead
Can you add a way to signal this runnable to finish?
You are still programming in Javascript here. :-P What about replacing "" with null here and remove "" from the variable declaration?
what about memory and network costs?
Is this stubbing necessary for the test?
I'd suggest reversing the check: if(Event.Type.LIGHTS_OUT.equals(event.getType()) that way if getType() is null for whatever reason, you don't have a NPE.
I think we need to flip the logic here and on line 118: return options.diskCache == null || options.diskCache.isEmpty(); and && **!** isRemoteCache(options))
Please use ? ternary operator
This methods should return the index of the max/min axis: x = 0, y = 1, z = 2, but it would probably be better to remove them from the interfaces.
assertTrue(queues.isEmpty(), "Expecting empty queues but was %s", queues)?
Is this closing bracket in the right place?
Why caps EXPECTED and ACTUAL here?
No need for null check
It could just be a BlockUpdateListener.
I guess we can use direct call <code>get()/set()</code> instead of this field.
Please move this line into the if/else branch, e.g. @Override public void initSelectedProfile(ListModel<VnicProfileView> profileList, VmNetworkInterface networkInterface) { if (networkInterface.getVnicProfileId() == null) { profileList.setSelectedItem(VnicProfileView.EMPTY); } else { Collection<VnicProfileView> profiles = Optional.ofNullable(profileList.getItems()).orElse(Collections.emptyList()); profileList.setSelectedItem(profiles.stream() .filter(profile -> Objects.equals(profile.getId(), networkInterface.getVnicProfileId())) .findAny() .orElse(VnicProfileView.EMPTY)); } }
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
Setting the response header seems to be duplicated in three files. Please pull this out into a common method in a utility class.
For all asserts, provide a 3rd parameter "message", which will be printed in case if the assert fails.
getStringCellProcessor should follow same if else pattern.. Again do you need cellProcessor = addParseLong(null); Can cellProcessor not be initialized with new ParseLong()?
I think it should be items.length > 0
Only thing I've got here is that perhaps when you use this approach of design (interface - implementaion) then the implementation class should never occur anywhere in the code except for the constructing. So maybe a factory, or factory method would be more appropriate and the suggester service would be a part of RuntimeEnvironment? The point is that the concrete implementation is always hidden to the end user. If it cannot be done, leave it like this.
change
maybe you could rename this getNotFullFuture to waitForWriting?
Maybe we should just return something like "Device is offline"?
As this method is duplicated thrice, should make it static util function, int getLayoutPosition(boolean isRTL, int count, int position)
If getNextMergedRow() return null or a full row, then we don't need to translate from !isPresent to null.
There is a better way to do this, WorldServer holds a Map of 'entitiesByUuid' which you can use to directly lookup the entity.
Please check exception message
if getExternalNetwork() returns null, you'll end up with NPE.
try/catch
How about narrowing it to ClassNotFoundException and fail with other exceptions?
For PropertyChangedEvent, "args" will always be an instance of PropertyChangedEventArgs. Therefore you can also cast "args" directly, for example: String propName = ((PropertyChangedEventArgs) args).propertyName; Above should simplify the code a bit. It's up to your consideration, as for me the instanceof is just unnecessary complexity. BTW, we have a BZ exactly for this issue: <LINK_0>
Consider making these named constants DEFAULT_HTTPS_PORT and DEFAULT_HTTP_PORT.
I would keep the condition order as in the if on line 116 (or change the order there). The similarity between conditions is more clear this way.
Since this is in a super low-level loop of the driver, could we do an explicit check for isDebugEnabled here before we construct the string? Otherwise we'll create a stringBuilder, chararray and a string object twice every time a network packet is pulled in
just use string concat instead of format
The same goes for all the changes in this file.
Same question. E. g. in constructor, it uses NullHandling.emptyToNullIfNeeded(value). Could you also self-review once again ALL usages of emptyToNullIfNeeded(), emptyToNullNonDruidDataString(), and Strings.emptyToNull() (if there are any remaining in the codebase), and reverse methods?
This is redundant, auto-boxing will work just fine and IIRC unlike JGit we don't warn on auto-boxing in Gerrit.
Correct me if I am wrong, I think we record every "onControllerChange" processing time. So it should be easy to derive the latency from that log. I feel this log would be redundant a little bit.
This is the wrong error message. Should it be HIVE_PARTITION_DROPPED_DURING_QUERY? Or a generic HIVE_METASTORE_ERROR?
Remove these unnecessary logs.
Check that the RyaStatement and Config are not null.
suggestion if (!passwordViolations.isEmpty()) {  I think this should be negated.
this will be entry.getValue().executionDelay = entry.getValue().executionDelay - POLLING_RATE
suggestion msg = "&e{USERNAME} left the game";
suggestion return getInstance();
Use FileUtils.mkdirs
you can use here LockingGroup.VM.name() and not worry of some unexpected LockingGroup.toString() future implementation
return tags;
Maybe we should derive this from Prefs.getMediaWikiBaseUri() or require the client to pass in a default protocol. I think I prefer the latter to avoid complicating this nice and simple model type.
What in the... Please no. You can do better <3
typo then -> than
StringBuilder
use return ... ? ... : ...?
Hmm. I think we should retain a helper that fetches all boolean flags. That's likely the most common use case for this method, and it's inconvenient to have to transform the map to filter out just the boolean flags. Whatever we do we should square this away so that all the typed languages have the same API footprint. The untyped languages should be similarly consistent. Should probably sync up on a separate Quip doc on that.
"Generated wrong BigDecimal RexLiteral" does not clarify much. testBigDecimalLiteral clarifies much neither. Exception message should provide clear (to a developer who never looked into the test method source) indication on why the test failed. For instance: assertThat("builder.makeExactLiteral(new BigDecimal(" + val + ")).toString()", ..., is(val))
Seems like something that should be a field, probably static and final.
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Could we replace the 2, 3 with ProcessInstance.STATE_COMPLETED, ProcessInstance.STATE_ABORTED?
Can you make this if clause a block by using {...}? Supposing somebody enters a new line accidentally, then this method will end by returning false always.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
extra ; at end of line
Being paranoid here, is it possible that the checksum retrieval code is failing and returning empty strings?
childQuark?
We may want to log the operation / chain id? I'm not sure "this operation" will be useful in the server.log.
'null' must be first operande
suggestion boolean existJavaUserDefinedFunction =
could you change the value 20000 from a literal to a class private final static attribute?
I think we should allow to also log the stack trace by switching log level to DEBUG to enable analysing problems we don't yet anticipate
I don't see the benefit of this. It does make it less obvious that it is the same object having cancel called and being set to null below.
Make this and the one above a ternary return, i.e:  java return inline ? "<span ..." : "Equal ..."
This failure isn't related to container, rather the ingredient can't be used as a lubricant! (not a fat, but using something like chicken to grease!)
Maybe its just me, but this calculation looks wrong, since we are assign a = b, then b = a % b will always be 0, since a = b. Shouldn't it be: long c = b; b = a % b; a = c;
public isn't needed
1. this file isn't related to the create snapshot flow. 2. do you persist the placeholder to keep it compatible with the rest of the code?
Please name it "Shortest unique abbreviation".
Shaerable??
I wonder if we should try to be consistent here, one time we use "Reg" and another time "Registrations"
Minor performance enhancement - flip the && operands' order. This way, if archSupportSnapshot is false, you won't need to execute another costly FeatureSupported call
i think it can replaced by the use of List.of java 11, if it's possible as you did it below List.of(user1.getName()), thx
!bean.equals(null) -> lol ?
why not use a constant for that?
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
Encapsulation
Make the tick delay 0.
... yes it does ...
Such approach may cause the OverlappingFileLockException  if the lock is being already held by the JVM. It will cause an unhadled and random Runtime exception here. The best pattern is a loop with tryLock(), but surprisingly it also has to handle this exception.
"..getName()" is redundant.
Would it make sense to add this method to ResourceManager interface ?
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
nit: Could statically import these assertion methods.
how about: assertTrue(new RpmVersion("").getValue().isEmpty())
No null check for zone?
The super implementation is a no-op by design.
And then else if this
what about using IntSetsExternalization.writeTo() and IntSetsExternalization.readFrom()?
Can we refactor this out into a private method getCurrentLeaderEndpoint()? That will make the code more readable and reduce duplication.
We should set connection and socket timeouts here. By default there are no timeouts, so in case of network problems this may hang forever, which is pretty long. ;-)
I think the hashed custom API should be prefixed here by the R.string.analytics_label_custom_url? This would allow us to return a list (or count) of all custom APIs that we've seen. So, it would look like CUSTOM_URL=8nh2j02f.... Otherwise, if we have only the SHA-1 hash, we'd need to filter for all custom API URLs that aren't region names, which would be much harder to implement/maintain.
Given it's for a test, I don't really care but... I much prefer using higher-level synchronization utils from java.util.concurrent whenever possible, rather than synchronize. An object.wait() can wake up prematurely, which is why one should always wrap it in a while block rather than an if block.
@Override
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Rest of the class does this lookup in the DataPurgeJob instantiation, this should be there also for the clarity.
Since you're already calling initMocks(this), you can annotate all your mock objects with @Mock and remove all these mock() calls.
Please have test for null result.
Also verify the body being generated
BTW great use of atomic boolean here :)
Path and Package will NOT be available in Submarine.. is this meta-data essential?
Is the test for encoded wrong credentials missing?
the createFormatValue() implements the same code as above allFormatDefs = getPossibleFormatValues();
I would either inline this method, or give it a more precise name, like initializeContextPath
Again, multiple exception types that are handled identically can be grouped in a single catch block.
IIUC, there is a chance that users will never hit this path. Therefore, there is no need to load and initialize DnsServerAddressStreamProviders in advance. Can we use DnsServerAddressStreamProviders.unixDefault() here instead of a static constant?
I believe that this would break compatibility with older versions of Spigot. Keep in mind Factions still can operate on very old versions of Spigot (afaik, back to 1.7). I would recommend taking a look at how we maintain compatibility over here for an example <LINK_0>
Why log a message with the IP as a reference? The IP is dynamic, so when reading the log there could be no match with a device anymore. The DlmsDevice object is available, why not log with device.getDeviceIdentification() as a reference?
Hmm, I'd reformat to make it more readable: if (host.isInFenceFlow() && (host.getStatus() == VDSStatus.Down || host.getStatus() == VDSStatus.Reboot)) {
Also with explicit contentType check java if (contentType == null) { return callApi(data, ..); } else { return data.windowUntil(..).flatMap(fluxes -> { var contentType = getContentType(cachedBuffers); if (fluxes.size() == 1) { return callAPI(Flux.fromIterable(cachedBuffers)); } else { return callAPI(Flux.fromIterable(cachedBuffers).concatWith(fluxes.get(1))); } }); }  I think we just have to cache in the windowUntil operator i.e. no contentType check in windowUntil, the check can be deferred to flatmap operator.
Likewise here. Removing a PassengerData from an Entity should unmount the passenger.
Do we need these escapes?
pockemon -> pokemon.
Doc
nit: can we consolidate producerFencedOnCommitTxn to the more-general commitTransactionException? I.e. if you want to fence on commit, you just register the commitTransactionException as a ProducerFencedException
System.identityHashCode would be more consistent than reader.toString in terms of making sure that the name never contains a massive chunk of information if toString serialises the entire Reader to a String
yarn@EXAMPLE.COM?
@raphaelln please pay attention to indentation here as well
Why "next"?
flip this expression dictionary.getIdFieldName(currentClass).equals(currentField) to avoid the case that getIdFieldName() returns null
why not keySize? from all parameters of the called pattern, we select the bound ones... so the source width should be the number of symbolic parameters
We cannot just rely on hashCode for equals (because of complex object types, like DateTime).
Add and offer are the same thing for ConcurrentLinkedQueue.
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
Maybe better to return null
I think we should store ignoredRegions instead of ignoredLineNumbers. Single lines that need to be ignored can be stored as <LineNum, LineNum>.
See earlier question.
This is a strange one... you are setting one limited repetition and the other one unbounded repetition... does not look strange to you ?
Aren't there url's like this too? file://some/path/my.jar!org/foo/bar The ! is often used in java url's to indicate that it's inside zip (not sure if it's used in these kind though). I agree contains has false positives (like tony.jarvis) but endswith might have false negatives (like my.jar!org).
I see some improvement can be done here.Is it required to define method as synchronised.Can we use ReentrantReadWriteLock and get write lock here? It will be resulted in performance improvement
This logic is perfect, but for a while I got confused with connection being Connection and this.connection being AtomicReference. Can we rename connection to connectionRef to indicate AtomicReference?
toString usually is a "human readable" version of an object. Could you make a separate method on StartpointKey which generates the key for the store? Then someone won't accidentally change toString. Also, it will allow toString to be more verbose while keeping the store key concise.
Could the exception message include the name of the file that failed the permission setting operation? That will help us more quickly diagnose the failure in those cases where the caller shows the exception message rather than showing the entire exception stack trace.
Date[] boolean[] Boolean[]
You are still programming in Javascript here. :-P What about replacing "" with null here and remove "" from the variable declaration?
Why remove these?
Maybe some not-null check should be added here.
What is the purpose to catch it? can we remove the try-catch?
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
should probably be Integer.valueOf(10) purely for consistency reasons.
Would you please explain why clear() need to call ?
isEqualTo -> isEmpty?
I would just use ASC and DESC like the standard hive syntax
String.split?
The operation runs in a background thread; this access to get the checkout result may not work.
I think we should create a defensive copy of the Map
Use Assert.fail() instead
if interrupted and not rethrown as a good practice the flag should be set up back to the thread Thread.currentThread().interrupt(); _I'm not going to write this request on other places where it should be included_
Not blocker: please put a space after "catch"
Why not catch Throwable ? I have strange gut feelings for Error
Actually I think it would be good to have them split, even if the class internally used is the same. Passing an aggregation mode "NONE" is a very implementation-specific detail, and it doesn't make much sense for a higher level layer.
I am not convinced that using the stream API here is the right choice. What we are doing is to do computations with side effects. For that I would always prefer a traditional for-each loop.
woudln't it make sense to have the system register only if all dependencies are present? (Also I am not sure if this is a good concept in general, but since some people want it i won't object)
please add getMessage : {}\n{}
This will loop forever if the user sets a negative size.
Return null instead pls, and make sure we handle it correctly down the road (add @Nullable etc.)
nit: you can merge both lines above as checkNotNull will return the given argument
> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
We can do null checks and if host is removed or is some unsupported state like error etc.?
nit: if the only usage is to find diff b/ end and start, directly using System.currentTimeMillis() might be preferred option?
In this case, I find it easier to read the original version. It needs less indentation and shows more clearly what belongs together.
Consider using HttpUrlConnection.HTTP_OK constant instead.
@aertoria Can you change all the variable names in test method to not have _1
@fanifieiev RequestOf is a better name than RqOf.
No need to declare the types in new constructor, diamond is enough
This can be simplified as follows if(refresh != null) { refresh.cancel(); }
Also about this location, we have a cache subfolder in the data folder for all the github files, should we move it there? Then they wont be bothered with this jar sitting inbetween their configs?
We should turn the auth system back on after creating the test data.
I think it's slightly better to move this line to prepareEncoder method.
Maybe we should check the annotation type, in case we add value later to the other annotations ?
You should probably not store the previously started true value until the user completes the changing room and proceeds to the map, so in case the action stops in the middle, you don't leave an inconsistent state
Now it's correct! :+1:
Shouldnt we have this defaulting to the common namespace (ICommonAttributes#COMMON_NAMESPACE) so that we can tell the user what this defaults to?
please put record above as well.
use change(db) to ensure you have the Change object loaded and it isn't null.
This will loop forever if the user sets a negative size.
Please update this example according last changes in the master (look at the another preprocessors)
I think this should be stripe_account_id ? as per PP-4302
I think package private scope is enough for tests
I think you can just use alias.hashCode(). lists should implement it correctly.
Backwards? after:foo should match where last updated on is > foo.
what is this new condition about? is this related to the original story? anyway, this seems a good place to use 415/Unsupported Media Type
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
This may not be thread safe if only one sender is instantiated. We probably only want one sender or at least only one httpclient.
This is imho not fully clean. In the noargs constructor you keep the this.readonly uninitialized while you specifically set it here to false. I would prefer to have both constructors operate the same way. The easiest is probably to explicitly initialize the field in the class like boolean readOnly = false; and only keep the != case here in the constructor. Same for the other booleans.
@piddubnyi full path LastModifiedCachingWire.LAST_MODIFIED
No need to use UriBuilder
I think you need to assert that the return value is 0.
Why not to add message here also, even simple description can help to user or support, or if you will provide correllationId in description, it will help even better. But at any case message should be user friendly
Could we get a deadlock now in some cases? #reset holds a lock for the outer ProxyWhitelist, and when this is called it will also acquire the lock for the delegate ProxyWhitelist. Do we know that the locks will always be acquired in the same order? I would be surprised if there are cyclic references between instances of ProxyWhitelist, so my guess is that it should be fine, but it would be good for someone to confirm.
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
Add doc Add @Override
Why Integer is excluded? LongOrNarrower should contain all integers, should it?
use return ... ? ... : ...?
It would be slightly better to check that project is opened first instead of letting it throw CoreException in hasNature().
Same here. Also, this can be replaced with waitUntilNodeAppears. Platform.runLater shouldn't be used like that.
Maybe call finish() after startActivity()?
This is normally made so different implementations can override the type() method to go somewhere else in the objectstore - however you have a getType() on BACoordinator so it means no one could ever override the getType() from what I can see, maybe I miss something or maybe its not required but I do need some clarification
The rule @WithSystemProperty can be used instead.
It seems we would have a very small edge case where if the timeout future is set right after the task completes it would still be held in memory for the full duration. Thinking we have to check the completion state after setting the future and if it was complete then notify the timeout future manually.
Unneeded parenthesis. You probably can one-line this method anyway :)
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
There should not be a need to set this to public. Perhaps private would be better.
Not sure if related but maybe add some logging if the exception occurs.
Do a better distinction between String and Pattern, as in the [replace() method](<LINK_0> ?
Optional (and I know we're inconsistent elsewhere): createObject().cast().
A comma after "Source is empty" would make this more readable.
Let's remove leaseManager from class variable
Make a copy instead, so that we will not accidentally change the passed in map. Also add requireNonNull to make sure aliases is not null.
Long method, parts of this can be extracted
Here it breaks the format.
if (getWindow() != null ) {..} may help
The macs are just 'marked' as to be removed, only on 'commit' it will be actually removed from the pool.
remove changes in this class
could use a more meaningful variable name
getDrawable() is deprecated and will result in a logcat warning. Refactor to use the AppCompat library:  java ContextCompat.getDrawable(getActivity(), R.drawable.ic_info_outline_black_18dp);
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
exception
not sure we want to use joinSpan like this. if you have a span, wouldn't you just use it?
You almost got me right now. :-) There is no need to test the injection point. You only inject instances of this interceptor to the injection points where it should do its work anyway. Because of that it is unnecessary to provide and check the injection point. Just delete this method and the field and constructor parameter and change java private void invoke(IMethodInvocation invocation) throws Throwable {  to java @Override public void intercept(IMethodInvocation invocation) throws Throwable {  and you should be fine. :-)
Remove this increment
Do we need that log?
instead of calling an extra method for just one if statement (seems a little overkill), why don't you do one if statement to determine the validation status Status status = condition ? passed : failed and then one more line for setting the status if it needs to be set => 3 lines of code
if you have enum... never assume else... switch(enum) { case a: break; case b: break; default: throw new *Exception("invalid..."); }
Newline between @Test and public. There's only 4 instances like this in the libcore source, hundreds with it on its own line.
call byteBuf.release() and also add assertFalse(ch.finish());
replace || with bitwise I
I wonder if it's possible to change the logic of Util.isValidDate instead. Because if it's not parseable then is must be invalid too.
Let's make these final because we can :)
Super nit: unintentional additional white space I assume.
Why the hassle with lambdas? A few lines above a simple not-null check works fine too. I'd prefer a method in AttributeMap (what good is that class anyway), that ignores an attribute if a null value is given.
Unnecessary (and incompatible); revert.
be backwards compatible
Remove all these changes.
suggestion Assert.notNull(id, "Labelset ID must not be null.");
Here and elsewhere, the Fragment probably shouldn't force the host to do things by getting its internals and changing them. The dependency on a toolbar is clear because of the callback pattern but exposing the toolbar directly allows any Fragment to change it. It's ok to defer but consider pushing onSearchOpen() into the host and allow it to hide / show the toolbar.
Use try-with-resource block: try (FileChannel fileChannel = ...) { // use the resource } It will automatically close the resource when exiting the block.
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
Are you sure this is right? Please double check.
I think sassertdoesn't exist :)
any reason for explicitly invoking super.toMap() ?
Instead of doing this, we should store the host id into the FileAssetContainer and compare with the current host
Same here, && should not be used.
Need to check that the rebalancing actually finished and affinity reassignment is actually triggered after snapshot restore.
this should be java Throwables.throwIfUnchecked(e); throw new RuntimeException(e);  That way the exception is only wrapped if it needs to be. You can find out more about it here: <LINK_0>
what else? any warning or exception should be there?
this.monitor to avoid confusion with the parameter of the same name optional: this whole block could be a ternary: this.monitor = monitor != null ? monitor : NullProgressMonitor.INSTANCE;
use return ... ? ... : ...?
I think that may have been an oversight in longSum. Try a query that results in +Infinity at the historical level and you will see why it is needed to deserialize at the broker level
pls log the "else" cause of this if
rename to contribution
need to test with external monitor. can we use something like get_active_monitor?
Hello @mcimbora , I think it can be worth to provide a more fine grained filtering here. To be sure that the method is not a constructor, has the @Generated annotation, and also "is one of the generated" by the planner stuff. Probably inspecting some additional planner generated annotation for the method (I I don't remember wrong for this planner generated method you added has also a planner annotation with two parameters?) or eventually exploring the return type, or some other trick. This will prevent us from loading other methods with the @Generated annotation that we don't know how to manage. Specially because when the java source is being updated, all the accepted methods are being deleted.
do we care to check the length to be positive here?
System.out call :(
Don't bother. This doesn't help, as we found out.
static?
- log warning that option is not supported by SNMP
Can we set a charset? Like ASCII or UTF8?
Minor: Can you inline this, since getStreamConfigs is private anyways?
call super.hasMailAuth()
suggestion private String getModifiedIndex() {
I'd rather this method be split in to : "getMasterEquivalenceOnEOpposite" and "getMasterEquivalenceFeatureMap" with this second part you introduce. Do note that filtering might help here too : Iterators.tryFind(diff.getEquivalence().getDifferences().iterator(), Predicates.instanceOf(FeatureMapChange.class)). Not really necessary, but might make the loop cleaner (and remove the "break" while we're at it :)). I don't really like where this concept of "master equivalence" is going (yes, I know I'm the one who introduced it :p). If even more cases carry on creeping up on this, we might need to try and find a better mean to detect them and reorder (or rethink) the equivalence relationship.
return new StringBuilder().append()....toString();
As IOUtils has been imported why not just use IOUtils.closeQuietly()?
Shouldn't this be the thingType id instead of the modelId (modelId can be logged as well, but the primary information should imho be the thing type)?
Mappers can be stored in static final variables instead of rebuilding these each time.
You can use Preconditions.checkArgument() here, if you like.
unsubscribe()
We could maybe moved this where return processed is so its only evaluated if needed
could use |= if you wish
It's a warning. Do we want to log the complete exception stacktrace for a warning? Check with <LINK_0>
Hi @stevenschlansker, I think this should be Throwable (_the father of all errors_). The Error case is very specific and I assume it was only provided in #1405 as an example to demonstrate the problem, but in a wild there is a bunch of Throwable monsters (especially in Scala) which are neither Exception nor Error but which extends Throwable and can easily flip stack trace upside down. Therefore, if there are no other reasons to limit a range of throwables being caught here, I think this should be changed to: java } catch (Throwable t) {  Both Error and Exception are instances of Throwable, but the Error is **not** instance of X extends Exception. I guess this works only because IDE or compiler did not pick it up, because generics are erased in compile time and X extends Exception disappears, or maybe, just hypothetically, because Error is a magical monster which can be cast to any other exception (but I'm not aware of such magical Error properties).
Since Kieker now requires Java 7, you can use the try-with-resource clause here.
nit: Unnecessary "//" characters.
We really should define an order here. Right now you might get a random localized name, if I understand the code right. I suggest: housename, int, loc, reg, alt, old Also, note that again only NAME has other names than the default and localised ones. So a special handling of the name would be a good idea.
Hello @mcimbora , I think it can be worth to provide a more fine grained filtering here. To be sure that the method is not a constructor, has the @Generated annotation, and also "is one of the generated" by the planner stuff. Probably inspecting some additional planner generated annotation for the method (I I don't remember wrong for this planner generated method you added has also a planner annotation with two parameters?) or eventually exploring the return type, or some other trick. This will prevent us from loading other methods with the @Generated annotation that we don't know how to manage. Specially because when the java source is being updated, all the accepted methods are being deleted.
nonVmMtu5000 ==> nonVm
is this the 'button' described in commit message? do we really need this Label?
lastComputeYielded
This is unnecessary duplication, it would be better to call the other findTasksAssignedAsPotentialOwner with default sorting.
It would be better to check return msg.getFlags() != null && (msg.getMessageStar() || msg.getFlags().contains("starred"));
You have a typo in unlfoldModel. Also, I'm not sure if that's the best name. Either unfoldedModel or flattenedModel, I guess.
data.size() sounds better! I'll rename it. Thanks!
typo in pathUi (pathUri)
Should LASTeam.class be also required in the list of components here?
I think you misused a bit this variables. It should be used like, if you know you need something later or multiple times in the following state, then you put it here, and get it later. So you should know when to set it, in which state/action. Trying to set it in every action, as you do it with adding this logic to context building, makes it loosing it's purpose. Also if you won't do this in every "step", only when you have to, we could avoid using instanceof.
I'm not sure it's desired to switch the lookup to not use Syntax.HELP. Why not just add the missing properties to the HELP, along with some helpful information? You can draw that form the existing docs.
Simpler as getMetric(fieldName) != null
For consistency, this should come from the Builder
You updated the port which is good - can't we have the hostname be localhost as well?
instanceof is null check itself.
hmm, that method makes somewhat sense in core java, but I'm not sure I like that behavior for selendroid. We're expecting a boolean value, but essentially we only care about either true or "true" coming across... everything else is false. Is it going to be confusing to any users? I'd almost rather add an additional else clause to check for the string of "true" or "false", otherwise raise the exception. Since users of other programming languages (like javascript or python) may have a different impression of what a truthy value should be.
If we remove the null check, will it results in NPE? (Line 74)
What's with the null check?
same here re map assertions
You could return empty set when user is not logged
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
can you add some docs around this method.
redundant filePath at the beginning the message
Why call setScrollBar() twice? (L157)
Should not this logging be removed?
the steps 35, 36 and 38 are not neccesary
Should be here ac.stateChangingCheck(); @zlamalp?
make this method synchronized. just in case it gets called twice in same time.
Why have you moved it into try block? now we count something (potentially long) before closing the archiver.
What about testing the happy path - that a POST is made to a correct URL if correct arguments are provided?
this method should be explicit about the encoding that the resource will be decoded as. ( utf-8? ) or the system default? I worry about internationalization issues with this method. we should force utf-8 (unless for some reason we don't want to do that?)
Why are we loosening this test? Seems we knew the User ID before this change. Is it no longer possible to match this on the passed in assertion
Alex, I don't think they can be merged. getLong is still missing in the code base. Committing this patch without test seems a bad idea to me.
That's a separate behavioural change, should be done in a separate patch, if at all ("just wait for the varints bro").
It was previously returning null when a db error occurs, so I hope whatever is calling the function can handle a null return. It's worth double checking. If it already handles null, returning null is fine.
Please add null check for entity.
Why remove these?
move it to new test
you can't get here with vm == null, so it should be removed from here.
I believe this is the cause of your failures as you are setting up a Java17 project which will be called TestSetup17project or something like that.
Expected before actual value.
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
ex is never used
Can you also add this to the application logging through use of Slf4j.
map(Queue::getActualName)
This IMHO introduces a rather surprising piece of global state into the translation. What about extracting a relativeTo(namespace) method that returns the appropriate Function?
Cannot render banner ad. -> Cannot render interstitial ad. AdMob console -> AdMob UI. Please apply this across all messages.
Same question here - what's the purpose of removing the null check and setting objectMapper to null?
Why did you replace manual modification of files by changing them through the TestGitHubRepository?
Shall we change notebook -> note in log too?
Since the method is simple public synchronized Project removeProject(Project project, User deleter) throws ProjectManagerException { projectLoader.removeProject(project, deleter.getUserId()); projectLoader.postEvent(project, EventType.DELETED, deleter.getUserId(), null); return project; } Would using mockito to verify the internal calls be a better test? This will cover for example the user parameter is passed correctly.
As discussed, little more cleanup has to be done in attach store
I have some doubts about the change here. In this case, the attempt is exactly to alter the current ResteasyProviderFactory instance (yes, I agree, that's not a best practice at all). By creating a new instance and not setting it in the singleton reference within ResteasyProviderFactory, you're altering the test. I suspect this is not spotted by Travis CI because the test here is likely not running due to the exclusions for RESTEASY-1935.
Please remove unnecessary parenthesis: !ag.getVdsIds().isEmpty() || affinityGroupContainsRunningVMs(ag, runningVms)
userId instead of u
It looks annotation is only used in the if (invalid) so this part could be moved there (and we will gain a bit)
There should be a null check here if it doesn't accept null values
shouldn't we actively check that _no_ changes have been made on dcs that should not have been touched? These tests currently seem to only ensure that changes go in and they are correct (correct me if that is wrong)
This could potentially take a long time. I'd probably request more time from the commcare service connector so the app doesn't time out trying to connect to the db (I think the fixture migration code does this)
Hi Ravi, First of all, congrants on finding this out. Second - I think that while you're on the process of working on KerberosManager, I think we're making a mistake here that we're not throwing an exception if krb5 conf file in case we do want to use kerberos auth. Regardless, I think that the system property you discovered. should be set only if the krb5File exists.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Do we want a space here before the brackets?
while(it.hasnext())
Again, could be a much nicer one-liner using Java 8 streams and/or StringJoiner.
Doesn't it override user decision when user de-selects this radio button and rotate the phone?
I'd like to see the code further simplified if possible please. If calling Thread.interrupt() on an already interrupted thread is a no-op, then I'd suggest the following instead...  if (exception != null && !currentThread().equals(testThread)) { testThread.interrupt(); }  ...and remove the testThreadInterrupted field and the separate interruptTestThread() method. Note: this is common practice to move the possibly-null variable to the argument of equals so that a null value returns false for equals without requiring the extra != null check. For example: "nonNullString".equals(nullableString) instead of nullableString != null && nullableString.equals("nonNullString") Note: also common practice to put the cheap-check first in an if condition: if (exception != null && !currentThread().equals(testThread)) ... instead of if (!currentThread().equals(testThread) && exception != null) ...
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
onErrorMap?
This does not need to be public. Instead, just pass the builder to the private constructor. See what we do in HtmlRenderer.
Just because nobody else currently needs it besides the class itself. I typically keep things as restrictive as necessary and increase visibility when necessary, or when ready to provide a public, stable API.
If the requested encoding wasn't available, do you really want to return the string in UTF-8 as opposed to simply failing the method call?
might be worth logging here, JiC
Shouldn't this be: FailureItem.of(FailureReason.PARSING, "CSV file does not contain '{}' header: {}", TYPE_FIELD, charSource));
lambda?
add a check that no bitstreamformat has been created
Optional: better to invert equals to avoid potential NPE
studentsWhoRespond -> studentsWhoResponded
Should be dispatched from UI thread, see TimeGraphViewTest:225.
Qualify this.uri
Why not just add another column to the table between name and version?
couldn't we just read the boolean as a string (I would assume that this return "true" or "false"), migrate if to its new value and keep using the same pref key?
Forgive my ignorance, but why perform these calls if we expect only a single element? EG: String annotationPattern = annotationValue[0]
You have changed the existing JenaTextExample1.java that was an example of how to use jena-text/Lucene. Make a copy instead, leaving the original intact, since we need to have an example of how to configure a Lucene index from code. The new class could be called JenaTextESExample1 or similar.
Tip: we can use StringUtils.stringToInt() here and in getWidthInt().
bikeshedding, but return null and then put the tid under.
do we care to check the length to be positive here?
Missing randomDiscard param.
suggestion sb.append("QueryImpl{"); sb.append("filter=");
Can we use a try-with-resource pattern here?
Hello @mcimbora , I think it can be worth to provide a more fine grained filtering here. To be sure that the method is not a constructor, has the @Generated annotation, and also "is one of the generated" by the planner stuff. Probably inspecting some additional planner generated annotation for the method (I I don't remember wrong for this planner generated method you added has also a planner annotation with two parameters?) or eventually exploring the return type, or some other trick. This will prevent us from loading other methods with the @Generated annotation that we don't know how to manage. Specially because when the java source is being updated, all the accepted methods are being deleted.
Might be clearer if you actually check that sampleRowKeys.size() and bundles.size() are 1. Also a check on the estimatedSizeBytes will make things clearer.
&& buffer.isBuffer()?
Is this check only needed in the MigrationRunnables that modify the partition table? Is it needed in MigrateTask?
Do we need these escapes?
@davecramer Would it be better to do LocalTime.MAX.equals(localTime) here, instead of using the reference equality? Otherwise there will be a difference in write behavior between a LocalTime that has a value of 23:59:59.999999999 and when using LocalTime.MAX, even though they are value-equal.
This would call the same method.
cool :+1: that you use this Java 7 sugar.
nit - move the deceleration one line up..
if previous one is not deleted after dump is done successfully ..then there could be 2 dump directory
I would think that you should have some kind of synchronization/locking to avoid that several threads are requesting the client concurrently and executing the initialize method in parallel.
My personal preference is to use brackets even for one line loops and condition. Not a blocker to merging.
ditto about anyMatch usage & readability of the condition.
Newline between @Test and public. There's only 4 instances like this in the libcore source, hundreds with it on its own line.
Would you also add an IS_NULL filter here?
You can do only a single if with  if (!(o instanceof Map.Entry)) return false;
nit formatting 2 spaces.
Need to verify no interactions with log
formatting
does this need to be synchronized?
I suppose make it private and create via static method. To make it easer to support compatibility in the future)
No need to change this; just an FYI. We put in quite a few of these early in AS7 days, but they can be just an assert delegate != null; If this is null it's a programming error, not a mistake in user input.
Use 4 spaces for indentation.
Eh, I mean, you could try delete the null in .getByResourceGroupAsync(this.resourceGroupName(), this.name(), null);. If it compiles then all is good. If not let me know. It should works same on .getByResourceGroupAsync(this.resourceGroupName(), this.name()); The null is there when the above overload method is not generated by old generator. So yaohai added the null to build pass and add that TODO.
isConnected should be set to false here.
Is it really necessary to put the full enum name here? If yes I'd actually be surprised because I'd consider values() a static method of every enum
better return a null object (new Pair(this, null)) or throw UnsupportedOperationException
I guess all this (and the finally/close) can be simplified with try-with-resources.
Rather than return a new arraylist - just return an empty iterable, e.g. return Collections.emptyList();
add brackets around if the clause or move on to same line.
no need to specify types on RHS
It's a bit odd to see here a mess of public static and other methods. Does it make sense to move public static methods into util class and make this class visibility is package? Or if the goal was to avoid unnecessary serialization lets define this somewhere explicitly.
Can this be accessed by any user? Should this be restricted to users who have permission to access the pipeline?
check whether Exception throwing
Presumably the method getAllGroupsSize in KeycloakUtil was written so that it could be used here?
Exception#printStackTrace goes to stderr by default.
Similar
putMonitoredEntity
why not use the field directly? In fact, perhaps checking fSSAssigned instead would be clearer.
then we need a MapDataFetcher
Why can we remove the finally block, InputStream and OutputStream not being AutoCloseable?
Can we catch a specific exception here?
do not assing parameter! nowhere!
so, reopening an existing table on which we also did activate AutoCellHieght, then unactivate -> you get a BooleanValueStyle with the false value -> your assert will break all...
You can remove this line and use directly this.value, like you do in other places.
this should be checkBasicAPIs(strings, deserialized, false);
please make this assertion before the hasSize. Otherwise the error message we'll get will still be 50 vs 55 and not the list of missing stats
@essobedo field type can be relaxed to simple Map as we don't use ConcurrentMap specific operations
nit: spaces around + I'd also change / to use OS-specific path separator, i.e. [File.separator](<LINK_0>
unsubscribe()
this should be moved to @BeforeAll
You don't need to return anything here, as it's unused.
so even if exception occurs, we return with 200 OK? feels way wrong
I imagine this should be !Functions.isWindows(), rather than being hardcoded to true.
Why we should avoid using ContinuousFileMonitoringFunction here? and why not return SourceFunctionProvider of InputFormatSourceFunction directly?
white space
i would put in threads.lengths as initial capacity micro optimization
Store these string constants in the NBTDataUtil please.
Is it possible to break this out into a separate file as a subclass? I think adding too much to an Activity or Fragment is tempting but once we get a third card type in will start getting a bit hazy.
Don't think items can be null, and ArrayList (as well as List and Collection) has an isEmpty() method itself...
Since you're already calling initMocks(this), you can annotate all your mock objects with @Mock and remove all these mock() calls.
Given that the env itself can add config options later, maybe the message here could change to reflect that this is the effective configuration at the CLI client or after the addition of the CLI options. Although a bit esoteric, this is a debug message so I think it is ok. If we want the actual effective config I think we should go in the env.executeAsync().
Ok. But so to be extra clear, we should still always block commits from happening during a rebalance when eos is used, yes? I'm guessing it has to be that way since that makes sense, but if you have any thoughts about a possible alternative fix for eos let's at least make a ticket for now. I guess so long as we can still return data during a rebalance then 429 is still useful for active throughput of eos..
I think you're loading a CourseCategoryDAO by primary key so you Can just use session.get(Class, Serializable) which will only ever return one item.
why 0E0 and not DOUBLE '0'?
Strictly speaking, you should make this ApplicationContextAware and check the context in the event matches. We don't want to react to events from other contexts in the hierarchy - maybe not relevant here, but best practice.
I prefer using Preconditions.checkArgument over asserts (at least for cheap things), since the former will always run and catch issues that might crash at any point early even in production (IIRC assert is disabled there by default).
I think you need to use the 'message' field here.
suggestion if (hasVersionProperty() && hasSeqNoPrimaryTermProperty()) { logger.warn("Both SeqNoPrimaryTerm and @Version properties are defined on {}. Version will not be sent in index requests when seq_no is sent!", getType()); }  We can remove then the duplicate warning from line 254.
execRoleName must be changed to viewRoleName, right?
Nitpick: We can do the if else together here :)
I think HttpRequestUtil(request, "publish_id") is better
nit: we've followed the pattern where the sync APIs call their next max overloads -> this sync API should call the sync API overload with Context.NONE.
Catch relevant exceptions.
port number is hardcoded
This should probably go to System.err, as goes e.printStackTrace()
It's not an issue but I think that it's better to put the both checks on a single line (if (!dir.exists() && !dir.mkdirs()))
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
Should be able to do a for() loop here as the class implements Iterable, no?
I would expect the default to be false. Don't allow remote installation.
I this refactoring, very nice. Could make this method protected.
Very nice change already for that!
Is this still needed? We don't add any other elements, so parent.get(anythingElse) should return null anyway.
This should be greater than 0 or else your % operation is going to get interesting.
This method needs the same processing that happens in addJavaOption.
There should be a null check here if it doesn't accept null values
We deserve at least a DEBUG log here.
unused try catch block
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
Shouldn't this apply to more code above? (the try block) Too bad we can't use java 7 constructs.
java .subscribe(new Action1<ResultType> { });
can we avoid passing null here? and introduce constant like IndexOrder.NONE for that instead?
For objects we provide human readable NullPointerExceptions. Please add a  java Objects.requireNonNull(clazz, "clazz is null");
Since you're already calling initMocks(this), you can annotate all your mock objects with @Mock and remove all these mock() calls.
Can't you keep that one at the top? Let's avoid the cast if we can.
could be simply if (reAggregationFlag || (aggregationFlag && !rawService.getStatusAgg(...)))
Put the getStat call inside the recordPathStat parameter list is no longer clean. Please create a local var for the state and pass it to the record method.
Is this needed as doesn't the later loop remove them all?
Suggest using instances of java.util.AbstractMap.SimpleEntry instead of making a bunch of anonymous classes.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
if i get it right: if response is null, we will not retry. i think we should retry even if response is null. btw what caused this in your case? so it would be:  response == null || ....
If opening is true, doesn't it mean it's still opening but not done opening yet?
isn't it irrelevant for DirectLUN disks?
Is it safe to remove all of these?
We will never have touch notifications here for elements with a font syle different from Normal. Each setXXX(false) will produce a notification followed by the corresponding setXXX(true) notification: we will have two changes notification instead of maybe a touch one. Something like fonStyle.setBold(labelformat.contains(FontFormat.BOLD)); might be better.
Why not the default instance?
Why scheme has to be hardcoded in configuration ? Can it be auto-detected programmatically ?
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
Could you please change this to:  throw new ArtifactStorageException(String.format("Invalid checksum [%s] for artifact [%s]", checksumStr, artifactPath));  Thanks! :)
The SqlDatabase db field can be removed now that the value write for it has been deleted.
Is there a reason for using stringbuffer instead of stringbuilder?
![MAJOR](<LINK_1> Rename this method name to match the regular expression '^[a-z][a-zA-Z0-9]*$'. [![rule](<LINK_2>](<LINK_0>
Add here if (outlinePage != null) { outlinePage.setSelection(new StructuredSelection(selected)); } to make the normal outline page follow the selection in the quick outline.
nitpick: think the superfluous Assert adds a Codacy alert
Please follow the strategy employed in ParallelExecutionIntegrationTests to make these tests faster.
same as for backup, general context creation should go into abstract
What if a student or unregistered user calls this endpoint?
Is it really necessary to put the full enum name here? If yes I'd actually be surprised because I'd consider values() a static method of every enum
isn't used...so perhaps do not set?
I think that may have been an oversight in longSum. Try a query that results in +Infinity at the historical level and you will see why it is needed to deserialize at the broker level
What is the reason you do not follow these standards?
You need to remove all the parts about property and instead look for other nodes in the metadata.
We can throw the exception to client.
add the exception object to log - e.g log.error(customErrorMessage, e);
break?
Release needs to happen here as well.
it doesn't make any sense to allow boolean fields, as this model is for text. It should be a string or nullable string. Don't need to support an array of strings either, should just have an optional split pattern as a property that defaults to whitespace.
Do we expect MSAL to return an expired token ?
Should be +1000L?
return index == 0;
Same issue here, double delete user.
s.a.
startin -> starting
can you add @since 11.1 for the new properties
could you just do a poll and, if the entry is not null, return it (instead of continue?)
"ITask" selection is not processed now. Also, it would be great to amend commit message - "EBZ#492124 " should be changed to "Bug 492124" - this will link gerrit change with bugzilla automatically and will make it easier to track
Use context.getApplicationContext() to ensure the class can't leak any shorter lived contexts that might be passed to it (it's always fine to hold onto the application context, since it's expected to be around for as long as the process remains alive).
I think <= ? If name space was 0 you would want x=0 to be OK.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
What does it mean to have the list set to null? As soon as compareCaches() will be called, then calculateAllDistances will be called as well, and there will be a NullPointerException in the for loop. Does it mean that compareCaches() will never be called on the singleton? If this is the case, why not use null instead of this singleton? I'm not sure I follow the logic here.
Camel case
remove unused whitespace
parentheses please ;) return (number == null ? null : Long.valueOf(number.longValue()));
Btw. I think currently this else branch cannot be reached anymore, because according to the plugin.xml the command is only visible on RefNode, TagNode and AdditionalRefNode. Or did I miss something?
Thanks for this. We have a util class, ServerReload, that should be used for this kind of thing. It looks like moving this test to it was missed. The block here looks the same as ServerReload.executeReload(managementClient.getControllerClient(), false) so please use that instead. I thought it might be, but the ServerReload.executeReloadAndWaitForCompletion call is not appropriate here as this test is asserting some intermediate state while awaiting completion.
Use an entrySet() here to avoid having to re-do a get(key)
Consider using AnnotationUtil.getAnnotation(...)
I would add cache=true/false as a parameter.
This isn't a test, it just prints it out. What we want is something that at least checks that the output is a non-zero % number for example.
add style as parameter to above 2 methods
Maybe rename this addConstraint as it does not create the constraints anymore.
Please use diamond operator, you don't have to repeat time a second time. ArrayList<Integer> a1 = new ArrayList<>();
use return ... ? ... : ...?
[minor] Do we want to show nulls here, or use omitNullValues?
Can you add a CommonHelper.assertNotNull("delegate", delegate); check?
I think this kind of breaks the current API contract in a subtle way: while this is ABI compatible, subclasses will fail at runtime trying to add up to the base class collection of in-app packages.
- log warning that option is not supported by SNMP
CI build shows 90+ failing tests, and they all appear to be caused by this change. Perhaps some of the other converters are lossy as well, and some of the failures appear to be for objects which do not have hashCode and equals methods defined, so the comparison fails because we have distinct references before and after deserialization:  junit.framework.AssertionFailedError: <camera name="Rebel 350"> <n> <name>foo</name> </n> </camera> vs. <camera name="Rebel 350"> <n> <name>foo</name> </n> </camera> expected:<com.thoughtworks.acceptance.AttributeTest$Camera@50d640dd> but was:<com.thoughtworks.acceptance.AttributeTest$Camera@447bf09d>  Also one small nit, I would change the spacing to make the failure messages a bit easier to read: suggestion assertEquals(xstream.toXML(expected) + "\n vs.\n" + xstream.toXML(actual), expected, actual);
Maybe "Default instance resource, CPU: %f, RAM: %s, DSIK: %s"
Is a public setter necessary? Can the abstraction be the CentralRepositoryAccount instance itself, rather than the primitive?
nit: both these statements can be included with above try (Statement statement = conn.createStatement())
Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.
You should check if getRepository is null
Perhaps safer to construct a new List using subList as you otherwise have to make an assumption that Files.readAllLines will always return a concrete List that supports the optional remove operation.
Same issue here, double delete user.
As a non-admin user I am not able to set the account's own name.
Good point :)
suggestion ______TS("Instructor attempts to edit student's response, but without appropriate permission, "
RefNames.REFS_CONFIG
If you do = Lists.newArrayList() then you don't need to repeat the generics (importing the guava Lists).
Why Integer is excluded? LongOrNarrower should contain all integers, should it?
Default the member variable to Proxy.NOPROXY. Never mutate or translate a value in a getter, it breaks all expectations that the caller will have. This one breaks the relationship between the get and set.  options.getProxy(null); if (options.getProxy() != null) System.out.println("Whut?!");
suggestion LOGGER.trace("The service with name [{}] is not found in the cache, try to find it from [{}]",
It might be a whole lot easier to just use logger.error() here rather than trying to report all the errors in an exception.
Can we log ex.getLocalizedMessage() here
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
I would recommend removing the isInitialize flag (and make deleteExtraSegments private) and adding a new method deleteAllSegmentsForStoreIds(List<String> storeIds) for the non-init use case
Is using mAdConfig here make sense? We should use banner size that returned in VungleBannerAdapter#getSupportedAdSize().
findbugs will tell you there is a NPE here... as Jenkins.getInstace() is checkForNull
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
Hmm, shouldn't we break the processing and return the error? If we fail to submit search for one server, we may not return correct results ...
Is it practical to do any more-specific validation on the arguments here?
Warn log level seems to high for a normal state transition.
ignore case => don't build this screen.
It might not always be a lambda - someone could implement their own concrete flow.define(). We should check bean.getClass().isAnonymousClass if needed, but I suspect we don't need to know whether it's a lambda or not.
Should not change this file
Should it be node.getChildCount() > 1 ?
Is this still needed? We don't add any other elements, so parent.get(anythingElse) should return null anyway.
Does issueRequest ever return null?
Isn't this always true at this point?
Technically, that should never happen, but why not ^^
We should use new [StringUtils](<LINK_0>
final
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
This seems entirely redundant (if the idea is to restrict the allowed methods, it still lacks a default branch and could be a lot more compact with a fall-through).
I don't understand why you verify if filterChain needs to be updated with every message read. Maybe filterChain should be volatile.
This is somewhat confusing to read - why does setup() call something named validate(), instead of setting up the cluster? One has to go to inside validate() to figure out what is going. Perhaps it can be named setupClusterAndValidate(), or something more readable?
This is a super interesting idea. I like this a lot. For debugging it might be good to get both the display and data text in case the data has something interesting going on. Also: Would be good to make sure every wrapping call like this is 100% execution safe. It's good to check the null thing here, but would like it to be the case that it's impossible for our logging calls to crash things if at all possible (not sure how cleanly we can wrap those contexts in java, though)
All tokens with blocks should be here:  TokenTypes.ANNOTATION_ARRAY_INIT, TokenTypes.ANNOTATION_DEF, TokenTypes.ARRAY_INIT, TokenTypes.CASE_GROUP, TokenTypes.CLASS_DEF, TokenTypes.CTOR_DEF, TokenTypes.ENUM_CONSTANT_DEF, TokenTypes.ENUM_DEF, TokenTypes.INSTANCE_INIT, TokenTypes.INTERFACE_DEF, TokenTypes.LAMBDA, TokenTypes.LITERAL_CASE, TokenTypes.LITERAL_CATCH, TokenTypes.LITERAL_DEFAULT, TokenTypes.LITERAL_DO, TokenTypes.LITERAL_ELSE, TokenTypes.LITERAL_FINALLY, TokenTypes.LITERAL_FOR, TokenTypes.LITERAL_IF, TokenTypes.LITERAL_NEW, TokenTypes.LITERAL_SWITCH, TokenTypes.LITERAL_SYNCHRONIZED, TokenTypes.LITERAL_TRY, TokenTypes.LITERAL_WHILE, TokenTypes.METHOD_DEF, TokenTypes.SLIST, TokenTypes.STATIC_INIT,
The overrides contains table names so we should treat it as unsafe, or sanitize it as we do above with safeTableNamesToScore . The set of people able to view the safe logs may not be the same as the set of people able to view and edit the config (and hence know the table names).
also use a map here (this is likely to be extended I guess)
wait what? Why are you changing it if and only if the data is present?
you should just add ", InterruptedException" in the signature of this method, no?
So this will fail checkstyle right off. if (row..... should be if ( row ..... Please make sure you run the site target in Maven to get the checkstyle output and then navigate to the target/site folder and open checkstyle.html to see all the violations in your PR. This line would fail.
Let's rename locationModule to just module. Then we can bind SessionPropertyProvider inside the module. (The name is already bad, as it's no longer for location. I missed that when converting to Drift.)
Place in ApplicationConstants instead.
Add a check here to verify that the broadcastSerialDataReceived method was not called.
Hi, Don't we want to put the entire hierarchy that created the task at the commands map?
String log = "..."; assertLastMessageIs(log)? for me, assertLastMessage(...) isn't clear what the assertion is doing (without looking at the method). - edit... assertLastMessageEquals(String...) I guess "equals" is more familiar than "is"!
This is unnecessary, you can remove this check <LINK_0>
Very good point! We should always specify the encoding, and static analysis is very quick to point it out. Instead of defaultCharset() however, I would explicitly specify UTF-8. Guava has Charsets.UTF_8 for instance (I always prefer that than Charset.forName("UTF-8") and risk messing up the string). It does restrict the external processes to output in UTF-8, but I don't think it's a problem, UTF-8 is so common. At worst we could always add a parameter to pass the expected charset.
Response is never closed
there are multiple uses of these values in different tests would be nice if you could move them to constants with a descriptive name. especially height and width because they are always the same
off topic: I've been writing this as "client == null". I think this conveys just as much information in fewer characters, so by Shipley's law I should switch over. The drawback is that "client == null" is a boolean expression, and is consistent with "limit < 0" etc. . .
space before the colon
Instead of using Boolean.valueOf(boolean).toString(), just use String.valueOf(boolean)
couldn't this be handled via a stream + filter or a sub method + return?
what's the point of giving 5 here if you're not comparing with it later?
These catch code blocks seem to be very repetitive, should they be factored out into a utility function/lambda?
Hm, so when I originally wrote this, I intentionally ordered it to check for these 2 states (if the app resource state is corrupted, or the currently seated app is not usable), _before_ checking for session expiration, so that you couldn't end up on the login screen with a corrupted or unusable app as the seated app. I don't have hard evidence that this is necessary, but I think we probably want to still preserve that behavior.
I think 403 forbidden should be used instead as server understood request and entity is valid but value in entity prevents fulfilment of the request
Navigating again...
Would it be more appropriate to define host/port as constants ?
Use Assert.assertEquals
This remove will not occur if the group or store removal fails and the scheduled future is already "spent". We need to reschedule in that event. Same delay?
Inject it as a regular Spring bean
nit: you can merge both lines above as checkNotNull will return the given argument
I assume this lazy initialization should never happen as we will always initialize this field in class constructors, agree?
Remove the public modifier from all injection constructors.
Not really.
Baking this logic into RollingUpdateOpFactory this way seems a bit out of place and conflated, but I see that you need to emit an event AND move to the next task. Looks like it's time for some refactoring of RollingUpdateOpFactory...
just write return stage != null ? stage.getStageId() : null; spare some lines : )
Below you defined openRepository() to be exactly this. Use that method here too?
Not a property that open source HBase or Phoenix recognizes.
Typo: Somehow an extra 'And' got introduced here
I'd return suggestedId for the time being, but if you have reasons to keep it this way for the time being I'd be ok with it.
embedcode2 - please name it according to the purpose of usage
The problem with image. It is a local variable which is returned to the caller, but you still use it in parallel as a container for image data. Situation to consider - user e.g. draw image on some panel, but in parallel the image is updated with a data from camera. Possible side effect - half of image is from old image and half is from the new one. This is because there is no synchronization between operation on image data.
I wonder whether the upper bounds should rather be: x < this.maxX and y < this.maxY as current this is inconsistent with the int version of this method, yielding for exact integer coordinates false with the int version and true for the float version (for exactly float-representable integers).
why store is required in two places. its already stored before submitting entities
Current assumption why we see some missing parts in WS is that we should apply the current transform to the clipping before we intersect it with requested one. We are investigating in this direction.
needs to consider customAttributes?
maybe return EMPTY_LIST that way we can make expansions final or even better if we have a constructor that assumes expansions list is empty.
Shouldn't it rather throw an UnsupportedOperationException? Alternatively, it could return new ByteArrayInputStream(buffer).
My question was more about why this specific test is looking at nonNative while the others are all looking at simpleOrTini(), since it looks like before this change there was no code to check for zombies at all anywhere, so it's not obvious to me what is special about the native platform for this test vs the other tests. No strong opinion on whether we want the zombie tests or not. If they give use useful information on the other platforms, then seems fine to leave them in to keep us from accidentally making a change that regresses the behavior. If they are pointless because all of the docker fixtures pass --init and so it doesn't matter what our script does, then it seems better to remove them.
Cant we do this massaging in method getTaskMessage itself ?
Not sure, would it make sense to have this in a finally block to ensure that messages are sent even if an exception occurs?
no need I think. iccRecords is null always if uiccProfile is null.
At this stage, we shouldn't have dependency on StringHelper.encrypt because this method has dependency to the encryption key set in the application. We need to either: - Set up another encryption method that is configured via test.properties used by E2E tests. (not preferred) - Modify the API layer such that all keys that are returned are already encrypted. I am of the belief this is already the case for non-admin user-facing endpoints.
> Alternatively, as we're concerned about usage of the image in a Wiki article, I think it makes sense to copy the wikicode for the "thumbnail" image rather than the wikicode for the full image. I agree with the thumbnail approach, pictures are almost always displayed as thumbnails in wiki articles AFAIK.
this is being called on a different flow now. is this intentional?
This condition would effectively exit from the loop at the first iteration, so it will hurt performance.
I'd prefer to remove the field itself. Feels a bit unclean to have a field which is only valid during the execute method. It should be a local variable in execute and passed as an argument to getTagTarget. What do you think?
good practice: usually actions go before WS as they are injected into it and so they are grouped together
I see some improvement can be done here.Is it required to define method as synchronised.Can we use ReentrantReadWriteLock and get write lock here? It will be resulted in performance improvement
We should return true here to ensure the menu is displayed.
I like the previous containsNull variable name better.
Don't call ts.getParameter(key, ERROR) twice, put it in a local variable. There's some redundancy between downloadBlob and downloadBlobStatus, so maybe some things could be factored?
You can delete both calls to Clazz.methods() since we no longer allow the annotation on methods.
Remove trailing whitespace here.
Should be exchanged.
If you want to be fancy, method reference can be used here suggestion .map(SObjectDescription::getName)
why do we need a loop if we break here?
parentheses please ;) return (number == null ? null : Long.valueOf(number.longValue()));
I doubt this gives you what you want, especially in presence of virtual methods/calls.
would we get enough information about the error from the wombat side? would it be helpful to have error logging here?
Instead of returning a boolean should we just use the state, I'm not sure we are getting that much simplification?
On Android 8 (emulated), this still does not work. When pressing the contributors, you have to press back twice. After the first press, the webview does not load the main about page again (does nothing). If you use the actual url ("file:///android_asset/" + webViewData.toString()) instead of about:blank as the history parameter of loadDataWithBaseURL, you can remove the depth variable (I think thus is the most elegant solution).
unnecessary array new: {{true}, {false}} should work here
nit: Could use server.activeLocalPort()? <LINK_0>
Not this pr s scope but this should use parent, false pattern.
if .newIntValue() is used in the provider, you will have to use Type = Integer and .unboxInt() here. In fact, since we control what is put into that attribute, you could skip the switch entirely and just do prioValue.unboxInt(). .getType() is more more for when you want to query state system/attributes we do not know anything about.
This reminds me that we should probably deprecate this method in favor of logError. Error message should be localized.
fQuarks = quarks?
filter is always null and nullsAllowed is always true
We don't want to create an exception object just for logging. Also, Timber supports format strings. So this could be: java Timber.e("Invalid address: %s", address);
ooh, I would have probably missed this.
To always be safe please use context.getApplicationContext()
As in DateWidget you don't need this variable just return binding.getRoot() at the bottom
<= -> <
Again this part should be handled in the above block, with UnixSHACryptPassword extending AbstractPasswordImpl.
if you do this, better put N/A :)
for the case where the file is being thrown away (abort is called rather than commit) we could get away with not calling force. (that is the ATF.commit could call a force method which does a flush, force, and then subsequently call close)
spacing
this needs update as well
again old unit test style please update
StringUtils.isEmpty(namespace) will take care of both (not important, just FYI)
Should the first parameter not be getTaskServerLogsByTag?
Since initIndexFile is called in the middle of the constructors, I would make it static (you'll have to pass in cramFile as well) and just have it return the updated indexFile, which the constructors can use to initialize the member variable. You might rename it (maybe "findIndexForFile" ?).
Should be a SamzaException with a message, not NPE.
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
change to error
would it be easy to interleave a bad operation with good operations and ensuring that the good ones are not affected?
Capture of arguments and some metrics can be factorized.
This line and all the following ones can be replaced by the single line  java return cache != null ? new SearchResult(cache) : null;
Request.State.OPEN
No need to configure the deserializers since we inject them explicitly.
Log an error using slf4j if it's safe to ignore or throw an exception
wait 15 seconds to match the code?
UnchangedCommitMessageException
I do not like createExtension modify the entry... I think it should be: entry.setExtension(createExtension(entry)) there is no reason to load the module here and not within function... also, I am unsure the function of createExtension is worth a separate function but not that important. the activateEntries.put()... should be after initialization is success as last action, this will enable you to skip extensions that fail initialization. you should catch exceptions within the loop, to allow proper initialization without faulty extensions.
Your name to the @author list since you have done a change to the class. I think you did a good test, although right there is need some improvements.
I think an additional MongoDbFactory ctor would be useful too.
Please rename method to capture its function - generateGermplasmNamePairs
This method isn't called very often, so I think it's better to have just one signature (the 3-arg signature) so call sites have to be explicit about their multiValueHandling. IMO this will make bugs less likely.
Can we log ex.getLocalizedMessage() here
I think this should be > 0 since a value list item of 1=One does not work.
Shoudl definitely check for null there -- to avoid NPE at the very least
Can you use LOG.debug("CSS parser error: {}", exception.getMessage());
I would just simply get the instanceIds from the event, and put into the variables here
OperatingSystem.equals(String)?
Such code can affect organizations which are created in parallel threads of test execution.
please add specific error message for nic plug actions which specifies the valid statues for this action.
IMHO it does not need to be public
If we throw a IllegalStateException here, we'll end in the same retry-loop as we had before, since we catch Exception on BackgroundSweeperImpl. Shouldn't we just log a warning and continue here - the worse it can happen is that someone else wasn't able to acquire the backup lock while this thread thought it was released.
Use CharacterEncoder.getSafeText()
Let's checkNonNull() the params of the builder, which must not be null.
Can you make a method of this section, like registerAutoShareProjects
In the spirit of other functions should probably return null if the first arg is null
These three if conditions can be merged into 1 if condition.
Please combine lines 96 and 98 into one line.
Style issue: @Override shuld be on line above the method declaration
If no executor block exists, this will return null which even with defaults below I believe would cause an NPE.
same under_score format for the parameter here IMO
This is addressed by <LINK_0> which is now fully acked, I'll merge it soon.
Get the service registration reference and unregister within the deactivate method
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
This methods should return the index of the max/min axis: x = 0, y = 1, z = 2, but it would probably be better to remove them from the interfaces.
There should not be a need to set this to public. Perhaps private would be better.
use return ... ? ... : ...?
suggestion greeningNodeShouldBecomeLeaderRateLimiter::tryAcquire);
To save an RPC roundtrip, could you create a new suggestservice that does both of these queries and returns the combined results instead? I think that it is important to ensure a single RPC for an oracle since it needs to respond quickly while users are typing. Additonnaly, such an oracle could perhaps already filter groups which are larger than maxAllowed? It could also filter out the Registered and Anonymous User groups?
Again this part should be handled in the above block, with UnixSHACryptPassword extending AbstractPasswordImpl.
in theory this should be newTableHandle.getLayout . But if we decided to squash these commits it might not matter..
taking out the verify statement will eliminate the captor.capture, causing a null return - noticed from the build failure
Why change this? Also it is strange that i can see from CI log the ROS docker has been started/stopped correctly:  + docker logs ros info: Integration test server listening on: 127.0.0.1:8888 info: Starting sync server in /tmp/ros117014-6-g5ntk9 info: info: stdout: 2017-01-14T07:37:58.674Z - [32minfo[39m: Logging to file /tmp/realm-sync.log at level 'all'. info: Sync server stopped info: child process exited with code 0 info: Sync server stopped  But the CI still failed because of waitAuthServerReady return false.
Should be a SamzaException with a message, not NPE.
I don't know if we ever call put twice for the same key, but null effectively removed the previous value in the method's "before" form, and now it doesn't.
.toString() invocation is redudant here.
No need to do this anymore. Just set the field's value.
Pass null as a listener, it will dismiss the dialog.
int enbale = 1;
Would it be possible to create a more general helper method, that would contain some common shared code? Basically from here to the end of loop, this is almost identical with findFileds (only the "output collection"is different), which is 100% understandable - it does the same thing as findFields, just for methods (except it doesn't need to look into superclasses and interfaces). Just a suggestion, if it would make the code less readable, we can leave this way (after all, this is still in incubator).
Same here. Add clarifying parenthesis
What happens to dst and copier in this case? try-with-resources style wouldn't try the close() again, so should we retry the close to prevent them from leaking?
Why change this? Also it is strange that i can see from CI log the ROS docker has been started/stopped correctly:  + docker logs ros info: Integration test server listening on: 127.0.0.1:8888 info: Starting sync server in /tmp/ros117014-6-g5ntk9 info: info: stdout: 2017-01-14T07:37:58.674Z - [32minfo[39m: Logging to file /tmp/realm-sync.log at level 'all'. info: Sync server stopped info: child process exited with code 0 info: Sync server stopped  But the CI still failed because of waitAuthServerReady return false.
Personally I would do splitProps = ImmuatbleSortedSet.copyOf(splits) here. This makes this API's behavior more predictable.
disable table has some validity checks, should this?
should we make this a config?
Does this need to be a singleton?
It's really not clear if this is the source or the target.
I never did like these local caches in the models that Carlos introduced. :/ Besides, creating one of those is dirt cheap. I have no idea why he wanted a cache.
"'Endpoint' is required and cannot be null."
want to extract iterating over handlers and checking if they can handle the required auth method to some metod called #getChallengeHandler(requestHeaders)?
Is this change required now that we have the default method in the interface?
What if the value is instanceof SortedSet but the set is not sorted according to the desired comparator?
Why 2? is that a boundary value?
#2935 forces the null check (so #3021 does not save us here), but if it _is_ null, we should just do nothing because Jenkins has not even started up yet anyway. Thus java return loc != null && loc.getUrl() == null;
You could make tryList final and perhaps inline initialisation in declaration.
Use I18N, this description is seen on the SQL panel function list.
Pease add on-demand static import for Calendar.
Nit: No need for final.
why creating new notebook instance here? can just reused previous one, isn't it
Can we move that line to the top?
shouldn't this method be private?
Can't we directly cast this into a map?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Why not use The vmValidator here?
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
do we really really really need this msg temp var?
Request.State.OPEN
style issue.
please extract these constants
Please use try-with-resources
same here: could be decided outside of the factory
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
Can you extract this to a method? There is code duplication here.
String log = "..."; assertLastMessageIs(log)? for me, assertLastMessage(...) isn't clear what the assertion is doing (without looking at the method). - edit... assertLastMessageEquals(String...) I guess "equals" is more familiar than "is"!
should specify an expected exit code
After more closer inspections I believe we have to synchronize the whole method. newValue and oldValue pair still races and the main reason we log the change is to know what's the current state is. Without the synchronization, the log messages are not guaranteed to reflect that since the order of log messages is not coupled with the order of the changes.
It might be better to use the R.string.share_link here instead of the specific R.string.reader_share_link. Better yet, if we don't think the localized version would be special for reader sharing, we can just remove the reader_share_link resource all together. What do you think?
This issue is only about InstructorHomePage so I think there is no need to do for other places here. Instead, you can open a new issue to to add statusToAdmin to other Actions that don't have it.
It'd probably actually be okay to call getTypes() for all objects. I think for binaries it'd still work, and we want to be able to process AdminUnits and likely folders too.
I wouldn't bother with a variable, just pass the new GetAllFunction<K, V>() to the bulkComputeIfAbsent. That would make the code an tad cleaner.
immutable copy!
Also about this location, we have a cache subfolder in the data folder for all the github files, should we move it there? Then they wont be bothered with this jar sitting inbetween their configs?
nit: metric names are generally lower-snake-case in this codebase.
use return ... ? ... : ...?
It seems you can remove the IOException now.
I am not sure which method do you mean by "Collections.add", should it be java.util.Collections#addAll ?
Style-nit: Put curly braces around the then statement.
Maybe better to return null
Again, the local variable ListData should be renamed to listData as per local variable naming conventions.
use return ... ? ... : ...?
Since we pass info as the message param to the super, do we need a copy in the subclass?
s/ with error/:/
you don't need validator here. you already have the errors (getErrors()), just use it. and remove validator dependency. no more cyclic dependency ;)
Why is there a fromByteArray method? Why not call the constructor directly?
It's better to use Function.identity() here, you won't need to test nullity after.
given search systems have a greater latency anyway, I wonder if we might want this to be a little less frequent. A minute?
Variable not used; please, remove this line.
Why not in combination with above do this: setValue(value, false);
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
Why not make this create simple string and then invoke the setAddress(simplestring) , there by not needing the two new methods and logic encapsulated in the setAddress(simplestring)
protected instead of package protected
Why wrap into a TskCoreException? The query is not run on the case database. Furthermore, the client will need to catch a SQLException anyway in order to interact with the ResultSet.
Something has to be wrong here. Initially you made this, 'connection.getState() != EnumDockerConnectionState.ESTABLISHED', and I suggested '! connection.isOpen()'. Now it's just connection.isOpen() so the negation is missing. Is this just a typo or is there a reason for the change in logic..
typo
The old file should be fully overwritten. Is the old size really needed?
you should check if the message severity is ERROR
Lookup the host here and add host name too. Can just use the objectManager
Was this cast to TracingActor unnecessary in the first place? Otherwise I didn't catch a change that would explain why it is not needed anymore
I suspect that this test is not very robust. There are so many ways that the query could fail to return any entries. Is there any way to fiddle the data so that there is at least one thing there?
Should just return properties.get(), the containsKey() call is redundant.
This log message would benefit from using {} placeholder in message string: java log.info("got 400 HTTP code in response, potential reason: access token invalid or expired, server response: {}", EntityUtils.toString(httpResponse.getEntity()));
for the boolean parameter could be useful to use enums, so that it is more clear what it means
Please do a table.put(List<Put>) instead.
These should be marked as abstract and let the subclasses should implement them.
Shouldn't we assert the result of this is not null? AFAIKT, that means the promise never got a result (or exception) in the default/environment timeout. (Which implies the start failed?)
How does replacing a NPE with an AssertionException help ? I'd rather try to annotate the method's parameter with @NonNull and watch out for "Null type safety" warnings in Eclipse and fix them.
You probably want to pass the exception as the second argument to the logger. If it is in the message all you get is the result of ex.message() but if it is the second argument you get the message and the full stack. Often the message is almost worse than useless and for some exception types it is null
I've been meaning to ask you if there's a class I can actually instantiate, thank you!
It's probably cleaner to default to a no-op configurers and assert not null in setters.
Upside down, "f" override accepts, so it should be tested first.
This will end up stripping off newline characters, so it won't return exactly what is at the other end. You may just want to refactor the getFileAsString method so then you have another one 'getReaderAsString(java.io.Reader) (and if you do that, just get rid of the BufferedReader wrapper and use a char[8192] for the reads...since my current logic in there is sort of silly since it buffers it 8k and then uses 4k reads...so you're doubling all your memcopies)
also do schedulerState.removeTask(taskId)
Please don't assign null. I would prefer the idiom to be: ReviewDb db = schemaFactory.open(); try { } finally { db.close(); } As then the Java compiler can promise us the value cannot be null at use sites, and its clear what the scope of the value is.
This seems ill adviced, same reason why it was ill adviced to do this in the constructor.
Default size not necessary.
You could reuse the method input[i].getFullName() here.
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
Another question, this is something I am not sure. No true or false passed in here as 3rd parameter in line 962. THe function signature has not default value. What value would be then for this invocation of fireDataChangeEvents?
This copyOldResponseToNewResponse method can be error prone because it does not return anything but causes a side effect. It's not immediately clear which object is copied to which. Can we move it to FeedbackResponseAttributes? Or may be make it a constructor of FeedbackResponseAttributes?
Why not use if
Avoid the scannerLock object and synchronize on KieRepositoryScannerImpl.this. I believe this will make also clearer that you're sync'ing on the same lock of the scanNow() method.
nit: you can merge both lines above as checkNotNull will return the given argument
How about name it using camel-case? such as org.apache.shardingsphere.elasticjob.lite.internal.schedule.JobRegistry#getInstance
Since it's just a copy and paste, why not creating a private method to do the calculation, e.g. private void setRemoteCostPerPartition(...)?
This portion of code looks a copy-paste changeset from DomesticEventPublisher.
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
Suggestion: That is not regression case but probably we could Create one instance of IllegalStateException("Wrong expression, this should not happen")) before the loop and reuse it inside?
this for loop could be extracted to a function so you can just return the first awardAccount that meets this condition. That way you wouldn't have to have keep track of the extra accountToUse
style: no curly braces for single line statement
this creates a hard dependency on the outer class and will make future refactoring a bit harder if you want to extract this class to its own file. Perhaps tokenSep should be passed or made a member of this class?
Just a nitpick: Extra ; at end of line.
in the case where the Bytes object is immutable, it would be nice to store this after computing. This way it does not need to constantly recompute for case when Bytes are used in hashset.
suggestion final String lockToken = UUID.randomUUID().toString();
checking for nullable parent was added specially, cause going into project node simply has no meaning
this code can be simplified; first iterate and remove the excluded columns, then execute the same code path -- there's no need to do different things if you have excluded columns or not.
Is forEach better that putAll? I suppose we also need to take care of the case when params are null.  if (params == null) { namedParameters.clear(); } else { namedParameters.putAll(params); }
WSO2
Why is this not a BeanFactoryChannelResolver? Although why don't you use a ChannelResolverUtils.getChannelResolver() instead any way?
We probably don't need to do it here, but we may want to read in all these parameters (username, password, etc) from a properties file (rather than hard-coding them in multiple places in the code).
fieldName
This method should declare that it throws this exception so that all usages are forced to handle it
can we get rid of the double spacings between click listeners?
Log and throw is generally considered an anti-pattern. You can perhaps just throw the exception without logging in instances similar to this.
might be more logical to swap the order of the two lines above (install java, download tarball, unpack tarball)
:shipit: suggestion throw new FormException(x, "configuredBuildDiscarders");
This looks very nice! What about adding a throws JSONException to the signature of getValueForOptionalKey() and parseImageLicenseMetadata() since you have the needed try / catch already in place for processPage()?
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
rename to comply java standard name convention. validateEmail
do you want to call addRequestProperty ?
is this logging just for debugging while you're working on this?
match -> count?
new ArrayList<>()
I think this Map.class.equals(type) is a remnant from a previous implementation and can be removed?
I think this should have type Cdr.WorkObject instead of FileObject.
These are from the org/json library. Edits to this are really not recommended.
checkState?
Fix confirmed!
ligically i'd say addVmToDb ends here, and from here is images handling
Can you add a getDeclaredConstructor ?
Can be final.
you can simply define the return type as FieldArray to save some casts, I think. It will still be an override.
We could have a cache here as well (each join invocation creates a new char[] via StringBuilder).
This should actually be APIException, the + should be a , and the other part should be wrapped in new Object[] { } so this gets properly localised.
Pointless style opinion, but I wouldn't mind writing a query like this on a single line when it's short enough.
I'm wondering if we have to continue using NIO buffers? @saudet Was there a reason for this?
It is not, this change should be reverted.
This function should ignore the local result and instead just merge the two incoming maps.
Does this mean that if a node is above the quota and for some reason restarts, it will not come up ? Does this mean a cluster restart could get blocked ?
return angle == 0 ? this : rotate(mQuat.fromAngleAxis(x,y,z,angle));
Is it possible for accumulator to be empty? There is code below (lines 145 and 148) where accumulator.get() is called without checking isEmpty().
so this means when you ask to automatically install the schema, we crash if an older version. Sounds fine as long as ENSURE_SCHEMA=false doesn't kill others
If the default cases in all these switch statements are expected to never be reached, maybe we can add a severe log so that we can catch missed cases like this in the future.
let's export this part to a method so that this if clause will be more readable..you can name it retrieveDomainForDisk()
At <LINK_0> we first give the application the chance to return custom MIME type. I think we should do the same here.
shouldn't this be: return setAddress(null); ????
This drops all rs and collapses all ns to  .
![MAJOR](<LINK_0> 'Severity: MAJOR') Remove this call from a constructor to the overridable "add" method. [![rule](<LINK_1>](<LINK_2>
same map function can be used for replica/distribute-replica?
Please use the formatter. The line is too long and should be broken to two
I would prefer to not expose this map directly to KItem
we still need this snapping logic if the window is not divisible by the step size
This should be "isSetReboot". The reason is that we don't even want to call the backend method if the user didn't explicitly provide the value, as the backend method may have side effects (very unlikely in this case).
Add an assertion to check the hardwre id.
maybe clientCaps or something.
Also about this location, we have a cache subfolder in the data folder for all the github files, should we move it there? Then they wont be bothered with this jar sitting inbetween their configs?
Why is this necessary?
nit: this is a slightly nasty way around the line length issue.
Utils.validateArg(lowerBound < upperBound. . .)
suggestion return tx.run("CREATE (v:VersionedThingWithAssignedId {id:1})").consume();
where did this go?
It seems that most other widgets use waitForEnabled(), I would say change it for all methods. It's probably worth changing them in SWTBotTableItem at the same time...
Maybe we should try to fetch the hook from the id, and add return failure if not found?
before accessing it's property, wait for element
What should happen if the previous DR sync itself is not completed yet and new DR sync is triggered by job scheduler. 1.Do we need to skip the previous job or ignore the current job?. 2. Creating the snapshot with name vm.getName() + "-TMPDR" may fail since there will be a snapshot with this name already.
Remove this now that it's on 1.4? suggestion }
method,path no space
I think that line should use alertViewBinding.getRoot() instead
Closed channels are automatically removed from a channel group. This line can be removed
this("SingleOp);
Can also do  return Optional.ofNullable(r) .map((rec) -> rec.map(new SecretSeriesJooqMapper()));
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
Is there any reason to return this on all those methods with a side effect? I'm not a big fan of that personally.
It seems like we would be better off making this actually return the path instead of a String. It's different than the old API, but I'm not sure I see the use of getting a string back.
Aren't all of these put statements handled in the constructor method of Person?
But existing rows use null not "" for the parentUuid.
Still prefer returning early on error conditions. In this case it would be if (cursor.getCount() == 0) { cursor.close(); return null; }
Can we use the logger here?
@raver119 I feel like this should be in a util class of some kind?
Even though it is technically correct to have no braces for a single line statement inside, it is better if you can add braces for clarity.
The trick with create is you need to convert the String to the Account.Id here in create and embed it into the view instance you return to the caller. :-(
And indenting is a little off.
Hey @PrajwalM2212 can you add categories as well in this PR and solve similar issues in the same PR.
ImmutableList.Builder<...>. You should have gotten a warning from IntelliJ when you passed builder.build() to newExpression.
this should be reformatted, the left indent is too big
Would it make sense to add this method to ResourceManager interface ?
Is this thread-safe? I guess, maybe, although it might do extra work since not all threads will see the update at the same time. I'm also not sure if ParseSpecs need to be thread-safe; if it's an issue could you please double-check it?
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
use return ... ? ... : ...?
I think output is deprecated, you should instead use DialogService.
I think this is more readable java descriptionList.stream() .filter(x -> fieldApprover.approve(x.getDataInfo())) .filter(x -> StringUtils.isNotBlank(x.getValue())) .filter(x -> !NULL_STRING_VALUE.equals(x.getValue())) .findFirst() .map(StringField::getValue) .ifPresent(metaBuilder::setDescription);
Maybe a better solution would be to define size as Integer? The size here is in GB so it might be confusing to allow such large values... As for block domains we limit disk size to 8TB by default any way (ConfigValues.MaxBlockDiskSize). For file domains, I don't think we can have disks larger than 2147483647GB..
retrieving clear alarm register
static.
Should we better make this method package protected to only allow jackson access to it?
@rakeshadr is there a potential race here between setting the shutdown handler and checking if it is null?
return Optional.ofNullable(entry);
FYI I don't think putting these inside the method contents has any effect as there is no proxy to intercept and evaluate them.
Shouldn't this be checked only in case cluster is secure ?
Here is another use of sorting via TreeMap. It's just a debug method, but I don't like the functionality change
Please rename the variable to nanos and use 1_000_000 instead of 1000_000.
You can use CollectionUtils.toImmutableList
Please run build with sourcecheck profile
I think there is no need to change this here: the initial SerialSubscription can safely overwritted by the result of the schedule as it is not reentrant.
or just assertFalse(responseData.isActive());
I am thinking.. should we make PreviewView a required parameter ? if yes then we probably should ask developer to pass the PreviewView to the CameraController constructor (or we can make a builder for CameraController so that we can configure more options like specifying video support or ImageAnalysis in the future.)
can u change all constructors to protected
I think it would be nicer if the user external ID were explicitly specified (in the say way that externalId and amount are)
Drop this, Keep the iterable only?
String log = "..."; assertLastMessageIs(log)? for me, assertLastMessage(...) isn't clear what the assertion is doing (without looking at the method). - edit... assertLastMessageEquals(String...) I guess "equals" is more familiar than "is"!
can we remove the version completely?
You can also use something like return url.replaceFirst("^\\w+://", "");
Please keep var assignment (list = srcDir.listFiles()) along with the object reference. File[] list = srcDir.listFiles();
Minor: consider replacing equalTo with is from Hamcrest here and below.
this is bad IMO. if offset >>> fe.offset the diff may overflow the int (and return a negative int instead of a positive one). you should use Long.valueOf(offset).compareTo(fe.offset) another suggestion is to swap the order... first check the offset then the size since it is most likely the offset to be different than the size.
if i get it right: if response is null, we will not retry. i think we should retry even if response is null. btw what caused this in your case? so it would be:  response == null || ....
Maybe we should derive this from Prefs.getMediaWikiBaseUri() or require the client to pass in a default protocol. I think I prefer the latter to avoid complicating this nice and simple model type.
Use an Enum here
Do we need this?
suggest to use truncate or provided another truncate method. The same to all other datatypes.
How could we not be in a group ?
Maybe there should be a baz property here that isn't included?
Streams used in proper way, however I would propose slight improvement: java categoryWidgets.entrySet() .stream() .filter(entry -> !Objects.equals(entry.getKey(), categoryId)) .forEach(entry -> entry.getValue().setVisible(false));  I think proposed formatting is more readable and prevents NPE in filter part, let me know WDYT.
Put this static method after instance methods.
Do the deletes in a finally-block in case the test fails.
A certificate Verifier == null means that we don't support X.509 right ? If we don't support X.509, the certificate type/cipher suite negotiation should have failed before. So if we still receive a CertificateMessage with a CertificateChain, I don't know if we should log and raise bad certificate. I feel this is more an error from the foreign peer (or a bug at negotiation time). Maybe HANDSHAKE_FAILURE and the log about "invalid Certifcate message" would be more appropriate.
Gonna go ahead and call this one a blocker.
please move it as a class attribute, so the same can be reused
Missing <>, this is a raw type.
Collections.singletonMap() instead?
Need to be version checked for GTK 3.6 or newer.
shouldn't be NotFoundInDbException or similar to get 404
In this case since the "style" part is only used once (here), I am not sure if it would actually be cleaner to use the original createButton method and then just add a deleteButton.setAttribute line. Hmm....
rename 'element'
I believe the conditional above will need braces otherwise this is considered outside of the block and will always execute, which may not have been your intent due to the indentation. If you did want it to always execute, you should update the indentation to reflect that.
there are constants defined for these strings.
shouldn't be assertNotInCacheAndStore(cache, store,...)? (note you have cache in the first and second parameters)
I would assume that if this happens we have a fatal error. Wouldn't it be better to throw the exception and fail immediately?
You need to check that cursor is not null  java if (cursor != null && cursor.moveToFirst()) { // proceed }
does it make sense to put the name / ARN of the task definition to the log? Otherwise this log message might be very unclear, as people do not know what it relates to
Too many unnecessary blank spaces in this class. Please refactor.
Creating a new constant FEEDBACK_SESSION_MODERATED_INSTRUCTOR may be more appropriate.
final
purge takes too long, just delete
why is this necessary? Is the tab sometimes hidden?
wrong casting
I added the line above, is that correct? Although, what is the point of creating a rectangle with 0 height here? It seems to be the same with and without it?
Looks like if we pass null instead of new char[0], the content assist will auto-activate.
if using processSoftwareCapabilities, then you can call the methods above (or a new method) from within this one.
AFAIK Writer::close throws IOException, so there is posibility that exception is thrown by flush method will be suppressed.
Unnecessary when the string is the same.
throws BindingConfigParseException
suggestion this.className = requireNonNull(className);
You're missing 64 here. <= would be better.
Use an Enum here
Why not have this method private?
Remove
Why not using directly assertTrue?
Use context.getApplicationContext() to ensure the class can't leak any shorter lived contexts that might be passed to it (it's always fine to hold onto the application context, since it's expected to be around for as long as the process remains alive).
Will this be OK across different screen sizes? Should we put the 35 in dimens.xml?
size is calculated here. Do you want to change sizeCached to true?
non -> not
This should be put into a constant.
This could be a private function then in-line it rather than creating a local boolean variable e.g.  Response.ResponseBuilder res = allHealthy(results) ? Response.ok() : status(503); private boolean allHealthy(Map<String, HealthCheck.Result> results) { return results.values().stream().allMatch(HealthCheck.Result::isHealthy); }  I'll stop here since Oz has reviewed the rest. This isn't mandatory, it works and makes sense as-is.
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
why this line is duplicated ???
I'd recommend to add process id to the name as well as there might be tasks with same name in different processes but still in the same kjar
Money is a reference type and needs to use .equals() instead of ==. Also we need to make sure calculateCost is called first. suggestion return part instanceof CombatInformationCenter && getStickerPrice().equals(part.getStickerPrice());
In the HealthMap conversion code it's the HealthMapAlertConverter's responsibility to create a new feed if necessary, rather than HealthMapLookupData. But I can't actually think of any obvious benefit of putting it there, so happy to leave this!...
Consider removing the "Optional" part. Seems better to return an empty map, if not present.
I would retain the existing indexOf body to to avoid indirection in the most common case.
should be int y
QCTX_VARIABLE_NAME ?
This also doesn't work. The compiler doesn't auto-close the inner writer unless it's assigned to a variable.
if we introduce a constant for this the rule should reference it.
suggestion return tx.run("CREATE (v:VersionedThingWithAssignedId {id:1})").consume();
Do you think naming it removeFromParent() could be enough?
UI plugin infra is WebAdmin-specific, no need for this instanceof check, it will always be true. Just typecast like you do below. Or, if you prefer, inject WebAdminPlaceManager instead of PlaceManager interface. Up to you.
path separator?
Can you make this a public static final constant instead? (And maybe use the same constant in the RequestMapping on line 37 too?)
This is potential performance killer, but I don't have better idea how to address this. So I assume we need to live with that. Fortunately there will be thousands of groups at most (not millions) and it is just about admin requests, so hopefully it is ok. IMO in general, it is probably better to have pagination approach, which doesn't require counts. Something, which always returns the token for next page? Although this approach also has limitations (EG. it is not easily possible to move to the exact page like "Go directly to page 50" etc), and there are probably other limitations. But maybe something to consider in the design of new REST API (CC @pedroigor ). Sorry for hijack the PR :)
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
You didn't execute this ddl statement
Moving that bits above and allowing the user to change the decorator via a public setter means you can completely shadow what AbstractTransactionSupportingCacheManager used to du using public API. Also, if CacheDecorator is a first-class concept, you should probably expect that more than one decorator can apply at a given time. This wrapping shouldn't be the responsibility of the caller.
newTreeMap so the raw JSON is ordered in a sane order, for the sake of a poor human reading the output?
Some exceptions will have a null message. Should we include exception class name as well, or is that giving too much away according to security experts?
why do we still have a condition on getParentCommand() ?
As a practice its a good idea to call commit on a connection that is returned from the pool before performing a SELECT operation. This ensures that any uncommitted data will not be returned by the DB. The pattern to be used therefore should be,  try (Connection connection = GatewayArtifactsMgtDBUtil.getArtifactSynchronizerConnection(); connection.setAutoCommit(false); connection.commit(); PreparedStatement statement = connection.prepareStatement("SELECT ...")) { }
I would have added specific config so that we can implicitly have a key to the vdc_table which may be other name than the profile.
You don't need to return anything here, as it's unused.
why do we actually need it - we get the Down event...and IIUC this method is for the case when vdsm stops reporting a VM. Also, if dbVm == null this raises NPE
This isn't a test, it just prints it out. What we want is something that at least checks that the output is a non-zero % number for example.
Nothing should ever have a sourceSubscription AND sourceStack. I'm not sure how much more work the db has to do for this join, it shouldn't cause problems.
This function should be a single line (inline return).
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
datasetId is unused in reorganizePhenotypesStatus method
Is this going to cause a problem upon restart? Should we log something higher than debug?
this check should take precedence over the pageview check. That seems more natural for clients to understand, that if something is tagged preview it's always preview no matter what.
We should only rewrite the exception if the error code is NOT_SUPPORTED. Also, we usually wrap the original exception as the cause in the new exception, e.g.  throw new PrestoException(INVALID_FUNCTION_ARGUMENT, "Array contains elements not supported to be compared", e);
use return ... ? ... : ...?
This null check isn't really necessary. Principal should have a reasonable toString(), and tracef can handle null arguments. Also just use "context" not "context.toString()" - this way, if trace isn't enabled, toString() is never called.
This and the corresponding overloaded get is not necessary. Will explain below.
add a message to this exception.
hmm, IMAGE_JP2000 is the boxc3 name for the datastream. Might be better to update JP2Viewer.js to request datastreams jp2 (I think that's the current datastream name). Its kind of funny that hasAccess has this default datastream behavior but the actual controller methods both require the datastream name in the path.
Here it is going to depend on the resilience strategy ... so hard to say. I would drop the operation result assertion though.
You can use StringUtil.notNull() for this as well.
Instead of having the conditions for the different geometry types duplicated here, you could just call unifyWindingOrder(geometry, counterClockWise) for the individual geometries in the collection.
I would init the map in line #34 so it won't be null and you can remove the null check here and in getProperty
List<VmTemplate>...
These strings need //$NON-NLS-1$ annotations.
So if there are 3 parameters, we include 3 copies of all parameters?
I don't think we do a very good job with this, but I think AppLog.v might be more appropriate here since it's probably too valuable during debug. I also find it interesting that you chose AppLog.w over AppLog.e while handling the error, I think it [has the lowest priority overall](<LINK_0>
purge takes too long, just delete
Should clone the list before making it immutable. Collections.unmodifiableList just wraps the collection in an implementation that throws on all mutating APIs.
wonder if we can put (null !=exchange) to make reading more easier? If not, don't worry.
this method (clue of your PR) always returns null. Write tests, check if they fail, and then implement a new feature.
extra space
Similar to the JDBC library, let's hide the entity column cache from the public API. EntityQueries.from(...) is a good example of external API.
The old constructor is still there, why did this need to be changed?
wrap this line
This is again a help string probably intended for stdout
Can use a lambda for shorter code.
Is it worth validating the contents of the schedule criteria rather than just the count?
IMHO it does not need to be public
Usage of ternary operators here will make the code more reader friendly: page = pageStr == null ? 0 : Integer.parseInt(pageStr);
Extract the Priority into a constant so we don't have to change it in 2 places
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
I think !Stings.isNullOrEmpty() is more fail safe.
max bytes per char in UTF-8 is actually 4 bytes (the new standard) [6 bytes in old standard]. <LINK_0> Java could handle Unicode U+10000 to U+10FFFF through surrogate pairs. Those chars require 4 bytes in UTF-8. I'm not aware of Protocol Buffer limiting the character range to at most U+FFFF, so better not assume.
nit: just do the ternary form Collection<Account.Id> results = (cd != null) ? cd.reviewers(Providers.of(db)).values() : approvalsUtil.getReviewers(db, change.getId()).values();
It might be nice to also have a test with a user in the administrator group, so we can verify that it gets the ADMINISTRATE_SERVER permission.
why is this public?
This try/catch would not be needed since GoraException thrown by getDataStore extends IOException :)
Won't the issuer be the internal/system host?
not so important, but for readability, you could define AuditLogType logType = checkHardLimit ? AuditLogType.GLUSTER_VOLUME_SNAPSHOT_HARD_LIMIT_REACHED : AuditLogType.GLUSTER_VOLUME_SNAPSHOT_SOFT_LIMIT_REACHED and use this logType in the 2 instances here.
![MAJOR](<LINK_0> 'Severity: MAJOR') Define and throw a dedicated exception instead of using a generic one. [![rule](<LINK_1>](<LINK_2>
Add SubChild here as well, perhaps SubChild is just persisted as a Child currently..
I don't see why we need these sorts of constructors... We've never needed them before, and there's nothing special about the useLayerNormalization arg (it's just another boolean)... unless I'm missing something?
How about inlining it?  if (!contains(o)) return false;
I think this method could be private
Please specify why you are using "," as a separator b/w key and value.
Such worker threads should be daemonic. Daemonic thread will die when all non-daemonic threads are done. In this case when startProcess() is blocked to some reason the application may hang and you won't be able to exit JVM :( Such kind of worker threads as you are creating here should always be daemonic unless you are 100% sure it can be done and will not block e.g. on reading stream. java Thread t = new Thread(..) t.setDaemon(true); t.start();  <LINK_0>
state is started but not stopped. Nothing can stop it if lookupName is already present
Same here, no need to calculate hashcode above and set it here. This line is enough: .append(this.getProvidedProducts()).
Looks odd - shouldn't that different actions?
:bug: this is not reliable. I presume you are attempting to somehow detect the case that a user "did stuff" (meaning, created items) in Jenkins 1.x but somehow managed to avoid ever saving /configure-possible, if very unlikely. But this check will be false if the user created top-level _folders_ but no top-level _jobs_ (or subsequently moved all jobs into folders). getTopLevelItemNames would be more appropriate. Or more directly:  java if (!Jenkins.getInstance().getItemMap().isEmpty()) { // some items configured  (Note that using getAllItems() etc. is not only slightly slower, but vulnerable to inaccurate results in case the caller is running with non-ACL.SYSTEM authentication.)
Instead of collecting transaction edit logs here, we can add the count header in AbstractTransactionLog.sync() method before calling append, right? Since the edit logs are already being collected over there, we will then avoid code duplication.
This needs to be a log statement.
looks like an unexpected behaviour: would prefer a 'warn' log
This removes an existing constructor. We can't do that. Hint: Keep this constructor, copy previous constructor from earlier code and paste it just before this constructor.
why it was increased so significantly? As I understand in this PR you just added new property to the batch, I expected that it will not increase any timeouts etc.
This will likely fail when run on Windows using a project directory that is a UNC path rather than a drive letter: just as File.toURL had numerous problems corrected only by File.toUri, so File.toUri has some problems corrected by Path.toUri. I would suggest dropping shouldRelativizeOnRealPlatform and shouldMakeAbsoluteUriOnRealPlatform. If you want unit tests, that is what I originally wrote. If you want something more realistic, demonstrating that the _result_ is what was intended, shouldMakeRelativeUriOnRealPlatform is better.
Unnecessary Optional wrapping. Replace this code with:  java for (Map.Entry<Node, Optional<T>> entry : result) { return entry.getValue().orElse(null); } throw ClusteringServerLogger.ROOT_LOGGER.noResponseFromMaster(this.context.getServiceName().getCanonicalName());
we reverted the try-with, since it requires minsdk 19.
declaredOuputStreams is too verbose. the variable/method can be outputStreams/addOutputStream.
this logic seems to be duplicated. I think it would be beneficial the refactor it
Need to declare the adapter type here, too.
The line 108-110 are going to be a heavy processing. Could you use a cache mechanism on the jsonGenericRecordConverter?
We already did this on line 118.
We can replace this with: return date.getTime() / TimeUnit.DAYS.toMillis(1);
invert this.  java if (List.class.isAssignableFrom(target.getClassType())) { return multiInstantiator.instantiate(target, parameters); } return conver....
Request.State.OPEN
Even better would probably to compare File object. I wonder if AssertJ has some support to do this more cleanly...
I think this method should either: 1. start with if (rec.getReadUnmappedFlag() || !rec.getReadPairedFlag() || rec.getMateUnmappedFlag()) return false 2. or make it explicit in the javaodoc that it's only legitimate to call this method on a read that is paired with both it and the mate mapped
We don't need to generate uuid when updating the Registry. Shall we remove it?
You can replace this if/else with a single call to restartRequirement.setRestartRequired() (added fairly recently).
... yes it does ...
Ah ok, I would add a new method signature along the lines of private void launchCwl(final String entry, final List<String> args) and re-use most of the existing method (i.e. not copy-and-paste) instead of creating a new list this way.
Hmm, I know we do not have anything better, but how hard would it be to create a bulk update call?
I don't see why we need these sorts of constructors... We've never needed them before, and there's nothing special about the useLayerNormalization arg (it's just another boolean)... unless I'm missing something?
Please throw unsupported operation exception instead, this dao is not used. We're going to get rid of it.
For such small method (next one in next file too) having extra blank lines doesn't bring anything.
Instead of equals, we should compare the input's digest
@Serranya same here. See above.
do we care to check the length to be positive here?
isn't the currentRow the instance of RowBuilder which was just added?
The method is "getItemFromRegistry", not "getItemTypeFromRegistry". Shouldn't the error message read "Unable to get item for item name {}" ?
OCD: missing space between ) and ?
I don't think 4+"" is a good practice here :). How about using Integer.toString() instead?
Yes, it's easier to understad having a piece of code to lookt at. :-) I think we should separate discussions here: - How to do preprocessing in Maven? - Is preprocessing a good thing at all? The target of the current PR is Mavenization. Hence, the question is "How to do preprocessing in Maven?". That's pretty simple: Maven can filter source code automatically before compilation, so the solution as-is will work once Maven is correctly configured. What you need is called the "Templating Maven Plugin", which is an alpha currently and the web site is moving from Codehaus to Mojohaus at the moment (bad, so you cannot do it NOW). A different approach is to apply a workaround using a combination of the "Maven Resources Plugin" (which can filter pretty anything as long as it is text) and setting the source path to the output of that plugin. We use that a lot that way to patch version numbers and build dates into the source code and it works pretty well. The drawback is that least IDEs any of these solutions and won't be able to support it. So our conclusion is that we do not like preprocessing as it makes things complex. The second question is whether it is a good idea to patch sources at all. I do not think this should be part of the same PR, but we should first open an issue for that and discuss in a larger audience. My personal opinion is that I would keep one single source code for one single platform. It makes development pretty easy and new people can jump right in easily. I'd call that "one code for one platform". If really multiple platforms or even a matrix shall be supported (and it looks like the project leads want that), I'd go with git branches. A different solution would be using the Strategy pattern, hence solving the complexity at runtime by simply loading different implementations. In fact, the problem is less the different JDBC levels. We could simply always support the latest level, as the JVM will not complain about unkown classes until we really instantiate them, which is not the case if the code is kept JDK 6 compliant (you can offer interface that uses JDK 8 without the need to load JDK 8 classes until that class is really used). Maybe this is the way you like to go?
Out of curiosity, why is the return type of this setter not void?
shouldn't it return false even if addCanDoActionMessage=false? from the name of the parameter it sounds like only the message is not needed but still give the correct return value
I think these two variables are not used?
I think !isNullOrEmpty(stream) can be removed
\s+
You could factor this out. Arguably uglier because you'd have to use instanceof instead of separate catch blocks, but I think the reduced code duplication would be an overall win. } catch (IOException e) { handlePackError(e, p); } ... private void handlePackError(IOexception e, PackFile p) { String tmpl; if ((e instanceof CorruptObjectException) || (e instanceof PackInvalidException)) { tmpl = JGitText.get().corruptPack; // Assume the pack is corrupted, and remove it from the list. removePack(p); } else { tmpl = JGitText.get().exceptionWhileReadingPack; // Don't remove the pack from the list, as the error may be transient. } StringBuilder buf = new StringBuilder( MessageFormat.format(tmpl, p.getPackFile.getAbsolutePath())); ... }
This is a good approach IMO.
String name = StringUtils.EMPTY;
It'd be safer to put EXTRA_SUBJECT only if !TextUtils.isEmpty(subject)
DomainWildcardMappingBuilder::build is alredy creating a fresh new map that would be owned by ImmutableDomainWildcardMapping: if you let the copy of DomainWildcardMappingBuilder::map to happen inside new ImmutableDomainWildcardMapping, you could save using an unmodifiableMap and the pointer chasing introduced by it
Please remove this. Tests are by intent using a string and not a constant here.
My personal preference is to use brackets even for one line loops and condition. Not a blocker to merging.
The jboss.server.xxx.dir properties should not be being set if the embedded process is a Host Controller. The HC equivalents are jboss.domain.xxx.dir.
Don't use assertTrue(equals()). Use assertEquals() like JUnit wants you to. It works now that we fixed .equals() on RevObject. :-)
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
Not sure that I know the logic supposed to be here, but is it really that message.data() is always an Message here?
why not null as value?
please move lines 330 and 332 into the condition. There is no need to invoke them if network is null.
I don't think we need this line
toString(java.io.InputStream) usage is deprecated. IOUtils.toString(inputStream, StandardCharsets.UTF_8.name()) is recommended. This is not critical, just seems like is causing a build issue on some travis build.
The incore merger works in memory without a working tree. Does he need attribute handling?
But why? Is that really necessary to change boolean to Boolean?
I think you should throw exception if somebody calls setEvent and give an empty event name. #Pending
Type field is not needed anymore according to Sun's description <LINK_0> I think it would be better to leave it empty and make GWT IDE asking project type instead of hardcoding it. WDYT?
use isLoggable() also here ?
It would be hard to troubleshoot the error especially when it throws in production env, when we just show a simple string "Could not read double.". I suggest to include the 'ex' itself and wrap it up with ParquetDecodingException so that the exception can have more information. It is also recommended to print out more information of the data stream itself so that it is easy to troubleshoot the error.
> return new String[] { resource + "/.default" }; [](start = 7, length = 48) Should this use the DEFAULT_SUFFIX constant above?
I don't think this will work for all cases. Have you tried a deeply/nested/directory/like/this? getName() only returns the outer most subdirectory, which is only adequate when you control the paths (voltdbroot/log for example).
why?
Use <LINK_0> or similar so that we don't need to touch this when we need to get Galaxy in here too.
Add reasonable toString() method, returning null doesn't seem as proper way.
projectExplorer.waitAndSelectItem(PROJECT_NAME); projectExplorer.openItemByPath(PROJECT_NAME); projectExplorer.openItemByPath(PATH_TO_GO_FILE);  Can be changed to "ProjectExplorer#expandPathInProjectExplorerAndOpenFile(String path, String fileName)"
two places where partition is serialized? Not very comfortable with that - this is repeated code that needs to be kept in sync.
This seems a bit lenient. Is there a reason we can't do  List<CfDef> matches = cfDefs.stream() .filter(cfDef -> cfDef.name.equals(CASSANDRA_DEFAULT_TABLE_NAME)) .collect(Collectors.toList()); assertThat(matches).containsExactly(expectedCfDef);  ?
Should be a SamzaException with a message, not NPE.
Missing space.
It may be a good idea to log this at a lesser level. I think I remember being told that not being able to close a stream isn't that big of a deal. Can anyone confirm this?
can we still add a check for null and throw if it is not set?
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
do you have anything against making the longtext fields bytes instead? I'd prefer to keep character encoding issues in the code and not in the db...
I think it would make sense to have "serverGroup" parameter optional. User may want only to upload DomainDeployment and then assign it to several groups manually (or via additional CLI script)
![MAJOR](<LINK_0> 'Severity: MAJOR') Refactor this method to throw at most one checked exception instead of: java.util.concurrent.ExecutionException, io.fabric8.maven.docker.wait.WaitTimeoutException [![rule](<LINK_2>](<LINK_1>
need to handle case where fieldMapping is a macro, so output schema is not available in configurePipeline
declaredOuputStreams is too verbose. the variable/method can be outputStreams/addOutputStream.
What's the intent behind this? Generally we want to allow this to be changed at any point. Is there something in particular that requires this with the update?
Use the constant MINIMIZED_URL_KEYWORD
an alternative is to log at just one place with the error code.
we can use handler here instead of calling getHandler again
![MAJOR](<LINK_1> Remove this use of "getBytes" [![rule](<LINK_2>](<LINK_0>
this is counter-intuitive. You expect getPKStrings to get you PK strings only, but sure.
I would ignore empty notifications and would log warning.
1. this file isn't related to the create snapshot flow. 2. do you persist the placeholder to keep it compatible with the rest of the code?
Can we throw an exception instead?
As a small improvement you could switch L:86 and L:87, declare Class memberClass as final and reuse memberClass within the ternary expression.
I think maybe we should first set this.needToRefreshCreds to false and then update the creds. Imagine we uploaded credentials twice in a row and this loaded the first creds and the thread paused. It would then clear the update flag and miss the second credentials upload.
This looks very flaky. What if there is a space between the field name and the value? (as i the examples you copied). We need to do this better.
Shouldn't the collection be added as given and the existing items be "moved" to the new positions?
why is this useful?
You should pass here message not group converted to string.
I would change that to Collection<VM>. You're not using any specific List functionality here, and this would improve flexibility and prevent breakage in case someone decides that it's better that the query returns a Set, for example.
Consider adding an additional layer of abstraction for this block. This has very similar lines as the other two methods.
consider adding a log on failure
use CollectionUtils.isNotEmpty()
maybe this could be in a factory to make it readable and more organized. We could expose the ThriftServer configuration parameters in the source params as in the HTTPSource with the FlumeBeanConfigurator <LINK_0>
minor: this. does not appear to be our convention for fields. Use it (or don't use it) consistently for all fields
You can do zoneId>0 instead of != - 1
Exception#printStackTrace goes to stderr by default.
How do you ensure that the workflow is in progress at the time of deletion?
usually data objects never return null where collections is met
I note this is going in the map before the store is updated
are you sure you need credentials temp variable?
why do we check for both default size and user-configured size? It should be either one, right?
perhaps if not has permission?
assertTrue is redundant here.
Is this a EntityDoesNotExistException? should there be a log message instead/as well?
What we actually need is to **pass the file name information into Parser plugins** so that the Parser plugins can log parsing errors with file names. I don't think we need to log this line here. (Logging here just for testing ourselves would be fine. But, users may have so long log messages if we log here.)
![MINOR](<LINK_2> 'Severity: MINOR') Catch a list of specific exception subtypes instead. [![rule](<LINK_1>](<LINK_0>
Is this change needed?
Typo: tableDefintionBuilder -> tableDefinitionBuilder
NBTExtras.NBTToList should be replaced with call to NBTHelper, we don't have a list one yet but you can just recreate what is there already with getSet and create a new getList method that instead of creating a hashset creates arraylist
Yes, polymorphism is what you want. instanceof generally is a last-resort kind of solution. Here you're in charge of the design so you can easily avoid it by adding another level to your hierarchy.
@antonini please name it user
Should use parameterized logging instead of string concatenation.
You can also use something like return url.replaceFirst("^\\w+://", "");
Not sure if we rather want Cipher.getInstance with second argument to be "BC" security provider as used for example in AesCbcHmacShaEncryptionProvider? AFAIK that may have bigger probability to avoid issues that some stuff doesn't work as expected on various JVM versions etc.
nit: you can merge both lines above as checkNotNull will return the given argument
Also redundant - setVcfHeader checks this.
This is now complicated enough that I would advocate moving back to non-lambda format. also needs { and } in if/else
'/' is a character, not string.
Don't we have a getVdsSpmIdMapDao() method?
Shouldn't content length of 0 be excluded from here?
finish() is called in case of an exception but the callback.close() is also included in the finally clauses of the top level methods. This leads to closing a callback() twice which is probably not intended.
return this.parent == null ? this : this.parent;
Please remove checkstyle related changes from this PR
This should be mBannerPlacementId.
rename to f
you could do i++ here and remove the line 1886
No suggested fix to lop off a few unimportant params? ;-) We might want to add something to the message suggesting an args object with a builder, potentially recommending immutables.
We normally reserve checkNotNull for argument checking, and use checkState for state-like checks.
Put the / directly in "_nodes/_all" string.
This needs to be System.nanoTime converted to microseconds. Otherwise we loose precision.
other methods like this put name first, then id. switch for consistency
The methods computeIfAbsent() and putIfAbsent() are not thread-safe. If two threads call fetchTree() concurrently, you might get two ids for the same aspect. You could use a synchronized block around the two lines, synchronization on one of the maps (they are final).
I think that may have been an oversight in longSum. Try a query that results in +Infinity at the historical level and you will see why it is needed to deserialize at the broker level
suggestion cacheManager::getStats);
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
You can check for class equality directly.
Add problematic host to the exception and also add the reason why can't. Because he has no privilages to use this hostName.
Previously if a RuntimeException was listed as an application exception it would not be wrapped, which is the behaviour expected by the spec.
Should return List<>, not ArrayList<>
Single pass is needed here.
The options are now rebuilt on every call. Did you want to leave the door open in case we ever need an option that would change for every new connection?
I guess you should return directly after the logging? And please log the task as well, so the admin knows which of the 10k jobs the log is talking about :)
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
Close readers
We are always in a case of an AbstractDiagramElementContainerEditPart host here?
This is also suspicious, I guess we shouldn't need it now.
Do we need to do this here? This seems like it's creating a circular dependency of the EMF into Guice, but the EMF depends on Guice.
after a second look, I think we should do this only when getVm()==null (in the import from glance flow), otherwise when user will try to create a template from rest-api without specify custom-compatility version we'll use the incorrect version. bottom line, should be done this way only if getVm()==null
note: Generally having a composition based factory is preferred. However since the ORC writer is already implemented this way - let's keep it so for consistency.
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
remove this, it is taken care of by the framework
Maybe some not-null check should be added here.
This may not actually solve the problem because if the original exception is thrown after columnWriters.forEach(ColumnWriter::close); in bufferStripeData and before this line, then during rollback, we will still try to close column writers before resetting them. By reading the code, the following part could potentially be the place in flushStripe throwing the error causing column writers to be closed. java // write all data orcDataSink.write(outputData);  As a first step, could you write a unit test to verify the stacktrace can be reproduced if the caller calls orcWriter.write(page) followed by orcWriter.close()? It doesn't have to be the full stackstrace matching. To make sure we can get into closing the column writers twice would be good enough. OrcDataSink is an interface that can be mocked. In terms of the actual solution, I may need to think about it. But feel free to propose a good one.
Let's move this to the block, since it will be closed in finally block anyway.
Elsewhere in LabelTypes you treat the name as case insensitive. But here for overriding we require the name to be identical, otherwise we implicitly override by accident inside of LabelTypes when the name map is created.
You should update this as well. This should require the MODIFY_SESSION privilege.
Is it a conscious decision to throw an unchecked here?
Maybe we should derive this from Prefs.getMediaWikiBaseUri() or require the client to pass in a default protocol. I think I prefer the latter to avoid complicating this nice and simple model type.
This should be a shared constant and not duplicated. BigtableOptionsFactory might be a good place for it
Try:  java final List<PoolBagEntry> bag = connectionBag.values(STATE_NOT_IN_USE); int removable = bag.size() - config.getMinimumIdle(); for (PoolBagEntry bagEntry : bag) { if (connectionBag.reserve(bagEntry)) { if (bagEntry.evicted) { closeConnection(bagEntry, "(connection evicted)"); removable--; } else if (removable > 0 && idleTimeout > 0L && clockSource.elapsedMillis(bagEntry.lastAccess, now) > idleTimeout){ closeConnection(bagEntry, "(connection passed idleTimeout)"); removable--; } else { connectionBag.unreserve(bagEntry); } } }
Given you have this check, you could remove the other check below java for (int i = 0; i < argumentValues.size(); i++) { ...
Not at 3.3.0 yet
This can be removed now.
Same note above about missing curly braces and relying on a a default-constructed ReferenceSource applies here as well.
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
I would move "affected" to a static variable as well for consistency.
we should pull the ObjectMapper out as a static final and use Afterburner, to avoid thrashing and testing too much serDe  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper().registerModule(new AfterburnerModule());
Could the ints added to the keys and values be cleared up a bit? There doesn't seem to be any reason to add 200 to them here, and if the number of entries is extracted to a constant, then it can be used in the invocation on server2 to prevent overwriting the existing data.
This looks like something Jack might optimize out (we're still using dx for Checker tests). Could you acquire the nulls through an inlined method and test the later constant folding? That seems more future-proof.
isEmpty()?
Prefer assertThat(something, is(something));. It's more readable
metaData.size() - 1 could be turned into local var and reused on line 196.
Use Logger.error
I this refactoring, very nice. Could make this method protected.
Maybe we should derive this from Prefs.getMediaWikiBaseUri() or require the client to pass in a default protocol. I think I prefer the latter to avoid complicating this nice and simple model type.
do we want to have actual percents? not rates as everything else is in Picard?
Is it possible to do this in a constructor and not on get?
@manuelplazaspalacio All steps of login process should be executed with AsyncExecutor first step included. Review PushUseCase for view a example of when execute in async mode
monitor submonitor stuff.
don't do this...just have the exception thrown all the way up
I think we should move the for statement in the writeLock block
space between -1
Why is that moved down?
Directive.getFetchDirectives().size() can be made into a constant on Directive statically.
Nice. I'll show you how to return different error statuses with Spring AOP next time
You can use FiltersHelper.Constants.HEADER_PREFER here.
How about inlining it?  if (!contains(o)) return false;
ObjectHelper#isEmpty already contains null check. suggestion return ObjectHelper.isEmpty(field);
What is this log statement for, exactly? Seems like a trace?
how about grantTablePrivileges, revokeTablePrivileges, createRole, dropRole, setPartitionColumnStatistics, deletePartitionColumnStatistics, updatePartitionStatistics, deleteTableColumnStatistics?
Instead of using DBUtil, this could take the DefaultAysyncQueryDAO - and use the load object method there.
Why on earth do you use a LinkedList for this?
How about using something like org.apache.commons.lang.math.NumberUtils.isNumber()
Why setting Token or MID imply sent = false ?
Please use a specialized primitive HashSet from fastutil.
how did the previous version work? Use FileUtils.mkdirs
What if obj.toString() throws an exception, for example, an obj has a field set to null that obj.toString() does not expect to be null.
Why is hard to read generic coding used here?
java if (resultValue.isSatisfied()) { expectedResult.resetStatus(); } else { if (resultValue.getErrorMessage().isPresent()) { expectedResult.setExceptionMessage(resultValue.getErrorMessage().get()); } else { try { expectedResult.setErrorValue(expressionEvaluator.fromObjectToExpression(resultValue.getResult())); } catch (Exception e) { expectedResult.setExceptionMessage(e.getMessage()); } } }  I know it looks a bit spaghetti like, but at least it is more readable
should this say throws PatternSyntaxException ?
Can we replace "selected file" with the full path to that file? This would give user additional confirmation and reminder of what was selected.
exception, so STDERR
Values seem to be of a particular user. Change them for notNull asserts or something that can be run by anyone.
Consider making these 5 lines of code (allocating a byte buffer, filling it up, and flipping it) a helper method in this file.
Same here. Add clarifying parenthesis
Even for moved code: Should here not an exists() call added or on a local variable an exists() call executed? I would prefer last option.
fail() if no exception?
I don't know what you are trying to do here, but the tile no longer exists at this point, so calling getBlockTile(world, pos) will return null always.
Suggested to pull hasLower/UpperBound and lower/upperStrict logic outside the predicate creation (create different Predicates for different combinations), to make applyLong() of each Predicate cheaper and clearer.
should be type that is passed in the constructor.
nit: Might want to give each measurement a distinct value.
problem with the argument passed to setupDiskSpaceTest
Intellij tells me that "public" is not necessary here.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Docs (<LINK_0> you must always check isConnected() before initia...
If you clear the queue here. It will be empty a few lines below. Why that? Is the upper bound not enough?
I think the annotations should be on separate lines
You updated the port which is good - can't we have the hostname be localhost as well?
java && SCMTriggerItems.asSCMTriggerItem(job) != null && job instanceof ParameterizedJobMixIn.ParameterizedJob  :bug:
It seems strange that we have to buffer this manually, no built-in stream util to do this?
I think each of these two constructors should provide examples of the querystring's they construct.
Can we improve on this message?
This step is same for standalone as well as domain ;-)
I would change that to Collection<VM>. You're not using any specific List functionality here, and this would improve flexibility and prevent breakage in case someone decides that it's better that the query returns a Set, for example.
This should be mBannerPlacementId.
I think this is a typo -> this.high < this.high -> should be -> this.high < other.high ??
one param per line
other methods like this put name first, then id. switch for consistency
You should pass here message not group converted to string.
Why segmentReplicatable() instead of server.getType() == ServerType.INDEXER_EXECUTOR?
I thought format used "%s" and "%d"?
@ILikeToNguyen Why the change in visibility here?
Really a warning or only info?
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
This if will prevent you to get a lot of fields that could be read from another instance :  class A { int field; A foo() {} void test() { new A().field; // read and MSE expression is not an identifier A a = new A(); a.foo().field; // read and MSE expression is not an identifier } }
if (buf.length == 0) break/return
Shouldn't this close the iterator before returning the list?
The rsps List seems redundant, we can just use the futures array directly and avoid an additional allocation and copy.
Could this line also be called from the Utilities.setThemeToActivity() method? It's called exactly the same from all activities and sort of intuitively fits in with that method.
this is not really necessary, right? You could just take the current mod time of the file, and increase until you see it change.
Nit: You can use assertThat method from assertJ to simplify this. assertThat(foundResources).containsOnly(resource1, resource2, resource3);
replace with ReferenceCountUtil.release(msg)
The old version displays a clear intention and explicitly exhibits the operator precedence. Please revert.
This bit can probably be factored out into MultiModel, and reused below.
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
I think a finally block is needed here to ensure that the record set and the statement are always closed.
use containsKey method
Might want to return a 404 if it's not found. Otherwise :thumbsup:
[minor] Throwable#getMessage returns String, so we can remove the first empty string literal.
too bad we don't have a feign Response assertj class, right? this would look much nicer chained. (ps if you feel like it, make one, else no biggie)
you could just do return Double.compare(...) here, no need for the 'result' variable (this avoids needing break's too).
The ListenerList implementation already takes care of this. Remove the "contains" test.
indicatorService.delete(id, params.getUser().getId()) is called twice.
you moved and changed these methods in the same commit, can you please separate such changes to separate commits. It is much easier to follow that way.
any reason for explicitly invoking super.toMap() ?
are you sure we need to use OSString ?
It shouldn't be public
Make a copy instead, so that we will not accidentally change the passed in map. Also add requireNonNull to make sure aliases is not null.
This code can be replaced by return str.matches("^[-_.a-zA-Z0-9]+$")
This cast doesn't make sense. Casting the "actual" argument to SimpleScore would make sense.
Why is this now a magic 20 instead of props.getInteger(PARTITION_OPERATION_THREAD_COUNT)?
rename to erroneousEntries ;-)
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
out is redundant, should be able to use bos in its place
Do we actually need to fetch the account ?
Would you please explain why clear() need to call ?
This unit test has no assertions
please remove else, code will be more readable
Can't it be localhost
Do we really always to CRLF conversion - even on binary files? Wouldn't this corrupt all checked-in jpegs? Even if the file contains e.g. a null byte in the first X bytes - something we used before to check for binary/non-binary files? Or have I overlooked a check here? I always felt that the lack of git attributes which we could use to specify what is binary and what is not is the biggest obstacle why we didn't have autocrlf.
Wow, that was a bug? Is PKrangeID always guaranteed in this code path?
We should probably prefer setReference and setAlternate to be private (or protected if used by a child class, but I assume that is not the case right now).
remove return val never checked. Suggest adding in log (info maybe?) if task is attempted to remove but not removed.
PatientDiscoveryDeferredRequestAuditLogger is used in several methods. Can it final object when the class get loaded?
This test case in error-prone. Both the first and the second statement may cause an AssertionError. Try using try-catch instead. This may help us to determine that the AssetionError is thrown from the second statement.
Why do we need a snapshot of the world? Isn't it possible to just use getCurrentState() to get the selection?
This code has been updated and its also now handled such a way that this sync will be called only once during loading and wont be called again till opennms is stopped.
Not really related, but this reminds me that during a demo, it was a bit of a pain that we don't have the synonyms found and masterterm found column when not doing every "token" (I guess that word is actually wrong in some cases now). Would there be any drawbacks to always returning them?
I don't understand why System.exit is inside the test.
Did you check if it's possible to reuse the hasPermission method of the PermissionEvaluator?
better to print , some message like, using default file "file-drop-zone.properties"
You either need a hasDrawable() method or to delete hasBitmap() on Result
The logic has not changed here, it is just a refactoring, isn't it?
Thinking about it, should we switch to use Duration (would apply to my own PR, too).
It would be useful to know if i file was not deleted for any reason. Maybe add an Logcat error.
We have different conventions. Please see the spaces around brackets and method parameters, and brackets on new lines. The checkstyle plugin would crash the build. Did you try to run "mvn install -P run-its"? It would take quite long time to complete the build, cca one hour.
DAYS_IN_WEEK
I think we have to order this list based on their current indexes. Lets assume this list [0,1,2] and due to a table comparator the tableViewer selection returns [2,1]. This would give us [0,1,2] again instead of [1,2,0] The question is, if this case is actually possible ;) Same applies for move down
The value returned by isPlaced depends on the mapped flag as well. It would be a lot simpler if this provider had tuples of [seqID, start, mappedFlag, usePositionDeltaEncoding, expectedIsPlaced], with test cases for each possible combination, and the test just created a new record for each case using those values, and verified isPlaced.
You should freeLock after the transaction is committed.
Just one more thought about this first fix: what if the double spending transaction *is* relevant to the wallet (either directly by the double-spent UTXO or indirectly somehow). Is it still ok to disconnect the inputs? Do we already have a test for that?
Surprised you're not using some Java 8 magic?
What are you testing here?
Could this be caught and handled in the outer try/catch? There's overhead to creating an exception. In this case, we know the exception is caught and wrapped in yet another exception.
This drops all rs and collapses all ns to  .
nit: just immutableTs?
Can you please edit the message slightly so it would be more explaining? It is obvious, that when assert fails, something is not correct/expected...
@pinaf throws IOException could be removed
I am still confused by this. The one place where this configuration is used is to construct IBuildPlans in the server beaviour. this map will result in build plans whose IDs are the Url or name (which is fine) and whose names are the URL. This is inconsistent with how the build plans are otherwise constructed from the model jobs. When constructing the build plans from the model jobs the ID will be the Url or name, and the name will be either the display name or the name.
Why ignore the epoch/cluster id check?
The logic of this method should return true if any part of the range is covered by any part of the Block's revision range. Currently it only returns true if the entire range is covered by the Block's range
You don't need this as compareAndSet will set it to true.
If we continue to use a StringBuilder here, we should use it in a way that makes sense.
should this move to the removeProject try catch block? Another question. Do we remove normal schedule today when removing a project?
Given the verifyZeroInteractions that you inserted aren't these individual verifications redundant?
Just use !secondaryIndexes.isEmpty()?
I think we should not automatically append something to the provided name
This will add a message per host. So if we have 100 hosts and 2 are fine, we still get 98 messages. Wouldn't it be better to collect all failed hosts to the same message? Also, please check with Martin Sivak how he makes sure to collect all filtered-out hosts, so when there are no resources we present an informative message per filter.
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
This looks a logic change ? Is this correct ? If this is a bug fix send it in another PR and update <LINK_0>
just plain "java" seems to work for TestKillRestart?
extracty should be extract (extractyAnnotatedFields)
Druid's coding convention is breaking each line to not exceed 120 characters. Please follow it. Same for other long lines.
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
We can't have a multi-catch with Java 6, which is the earliest version we say we support in the docs.
When testing, I got an NPE when studentProfile is null. This needs a non-null check. Also needs a test to prevent that from happening again.
Did you mean getBatchSize() and not tableName here?
This should be Repository.class. The method is supposed to return the list of adapterTypes, i.e., the types to which this adapter can adapt objects to.
minor point: I usually prefer a static import of org.assertj.core.util.Lists.list for conciseness (feel free to ignore me).
Can you reduce the nesting depth here?
This change is unnecessary.
msg
Add a static import for assertVisibility method.
Need to 'put' in the cache, after the trace set has been updated - the put may result in the cached object being written to disk or distributed to remote node if we change the cache type.
nit: this should be o, not object, right?
Multiple getIndicatedServerNames() maybe clearer, if get once and stored in a local variable.
be backwards compatible
Is it replicaId or replicaIdCount when assigning values in message?
Why?
I would go with stream iteration here java titleList.stream() .filter(x -> Objects.nonNull(x.getQualifier())) .filter(x -> InfoSpaceConstants.SEMANTIC_CLASS_MAIN_TITLE.equals(x.getQualifier().getClassid())) .filter(x -> fieldApprover.approve(x.getDataInfo())) .forEach(x -> metaBuilder.setTitle(x.getValue()));
do byte, char, and short fields work when we convert a HCatRecord into a StructuredRecord?
remove this line
Move this also to the Util method as suggested in PR 331.
The field_type should be integer/number here, because the nightly job will be doing a math calculation on it while purging stale tags.
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
suppress warning (unused parameter e)
Is the + in "Course + " intended? Perhaps it could be removed
Is this the template or the actual path?
Here I would also prefer a one-liner with a ternary operator.
Move the cancel up above the persistor.write(). Since persistor.write() is synchronized, this will ensure that , if a background persist is in progress, it will be completed before the close() method is completed.
You could make tryList final and perhaps inline initialisation in declaration.
I thought java had automatic content type detection. If so, can you not pass the content type since that's what most users will be doing
can be simplified with return value!=null? value : defaultValue?
contextHelper.switchMobileContext(MobileContextUtils.View.WEB, getDriver()); it looks strange. I believe it should be like that: contextHelper.switchMobileContext(View.WEB);
According to this current plugins would not allow starting a workspace. Can you elaborate on how are you going to handle that?
Add the doc link, and find link.
What happens if the date is 02/10/12 00:00:00 ? Generally, How much of the behavior has changed ? How many of these test cases have changed output with your change ? Do they all run without your changes ? If not, are the failures expected ? Were we outputing one format before your changes and another one after them ?
Why are we catching and ignoring all checked and unchecked exceptions?
Is 7.2.2 supported? If so, then it should be ">=" not ">".
rename 'resource'
I'm wondering if logging and continuing is the right fallback here? Ideally we'd probably want to leave the event unprocessed rather than ignore it, but as echo doesn't really have a queuing mechanism, I suppose that failing is probably the only option.
This is cleaner: return (student != null) && (student.googleId != null) && (!student.googleId.isEmpty())
Check if an entry with the given key (name) already exists and throw in that case an exception.
I presume this was to avoid log noise. Why change? If your intention is to alert the user of the problem, it would be better to log rather than the task executor printing the stack trace.
My personal preference is to use brackets even for one line loops and condition. Not a blocker to merging.
Style issue: @Override shuld be on line above the method declaration
Let's include the group name and say it's getting the ids that failed.
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
Is this idempotent? If this is, Why does it need to be called only by the leader? If this is not idempotent, How do you ensure that this not called multiple times?
Accessing fields is generally frowned upon in idiomatic Java. I know it's an annoying extra couple of keystrokes, but it appears like the Task object is not actually encapsulating any state.
Can use existing existing message getMessageAnnotation(Symbol annotation) method
could you move it at the top of the class as you are using it more than once? :)
You can use Preconditions.checkArgument() here, if you like.
Could be useful to split this into Charge not available in ledger and Charge status mismatched so we will be able to quantity them by type (missing / mismatch ..)
you can use getGlusterVolume() from base class as the volume id has been set in the constructor
Empty method?
Then put an assert here? Just so there is an exception, that indicates that the connection was null.
this is not thread safe, is it suppose to be thread safe?
Can this really happen? If not why care?
Not very useful and will just clutter the logs
ss.getCurrentEndTime
Does leaderInformation must always contain a leader address? So we are not allowing to explicitly remove the leader information?
We should only be pulling down upstream changes here.
s/B/b/
is anyone going to know what a collaboration set is?
Since you have assingAnyCPuProfile now, you can use it here too, to remove logic duplication
name can be null, causing compareTo to NPE if its on the wrong side. In these cases maybe treat the name as though it was "".
"disconnecting"
How does this work if the app image is loaded? Won't the test fail?
any reason for explicitly invoking super.toMap() ?
I need to think about this some more but, given all the streamlining we've been doing for XD lately, I am not keen on all this per-message extra object creation, especially when there are no interceptors.
It would be more type-safe to do something like jsonMapper.convertValue(parser, JacksonUtils.TYPE_REFERENCE_MAP_STRING_OBJECT), on a parser you create using a normal constructor.
DRY: would use this(username, password, null) instead
Please bring the braces back.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
objects cannot be null after the constructor. (write if (fTrace == null), you will get a compiler error)
please use Cluster#hasGateway
allOn4_1 does not really correspond to version.onOrAfter(Version.V_4_2_0) which means versions >= 4.2.0
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
Same question about maintaining type information.
I think I'd rather store the instance as a field than to have to loop through the projections with instanceof attempts? You can easily store the EntityInstance during populateWithEntityInstance.
Thanks for updating the tests.
I modified the test to ensure that if intersects is symmetrical and the test failed with NPE:  @Test public void testIntersectsOnGeometryCollection() { assertIntersects("GEOMETRYCOLLECTION (POINT (1 1))", "POINT (1 1)", true); } private void assertIntersects(String wkt, String otherWkt, boolean intersects) { assertEquals(OGCGeometry.fromText(wkt).intersects(OGCGeometry.fromText(otherWkt)), intersects); assertEquals(OGCGeometry.fromText(otherWkt).intersects(OGCGeometry.fromText(wkt)), intersects); }  Here is the failure:  java.lang.NullPointerException at com.esri.core.geometry.RelationalOperations.relate(RelationalOperations.java:45) at com.esri.core.geometry.OperatorDisjointLocal.execute(OperatorDisjointLocal.java:31) at com.esri.core.geometry.GeometryEngine.disjoint(GeometryEngine.java:376) at com.esri.core.geometry.ogc.OGCGeometry.disjoint(OGCGeometry.java:275) at com.esri.core.geometry.ogc.OGCGeometry.intersects(OGCGeometry.java:280) at com.esri.core.geometry.TestOGC.assertIntersects(TestOGC.java:1007) at com.esri.core.geometry.TestOGC.testIntersectsOnGeometryCollection(TestOGC.java:1001)
also host/port instead of socket address
I prefer to use com.google.common.io.Closeables.closeQuietly(). It makes code more readable.
dataNode + "-State" should be enough. Also toString is not required. Spacing. Might wan't to apply coding standard template to this change.
Why was this added? This looks unnecessary.
again not this patch, but wouldn't it make more sense to have a 'toHash' method in storage_server_connections ? (and I don't understand the plural form here if it's only 1). Nor do I understand why the properties are allowed to have 'NULL' to begin with and not "" wherever relevant and avoid all this mucking around with converting NULL to ""
ReactorModule?
Program to interface, not to implementation - please change return type to Map<String, Object>
In practice, this can be the last check state listener to receive the event. The previous listener can have difficulty handling the large selection and freeze the UI thread for a long time. The user may have died before seeing the warning dialog. We should find a way to prompt the user before the elements are actually checked. The user should be able to cancel the selection.
It's better to use switches with an explicit "default" behavior. Usage of an external library (like @daniel-beck proposed) would be useful as well
Suggestion: Can unrelated changes be pushed as separate iteration?
We are using example.com in most other tests. I would prefer to use that one instead because we know for sure that it is a placeholder url and will not become meaningful in the future.
Might just be a personal taste, but I'd also prefer a for loop here:  for (Filter f : filters) { ArrayList<String> parameterValues = f.getParameterValues(parameter); if (parameterValues.size() != 1 || (commonValue != null && !commonValue.equals(parameterValues.get(0)))) { hasCommonValue = false; break; } commonValue = parameterValues.get(0); }
I this refactoring, very nice. Could make this method protected.
This seems to be similar to ImportVmModel.createSearchPattern() It would be great if the whole query could be extracted and shared.
Instead of relying on all the properties shouldn't we just rely on discoveryType? less confusion with if else logic and also while defining the descriptor.
This class is a DSF service and therefore can only be called using the DSF executor. So you can run the code directly without submitting it to the executor.
Why do we return the parents name instead of the name we store a few lines above?
what about changing to checkOpenOrWaitingForAutoClose()?
potential NPE: db is @Nullable
I think there should be && instead of || and the condition should not be removed.
Add SubChild here as well, perhaps SubChild is just persisted as a Child currently..
I'm pretty sure we use IllegalArgumentException for these everywhere else.
It looks like snapshot object should be created in lock, while saved out of it.
this should come after the volume==null check
This blocks the crash, but doesn't produce correct output. Either of the following would be acceptable transformations: js /** @const */ var module$test = { get a() { return 1; } };  or js Object.defineProperties(module$test, { a: { get: function() { return 1; }; } });
nit: you can merge both lines above as checkNotNull will return the given argument
Use 2-arg doc.setPropertyValue instead of 3-arg doc.setProperty
Shouldn't we propogate this exception?
Wrong param name here!
Just make this a List. You're iterating over a single list of LabelTypes, there can't be any duplicates.
The first if is superfluous. instanceof is always false for null, therefore a null value bypasses the instanceof checks and returns null from the end of the method already.
not so important, but for readability, you could define AuditLogType logType = checkHardLimit ? AuditLogType.GLUSTER_VOLUME_SNAPSHOT_HARD_LIMIT_REACHED : AuditLogType.GLUSTER_VOLUME_SNAPSHOT_SOFT_LIMIT_REACHED and use this logType in the 2 instances here.
![MAJOR](<LINK_1> 'Severity: MAJOR') Call "optionalBlobName.isPresent()" before accessing the value. [![rule](<LINK_2>](<LINK_0>
I don't think you want to call the super implementation, as you are handling capability registration conditionally.
Just return the negation of the if condition. Or return Strings.isNonBlank(contents) || Strings.isNonBlank(url).
We should get rid of this check and just have a DefaultHealthCheckHandler that always returns UP
unnecessary parenthesis?
data is never assigned, so this method always returns "". How about instead use: public String toString() { try { return getDN(); } catch (NamingException e) { return ""; } } as then you can't forget to return the proper value, and you aren't duplicating the logic which appears in the getDN method above?
forgot to commit the printStackTrace()
Yes, you can assign directly Boolean.valueOf().
adding an extra pair of around endTime - startTime would be nice for those of us who never memorized arithmetic operator precedence, like me :)
You want to use FormField.getFirstValue() here and everywhere below.
we also need to check if it is enabled otherwise we should load the native prepush hook if existing. Otherwise you effectively disallow using native prepush hook with jgit pgm since it always registers BuiltinLFS
- [x] Not required to check isDebugEnabled, because no heavy function on logging.
Can't break early here. Wrap the next loop in a null check instead.
What does it mean here to decorate it with Nullable while null is actually not allowed in the following line?
Using Long instead of long could open the door for returning a null object.
The following three lines of code causes for three updates on DB. First of all it is not clear, but second you open a 2 transaction, but updates are related, as I understand they should be committed together.
There shouldn't be logic in the Bean-classes, please extract it to the TaskService. Furthermore this code is duplicated in the "GeneratorSwitch" class. Please consider, what the code does and where it should go.
any reason for explicitly invoking super.toMap() ?
use -1, especially for rightMinPosition where Integer.MAX_VALUE could be seen as a correct value.
try-with-resources?
error log must be i18ned
I think each of these two constructors should provide examples of the querystring's they construct.
Here we can return the ITmfTrace that belongs to an opened experiment (because it has the same resource as the Traces folder trace element that is 'this' element. This is not what we want. I think what we want to do is: - If 'this' is a trace element under an experiment, we should return the ITmfTrace instance that is a child of that experiment (if the experiment is opened). - If 'this' is a trace element under Traces folder, we should return the ITmfTrace that is an opened trace with 'this' resource. (I think this can be the super implementation and will cover the experiment element case). That being said, for the purpose of the trim trace handler, if we try to trim a trace by selecting a trace element under an experiment, we need to use the ITmfTrace instance as in the first bullet above, but for the purpose of enabling the handler and determining the selection range, we probably should use the experiment element (as it is the 'opened trace'.
This will not be useful in the default configuration where maxPendingPersists = 0. It'll just print the warning every a persist is submitted, even if things are not actually being throttled. A better "possibly throttled" detection would need to check if a persist is running right before we submit a new one to the persistExecutor. That is racey but probably fine given that the check is only being used to emit a warning.
Make static
Why divert and separate address is needed. Why not have the retro queue under the original address? With having separate address will mean message has to be copied rather than it simply being a message reference to existing message. Also adds more risk in what if divert or other address dont clean up cleanly etc.
since we know this in the init, can we set a final boolean _extractAll? jvm might be able to optimize it.
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
Other implementations of Comparable in Java don't even check for null, do we have to?
I think we have to improve coverage of the cache usage in the mapper class: manstis/kie-wb-common#30.
you can use assumeTrue(store.getStoreConfig().storeValidateAuthorization) - the test won't run if it is not true (will get skipped, won't fail).
Consolidate to a multi-catch and log the exception details to DEBUG explaining why the exceptions were ignored.
The options are now rebuilt on every call. Did you want to leave the door open in case we ever need an option that would change for every new connection?
Do we have any concern about loading full logs into memory?
Couple of things here: (a) we can use Preconditions.checkArgument/checkState - less verbose (b) When throwing exceptions, I think it's good practice to include useful information. What dimension? What's the shape of the array? Without that, I need a debugger to get that information, which adds a lot of time required to fix it...
Same as above, asserting on printed output is brittle.
Looks odd to use buffer a couple of lines above and payload() here since both refer to the same thing.
We need a mechanism to specify that certain microservices get exposed only on certain ports. According to this implementation, all services will always get exposed on all ports. It is ok for now but create an Issue so that we can address that in the future.
I'm considering if we should introduce a method like SqlDialect#supportImplicitCast, the castRequiredForStringOperand seems a little too related to the sql contexts. There are kinds of sql contexts for implicit type coercion, also not only for STRING type.
this assigment is not needed, since its default value is false
Shouldn't need this, let's just use the class level reference throughout
Request.State.OPEN
why not make "update" a constant too?
Do you need to use the "text" constant?
Wouldn't you want to always reset loc, regardless of whether localName is loc or sitemap?
I think I prefer "Invalid key" as exception message
this variable name is misleading, it contains not only the commandData but also Ne field (see also other ApduTest classes)
make this synchronized.
can this be readSafely instead of readBuffer so that read uses readSafely
I don't think this needs to be stored in ZK explicitly. The way FATE works, each step of a FATE op is serialized to ZK. Therefore if you store any info you want to keep around in the TableInfo object, then the TableInfo object will be serialized in subsequent steps.
This would change accordingly, as well as several other spots in this file...
checkState
This is invalid before the change because LHS has a wildcard and RHS does not.
I think the hashed custom API should be prefixed here by the R.string.analytics_label_custom_url? This would allow us to return a list (or count) of all custom APIs that we've seen. So, it would look like CUSTOM_URL=8nh2j02f.... Otherwise, if we have only the SHA-1 hash, we'd need to filter for all custom API URLs that aren't region names, which would be much harder to implement/maintain.
Does this need to be a singleton?
Returning 0 or 1 is not exactly a good way to estimate the progress of the algorithm. Can you come up with a better way?
return new StringBuilder().append()....toString();
Should it retrieve the OAuth2AuthorizedClient again if the token is expired?
what formatting is this? @override should be above the method
This is ugly, see my notes in the token code.
is there a way to delete a scheduled job once a cron trigger is set
Is this part of the issue?
Don't know if this is what is intended but if this is done in another service already, I assume it is fine.
Maybe it would be better to combine this two try blocks?
I would suggest using the related constant instead.
isn't that redundant, getProcessId(event) does just that... if there is not pname or tgidname field, then just forget it and getProcessId() directly.
Shall we replace "Cannot get ozone delegation token from" with "Cannot get ozone delegation token for {}, renewer"?
Is here not a possible NPE if getModelElementsByType or following iterator call are returning null?
This complicates code quite significantly. Can you move it to a separate method?
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
if we fail here we have a stale VM version in hand. we should roleback
Similarly here, we should also verify that verifySecret() is called.
Exception should contain some details like length and related size to help understand the problem when it will pop up
log.isDebugEnabled() check is built-in inside log.debug(..) so this is not necessary. you probably wanted to avoid eager value.toString() computation that can be done by replacing same with value .
please also add the GUID which is important.
Instead of these setters, did you try doing this instead?  configurationBuilderHolder.getGlobalConfigurationBuilder.read(gcb.build())  What ^ does is take the base configuration objects that you read from XML and override them with whatever gcb contains. Is that what you're trying to achieve?
the createFormatValue() implements the same code as above allFormatDefs = getPossibleFormatValues();
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
i dont think clear is needed, it looks to me its called only once per run
oh... you are copying Radim's StringBuilder code... what is wrong with b.append(collection)?
consider using a mixpanelPushNotification.isValid() that checks for errors inside
Should defensively clone the WeightedTable.
use return ... ? ... : ...?
Since this "result value" only lives for a few lines it does not look necessary to rename it, but you could of course do this
should handle the exception some way
This should be moved to the ClusterResource. The ServerResource is only about the server where the REST call is being made. It feels strange to call http://serverA:11222/rest/v2/server/stop?server=serverB
Does OpenShift machine have meaningful toString() to use it here?
this.pool = requireNonNull(pool, "pool is null");
Might the AutoCloseable close() have already finished? Should the futures waits happen inside the try?
I think this boolean should be initialized to false as it is not connected to any server at this point
STRAFE_RIGHT?
does the disconnect() need to be inside the sync block? We are going to acquire another lock while holding partitions lock. Danger!
This statement could be removed (does not add much, it already goes to next cycle).
!(parent instanceof MGenericStack) || parent.getSelectedElement() == part
One of the need for acceptSession() API was to show user that it can fail. if session does not get accepted they need to do something? Either go to next session or have some code to log message about it.
No extra (clutter) please.
Isn't this a behaviour change for pig job ? Initially we used to set proxyUser either security enabled or remote user and then do a doAs to runPigJob(args), but now we don't do a doAs for non-security enabled case ?
Why was this removed ?
Is the idea to always copy because the request could be used again in a Retry (independent of a speculative execution being executed?)
maybe count the rows and assert the result?
Minor: maybe we should add a method to Data similar to isPortable?
set your feature as transient
The connectTimeoutMillis and readTimeoutMillis in the builder appear unused.
Is forEach better that putAll? I suppose we also need to take care of the case when params are null.  if (params == null) { namedParameters.clear(); } else { namedParameters.putAll(params); }
Is this still needed? We don't add any other elements, so parent.get(anythingElse) should return null anyway.
Please do not use "attributeDef" name, because it looks like "attributeDefinition" and object AttributeDefinition is Attribute template without value.
suggestion for (char i = SPACE; i <= TILDE; i++) {  Can you do that? Can remove need for casting below, and can make SPACE and TILDE chars.
Static import?
same here, can be package private
I think here we re-introduce logic we already have [1] [2], from my point of view would be worth to extract this scroll logic into a separate class and reuse it multiple times. [1] <LINK_0> [2] <LINK_1>
Shouldn't we remove the Realm and its management files?
assertFalse
Store unknown concept in variable outside of loop so it's not re-fetched each time
this can be moved to localize() method
should you enforce input correctness ? i.e. by org.apache.commons.lang.Validate.isTrue(maxNumberOfPrintedItems >= 0); ?
authenticateWithSharedTokenCache searches the shared token cache for an account each time. Shouldn't the account be saved off after the first time this method is called so that authenticateWithMsalAccount can be called instead?
since you are changing here, can we improve it to get rid of the sleep logic here?
If this array isn't meant to be modified aftewards, you can now use ImmutableList, which will have better read performance (and no potential synchronization issues).
Save an ... --> Saved an ...
This test and the test before would be more interesting if just the "includeStats" parameter when building VariantMongoWriter is changed (now we are changing include samples too). If one of both is required, it should be made explicit in VariantMongoWriter (I don't see that check)
These two lines probably can be combined into one.
We have a removeConfiguration so let's not allow null value here?
So if there are 3 parameters, we include 3 copies of all parameters?
The function name is 'shutdown' and message says 'Terminating'. Is it possible to choose one of the two words and make it consistent? "Shutdown" has an association with a more orderly, proactive cleanup vs "terminating". This might help in making the choice.
I believe this is a leftover change from your previous, unincluded PlantRegrowth rewrite. It stops plant sources from being set to air once utilized.
link with the problem of dependency explained in MANIFEST.MF
Another question, this is something I am not sure. No true or false passed in here as 3rd parameter in line 962. THe function signature has not default value. What value would be then for this invocation of fireDataChangeEvents?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Why not to get it once?
Will mesos always have permission to RW /data externally? And will /var/lib/elasticsearch always exist?
Args.notNull
This evaluates different value that it stays isLeftTurn will return true, in case it is slight left turn
can't you create the label in "getLabel" if there is no label? I think it's not intuitive to create the label beforehand
It is easy to think that the rest of the method is part of this loop. Try to always use braces, even if the body is empty: while (...) { // Empty on purpose. }
check for valid weight scheme here instead - convert into an ENUM.
log.tracef
I'm not sure whether there's implications at run time if the return type of body is not exactly the same as the given returnType. Is there valid reasons that we want to allow coercion? Why not just require the return type to be exact?
Similarly, Tasks.forException(new FirebaseAuthUserCollisionException(...)) can be used instead of the mock.
Should be a SamzaException with a message, not NPE.
If request.getCookies() can be null, how is that this line is working correctly?! Shouldnt we fix this too?
You could combine the two checks, if (requestHeader != null && requestHeader.size() > 0)
UndefinedDatabaseException should be handled.
Couple of things here: (a) we can use Preconditions.checkArgument/checkState - less verbose (b) When throwing exceptions, I think it's good practice to include useful information. What dimension? What's the shape of the array? Without that, I need a debugger to get that information, which adds a lot of time required to fix it...
Does this need to be a singleton?
The logging message here is not accurate, please update it to reflect "executor is removed".
Should be a SamzaException with a message, not NPE.
why not make CONNECTOR_ACCESSIBLE_PLAN_NODES field public? assertEquals(ApplyConnectorOptimization.CONNECTOR_ACCESSIBLE_PLAN_NODES, ImmutableSet.of(FilterNode.class, TableScanNode.class));
This returns a rather large hard to read garbage. Instead, why not have a static AtomicInteger with addAndGet()? That might cause problems with ,multiple hosts, so maybe a static hostname variable that is initialized once, concatenated with that int? So it becomes lightbluecrud1-1234, which might be more human readable.
not going to keep pointing these out, but it needs to be addressed throughout the entire diff
Isn't EMPTY_BUFFER the "" case? and null is the case where flag should be unset?
The above line will set the default_job_timeout to null if the user has not specified it in the request body. IMO, Server should throw an error if the default_job_timeout field is not specified in the request body. Use jsonReader.getString instead?
Unhandled
I think this should be done in this patch, as now this method will replace the old getActiveMaster method, which makes it not only be used in our internal refresh but also be used by end users, we should not let users still have the ability to harmmer zookeeper...
Can we rename the message to "PartitionListenerThread Shutdown called for datastreamgroup"
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
I'd suggest simplifying this block to (and for the similar cases below):  return super.getConfiguration(igniteInstanceName) .setIncludeEventTypes(EventType.EVTS_ALL);
Should we better make this method package protected to only allow jackson access to it?
Similarly here for the csv variable.
... yes it does ...
should this be in some MathUtils class?
I guess you are putting it twice. Here and in line 181.
objCount or totalObjects is better
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
Please add a note about why MySQL, Oracle and Hibernate 4.2 and 4.3 aren't supported.
nit: if (p != null)
Same as for the hashCode - what if the element is null...
Class<?>
awaitRetentionExpiration(1000L); -> awaitRetentionExpiration(1_000);
This method may be written in a single line; check the reference for HashMap#get, it returns null if the key doesn't exist. <LINK_0>
nit: if (p != null)
assert name != null;
Instead of performing the candidate search in the get() function above, you could do it in this function and avoid the double control lookup for each candidate. And since this method returns all the info needed to return projects and project.Namekeys, the get() function could then call this one instead of this one calling get().
.append(content.substring(0, insertionIndex)) was IMO more explicit
We're on Java 8, so: IntStream.range(start, start+length).toArray()
I don't think args can ever be null, can it?
Minor: you can provide suffix and prefix args to Collectors.joining and avoid adding brackets with +
This will break logging again: LeasedLockToken is not loggable by our logging infra. So either get rid of the args in this logline or figure out how to collect the stuff you need in a way that's loggable.
Can you make this somewhat more Guice specific? E.g. guice.stage or inject.stage or something similar. Guice is probably not the only thing that can have a stage
Summary: 1. Removed @throws IllegalArgumentException when alias is null. as it is not required to declare throwing a runtime exception. We haven't declared this in other places e.g. Database class as well. 2. Remove an extra empty line before if(<variable> == null) {. 3. Add a space between if and (. Should be if (<variable> == null). 4. Add . (full stop) at the end of "... is null" -> ... is null. 5. Do the same for the other methods.
It would probably be better to have a clear separation between the call to getSolrUrl() and the creation of a log.
What do you think about making this method private and having two public ones: enrollUserInCourse and enrollUserInSection which then call the private one, adding the boolean parameter? Seems like it would be a little bit clearer to the users of the library. The two public ones could verify that the enrollment object has the required section or course ID before passing it on to the private method to do the work. (Stringutils.isBlank() check with an IllegalArgumentException thrown if it fails)
This solution still does this lookup and these tests potentially many times for the same parent project. And although you know will limit the returned values, you are still incurring the cost of iterating over every project here!
this exception is caught immediately below and effectively swallowed. Either logger.error here or before connection is closed so we see rational for closeConnection call in the logs.
This method seems to be a copy of SourceForeignKey.checkImportedModel().
This looks like it's impossible. Given L68, sampleRateIndex can only be 0,1,2 or 3 here, I think? If you agree, please delete this block (and the TAG constant near the top).
It is getId() of the pool -- see the other Tracer invocations
Using something like ImmutableSet.copyOf(contentTypeToTemplateEngineMap.keySet()); would make sense imho...
String.valueOf(0)
hmm, that method makes somewhat sense in core java, but I'm not sure I like that behavior for selendroid. We're expecting a boolean value, but essentially we only care about either true or "true" coming across... everything else is false. Is it going to be confusing to any users? I'd almost rather add an additional else clause to check for the string of "true" or "false", otherwise raise the exception. Since users of other programming languages (like javascript or python) may have a different impression of what a truthy value should be.
can be replaced with CloudTrailEventSupport.getRegion(event)
Avoid the scannerLock object and synchronize on KieRepositoryScannerImpl.this. I believe this will make also clearer that you're sync'ing on the same lock of the scanNow() method.
minor: change exp to exc, since exp kind of sounds like an abbreviation for expected
We usually use UnsupportedOperationException
remove
I feel like you should inject this threadpool, when an internal product instantiates a lot of these it will probably want to reuse the threadpool
Would a sure maxVote be some other numbers if we add more features?
I have question about this config. Will this determine the serverfactory for ambry-frontend and ambry-server?
if input is null isn't it valid for blacklist patterns ? if input is null isn't it valid for blacklist patterns ? I think we should either throw illegal argument exception or consider null as valid. I prefer it to be considered as valid because then the caller doesn't need to unnecessarily check for null of the input all the time.
Shouldn't we check if (e != null && (e instanceof CancellationException || (e.getCause() != && e.getCause() instanceof CancellationException)) ?
Oh, right, that was me. Sorry!
FYI: You don't need to over specify generics in Java 8 anymore, so:  List<Integer> list = new ArrayList<Integer>();  can simply be:  List<Integer> list = new ArrayList<>();
Wow, this is impressive! Great first cut.
you should use Integer.compare(o1.., o2..) here, since this method should return either -1, 0 or 1.
Oh. This actually creates a Java project. So it really should use the JavaProjectTester. Note that other places where we use Java projects we switch off autobuilding. Does this project need to be a Java project? Which tests need that?
If there's a lot of data we could add a Accept-Encoding: gzip header here and call IOHelper.readString(HttpURLConnection) instead.
Why close twice?
bucketNodeMap.getAssignedNode(driverGroup.getId()).orThrow(IllegalStateException::new)
In general, not a good idea to pass a mutable map around. ImmutableMap.copOf()?
Let's define eval to a constant.
What about testing the happy path - that a POST is made to a correct URL if correct arguments are provided?
could you define static constants for these strings?
Did you mean to make it a constant?
what I don't understand is the the else clause in line 437 below? Why is there an else?
final This should probably contain this.value = value at some point... and it should only do so if isListening = true.
This seems like a pretty weak version of hashCode(). How about using things like HashCodeBuilder to generate the hash code?
typo: you have two "f"s To avoid such typos, please copy from the config directly. These are quite hard to catch and we are not always looking for them.
Use assertNotEquals instead of == operator combined with assertFalse, == does not work properly for non-objects. <testing
The super() returns "" on null. Why should we differ?
Is it really necessary to refactor this method that heavily? I personally find the old implementation to be much more readable. - What is the use of transformNoResponse? If someone wants to customize the behavior, they can simply override transform(). - Why have both "byResponseStatus" and "byResponseStatusFamily" methods? The family case is just a sub case of the status case.
Is it okay to only checkForDecideUpdates() in onActivityResumed()? I think with the current logic, only one call is necessary now since we register the listeners.
Need to 'put' in the cache, after the trace set has been updated - the put may result in the cached object being written to disk or distributed to remote node if we change the cache type.
Optional should be used in interfaces. Use null as internal value.
@ikhvostenkov this variable can be inlined
<rowid> or <row-id>. No spaces here :)
I would prefer you use here an UIText.GitModelWorkingTree_workingTree instead of hardcoding this value in test
Use SystemTime to get the calendar
Need whitespaces after colons
Simpler to just say  if (!project.hasPermission(Item.CONFIGURE)) { return new AutoCompletionCandidates(); }
Can make this into a singleton as we have with UNSET.
doc can never be null at this point because if it was null two lines earlier doc.getField would throw NullPointerException? Perhaps you meant field?
Are any of these configs dynamically changeable? Looks like we load it once.
For loop?
there is no real reason to log this, i think, since there is a log for commands execution and also audit logs if you really like to keep this (and the others below) please change to debug
503 Service Unavailable would be more appropriate I think
Seems possible to simplify. If I understand correctly, this loop is handling the case when we need to paginate. The loop below is when you do not. But all getAllQuayTags is doing is putting all tags into one big collection. It should be possible to simplify by modifying getAllQuayTags to be tolerant of results that are one page.
Final.
Use File constructor with separate parameters.
I think this should be more for UI testing. Open trace, open the view, make sure that table is filled correctly.
We should probably use the separator for the slashes in the /stor/multipart string as well.
Could use assertException(ClusteredLockException.class, AvailabilityException.class, ex), or even betterexpectExecutionException(ClusteredLockException.class, AvailabilityException.class, lock.tryLock(100, MILLISECONDS) if you expect the call to fail.
Move this condition higher
There seems to be too much tabulators in my opinion. Please use 1 instead of 2 or even 3. And also there is probably no need to use new line on the row 943. You can inspire yourself in VoEntryManager on the line:97 method getAllVos. Thank you.
For PropertyChangedEvent, "args" will always be an instance of PropertyChangedEventArgs. Therefore you can also cast "args" directly, for example: String propName = ((PropertyChangedEventArgs) args).propertyName; Above should simplify the code a bit. It's up to your consideration, as for me the instanceof is just unnecessary complexity. BTW, we have a BZ exactly for this issue: <LINK_0>
Instead of this constructor using the other, I would make the other to use this constructor with a null linkUrl. What do you think?
This seems to be failing compilation.
Can you refactor these 4 lines to make a new function as follows. Then you can call it from 3 places (getCommittedWindow, storeCommitedWindow and connect) private void writeWindowId(long windowId) { BytesMessage message = getBase().getSession().createBytesMessage(); message.setStringProperty(APP_OPERATOR_ID, appId + "_" + operatorId); message.writeLong(windowId); producer.send(message); }
can we rename the string -> docId for more clarity
again, WARN if we are retrying
unsubscribe()
Is this still necessary? Where is this used other than here?
LOG.warn("Failed to publish to kafka topic {}", topicId, exception);
name must be final here
This close() method needs some refactoring to make sure that all the stream readers are guaranteed to be closed. For example, what happens if orcDataSource.close() throws above, or when validations above fail? You can use com.google.common.io.Closer, there are many examples of how to use it.
Might be good to put these two lines in a transaction. No sense making an expensive operation even more expensive...
shouldn't you check whether the enable value is true or false?
What about using a JOptionPane instead of layouting a custom dialog?
Resource leak.
Should be a SamzaException with a message, not NPE.
This probably isn't needed, unless we click on it?
Since we pass info as the message param to the super, do we need a copy in the subclass?
Old-style catalog items don't support osgi, so no point in the change, but doesn't hurt either.
return data.stream().mapToInt(CurveParameterSize::getParameterCount).sum();
c instead of t here for Connection?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
I would add this line before line 134, so we first fetch the LunDisk and from it we will fetch the lun.
why the second nested "if" is not just part of the upper "if" (the one that checks type) with a && condition between them? And is it safe to cast it here to DiskImage? What if the casting fails?
Can we make this package private instead?
For PropertyChangedEvent, "args" will always be an instance of PropertyChangedEventArgs. Therefore you can also cast "args" directly, for example: String propName = ((PropertyChangedEventArgs) args).propertyName; Above should simplify the code a bit. It's up to your consideration, as for me the instanceof is just unnecessary complexity. BTW, we have a BZ exactly for this issue: <LINK_0>
Change to AGENT
I think we can do this only when savedInstanceState == null (ie: when the activity is first created). Otherwise the plugin info is updated every time the device is rotated, which seems wasteful.
LOG.error("can not broadcast for job manager {}", e) instead
Also add warnings for all transitions that have lower priority. Use message like: ' Dead transition. This transition can not be taken due to previous transition with '%s' trigger.
Doesn't look like this is used
use log formatting.
NIT: else Logging or IOException
This can delegate to the two-argument createSystem variant.
We know rankingStr is null, this will fail in NPE. Split into another if such as what you did for the postProcessors extension point.
Maybe better to return null
Please use Optional.ofNullable()
this. maxRetries = Math.min(5, maxRetries);
Why not just read from the stream using a bufferedreader?
Use fail again.
Floating point math is weird, is this always going to be 1.0?
writing the identity hint in this method is very confusing (and potentially wrong) because it should be done regardless of the type of curve, shouldn't it? IMHO it should be moved up into *fragmentToByteArray* or into its own method ...
I don't see any waits to be woken up by this notify?
Does this need to be SEARCH_QUERY?
ObjectUtils.tryCast(expression != null ? expression.getParent() : null, ErlangColonQualifiedExpression.class);
@NielsCharlier consider refactoring this to use Java 7 try-with-resources.
Hello @mcimbora , I think it can be worth to provide a more fine grained filtering here. To be sure that the method is not a constructor, has the @Generated annotation, and also "is one of the generated" by the planner stuff. Probably inspecting some additional planner generated annotation for the method (I I don't remember wrong for this planner generated method you added has also a planner annotation with two parameters?) or eventually exploring the return type, or some other trick. This will prevent us from loading other methods with the @Generated annotation that we don't know how to manage. Specially because when the java source is being updated, all the accepted methods are being deleted.
This method is in a non-final class, so there could be code out in the wild that override this method, so we cannot change its signature
Yes, even if we add empty set of tags the entry is treated as accessed. I don't think it's correct.
ugh, blocking ALL insertions while you're iterating on the whole thing to do a query would be a huge slowdown. There needs to be locking in here, but it's really something that would be abstracted nicely in a separate "BufferedBlockingQueue" class.
What about "fail[]".length() instead of 5?
remove useless blank line
Use %s rather than %d unless you need specific formatting like %02d. It's safer since it works for any type.
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
Is not it subject to ConcurrentModificationException?
Typo and add a space
Hmm, everything else uses the cacheloader, feel like we should probably convert this to working the same way if possible.
We are just asserting on null here. Could we have some more meaningful values to test for?
Instead of using Boolean.valueOf(boolean).toString(), just use String.valueOf(boolean)
objectMapper should really be declared "final", also map below
This should be a test error.
Add the other properties too?
We need to rework this method (replaceAntiCsrfTokenValueIfRequired) to ensure that we are able to extract tokens even if not previously registered (i.e. use ExtensionAntiCSRF.getTokensFromResponse with loginMsgWithFreshAcsrfToken, instead of getTokens and getTokenValue)
this should probably be an error?
Same question/concern as before. Wouldn't updated resource configuration simply result in the previous configuration history to appear on the resource's configuration history page?
unsubscribe()
Can we find a better name? I mean, when you read quickly, you can easily read it as a RealmObject.
se (SWT.H_SCROLL | SWT.V_SCROLL) instead of SWT.NONE style when constructing the table
no logging here? seems dangerous to depend on the user of ProcessThread to correctly check and call getException
@omkreddy can you make similar changes here as well?. I had missed this in the previous review.
missing @since tag for new API
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
this should be indented if so the god of eclipse permits.
this message is not related to the version check
Construct this dynamically with a reference to the enum value for the error code instead of hardcoding 28
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
fail
why this one and the straight up delete?
List<PartitionId>?
1. Let's make it a warn instead of a debug. 2. The error message can be more specific here: Error closing task producer for task {} while handling lostAll.
nit: empty line
This is entirely pointless, mDevice is null anyway (not initialized).
I think that may have been an oversight in longSum. Try a query that results in +Infinity at the historical level and you will see why it is needed to deserialize at the broker level
Use a constant.
not sure if this is super-clean... returning ""... I guess it simply not be added to the this.reverseRoutes afaics... (I may be wrong though...)
You don't need the variable here. You could directly return inflater.inflate(fragmentResource, container, false)
nit: if (p != null)
Shouldn't need to sort O(n log(n)), probably better off iterating through them once and picking the maximum. I think javascript sort functions are supposed to return -1,0,1 like javas compareTo, I think this might be backwards.
there are multiple uses of these values in different tests would be nice if you could move them to constants with a descriptive name. especially height and width because they are always the same
Same here. We should make self final explicitly.
should surround the overlap with checkNotNull(overlap, "MergeFunction cannot be null!").
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
I don't think moving to trash is appropriate on this particular line. We know that a child directory of the pending-trashed directory is already in trash, from line 231 (because stats is empty, if deleted = false as of line 231 then stats.length will be > 0), so moving a now-empty parent directory would just create a timestamp-suffixed duplicate empty directory in trash, at each level of the path hierarchy. Reverting back to the original code here should be completely safe and a lot cleaner.
I think this reads better, if you extract the Display.getCurrent() to a local variable before this block.
do we care to check the length to be positive here?
Again please fix all occurrences of this exception message.
logic would be simpler to instantiate the collection if containsKey() is false, and then do the add() outside of the if statement
adding an extra pair of around endTime - startTime would be nice for those of us who never memorized arithmetic operator precedence, like me :)
I'd just merge the following into a single statement  block.append(ifStatement) .visitLabel(...) .append(...) .visitLabel(...);
I would give much much smaller cache (for example 10minutes). Consecutive reading of the same file will be rare and will probably be done in short time period.
you could just do setConfirmWindow(null); like above method
worth having both these lines as clearSubscriptions()?
String.format
if (!platform.equalsIgnoreCase("android") && capabilityManager.isApp() && capabilityManager.isSimulatorAppPresentInCapsJson() && hostMachineJson.has("simulators")) && !capabilityManager.getCapabilityObjectFromKey("iOS").has("browserName")) {  Let make the condition like this. Booted simulators also needs to be ignored in case of safari. It didnt work the way we expected so lets make the change.
The value returned by isPlaced depends on the mapped flag as well. It would be a lot simpler if this provider had tuples of [seqID, start, mappedFlag, usePositionDeltaEncoding, expectedIsPlaced], with test cases for each possible combination, and the test just created a new record for each case using those values, and verified isPlaced.
An alternative would be to check callExpression.calleeSymbol() != null
How about inlining it?  if (!contains(o)) return false;
use return ... ? ... : ...?
I think we can use describeMatch instead which inherits the summary message from the class-level BugPattern annotation.
Is this still needed?
if you do this, better put N/A :)
file might be a directory - message will then be misleading
There should not be a need to set this to public. Perhaps private would be better.
please remove this. on this line and the next
Meh. Not sure why a wait() was used here and not just a sleep(). Nothing is notifying.
We should put a child monitor here, set it to the number of units of work that the project has, and do 'worked' for each one of them.
Should we better make this method package protected to only allow jackson access to it?
Maybe we should derive this from Prefs.getMediaWikiBaseUri() or require the client to pass in a default protocol. I think I prefer the latter to avoid complicating this nice and simple model type.
See my note on the previous diff here: the passwordFactory should be queried using the convertibleToKeySpec method instead of instanceof checks.
Is this a convenience method or do we have genuine uses for having both generateWriters() and generateAndWrite()? Put in an alternative way, why doesn't this delegate to generateWriters()?
nit: Should we use StringUtils ?
You can do this without an Iterator:  for (Map.Entry<String, String> entry : rawQueryParams.entrySet()) {
suggestion
Shouldn't you be doing in this DAO in the query?
Thinking out loud, wouldn't it make more sense to use the file creation time, or the last modified file time?
How so you say node obtained if the statusCode is HTTP_NOT_FOUND?
Feels like skipRead should always be true here, but it looks like it's not really used.
boolean can be used instead list. defaults to false
I think here, it should be requireNotNull(userName)
Don't return null. Make it Optional<String>, and return Optional.fromNullable(...)
your toUrl method would throw AssetionError itself, so no need to null check here
Add SubChild here as well, perhaps SubChild is just persisted as a Child currently..
Do we need the checks both here and in the WindowAgg operator? If this code could handle other definitions already as well I think we could keep with one limitation that is closer to the components that cannot handle other definitions.
I think cache.get(key) == 100 should be true in any case
Do we care at this point of the status of the container.vtl file?, meaning +live:true?
Wdyt about removing this variable and returning machines just from try/catch ?
There is **addSystemWideContainerSettings** method for such code
I think you mean isNotBlank here.
Consolidate to a multi-catch and log the exception details to DEBUG explaining why the exceptions were ignored.
nit: you can merge both lines above as checkNotNull will return the given argument
StringUtils.isEmptry(XXX) if possible
Please do not construct exception message for some pessimistic case in class constructor. If you want to use same message twice, you can have a method formatting the message.
This doesn't seem right... wouldn't this result in the file's path being the file path of the parent directory (and hence overwriting that directory)?
oops, I missed to merge with Stefans fix for annotated tags (calling getPeeledObjectID()). I'll add that again.
Should probably remove(key) if value == null.
Shouldn't you use context.getCurrentAddressValue() instead ?
What is the point of having _both_ these statements?
ParameterNameProvider=ClockProvider Or, better yet, let's just move to getUnableToInstantiateException(), I don't think there's much value in having the dedicated versions really.
Eclipse is warning that the argument r is unused. I guess this should be changed to r?
public methods should be deprecated, not removed.
Why do we set this to null then pass it into the builder?
Class name is not needed when calling method on same class.
I am reading the class again again and I think we do not need sourceColumnIndex to be class variable. I think we can keep its scope just in the for loop. Then I think the only usage of sourceColumnIndex can be replaced by columnIndex.
please also add the GUID which is important.
We can replace this whole for loop by: final List<String> formattedPrefixes = prefixes.stream().map(prefix -> " nval LIKE '" + prefix + "'").collect(Collectors.toList()); sql.append(StringUtils.join(formattedPrefixes, " OR "));
The status should never be null, instead it should either throw generic exception (including NotFound if that is what the response from the coordinator indicated).
Shouldn't this check go to the service instead of here? Seems quite convoluted to have to submit an UpdateConfigCommand only to have it bubble all the way up?
It's a good update
StringUtils.isEmptry(XXX) if possible
Recycling a digest to which we still have references (namely in the member variabledigest) is bound to give problems at some point: another thread may obtain it by means of HashType.get() while we are still using it! If you insist on recycling digests, I guess this could be done in the finalizer of Hash. Note that the semantics of finally don't have anything to do with finalizers!
Not worth changing the commit for, but this could also be  replay(command, request, response, cache);
this is identity projection, can you use something more complicated like a +1?
Casting is not required here
add requireNonNull for bytes
1. Did you mean support only Firefox for _testing_ right? I assume the difference in behavior affects testing only? In that case we should keep the production code clean and apply any workaround in the test code. e.g. do an if-else based on WebDriver. 2. Yes, I think at some point we stopped using Chrome for testing. There are many other quirks between the two versions that gets in the way of comparing html. We can check if anyone is using Chrome.
It seems like it might be cleaner if we move all the waitForPossibleSplittedBatches logic into a ProducerBatch.await method that performs the await on its produceFuture as well as on the child batches.
what else? any warning or exception should be there?
this could be collapsed to new Gson().toJson(Map.of...
How about reading all of them at once and just the one we actually need?
This recursive invocation never ends.
![MAJOR](<LINK_0> 'Severity: MAJOR') Invoke method(s) only conditionally. [![rule](<LINK_1>](<LINK_2>
I'd return suggestedId for the time being, but if you have reasons to keep it this way for the time being I'd be ok with it.
Maybe we should use a specific ID/token (e.g. "HTTP", "WebSocket") instead of the class name?
This logic is fully implemented in the AbstractReplyProducingMessageHandler and its super-classes. You just should return the result of the query.
lambda?
I don't understand why you verify if filterChain needs to be updated with every message read. Maybe filterChain should be volatile.
nit: extra parenthesis around function
format across lines  if (VCF != null) { ... }
That should be toHtmlForAnthology. You mixed those two up.
size is calculated here. Do you want to change sizeCached to true?
Pass null as a listener, it will dismiss the dialog.
I'm surprised you didn't use a lambda... :p
return (source != null && source.isValid()) ? source : null;
cache the layers in a local variable
java return (bundle.getState() & (Bundle.INSTALLED | Bundle.UNINSTALLED)) != 0;
This should also not be an error.
Please use the new method of adding one or more subtypes to a card. ie, this.subtype.add(SubType.Cat, SubType.Knight); String methods will be deprecated.
Please replace with: VmDeviceDAO dao = getDbFacade().getVmDeviceDAO(); it will ease mocking when writing tests.
Does this need to be public?
Why remove these?
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
Change first occurrence to Set
use logger
Are we sure we want to un-static-ize this? Can't we get the trace from the EventDefinition?
other methods like this put name first, then id. switch for consistency
No need for final parameters?
Maybe we can explicitly ask Topic if it should be validated...
Same as with the imperative template: Shouldn't we just deprecate these methods and introduce Flux<SearchHit<T>> search( )?
IMO this should always return ElasticseachrJson.Result.
please add the actual values to the error message, in case it ever fails
Long method, parts of this can be extracted
so then this would run asynchronously (because new thread) in the shutdown hook? doesn't that mean it is possible that it hasn't shutdown completely then?
Seek to just before the readahead limit...
Out of curiosity, why is the return type of this setter not void?
This may not fail if anything in #rename or nested calls moves to a different thread. Have you tested? I'm not sure how JUnit handles this. A simple #get call on response and a subsequent fail("Rename should have failed when it did not find the current name") would work otherwise?
rather than needing an ArgumentCaptor here, you should just be able to do any(ZonedDateTime.class)
Any particular reason you left out "jk" and "wxy" from these sequences of alphabetic characters? And wouldn't it give us just as reasonable a measurement (albeit not identical) if we wrote a single sequence of a-zA-Z 50k times?
prop: change stateStoreNames -> stateStoreName here.
Same add/offer issue.
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
You could construct empty list. Compute the length of prefix to be copied from source list. And the perform copy instead adding all elements and then removing suffix. THough I am fine with this approach too.
Can you update the generator to remove the modifier so that the constructor stays at the package-private level?
This is wrong. What this plugin does is to filter the duplicate records based on the unique keys and filter function. The input and output schema basically will not change. So your field lineage operations should be a list of one-to-one field mapping from one input field to the output field.
could you move it at the top of the class as you are using it more than once? :)
This returns false if memberName is set. It's not what I would expect, though, given the function name. When I'm comparing to the class name, I expect to test against the class name and only the class name, regardless of the state of the other members.
You seem to be reusing this code in the other method overload as well. How about moving this logic elsewhere into a separate method to minimize duplicate code?
Always make sure to wrap the entire Runnable that you are scheduling in a try/catch if you want it to actually continue running. If an exception _ever_ makes it out of the Runnable, the schedule will halt. You have a try/catch over some of the business logic, but what happens if you get an NPE on 80 or for some reason itr.next() throws an exception or something.
TODO: This is why you are getting isMainPage=false when you go back to it.
To make assertion message unambiguous I would change "status" to "instructions".
What is this for? Feels like some unintended checked in code?
How about inlining it?  if (!contains(o)) return false;
This is not naturally readable. What about to rename the project() method to something like hasSameIdAs(). The same naming problem is also in the other matchers.
Actually, we can remove this line. Yes, I know you did not add this, you just copied it from the existing source - but I looked into the details, and it only caches textures, which are not being queried here.
just for a better readability, better creating a new typed variable and avoid doing same cast to ReusableSubprocessTaskExecutionSet on each line
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Isn't there a timing issue involved here, e.g if the server is slow returning the access token? I'm not sure how to solve this though
why did you change to final here? should be outside of the scope of the patch.
Can you add log.error to this catch statement too?
Use Collections.emptyList() to avoid unnecessary object creation
Why call setScrollBar() twice? (L157)
I think this would be better done as two cases, 1) if profile, add it to both registries and 2) if package, add it to just the package registry.
two arguments is iffy. e.g. if you just want to enable -nestedLoading, you also need to specify 'org.apache.hadoop.mapreduce.input.TextInputForamt'. we can move input format also to arguments (-inputFormat). '-inputFormat' will be rarely used.
(forever!)
Does this method need to be public?
@CheckForNull return. And why is this declared to throw NotExportableException?
can you change name of this list because 'l' says nothing to me
I like stringCapability much better!
This will loop forever if the user sets a negative size.
You should throw a WebApplication exception with a JsonError as entity for the client to receive a valid JSON.
Removed it
Why override this method, when you only call super method?
The initialization of length needs to be done only once and not all the time getClonedStream() is called. If we would like to handle file length changes it does not work (IIRC) as the file size could change also after the file input stream has been created. So, I think this line could be moved above after file = new File(outputFile); Or is it because you don't want to handle FileNotFoundException twice? But reset the size all the time... Hm WDYT?
We already have a local trackMetrics below, for XID events. I would assume execution time is per transaction, not per update - can we track this only for XIDs, or is that not how it works?
you can simplify this with String.join(",", getSortedList())
Could be a try-with-resources.
I don't think you need to walk the staged files, unless you want to. You should just be able to add the entire staging directory, and then iterate over your map of digests, calling addFileFixity for each.
whitespace is a bit off here
Why not applying forEach on refs directly ? Furthermore, @efge has made changes in SetPropertyComputation to better handle error, does it apply there ?
Immutable?
Formatting, the space in times( 1)
When concatenating the log message it would better to pass every parameter into the Objects.... rather than concatenating the string which is inefficient.
use assertEquals.
Can you please change it to '/'? This is faster.
Looks like we can simplify this complex construction here by decomposing it into servers.get(SSH_PORT + "/tcp") variable and if/else block  java final Server sshServer = servers.get(SSH_PORT + "/tcp"); if (sshServer == null){ return null; } else { return sshServer.getAddress(); }  or something similar. What do you think, does that fits here in your opinion?
to be consistent we should introduce constant for kmodule.xml
This two lines don't do anything proper. From other side you don't update MessageGroupMetadata in the persistence store. For that looks like:  java Assert.isInstanceOf(MessageGroupMetadata.class, mgm); MessageGroupMetadata messageGroupMetadata = (MessageGroupMetadata) mgm; ... UUID messageId = messageToRemove.getHeaders().getId(); ... messageGroupMetadata.remove(messageId); .... doStore(MESSAGE_GROUP_KEY_PREFIX + groupId, messageGroupMetadata);
There should be a null check here if it doesn't accept null values
Was wondering if it could make sense to put this in a function to align with the code above. wdyt? (Also probably does not make much of a difference but we are not returning a true to assess we managed the event.)
Mappers can be stored in static final variables instead of rebuilding these each time.
perhaps have the pair as Pair<Boolean, Guid>, we don't need the entire domain object.
Let's make this non-static and non-private. It seems like it's a function that might be useful down the line.
Should this be mHandler.postRunnable(mCountDown()) instead?
does not need to be public in non-public class
maybe this was the test that had a problem with NPE?
nit: you can merge both lines above as checkNotNull will return the given argument
the local var can be removed, doesn't seem really helpful here..
I'm not that much convinced by the message, especially has we are going to have a FileInputStream here, not a File. No secondaries/flow?
suggestion LOG.info(" JVM Heap: {}", flinkMemory.getJvmHeapMemorySize().toHumanReadableString());
This method needs the same processing that happens in addJavaOption.
Presumably the method getAllGroupsSize in KeycloakUtil was written so that it could be used here?
maybe consider isHidden() ?
When concatenating the log message it would better to pass every parameter into the Objects.... rather than concatenating the string which is inefficient.
You can use StringUtils from the commons.lang3?
The logic in the method can be improved. It is currently difficult to understand and hard to follow whether it is correct or not. What if it is as following: if (n <= 0) { return 0; } long remaining = count - pos; if(remaining < n) { n = remaining; } pos += n;
You should pass here message not group converted to string.
sounds fine to me.
final
We have Default, Left, Top and None as options. I think the label should be created when the alignment is Default or Left and not created when it is None. But what about Top? I think we should at least log a warning/info that this configuration is not really supported with compact mode
you need to call finishAndRelease() on both channels in a finally block to fix LEAKs.
Why catch this throw it
1. Let's make it a warn instead of a debug. 2. The error message can be more specific here: Error closing task producer for task {} while handling lostAll.
Factor out the common logic in a private method for both updateCertificateTS and updateCertificateKS
Also, if you open a trace, don't forget to close the editor and dispose the trace and the project and... you need a clean up job (@after or @afterClass)
a.buffer instead of a.
Is this really what you want? If you get an exception, you'll be returning null for a query on a record that exists, but that can't be parsed.
@eg04lt3r we've talked about this approach before in #123. there should be a thread pool.
filter and where should be upper case
can be final field of this class
Move to the end of the class
constant?
Is it possible that this returns null (or in other words, a selector fails to create a connection to the desired host,port).
Couldn't Granularities.ALL be used here?
Some debug output, perhaps can be removed
why the final need here?
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
I don't understand how this can work with null cache parameter.
free the lock in a finally block
Use {}? logger.warn("Blob metadata record not found: {}", blobId.getID());
These checks should happen within the build function when delegated to the object they are building, not a builder's set function. Don't duplicate the logic.
please declare variable in first usage
Make the map immutable with ImmutableMap.copyOf.
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
better return a null object (new Pair(this, null)) or throw UnsupportedOperationException
"if(" --> "if (" there are other instances of this, too
I suggest inverting these two calls, so that the instance no longer is in the created collection.
Can you replace this with STREAM_ID.addAndGet(this, 2)
return Arrays.asList(boolean.class, Boolean.class)
Could you please use TextUtils#isBlank here instead of "".equals(s)?
@ekondrashev let's inline this variable
Because destroy() is now async, there is a high chance that you will start initializing before it has completed its removal. You probably need to get a hold of the CompletableFuture from the runAsync() in destroy and wait for it before initiating init()
This error should probably be logged.
add this (also below)
Yes, we should. Don't we have a helper method to automatically do this?
What if disable cli snapshot schedule failed. We are not returning any error msg to UI ?
Why going for semantic here ??
perhaps worth to check if the map isn't null ?
I know I may be late to the game with this (the unchecked cast is everywhere), but is there any reason we don't use  return componentType.cast(clustered ? new DefaultPendingLockManager() : NoOpPendingLockManager.getInstance());
Why singular?
How does replacing a NPE with an AssertionException help ? I'd rather try to annotate the method's parameter with @NonNull and watch out for "Null type safety" warnings in Eclipse and fix them.
You don't want to display the information to the end-user !
@CarlosGines we should try inlining here as much as possible
hmm, that method makes somewhat sense in core java, but I'm not sure I like that behavior for selendroid. We're expecting a boolean value, but essentially we only care about either true or "true" coming across... everything else is false. Is it going to be confusing to any users? I'd almost rather add an additional else clause to check for the string of "true" or "false", otherwise raise the exception. Since users of other programming languages (like javascript or python) may have a different impression of what a truthy value should be.
why is the port only opened if the name of the port changed? I would assume the port as to be opened in any case, right?
We may consider just don't set TL flag if channel isn't Proxy. See a couple lines above - RabbitUtils.setPhysicalCloseRequired(true).
This method should be static and need not pass this as an argument to the constructor.
As this method does not change state (unlike the others) I would prefer to declare it static.
I don't see why we need these sorts of constructors... We've never needed them before, and there's nothing special about the useLayerNormalization arg (it's just another boolean)... unless I'm missing something?
I'd recommend to add process id to the name as well as there might be tasks with same name in different processes but still in the same kjar
nit: UnsupportedOperationException (java.lang) is more descriptive.
return flagdown; ?
Should be a SamzaException with a message, not NPE.
stringbuff -> buffer
This branch can be simplified: java final String[] split = ListSplitter.split("\"", true, removeBrackets(value)); for (String val : split) { result.add(val.trim()); }  or shortened java Arrays.stream(ListSplitter.split("\"", true, removeBrackets(value))) .forEach(enumItem -> result.add(enumItem.trim()));
space and pull back the }
I don't get the double protection here with the synchronized method and the CAS. Are they redundant?
This is the wrong method to update, replace the one that was called here. For a global check if the patch was successful check for references like registerDeploymentPlan, instantiate, they should we restricted to the EntityManagementUtils class only (outside of camp projects).
This error message is stating that it's a capture notification, but it won't necessarily be. Instead we should log the state we're trying to transition from and to.
The way MkContainer works, is that it sets up a fake HTTP server on the local machine. For each HTTP request that it receives: 1. A corresponding MkQuery is stored that corresponds to the request and and queues it internally. The container.take() method obtains each MkQuery from that queue in a FIFO-fashion. This means that each HTTP request should correspond to exactly one invocation of take(). If there are no more requests made (you called take too many times), it will throw an exception. 2. It responds by using the MkAnswer(s) that you've specified when invoking .next(), prior to calling start. If you need multiple requests and responses, you call next() multiple times with the exact answers that you need. If it runs out of requests, it will respond with HTTP 500. In this case, you only made one request, in commits.create(input), and are only checking its method. So no need to call take().method() twice to check the same thing. You can always store the reference returned by take() if you need to use it multiple times (e.g. to obtain its body, then its method):  java final MkQuery query = container.take(); String body = query.body(); int method = query.method;
lambda?
Similarly, Tasks.forException(new FirebaseAuthUserCollisionException(...)) can be used instead of the mock.
rename to contribution
Use sl4j
other methods like this put name first, then id. switch for consistency
Can we inject this feature directly ?
Yes. You are populating the map concurrently as the result of each render future is executed. Nothing guarantees synchronous access to the map.
Move the int i declaration to inside the loop. This loop counter must be only visible inside the loop body.
Main menu already exists, should not be new instance
If inputStream would be declared as class variable, then it could be closed in @After section of junit test. Then we could omit try/finally block in test methods
make these behave like the rest of the aspects
Maybe just have one TextView for parcelExtra like the other samples? parcelText.setText(String.valueOf(parcelExtra));
Same here, better in the constant class.
constant?
why BodyInternalTypes.ENTITY and not BodyInternalTypes.AGENT?
it's bigger change, but perhaps this method should publish a new class called ServoEventData .. better yet, we probably should call it ServoData to be consistent with EncoderData ... (and rename the method to publishServoData ) .. this could establish a pattern for all Controls that publish ControlData
maybe should be a switch?
Could you change this into assertEquals(expected, result) ?
fValueUpperCase is derived from fValue so it does not need to be considered for hashCode() and equals().
After the change this assignments to delimiter is ignored, so the tokenized path is joined without delimiters. To maintain functionality, the whole for loop needs to be extracted instead of just the body.
Let's only do this if the input was unformatted, same as for file inputs.
swap or Objects.equals?
Please use Verbs.gather instead of "Gather" here
If the delay is positive, the thread can't be reused and the code must be enqueued. Or, we have to check in UiThreadValidator' ifPropagation.REUSEis used with adelay.
Shouldn't it be a JackApiToolchainBase since you expect to catch FrontendCompilationException?
Woa, I'm not sure I like this being public.
We have a removeConfiguration so let's not allow null value here?
consider a cleared state, in which we subsequently added a null. Why is the size == 1 ? I'm asking since it seems size is being evaluated to see if the association object should be removed.
Should we call the function below instead?
You could still cancel it and return AIR if it's not valid
1. Please export lines 82+83 to a method 'selecetLabelChanged'. 2. Please call the method also before add the listener.
Minor: Or code conventions typically favor this style:  try { ... } catch (Throwable t) { ... }
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
No, no expression. It is a control-queue. It should be fixed configurable property. And it seems for me the name of property should be different. control-queue, control-list, queue-names-list... @garyrussell ?
can you use named "Stack.getAll" query here?
The executor service should be shutdown at the end of this method, otherwise it will leave alive threads
Please introduce a new method rather than adding a new argument that is the same non-obvious value almost everywhere.
so if someone is also running the notebook manually when the scheduler kicks off, would that block the scheduler?
The isDiscardable method can be simplified to this:  java private boolean isDiscardable() { return !PostUtils.isPublishable(mPost) && isNewPost(); }
minor nit: is it possible to add some message about the failure cause here ? Maybe something on lines - Failed to set config...
please check here isSetPmProxies() otherwise you can get NPE
hmm, that method makes somewhat sense in core java, but I'm not sure I like that behavior for selendroid. We're expecting a boolean value, but essentially we only care about either true or "true" coming across... everything else is false. Is it going to be confusing to any users? I'd almost rather add an additional else clause to check for the string of "true" or "false", otherwise raise the exception. Since users of other programming languages (like javascript or python) may have a different impression of what a truthy value should be.
This isn't a result of this PR, but this routine looks wrong to me. Shouldn't this be if **not** isSignedInWPComOrHasWPOrgSite?
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
I appreciate the centralized code of this approach, but i think it is going to result in all the premis events being added twice for most objects since addPremisEvents is called twice and it always reads from the same file. It may be hard to go with this approach without a larger code change
The implementation is the same as in HostNetworkQos, please implement in HostNetworkQosProperties.
Seems like AggregationFunctionUtils.getArguments first creates List, then converts to String[], and here we are doing the reverse, creating [] from List. Is that not redundant? Or is it because of more callers of getArguments() benefit if it returns String[]?
Use Arrays.asList instead.
"Failed to reindex {} object and its children"
@ikhvostenkov please name it json
Should not you use 'focusedInfrastructurePlugin' instead of 'focusedPolicyPlugin'?
Can make these final and use checkNotNull(catalog, "catalog")
wouldn't this fail if pattern was null?
move error log to condition body
Let's make sure that the DataStore transactions only receive FilterExpressions that never have a FALSE_USER_CHECK_EXPRESSION or a NO_EVALUATION_EXPRESSION. There will be better separation of concerns.
Should the name of the thread be maxwell-kafka-producer-worker instead?
use return ... ? ... : ...?
GeoJSON is long, lat <LINK_0>
don't you want to check also whether the connections is empty?
you can use containsKey()
Nit - import Constants so this all fits on one line.
Shouldnt we have this defaulting to the common namespace (ICommonAttributes#COMMON_NAMESPACE) so that we can tell the user what this defaults to?
Given that we check in the called overload, this method could skip the check on lines 119 - 121 The same concern applies to some overloads in other splitters.
StringBuilder
nit: This can be taken out along with last line in if and else block can be removed (it will be consistent with the IsNullConditional::generate method then.
The thread pool should be initialized only if stats are enabled.
There should be an assertion around this.
Should we add: Objects.requireNonNull(record)?
yeah, this was a rush patch to get the -2 issues out of the way. I didn't have time to look at code quality yet
whole block indented one extra
I believe appPath can be an empty string which will cause lastSegment() to return null, which then will cause an NPE. You can try this by leaving the program text box empty.
I believe using StringBuilder and toString() is not needed when creating a string in a single statement as this is done internally in an optimized way, please use a normal string expression to keep it simple
why are you using getAdapter() and not directly mAdapter?
Why uppercase fs?
"Modifier 'private' is redundant for enum constructors"
suggestion log.info("Starting JDBC Source Connector");
final?
Can you just use DigestThread? Instead of the full declaration.
IMO while would be better here
Would be better a specific ResultCode for this one, such as SHARE_NOT_FOUND, or LOCAL_SHARE_NOT_FOUND
there's an issue here - when running the vm as stateful, we'll get to this else block (as there's no stateless snapshot) and will detach the user although everything went fine. generally speaking, i think that in this flow we can inspect the result of RunVm instead of running the endAction() from here (Example - <LINK_0>
throw ConfigurationException instead
Add a private final stripeMask field that is initialized to stripes - 1. This will eliminate an arithmetic operation from this hot path.
The logic of this method should return true if any part of the range is covered by any part of the Block's revision range. Currently it only returns true if the entire range is covered by the Block's range
I'd like to suggest rollbackOutputCommit.
We should use a thenAnswer() on accountDao.updateAccount() and then verified that the commit hook is being passed in and called.
Left over?
This check is unnecessary. context can never be null for a properly constructed object.
I think we could reduce this constructor to a call to another constructor:  java this(configuration, null);
I prefer using () when there's a single value and {} when there are multiple properties, but it's just a matter of personal taste.
I think we have to improve coverage of the cache usage in the mapper class: manstis/kie-wb-common#30.
@soul2zimate We should not use lamdas generally. Also there is a GetClassLoaderAction which can be used to do the work for the privileged case
the name isn't intuitive, IMHO. perhaps copyUnchangedStoragePoolProperties(), or something down those lines?
nit: if (p != null)
@cvrebert We should name this variable existing, as per our naming convention [here](<LINK_0>
Use ImmutableSet.copyOf(E[] elements).
Should be a SamzaException with a message, not NPE.
This should be a test error.
missing space after if
nit: please remove the redundant else
I'm okay if you want to keep this as is, but it may be slightly more readable to adjust these assertions to assertTrue(stoneFile.getResource().hasProperty(RDF.type, Cdr.Tombstone));
These bounds include the namespace and the margins...
add fail() after call in case no exception is thrown
the log.error below this is going to go totally bonkers if the queue ever fills up; it'd be better to only print a log message every X events (similar to HttpPostEmitter)
both filtering methods should also be abstracted I believe. edit: by both I mean this one and the one above. the only difference being && or ||.
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
Instead of returning a modified selectionArgs but not selection please switch this to follow the existing pattern of returning an Object[] that has both the updated selectionArgs and selection. Less risk of bugs from the two being out of sync.
I would either inline this method, or give it a more precise name, like initializeContextPath
The connectTimeoutMillis and readTimeoutMillis in the builder appear unused.
Are we guaranteed that non of these entries has a key = href? I think it would be safer and clearer to make the map key something like params.xxx
Can this really happen? If not why care?
... yes it does ...
the default should be made a constant somewhere instead of being defined in multiple places
Following the implementation with other nested objects, we should change this such that we only examine the certificate IDs rather than the whole certificate objects. You can do so by tossing a comparator on here that pulls the IDs from both sides and only uses that.
would be nice for the 4 to be a constant for readability
optional suggestion: since we're extracting helper methods... it's mostly "false * 4" or "true * 4", so consider adding e.g. whenEverythingIsInitialized and whenNothingIsInitialized.
The value returned by isPlaced depends on the mapped flag as well. It would be a lot simpler if this provider had tuples of [seqID, start, mappedFlag, usePositionDeltaEncoding, expectedIsPlaced], with test cases for each possible combination, and the test just created a new record for each case using those values, and verified isPlaced.
We should log this error by using our Log.e method.
You can initialize directly in the try
Style issue: @Override shuld be on line above the method declaration
It may be better to return an empty string here instead of null. Unless others look into this code, we may be pushing the null pointer higher. Thoughts?
final
Rename this variable. It is no longer accurate.
The constructor should be made protected so that users can easily make a wrapper for it.
nit: maybe replace } with a blank line? There is no such code style in druid. The same for the { and } below.
This needs to be in an i18n Logger method.
should we add null instead of ""? What's the end difference? What about not adding it at all?
Same as above, just return the 404 jsonresult with the message you need.
finish() is called in case of an exception but the callback.close() is also included in the finally clauses of the top level methods. This leads to closing a callback() twice which is probably not intended.
StringBuilder
This logic will obviously need updated once we change this.cookiesToClear.
can the catch be around the connectorResponse.readEntity(DirectDebitSearchResponse.class) please
I don't think the variable updatedPatchSet if useful here. atomicUpdate returns what the update method of the AtomicUpdate class returns... which here is always null.
I would really appreciate if you rewrite this so it doesn't use -1 as startIdx. A year from now I won't remember why we want to load from position -1.
Could use getImageChainFromDb().removeAll(chainFromStorage) instead of having CollectionUtils.subtract force conversion of imagesToRemove to a Collection, since a Set more accurately portrays the intent of the, well, "set" of images. :)
Does it make sense to swallow this exception, or should it be thrown out of the method so callers see that there is a problem? Same with the other methods in the class.
I would init the map in line #34 so it won't be null and you can remove the null check here and in getProperty
redundant newlines
Do you think it is worth logging if there was an attempt to set the timeout below 2 minutes?
You could use CollectionUtils.isEmpty() || list.size >1
Is this thread-safe? I guess, maybe, although it might do extra work since not all threads will see the update at the same time. I'm also not sure if ParseSpecs need to be thread-safe; if it's an issue could you please double-check it?
add break
Add space after catch.
2 things: 1) If a DataException is thrown is it a good idea to go on? 2) Did this kind of error logging work with casting exception object to string message?
You can use the EntityTypeRegistryModule instead here.
Can't we do better than assert? IOexception?
@adrielparedes here the call for metadatastore ^
Should be a SamzaException with a message, not NPE.
Can't it be localhost
this must look at both request and session.
Ok. But so to be extra clear, we should still always block commits from happening during a rebalance when eos is used, yes? I'm guessing it has to be that way since that makes sense, but if you have any thoughts about a possible alternative fix for eos let's at least make a ticket for now. I guess so long as we can still return data during a rebalance then 429 is still useful for active throughput of eos..
To always be safe please use context.getApplicationContext()
> return new String[] { resource + "/.default" }; [](start = 7, length = 48) Should this use the DEFAULT_SUFFIX constant above?
The catch block for the IOExcepton, AuthenticationException appears to contain the same logic as ServerRespondingWithRetryableException; is there any reason we should not collapse these into the same catch block?
Always separate multiple function calls like this with newlines.
BigtableFilter should probably have a com.google.cloud.bigtable.data.v2.models.Filters.Filter member variable. That would likely mean deprecating the current constructor that uses com.google.cloud.bigtable.data.v2.wrappers.Filters.Filter, and use a com.google.cloud.bigtable.data.v2.models.Filters.Filter in a new constructor. Also, please add a BigtableFilter.getFilter() which returns the models.Filters.Filter and use that getter here.
If it's not good to use level(...) this time, let's remove my commit. Or please rebase it into your commit it if the changes are fine :)
minor, do we want to remove org.junit.Assert. prefix?
Be more explicit than normal. Too much ambiguity when there are normalized counts of normals.
suggestion nonBlockingCheckAndRethrow();  FYI the common practise in Java is to prefix member _variables_ with this. and to omit the this. for method calls.
nit: add a check it either has to be connector partitioning, or FIXED_HASH_DISTRIBUTION
shouldn't this be taken out?
You're mixing "scanner" and "plugin" wording in this method. As it's an abstract method, I would remain consistent, and use something else (component?)
Did we want to have this normalize the path also by returning the normalized version from Path?
any reason for explicitly invoking super.toMap() ?
checking for nullable parent was added specially, cause going into project node simply has no meaning
is this keeping of already modified buttons necessary?
Ideally LocalEnvProvider.rewriteLocalEnv would declare to return a ImmutableMap since all of its implementations actually do so. Could you please change environment to ImmutableMap and use ImmutableMap.copyOf(localEnvProvider.rewriteLocalEnv(...)) until that is fixed?
I'd do this filtering before the previous one - it's much cheaper.
public isn't needed
Please extend why you need this test. We try to avoid such tests as much as possible, please make such case in non compilable sources if you need. All test coverage should be on real Java files , not a fake trees.
please move the isEmpty methods to the scimSchema
Prefer not to have a null environment from start.
Above check can be done against Collection instead of List.
we could replace this with this(ID, description, Integer.MAX_VALUE);
Why not use badges = getBadges(userId); here? I think that's more clear than a call to a void method where you have to read through the whole method to understand the side effects.
This smells a bit like a reader/writer lock. Wonder if there's something in java.util.concurrent that would help and could be more efficient.
@sandreas ok, sorry - I thought this PR is still in the works. thanks for pinging. I'll rebase it soon and apply the formatter
Did you take a look at this? <LINK_0>
Can you make this a constant like the others at the top?
Is the indentation off here for the method parameters? Shouldn't it be:  private static void writeTilesToBlockBuilder(OGCGeometry geometry, int zoomLevel, BingTile tile, BlockBuilder blockBuilder)
still need an answer which role are we querying, and if not UserRole then we need to add parameter of what role we query.
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
IllegalArgumentException is a runtime exception, so it shouldn't be part of method signatures.
Use context.getApplicationContext() to ensure the class can't leak any shorter lived contexts that might be passed to it (it's always fine to hold onto the application context, since it's expected to be around for as long as the process remains alive).
please update hashCode method as well
mapper is usually set to env.service(ObjectMapper.class), so without copying it, the statements below will change the configuration of our shared ObjectMapper instance.
Maybe could be stated in the changeToken parameter description that it forces the session to be saved, even if the save parameter was set to false?
Please create builder for the Venue object... The tests are ugly
This check will also pass if out.draft is set to false. I think it is safer to also check that out.draft is true (when not null): if ((out.isCurrent || out.draft != null && out.draft)
file might be a directory - message will then be misleading
this check should be the same as in BackendDisksResource.add()
final
synchronized (LongJVMPauseDetector.class) looks like a bug
Make public void putObject(String bucketName, String objectName, String fileName) method to use this version of method to avoid code duplication.
If the first constructor is used then both oldSeqNum and newSeqNum are not explicitly initialized i.e. they are set to zero. Seeing "0..0" in the string representation of this object is less useful than seeing "aPSID..bPSID". Include the IDs always in the toString and additionally include the old/newSeqNum if they are set?
Don't change the declaration
I love LinkedHashSet's :-)
Then should we just use it to save the update items?
do we really need this? it is already logged in line185
minor: This can be private method
Can't this NPE as they're Booleans (i.e. objects not primitives)
> DRONE_TARGET_DIRECTORY it means that the last update cache is stored in the target directory, right? I'm not sure if it is a good approach as every new run of the test suite will require a new request - I had expected it in the ~/.arquillian/drone directory. On the other hand, I have to agree that the probability that you would run out of the limited number of request is very low.... Why you've decided to put it into the target directory?
How is it reset if the test failed before?
This log.warn is a bit strange... the String.format gives us a double message. Also if we used normal {} then you could probably safeArg the response.code() at least
This should probably throw if the value is null.
not your code...(perhaps...) but should try-with-resources
Maybe do a check if the event is being listened to with ShouldFire?
I guess this can be replaced by a public CommandImpl(String name, String commandLine, String type, Map<String, String> attributes) constructor call, what do you think?
I would really appreciate if you rewrite this so it doesn't use -1 as startIdx. A year from now I won't remember why we want to load from position -1.
Would it be more logical to put this in onPageFinished() in PageFragment?
getFirstName() considers empty getNames(), getConcatenatedName() doesn't.
you could here return the old one
If opening is true, doesn't it mean it's still opening but not done opening yet?
Could it be done in configureRequest method? Seems like it could be a good feet if it applies to all requests.
This might return null. I was wondering if setting 'null' for role might affect the task launch
Maybe its better to use interval terminology here, perhaps LeftEndpoint and RightEndpoint?
have we seen this error before?
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
simplify this
TransportException is not just a wrapper for other exceptions, so where it is thrown and it's (sub)class is important, just pass it as the new cause.
This is way harder. We need more than just the change. The user's notification filters might include "reviewer:foo" and thus require the approvals. So you'll need to loop through all of the filters, compile them, and get their own NeededData values and union that with your own need for the change here.
What does this flag does? Hope if someone update the sequence it won't get affected.
ClientLogger.logAndThrow all exceptions. Please search for all cases because soon Shawn will check in his CheckStyle rule and it will break the build.
This is duplicated with the above
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
LOG.info("Getting file {} from {}", fileName, tarFile);
you already have setUriInfo() at line 202
should there be an assertion at the end here?
why Sysout when you have a Logger?
Why did the consumer installed products come into play here? I think the list of productIds is already set to what was requested, which would normally be their installed products.
I think we should at least log this exception here before throwing other one
We better not have the supported/unsupported versions hard coded here. Please check whether discard is supported using the FeatureSupported class.
Remove?
This looks like a generic method that should exist in some common module.
This equals implementation should include attributes from the Command super class.
Is this signum call really needed here? compareTo should already return the correct value.
You don't need to wrap with the new ArrayList.
Instead of running the delete in a for loop, just use a single statement "DELETE FROM tableName", this should also throw an exception.
Are there no other standard utilities or libraries that can get this information?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Please use static imports for Iterables.size, filter, and so on (readability)
Maybe you could drop id and just increment sequence here?
magic? extract to constant
This means that exception during xml parsing will be logged, and the map containing a single element (for the current server) will be returned. This is wrong. I think you should throw an exception in all error conditions, except the ones while fetching fingerprints.
The editor can't be null
Use [Integer.valueOf](<LINK_0> Better yet, don't use value.toString. Is the Object returned not already an Integer?
Is this reload really necessary?
I think we can remove this line.
log.warn in default block is a good idea, but we should have case FAST_FORWARD_ONLY break without logging.
Add a check here that the country isnt DE already
I think a foreach loop here would be shorter and easier to read - or a lambda expression in future
There is no check whether or not the style belongs to the current user. Should we check it? If not, I wonder if the logged-in requirement is necessary?
respones -> responses
I know it's not your patch but those 5 lines should be replaced by: grouped.keySet().removeAll(collection);
i wonder if getQueryId should be a method on the baseQuery object. Then there is no need for query helper
return flagdown; ?
I would recommend versionId = "" can be allowed i.e. if (args.versionId() != null)
DRY: would use this(username, password, null) instead
why debug level and not error?
Would it make sense to return volumes with size -1?
I don't think this will work well if filepatterns is empty. Should we throw an IllegalStateException during call() if filepatterns.isEmpty() is true?
Shouldn't a copy constructor be used here, instead of sharing the same reference?
You may want to expose a mechanism for the client to cancel the AsyncTask or at least suppress the dialog show behavior. It looks like the easy way here would be just to expose a setter on Callback and do nothing if it's null when the asynchronous operation completes.
I am not sure if 503 is correct it this case. It indicates that something is wrong with server. In my opinion 403 will be better.
shall we print the exception stack trace as well? No need to add the e.getMessage() IMO. That information is printed with the stack trace
just return _props.get(key); in this method
Since you're already using Guava, consider using [throw Throwables.propagate(ex)](<LINK_0> here instead.
you aren't removing duplicated entries...
If position() gives anything other than 0 then this will give a LimitReachedException won't it? Did you not mean capacity - position?
what of the server is starting already? or stopping?
Could you provide the message here? Or just use the default constructor...
This logic appears twice. Can we extract to a method?
To always be safe please use context.getApplicationContext()
This is not optimal for localization (for languages that don't use arabic numerals). Consider using something like NumberFormat.getInstance().format(count)
Why we want to fail such queries? Presto can still query from such table if we disable bucket-by-bucket right -- Also it depends on our configuration on hive.max-outstanding-splits-size right?
Maybe it would be better to use IntNode for zero value in this method.
Add context specific message without using e.getMessage().
Could use elements.isEmpty() instead of checking size <= 0.
Put suppress warnings annotation to method and change to direct returning the getted value to avoid temporary store the return value.
Path and Package will NOT be available in Submarine.. is this meta-data essential?
this seems the same as the base. why is this copied?
good practice: usually actions go before WS as they are injected into it and so they are grouped together
This consumer can be a static constant. I don't think the consumer has to be tied to the lifetime of the credential. private static final Consumer<DeviceCodeInfo> DEVICE_CODE_CONSUMER = deviceCodeInfo -> System.out.println(deviceCodeInfo.getMessage());
where did this go?
See lines above. Videos should have the same behavior but should have their own default/global speed.
Is there any reason to instantiate a new ArrayList here? The Arrays.asList already creates a list.
Hmm, maybe my BulkExistenceEnum should have EXISTS, DOES_NOT_EXIST, INVALID_HASH, instead of True, False, Invalid.
Maybe some not-null check should be added here.
Since this is important then we should have a test that validates that we never lose the next param if present
Why not just modify the existing SeleniumHttpInitializer to accept a null sslCtx and have it only add the SSL handler if the value is not null?
This is a read only operation, please remove StandardOpenOption.WRITE
Enclose your blocks with if ... { ... } else {
nice catch
_endTimeout already checks for this, which you rely on elsewhere
Closed channels are automatically removed from a channel group. This line can be removed
I understand this is an existing code, but it seems weird that we create ALL admins EVERY time just to get a single one. Either we should create a single Admin, or we can cache the results of the previous getAdmins().
Typically we use Map on the left hand side rather than HashMap
This block looks the same as in the other constructor. Should it be DRYed out? I probably wrote this block,but I admit I am having trouble recalling why DefaultsConfigContext needs to explicitly be referenced? We allow config contexts that don't start with the defaults?
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
this param is unnecessary
Suggest having this error message mention the time condition property, so that users who encounter it know that the problem is with their query and not an internal server error. e.g. "requireTimeCondition is enabled, all queries must include a filter condition on the __time column."
To always be safe please use context.getApplicationContext()
Please put back the parentheses around (getIndexForKey(previousChildKey) + 1). The behavior is the same, but it makes the intent more explicit.
Why do we need to call snapshot() again? I can see the snapshot calculation just happened in the previous call during constructor initialisation.
Looks weird here. Keep the indentation level as before?
toString() is unnecessary
Do you think is better to replace it with Collection.addAll? suggestion arguments.addAll(Arrays.asList(values));
can u extract a final constant with a readable name out of "<[ ]*/[ ]*%s[ ]*>" ?
![MAJOR](<LINK_0> The Cyclomatic Complexity of this method "run" is 12 which is greater than 10 authorized. [![rule](<LINK_2>](<LINK_1>
Should we add: Objects.requireNonNull(record)?
Racy. Maybe just chuck a synchronized on.
stringbuilder?
the change is not clear, there is a default value passed of 20 and there is a check in SubscriptionService
While we're in here, could you replace that with this: for (Object selectedObj : structured.toList()) {
What's the intent behind this? Generally we want to allow this to be changed at any point. Is there something in particular that requires this with the update?
Instead of exporting this, I would simply replace the future usages with Optional.ofNullable(duration).map(Duration::toMillis).orElse(null)
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
These are from the org/json library. Edits to this are really not recommended.
use createSafeXmlSource here too
Unchecked cast
if you do this, better put N/A :)
should we log/meter this so we know when we've stopped hitting it?
Again, please don't make recursive RPCs, use data from the ProjectDetail object.
This is not starting another thread, but running the runnable on current thread. You need to use start() and thread.join() to wait for it to finish
So if there are 3 parameters, we include 3 copies of all parameters?
use return ... ? ... : ...?
Why bother locking if the size returned is immediately going to be invalid? aka, some other thread may have already changed the size.
We can remove this line right? Since we are returning products at the end of this method anyway.
does it make sense to check for null? we're starting from null anyway
Share the 'validateArchivePath' method.
Can you check return value and log if not found?
We should probably create some sort of "offline context" which is specialized for these cases where we have server-side offline tools which access offline system resources, like site configuration.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
double 's' at the end?
Remove e.printStackTrace, throw exception or log it.
You don't really need to declare this variable here. You can do setText(new Integer(SessionHistory.totalPoints) instead
map(Queue::getActualName)
Isn't the coding convention like: omit "this" when it is not needed ?
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
Broken alignment.
Wondering if we need to clean the folder when the test is done?
I think it would be more clear to have  if(!iterator.hasNext()) return 0; String first = iterator.next();  ?
Shouldn't this close the iterator before returning the list?
I think this is missing an @Override
Although this may be technically equivalent, it breaks with the structure of the rest of the method. As such, I do not think the change is warranted. So, please revert this change.
Please also exclude any fields starting with "$"
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
I think this should be > 0 since a value list item of 1=One does not work.
invert
You're doing the empty check twice, perhaps should be a @Value.Check.
Boolean.parseBoolean(...) is probably better (as it handles case insensitivity). Also doAdd could be a boolean not a Boolean.. but is being a bit picky ;-)
This change breaks null-safety. null.isPresent() will crash and burn.
checking for nullable parent was added specially, cause going into project node simply has no meaning
If you're modifying this anyway, there's probably some kind of way to write this more simply with Comparator.comparing.
I will be nice to have more meaningful error message. E.g. "Text condition must not be empty string." or smth else which explain the problem with comparing actual text and the empty string.
Why do we only call clear() if it's not empty? Clearing an empty list shouldn't have any effect.
This is bypassing the idleMinutes condition previously done in the superclass, so whatever its other benefits, it cannot be correct. I suspect what you meant this method to be was something like  java if (c.isIdle() && !disabled) { final long idleMilliseconds = System.currentTimeMillis() - c.getIdleStartMilliseconds(); if (idleMilliseconds > MINUTES.toMillis(idleMinutes)) { LOGGER.log(LEVEL.FINE, "Disconnecting {0}", c.getName()); done(c); } } return 1;  with a workaround for the fact that CloudRetentionStrategy.idleMinutes is private, either by shadowing the field here, or just extending RetentionStrategy<AbstractCloudComputer> directly (and inlining super.start).
I see some improvement can be done here.Is it required to define method as synchronised.Can we use ReentrantReadWriteLock and get write lock here? It will be resulted in performance improvement
This seems and odd thing to have in production code, is it intentional ?
Soft suggestion: there's no need to use a StringBuilder explicitly here, plain String concatenation isn't any slower because there are no loops, so the javac compiler will actually uses a StringBuilder for plain String concatenation (again, because there are no loops).
> APIEvent(final String eventName) { [](start = 4, length = 34) nit: new line please. #Closed
Do we want to be explicit about the configuration by not relying on the default and turn off the push options?
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
I think you want logical AND, so double ampersands. Can we use !license.isEmpty && !licenseShortName.isEmpty && !licenseUrl.isEmpty() instead?
Racy. Maybe just chuck a synchronized on.
rename to childItem
I hope the event producers are not shared across the connectors?
this.
Get rid of this duplication please :)
and return false here?
Maybe its just me, but this calculation looks wrong, since we are assign a = b, then b = a % b will always be 0, since a = b. Shouldn't it be: long c = b; b = a % b; a = c;
You could either use a constant for the id name here or use something like: java @FindBy(id = "export-form") private WebElement exportForm;
Please use parameterized log messages.
Racy. Maybe just chuck a synchronized on.
You should pass here message not group converted to string.
can builder even be null? if not, it is just getSslBuilder().build(), or in-line it.
I should explain it better earlier, what I mean by "inline" is to move the implementation body of isNonRetryableServiceException  to inside the isRetryableException method, then the negations should be applied onto each expressions, return true -> false; etc. This is still a double negative.
criticalVariable is not used now.
Simply printing an error will cause it to be overlooked, and users may be confused by the result. I think this should throw an exception instead.
I don't think this catch statement is needed since UnsupportedEncodingException is already caught by the catalog service implementation.
You can call this.setTimestamp(timestamp) from here.
I dont think the care setting and order class matter, so i would not filter on them
We may want to make the start/start stage, etc.. method names match up better.
Simpler as getMetric(fieldName) != null
Why no similar handling in all macros above?
nit: I would extract webDriverContainer.getContainerInfo().getMounts() variable :)
It's preferable to change the existing method (to pass the currURL) to avoid code duplication.
Help me understand the change below more. The one on the left seems simple.
remove, dead code.
make this synchronized.
how about replacing those with: getVm().setUseHostCpuFlags(false);
This method should just be collapsed into createVCGeneral (it seems like all calls are identical).
This can be rewritten as: java boolean exemptionEngine = request.getGatewayAccount().isRequires3ds() && Optional.ofNullable(request.getGatewayAccount().getWorldpay3dsFlexCredentials()) .map(Worldpay3dsFlexCredentials::isExemptionEngine) .orElse(false);  However, I wonder if we actually need this flag to consider whether or not 3DS is enabled. Presumably it's just going to be used inside the template and we can nest it inside a check that 3DS is enabled.
should this be localized too?
Assert formatted date and check without only asserting event arrival and count (what you have done in dateAddFunctionExtension7)
dont do this but let the exception be propagated back up so we can have a better error reporting about not possible to generate jacoco report due to .... Also these methods can be static methods
nit: we've followed the pattern where the sync APIs call their next max overloads -> this sync API should call the sync API overload with Context.NONE.
What happens if the above condition was non coded?
Could also use EnumSet.complementOf(EnumSet.of(Blob_Expired, No_Error, ...))
I think it should be:  java if (input == null || input.size() == 0) return null;
Embed the caught exception in the newly thrown exception
I don't think we need to wrap the exception since all possible exceptions are a subclass of RuntimeException. I prefer catching RuntimeException instead of Exception. If some methods throws non-RuntimeException, I think we should catch separately and wrap only non-RuntimeExceptions.
I don't think <T extends Object> is needed, <T> is enough.
It would probably be better to have a clear separation between the call to getSolrUrl() and the creation of a log.
why is that needed?
Consider merging these two filter operations into a single one.
this will always throw an exception (checkNotNull bellow). My guess is that for backward compatibility we'd want to not register if it's null.
can you please set the instruction file.getPath () in case of errors instead of file.getFile()
(Alt) Can we move the skip condition to the testSetup method just above.
nit - ConfigException is unused
Why does this test have two entity dictionaries? Elide is really intended to have a single dictionary.
Fair point. So, yeah, let's get @nbradbury 's opinion about removing setRetainInstance(true) and we'll take it from there. @nbradbury , what do you think? Would removing the fragment retainment here have any side effects we don't see? Thanks!
einfacher: return Priority.HIGH und lokale Variable Priority lschen...
state is a boolean - no need to _compare_
Add SubChild here as well, perhaps SubChild is just persisted as a Child currently..
I think this would be better off being @Intrinsic and calling through to the original method so it doesn't interfere with other vanilla calls.  @Intrinsic public boolean entity$addTag(final String tag) { Objects.requireNonNull(tag, "tag"); return this.shadow$addTag(tag); }  The difference between this method and that one is that you return the result of Set#add, vanilla just returns true - is it a problem if addTag just reports whether the entry is in the set, which it will be if it reports true, regardless?
This parsing has to be done in planner part, at the moment you read this tree from the table.
Init FeedbackQuestionsLogic should be enough.
Would prefer a tighter check here. As-is, setting to "no" or "FALSE" or "false " with some whitespace would make the coordinator be an overlord. How about throwing an exception if the property is set, but is not "true" or "false"? Or, at the very least, log a warning.
It's better to introduce a new variable this.request, like it's done in other classes (for example RtIssue)
We should use RemoteServiceInterface.FAILURE here as well. Also, we should create a contstant for 100 as well and use int respective tests.
> ~~~Thanks for your patience!~~~ No - on the contrary, thank YOU for your patience.
permissions can't be null, otherwise the constructor would throw a NPE.
not sure that the outerType is needed as we are trying to compare two Host instances
Possible NPE in next line when command.getDirectory() is null. When cloning into a bare repo it is possible to only specify gitDir.
unneeded if clause
use return ... ? ... : ...?
looks like you don't need these three variables at all. Just use this at line 41?  java List<String> boardNames = TestController.getUI().getPanelControl().getAllBoardNames();  You can probably follow it up with this (not sure)  java assertEquals(boardNames, Arrays.asList(new String[]{SAMPLE_BOARD})
FYI this can be replaced to a one liner: java getSourceDatabase().getTables().stream() .anyMatch(Table::isStem)
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
Maybe define these services in some kind of constants/Interface as static final in a future change
beginBlock should close the paragraph that was created in assertOpenBlock(), if there is one currently open. Note that it should not close *all* paragraph blocks, only the one that was implicitly created.
Generally speaking, there's no need to null out the fields of an object if no one is going to hold the reference to the object afterwards. The GC is going to do its job, you don't need to help. :)
Disable caching on the client and also test fetchAll. Also, waitForWrite option doesn't seem to be directly tested.
Here and elsewhere, the Fragment probably shouldn't force the host to do things by getting its internals and changing them. The dependency on a toolbar is clear because of the callback pattern but exposing the toolbar directly allows any Fragment to change it. It's ok to defer but consider pushing onSearchOpen() into the host and allow it to hide / show the toolbar.
recordCount++; doesn't work?
else { is redundant
We could get rid of the most outer if if we replace source.getExtensionElements() by getOrCreateExtensionElements(source). Just bringing to discussion. If you think it is better to keep as it is I am fine.
Would it be better to hold this a member variable or maybe even break it out and put the resonsbility on the client?
else { is redundant
The formatting looks weird in this block?
I would prefer return type(type.getDefaultState()) instead, to be less repetitive.
Needs some sort of assert to show it succeeded
Instead of collecting transaction edit logs here, we can add the count header in AbstractTransactionLog.sync() method before calling append, right? Since the edit logs are already being collected over there, we will then avoid code duplication.
can you make loadProperties() take configFile location as an argument and remove the global variable configFile . It seems it is not really needed and reducing global state is good in general.
Did OSCORE specify to use ACK (and not RST) even if the message processing caused an error?
please keep the body of an if on its own line
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
![MINOR](<LINK_0> Remove the declaration of thrown exception 'org.springframework.security.core.AuthenticationException' which is a runtime exception. [![rule](<LINK_1>](<LINK_2>
Tests should just be throws Exception, rather than a specific one, or multiple ones.
Should be done before opening a db session - for to fail fast.
Why Integer is excluded? LongOrNarrower should contain all integers, should it?
Why not just "else"? Also, please add a space between if and (. There should also be a space between { and else
It seems like we shouldn't need to override this, since it should work the same for all columns.
IINW, this call has the potential to produce NPE, since we don't check for the existence of the host.
Should not use the language asserts, they tend not to end up in the runtime.
nit: Can we just use a if/else here instead? This ternary operator is weird to look at
See above, but timeTakenNanos should take a long or this will be broken for times over ~3 seconds (Integer.MAX_VALUE nanoseconds)
- please remove TODO - please use propper logging instead of using printStackTrace()
This is already parsed inside the method.
This code can be improved, with a single check of isSinglePort and do all you need inside there. With the current code you're checking this twice, in this lines and then shortly below, making it more confusing to read.
Would be safer to do something like this.groups = Collections.unmodifiableList(group) otherwise anyone can modify the actual path trough getGroup() which is not great for a public API.
Should we set a different health code, since the original user has been deleted?
is this a common pattern in Java? At least in .NET, we always return an empty list instead of null (applies to other libraries too)
There is a join method that accepts Collection that would make this code much simpler..
should we log this?
are we guaranteed the test won't get stuck if something fails the test?
save the null check - use "".equals...
Isnt it already done above, in line 62?
Should be a SamzaException with a message, not NPE.
This will remove description set, please remove.
For backwards compatibility, why is passing the CAS protocol service param not enough? (I'm assuming that's what happened previously?) We've had some issues in this service url construction lately so I'd like to reduce our chances of getting it wrong again :-)
It may be better to return an empty string here instead of null. Unless others look into this code, we may be pushing the null pointer higher. Thoughts?
no need to add the same message to the secondary location
not only for 3.2 ?
Ics should be ICS in "...for a product with Ics=false"
specific exception if possible.
why not have java docs to explain what this does ? ( why it does it in that way etc)
change variable to something more meaningful
If there aren't any checked exceptions, you can probably do e.getSecurityErrorCodes().forEach(...) instead of a loop over the entry set.
minor: rename fb -> builder or formatBuilder
Can this really happen? If not why care?
Can we avoid this switch/case block?
Is it not supported?
Why this change here?
Collection is enough
Why should nodes necessarily have an ssl enabled port?
typo
why is this necessary?
As above. It's unusual by the way to have 3 separate log entries, normally it would be one message i.e. consider replacing these 3 lines with LOGGER.error(my message, e)
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
I remember some discussion for coming up with this logic of selecting cards randomly. Have you decided to remove that?
I would just use ASC and DESC like the standard hive syntax
is there a purpose to passing this value?
Huh?
Can make this into a singleton as we have with UNSET.
Add SubChild here as well, perhaps SubChild is just persisted as a Child currently..
The naming is a little confusing here. Should the "buildingProperties" variable be renamed to something like "assetConditionProperties" instead, so that it's more in line with what the method seems to be returning?
That's somehow cryptic for my taste ;) Maybe we start with int i = 3 and improve this if too?
Since getParent() is defined on IASTNode, there is no need to actually cast to IASTDeclarationStatement on the line above: we can just no declaration.getParent().getParent() here.
Supposed to be a new line between each row? L31-39
You can just get it instead of doing two map accesses, doesn't work? Same with below. java return (String) dataMap.get(key);
Yes, even if we add empty set of tags the entry is treated as accessed. I don't think it's correct.
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
There is an extra parenthesis nest. Otherwise I agree for adding this condition.
we need to validate whether nctIds is null
Should be a single call to removeQuotaFromCache that receives list of quota ids.
unnecessary changes
logging
better to use the official way here true instead than "true"
Should be a try-with-resources block.
Since the connection getting passed as a parameter to this method, it shouldn't close the connection inside this method. Need to close the connection in the original place where it originally (create and )close the dbConnection.
Either this is a bug or the code is hard to read - wouldn't you have a problem IF the previousPortfolio already contains this uid?
let's stick to if (style.isVariableHeight()) { return true; } for this patch.
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
java if (next == null) { return fromIterator.next(); } else { final TYPE result = next; next = null; return result; }  I find this better to read.
In case of creating template from vm snapshot this returns false because method updateLabelList() is called from constructor of UnitVmModel however isNew property is initialized after the constructor is finished. See VmSnapshotListModel#cloneTemplate.
We have different conventions. Please see the spaces around brackets and method parameters, and brackets on new lines. The checkstyle plugin would crash the build. Did you try to run "mvn install -P run-its"? It would take quite long time to complete the build, cca one hour.
Please move the above log entry to info level. In normal mode it's enough to say cache updated (and it took xxx second).
Why not putting NONE and MANDATORY together?
Same here. Also, this can be replaced with waitUntilNodeAppears. Platform.runLater shouldn't be used like that.
Please add message entity here by describing the error.
suggestion final ProducerRecord<String, byte[]> record = new ProducerRecord<>(topic, module.marshal(message));
Why not use model.getSelectedItemsChangedEvent() ?
again, since next call is System.exit(), write to STDERR.
why not just List<String> lines = Files.readAllLines(filePath);?
These calls are very hard to understand. It can be more clear like this: return (Pair<StorageDomainStatic, Guid>) runVdsCommand( VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters( getVds().getId(), getStorageDomain().getId())) .getReturnValue();
is it normal for Java to pass empty string instead of null into the request if the user doesn't specify a param?
are we streaming an empty list here?
still need to use getAllTargetAddresses instead of hardcoding ::, otherwise when user selects buildroot/a/b/c:: it will still do buildroot:: P.S. getAllTargetAddresses really means getting the target specs, one of the legacies I haven't got to yet.
I don't think we need the warning level log here. Let's change that to a Log.d for debugging.
Maybe check the file's existence just in case? otherwise the watcher will give up immediately (IOException ). But IIUC the code it may want to wait to avoid race conditions. Or not?
Do we need this here? I think onResume() is called when the activity is restored. Therefore the settings will be reloaded. So I think we can remove the logic from both the onViewStateRestored() and onSaveInstanceState() right? Or am I missing something here?
You can check if list of results is empty and our property ('numberOfPrograms') returns 0.
I would prefer constant there.
Honestly I cannot remember the exact reason why I make this so permissive but I know he has something to do with the GeoServer integration: <LINK_0>
You can check if list of results is empty and our property ('numberOfPrograms') returns 0.
possible NPE
Nitpicky stuff: This method performs the key lookup twice when you could do the same operation with only one: JsonNode node = json.get(key); return node != null ? node.textValue() : null;
Just to make sure I understand it correctly We only optimizing simple projections/filters of a bucketed table into the other bucketed table? It doesn't save any memory, but potentially saves CPU cycles on doing shuffle.
implements Constants
These methods should have an @NonNull annotation for the return. public @NonNull Builder setDomain(@Domain int domain) {
can't we combine this and the above for loop into one loop?
TmfWindowRangeUpdatedSignal
Why this condition? Will it be set to be <0 somewhere?
I just realized while I was dealing with the [editorial content TTL problem](<LINK_0> isn't it just as bad that these two taxonomy caches never expire at all? Each one stores only one entry per journal. Even if the taxonomy graph changes only once per thesaurus update, surely the taxonomy count table should update as new articles are ingested, right?
@original-brownbear oh, I see, it's \u00ea
This has already been committed, does it need to be rebased?
If opening is true, doesn't it mean it's still opening but not done opening yet?
This -1 smells a little. I wonder if a constant may speak more about the fact that it is a non value
I think here you can do something like steps.stream().findFirst().orElse(null); If findActions receives null, return a Collections.emptyList();
We use synchronized block when accessing *Params map. How about to use simple HashMap instead of Collections.synchronizedMap?
requireNonNull
Why is this now a magic 20 instead of props.getInteger(PARTITION_OPERATION_THREAD_COUNT)?
this way you'll go in to the 'else' while intention was different (if you already have <paranet_step/> specified) 1. please remove new condition 2. add validateParameters(step, "type", "step.parentStep.id"); in this if()
It looks like this method is not a thread safe, shouldn't we have synchronization here ?
This will always be true right now, you'd have to setNofityRequestNeeded(false) also in buildManually of the history builder. I'm not sure what this adds, it's one more call the module developer will have to make, just to avoid calling this twice.
After some thinking I think I would skip this if completely and let it be the last one, like it was done before. Rationale: for non-Windows systems this condition is always true, independently if the path is absolute or relative to the workspace, so probably this could lead to false positives and behavior change, compared to current code. So path like /tmp/libs/hello.jar could be either located in the project "tmp" somewhere on the earth or in the /tmp root directory in the local file system. Original code would try first the later one, new code will prefer workspace one.
This would be better as an array. You can use the url pattern of profileIdentifier=a&profileIdentifier=b Changing the method signature to String[] profileIdentifier should do the rest for you.
why did you call that? If it is necessary, I guess, you should call it everywhere and you could why it is necessary in the commit message
import NamedElement (replace x8)
Should return DataContext (the interface) and not QueryPostprocessDataContext (an abstract class which we don't want to expose to end-users).
Can we move this context.restoreAuthSystemState() and everything after this *outside* of the try clause? I think the try only needs to be around the BitstreamBuilder, unless I'm misunderstanding something?
Hey @abatac while both of these Exception types are thrown from the single service, they are different Exceptions, and the type of Exception gives the user a clue as to what might have gone wrong. This is why Exceptions are typed in Java, so we can provide the User with more specific information about the problem. Please handle these Exceptions separately and provide extra information to help users understand what went wrong
One child of compute entity
This doesn't seem to catch the SecurityException that could be thrown from ActivityMonitor.getMyMemoryState (Line 48). Remove the existing try-catch from getProcessInfoPreApi16 and then catch at this level?
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
Can we set external flag in ImportTableDesc constructor itself?
Could the test verify the metadata properties? (And the instance properties, based on the header line of the CSV file?)
lambda?
> I would rather use the first version and avoid the cast to M. Is that OK? Please cast (M) map.put(key, value). We save an additional Tuple instance which scales for many calls. I see our collections as low-level, they should be as performant as possible. A cast is fast.
This returns true if the code is not success and not one of the above errors. I would think the caller would expect an error to be returned if the error code was not success except for maybe the case where node already exists
Nit: you could have called getUsageForAccount instead, and do the filtering afterwards to avoid duplicating the date logic.
- [x] Why need this? Please re-consider based #768.
If calendarName can be null, there are other places in this class that might need null-checks. If the calendarName cannot be null, null-checks in the hashCode are redundant, and should be removed. The same goes for the other fields.
This log will be shown pretty often..
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
Remove it. It was used at some point but I forgot to remove it after code restructuring.
I don't understand the purpose of this test. Shouldn't you assert that fileInput.globalVariables() has 1 symbol of kind CLASS with empty parents property?
You should pass here message not group converted to string.
Can't we make it final as well? What if we try to rewrite the Mockito tests? I am asking to tweak the tests for several reasons: * it should be final by design; * we could avoid <p>Use the {@code Bus} class abstract methods to modify the behavior of posting and <p>This method defines the general posting flow and should not be overridden..
Use Arrays.asList instead.
nit: metric names are generally lower-snake-case in this codebase.
please use line number of lamba in argument of method , it is really cool idea to make it more visual.
Isn't this... just a re-implementation of natural ordering? I don't think you actually need this.
Why do we have to check read scopes when we commit cursor ?
TB too?
Since serviceBuilder is a CapabilityServiceBuilder, use: java serviceBuilder.addCapabilityRequirement(Capabilities.REF_HTTP_LISTENER_REGISTRY, ListenerRegistry.class, ((HttpListenerService) service).getHttpListenerRegistry());
I think there is some findbugs issue with not using {} not sure.
use FileRepositoryBuilder.create
log.warn in default block is a good idea, but we should have case FAST_FORWARD_ONLY break without logging.
add some message to the exception
nit: holder = new CacheHolder(locs)
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
suggestion SonarLintLogger.get().debug("Connected mode (using configuration of '" + binding.projectKey() + "' in connection '" + binding.connectionId() + "')");
A reason in this assertThat would help explain the condition being tested for.
It's a good update
is this auto generated by Eclipse of intelli-j? :) Have you considered using ObjectUtils.objctEquals? See VmDynamic.java for example. IMHO, makes the code cleaner.
can we remove the version completely?
I don't think args can ever be null, can it?
Would info logging be useful here?
This returns false if memberName is set. It's not what I would expect, though, given the function name. When I'm comparing to the class name, I expect to test against the class name and only the class name, regardless of the state of the other members.
returning feedback to users seems a good idea.
The trade method is really long. Consider refactoring into multiple smaller and more concise methods.
nit: doJoin(otherStream, (no new line)
Where does the IOException come from? Can you include that in the description?
toString(java.io.InputStream) usage is deprecated. IOUtils.toString(inputStream, StandardCharsets.UTF_8.name()) is recommended. This is not critical, just seems like is causing a build issue on some travis build.
these arrays could be static finals. That would save allocating new ones all the time.
Why is this required? The test you wrote fails when I don't apply the change on PrimitiveType, but doesn't fail if I don't apply this.
List<VmTemplate>...
Resource leak.
Are we removing Temperature Insight for new users as well?
I think this can just be LayoutInflater.from(context)
My guess would be you want the exact opposite of this, this'll get you a list of nulls.
Move end to same line
When using suggestion Assert.assertThat(testRealmResource().users().search("a", true), Matchers.hasSize(0)); Assert.assertThat(testRealmResource().users().search("apollo", true), Matchers.hasSize(1)); Assert.assertThat(testRealmResource().users().search("tbrady", true), Matchers.hasSize(1));  the output on failure shows the search results which is better for debugging potential failures.
Is NodeList Iterable? I can't check at the moment, but if it is, then it's usually better to use the "for each" iteration, since the implementation can give better performance than just doing .item(i) or .get(i).
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
!sizes.isEmpty()?
I'm not sure how the client uses the executorservice, but you might consider using shutdownNow instead, since shutdown will execute the entire queue of submitted tasks before shutting down. Also consider adding an awaitTermination here so close doesn't return until the service is properly closed.
I prefer using () when there's a single value and {} when there are multiple properties, but it's just a matter of personal taste.
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
Tiny thing to mention (just cause I've seen it alot in this PR). It's sorta useless (to me) to use e.getMessage() here. We either should pass in a more specific error message, or just do throw new RuntimeException(e);
Might there be upper or mixed case "csv"?
If the first constructor is used then both oldSeqNum and newSeqNum are not explicitly initialized i.e. they are set to zero. Seeing "0..0" in the string representation of this object is less useful than seeing "aPSID..bPSID". Include the IDs always in the toString and additionally include the old/newSeqNum if they are set?
I'm floundering on where toolbar code should live but it seems if it's going to access the Activity and has no dependencies on the Fragment, perhaps it should live in the Activity?
unused local variable
use ShellIsAvailable
can we remove the version completely?
I think that if this is the new notation you accept it as-is, fall back only if there is no \ atIndex = qualified.lastIndexOf("@") if (atIndex != -1) { } else if (userNameFormat == UserNameFormat.DOWN_LEVEL_LOGON_NAME) { backslashIndex = ... }
We can get rid of this particular null check too, I believe.
(empty line)
return new StringBuilder().append()....toString();
Let's remove leaseManager from class variable
I this refactoring, very nice. Could make this method protected.
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
do we really need to go through legacy object in it's usages here?
public boolean hasValue(@Nullable String value){ if (adapter != null) { return (getAdapterPosition(value) >= 0); } return false; }  Not sure why we are instantiating a variable here.
Hello @mcimbora , I think it can be worth to provide a more fine grained filtering here. To be sure that the method is not a constructor, has the @Generated annotation, and also "is one of the generated" by the planner stuff. Probably inspecting some additional planner generated annotation for the method (I I don't remember wrong for this planner generated method you added has also a planner annotation with two parameters?) or eventually exploring the return type, or some other trick. This will prevent us from loading other methods with the @Generated annotation that we don't know how to manage. Specially because when the java source is being updated, all the accepted methods are being deleted.
nit: you can merge both lines above as checkNotNull will return the given argument
Moving that bits above and allowing the user to change the decorator via a public setter means you can completely shadow what AbstractTransactionSupportingCacheManager used to du using public API. Also, if CacheDecorator is a first-class concept, you should probably expect that more than one decorator can apply at a given time. This wrapping shouldn't be the responsibility of the caller.
innerPosInRowGroup -> innerPositionInRowGroup posInRowGroup -> positionInRowGroup
use ==
I think we could reduce this constructor to a call to another constructor:  java this(configuration, null);
why are we changing the visibility of these methods?
use CharArrayType instead to avoid constructing a String containing a password
Yeah it's pretty bad. getAddress() allocates the address byte array. Maybe I should have these store the address array so I don't have to go to address to get it.
Call to default super() constructor is implied. This is only a question of style, but it make my eyes hurt... Feel free to ignore.
(nit) suggestion if (!aliasKeys.add(aliasName)) { throw new SqlCompilationException("Duplicated alias name found."); }
Don't use final here.
I'm confused. Why the unused params in the constructor?
Needs to be rebased on <LINK_0>
What is the use of this empty line?
Won't we land here for expected network errors as well? Should this be in the catch block itself?
you should replace the test by (primeRefining == null) and execute statements from the else block. Then always return primeRefining field after the "if", the main local variable is not useful
Error handler will only handle SAXParseException. So we will swallow IOExceptions here.
Is there any reason to add the this. prefixes? Seems redundant when the member variables are already prefixed with m_.
I think a compare between capacity and maxPageBytes is still reasonable here - even through the capacity > maxPageBytes is always true here. Because we cannot ensure the private HeaderChannelBuffer constructor is always called in create. Maybe it will be called somewhere else someday? A compare here may seem redundant now but will decouple the private constructor and the create
Doing this via double math is still 3x slower than return (nano + 1000) / 1000L;
It looks like validate is also "assigning" partition counts.. Would it at all be cleaner to separate out computation of partition-counts from their validation? As an example, computing of partition-counts depends on the order in which we process the StreamEdgeGroups while validation may not.
why did you change to final here? should be outside of the scope of the patch.
Use a correct name for variable.
useless
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
It's a good practice to keep resource that are related to some class in src/main/resources/com/rultor/web. In that case you get rid of this leading slash and avoid collisions between resources. If some other package has resource build_health.png - there is a high chance of collision. But, if you keep all resources prefixed by package names, collisions will be avoided.
I think that may have been an oversight in longSum. Try a query that results in +Infinity at the historical level and you will see why it is needed to deserialize at the broker level
BUG? you log the error but continue processing the invalid sequence number... what will happen? See call to m_gapTracker.truncate below using the invalid value.
unnecessary newline
is this class going to be created by the user?
you can either remove else or add pair of curly brackets
Is "Resource not found" the correct response during a rejoin? If so I am OK with these changes so long as they work and pass tests.
Formatting issue.
I think this is a good idea. I veguely remember running into some weird problems with jvm JarFile cache in the past. But even if this does not fix the problem, try-with-resource will make the code cleaner, so will be a good change.
I don't think args can ever be null, can it?
@yongpingchen What do you think about adding target id to responseBody? I think that using reflection is not good way in this situation.
Should we only assign the external ID if it changes?
nit: spaces around + I'd also change / to use OS-specific path separator, i.e. [File.separator](<LINK_0>
Same here. I don't think we need to check. Just let it crash if old doesn't exist. I also think we can also not check if device id is the same, just check both. Less code.
Please add message entity here by describing the error.
if output is not connected, will your parsedRecords will be zero? Same for validRecords. They should be incremented if there is no exception.. Why have two different parsedRecords and validRecords when they are same?
Maybe it's better to check if isEmpty()?
it won't work well: The message says: job.ImportVmTemplate=Importing VM Template ${VmTemplate} to Data Center ${StoragePool} Here you provide the VmTemplate only. StoragePool will be set to UNKNOWN. You should handle it as well - either by providing a value to it or omitting it from the message. Since templates are on DC level i think it shouldn't be removed.
Const.ParamsNames.ERROR was previously used to colour the status messages red, is it still used?
Does it work with setObject(column, Object[] or String[])?
FYI this can be replaced to a one liner: java getSourceDatabase().getTables().stream() .anyMatch(Table::isStem)
Why are these in here? Shouldn't they be seperate steps and meantioned in the feature file?
IMO, try catch block should only effect on default case.
The constructor should be made protected so that users can easily make a wrapper for it.
Why is this now a magic 20 instead of props.getInteger(PARTITION_OPERATION_THREAD_COUNT)?
missing unit tests for this in HashJoinSegmentStorageAdapterTest
add "domain = null;" to avoid problem at super.tearDown()
Being composite is indeed 1 criterion (as it makes preview useful), however I think another criterion is more about whether the rename wizard would show some options. I imagine the condition would be if (previewIsInteresting || refactoringWizard.hasOptions() { op.run(...); // show wizard } else { refactoringWizard.applyChange(...); // don't show wizard }
I don't see any literal numbers in this method. Why is @SuppressWarnings("checkstyle:magicnumber") needed?
What is the difference between request.withNextToken() and request.setNextToken?
Has this actually changed to include the value? Why does only the agreement_id include this?
same question
how about using an IllegalArgumentException here instead? > "Thrown to indicate that a method has been passed an illegal or inappropriate argument." from [Oracle doc](<LINK_0>
These is a most ugly way of work, you crated wrapper, passed all parameters and you are passing a list of canDoMessages all over a code in order to fill it. Such approach is wrong (I know that it is used at our code, but sometimes someone should do something smart), you should use return value.
This one too.
No need for null check
Maybe use some of the runtime exceptions from MyNakadiRuntimeException1 ?
nit: just do the ternary form Collection<Account.Id> results = (cd != null) ? cd.reviewers(Providers.of(db)).values() : approvalsUtil.getReviewers(db, change.getId()).values();
We may want to STATE.remove() rather than clear if these deques are going to grow significantly beyond their default size, to allow shrinking.
Why change to this?
Add a message in case this ever fails java "aggregation operator should not be blocked"
The "brackets for single statements" cleanup in this file should be done in a separate commit, as we should not mix unrelated changes.
&& get() != Long.MAX_VALUE
parentheses please ;) return (number == null ? null : Long.valueOf(number.longValue()));
This is figuring out the priority lazily, I think it should be done eagerly and passed as a parameter to the PrioritizedCallable.
I wonder if it may be proxy and therefore we need one more special interface... WDYT?
Shouldn't this loop release memory of "discarded" arrays? E.g. intArrays[intArraysTop] = null?
Since you're already calling initMocks(this), you can annotate all your mock objects with @Mock and remove all these mock() calls.
very strange for the appendFragment, I would rather propose something where we have the SysMLResource.LIBRARY_ROOTPATH and SysMLResource.LIBRARY_PATH
I assume you mean System.getenv(Constants.ENV_HADOOP_HOME) + "/etc/hadoop" here. Also the next line.
When meta == null, the column is missing and all values in that column are null. In @viirya's recent patch, 71cff7c5940b7101ff098601850d46b7a4698180, the user-defined predicate is called with null to see whether all rows can be filtered. I think this patch can work the same way.
Minor thing: please use "something <operator> null" convention.
Isn't the coding convention like: omit "this" when it is not needed ?
seems like you could avoid touching all the other share objects if you checked for null options first here, then kept the empty-argument openIntentChooser() and just chained it to this one passing null e.g. java protected void openIntentChooser() throws ActivityNotFoundException { this.openIntentChooser(null); }  That's a minor point though
It's too late to add to this list here - the (other) MBeanExporter may have already been instantiated by now and it registers its MBeans in afterPropertiesSet(). That's why this used to be a BFPP. I guess the issue you are trying to resolve is that the annotation BPP is adding more beans. Perhaps you can build the excludedBeans in afterPropertiesSet() here instead? (No that won't work because it will cause early instantiation of all beans). We somehow need to figure out how to be notified of any new beans created by the Annotation post processor.
this should be "/api/pid","pid" It could be better to define a constant to use in the Controller mapping annotation and here
spacing
For backwards compatibility, why is passing the CAS protocol service param not enough? (I'm assuming that's what happened previously?) We've had some issues in this service url construction lately so I'd like to reduce our chances of getting it wrong again :-)
we can make this more efficient if we first do something like: int startSura = pageSuraStart[page - 1]; then start the loop below from i = startSura instead of 0. also, once you hit a sura with the start page > page, break out of the loop.
nit: should be && rather than &?
Since the snapshot returned appendCheckpoint is a global snapshot that shouldn't regress, shouldn't we just select the first checkpoints snapshot and make sure subsequent checkpoints all return greater snapshots (instead of just finding a min of all snapshots).
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
I'm not sure we want to execute every REJECTED/NOT_STARTED command on engine startup, what if it took 2 hours to restart the engine? think of the following case: host went down and we run a VM that ran on it using this infra, the command didn't start and there's an engine is stopped and started after an hour - on startup we'll try to run the VM, even if no SPM was selected, so the user will see that we try to run the VM without asking and that the operation fails I think it is better no to try again to execute the commands in that case. we should do it only for special cases such as HA VMs
swap and use if(booleanVar) (which I would rename to just prettyPrint)
consider giving this boolean a name that describes its /meaining/, not what it is - e.g., doesStatusProhibitConnect
Remove the public modifier.
There's a lot of code moved around here for what seems to be just exception. Couldn't you have just released the bc object in the final finally block.
The names (__id, __cas) should come from TemplateUtils, although they seem to be hard-coded in several other places.
NLS.bind() should be used instead of MessageFormat.format() following Eclipse guidelines.
since we have this now, Line92 and Line 93 need to be adjusted  LOG.debug("supervisorsWithFailures : {}", supervisorsWithFailures); reporter.reportBlacklist(supervisor, supervisorsWithFailures);
Let's just use ParseObject.createWithoutData(String, String) instead here so it'll be more concise.
shouldn't this be: return setAddress(null); ????
I don't understand why System.exit is inside the test.
How do you think, is there a reason why we do not want a readable and concise class name like Revision to be used here? Or something like Checkpoint as the same concept is referred in API
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
Can we use same listener for all the entities, Because thought we have many listeners here but all of them are doing exactly same.
Shouldn't it rather throw an UnsupportedOperationException? Alternatively, it could return new ByteArrayInputStream(buffer).
return new StringBuilder().append()....toString();
it would be better to use compositions of iterators, e.g:  Iterator<Page> -> Iterator<PageWithPosition> -> merge -> Iterator<PageWithPosition> -> build page -> Iterator<Page>
use return ... ? ... : ...?
should return the ModelResponse directly?
If you're going to break this, add moustaches {}.
Unnecessary (and incompatible); revert.
Same here with not needing the local variable.
form.get("minX") != null && !form.get("minX").equalsIgnoreCase("") is probably safer
Leftover debug code?
since this is a method with the word "print" in the name, assume output should go to STDOUT throughout
if you do this, better put N/A :)
Doesn't feel right to put this feature in this class--the consumer isn't really a bound variable. Moreover, putting the consumer behavior in this class relies on BindFactory being the default binder if there is no annotation on the method parameter--but this can be overridden through SqlObjects.setDefaultParameterCustomizerFactory(), which the Kotlin SQL Object plugin uses. So this feature would be broken any time the Kotlin plugin was installed. What if we hardcoded it in CustomizingStatementHandler.eachParameterCustomizers(), after scanning for explicit customizing annotations, but before falling back to the default customizer: java if (parameter.getType() == Consumer.class) { if (method.getReturnType() != Void.TYPE) { throw new IllegalStateException( "SQL Object methods with a Consumer parameter must have void return type."); } return Stream.empty(); }
this method is called in the src Evaluator, when the data has been sent out. Could it be the case the data type is missing?
I think here we re-introduce logic we already have [1] [2], from my point of view would be worth to extract this scroll logic into a separate class and reuse it multiple times. [1] <LINK_0> [2] <LINK_1>
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
same with the return code here, you could return a boolean to indicate success/failure. the user doesn't have to use it, but the API should provide this info. Res: Done, a return type of boolean to indicate success or not
It seems inefficient to do this in an update loop. Wouldn't it make more sense to hook this into character movement in general?
please remove
nit: if (p != null)
The UI might get a bit verbose on errors with this change.
should we start the scheduler in constructor or prepareAndStartServer()?
the return of the result is hard to follow code wise. either return once, or return once result is retrieved.
null == adapter
builder never used
Please change **@NoAccrschema@** for **@C_AcctSchema_ID@ @NotFound@**
Are you trying to print the set of ids or just the size of the set? (The header doesn't match.)
Nitpick, use braces
As no transformations are happening to id, why not make checkForeignIdLimit void
It's an obvious code duplication. We can save this new request with a modified URI into this.request, and use it in all methods. This is how it works in other classes, take a look
use return ... ? ... : ...?
since we are before can do action, you should also check that getVdsGroup() is not null
Can be replaced with lambda
I think the brackets are wrong. Did you mean if (p.tid == e.ptid && !(e.start >= p.end) && !(e.end <= p.start)) ? Or if (p.tid == e.ptid && !(e.start >= p.end || e.end <= p.start) ? I suggest if (p.tid == e.ptid && e.start < p.end && e.end > p.start) . Or should these be <= and >= ?
Consider removing the "Optional" part. Seems better to return an empty map, if not present.
I don't understand why you verify if filterChain needs to be updated with every message read. Maybe filterChain should be volatile.
Can add synchronized to method signature instead of using this block
Just noting that the inconsistent use of the _FIELD suffix annoys me.
Add a message to checkState so that it's easier to debug if we ever hit it.
please move the isEmpty methods to the scimSchema
This looks as if it were copied from the CVS one. Does HEAD make sense in a Git checkout anyway? The idea (behind CVS) was to not write out the 'default' one for everything that needed doing e.g. default to HEAD. Should Git default to 'master' here instead?
I just realized that fTraces is the TmfExperiment. There will be only one iteration. So, the change of the subMonitor doesn't really help. Also, I noticed that the child monitor will not progress because the progress isd not update since there is no knowledge about the press and we can't call monitor.worked(). So, maybe it's better for the user to have a rolling progress bar. I suggest, to go back to your initial implementation. I'll review it right a way once you update it. Sorry, for that.
what it calls on partition seems questionable
Is this exception message meant to be the same as the one above?
Usually StatementBuilder is used in H2 codebase for such operations, because in has appendExceptFirst() that may be used for ", ".
Please handle InterruptedException and set interrupted flag. Why after interrupt you wait up to 10 seconds below?
Message could be enhanced to read e.g. java String errorMsg = String.format( "There is no field '%s' in the type '%s' that accepts instances of '%s'", fieldName, entityClass.getName(), // beware of null, though fieldEntity.getClass().getName() );
suggestion public @Nullable ImageIcon getImageIcon(int size) {
Nested try here too.
Same here for literal check and exception handling.
Why not continue to LOG.info here?
verify the error message
storage should be final according to the checkstyle guidelines (which are deactivated in this plug-in though). Anyways, I think we should stick to it as far as possible.
Should this be the same Date instance as above? If midnight happens in between the creation of the two instances, this test will fail.
suggestion addRole(new UserRoleEntity(role));
creation of assertionType is duplicated in both testTransformXDRResponseToCheckPolicy and testTransformXDRToCheckPolicy. Try to do it in one place.
Needs to be updated to Configuration.LIBRARIES_DOWNLOAD + "/JPushBullet"
the default should be made a constant somewhere instead of being defined in multiple places
add brackets around if the clause or move on to same line.
You have to check whether there is a property for the path, not the value of path. Otherwise it's fine apparently.
I think we should now use UUIDs to check equality.
unnecessary array new: {{true}, {false}} should work here
See my question above regarding using mocks.
use return ... ? ... : ...?
Instead of the memoryChunk.resize(0), replace with memoryChunk.close(). Best to do other close calls in nested finally blocks.
Intellij tells me that "public" is not necessary here.
Are we happy to have a ClassCastException here or would it be better to check the type before the cast and throw IllegalArgumentException?
Should this log message be moved up into the finally block so it's called if an Exception is thrown?
Please consider adding a Preconditions.checkArgument to check that base64EncodedKeyContent is not blank.
ignoreTagChanges needs to be in a try/finally since the tag add or removal can trigger a lot of code.
Please replace 2 + 1 with 3.
The same, use java.util.Base64.getEncoder().encodeToString(bytes) would be better.
Here we have NULLIF(dim2, 'a') = NULL being translated as, - Old, when NullHandling.replaceWithDefault() is on: CASE WHEN dim2 = 'a' THEN TRUE ELSE dim2 IS NULL END - equivalent to dim2 = 'a' OR dim2 IS NULL - Old, when NullHandling.replaceWithDefault() is off: FALSE - New, when NullHandling.replaceWithDefault() is on: dim2 = 'a' - New, when NullHandling.replaceWithDefault() is off: FALSE I don't think the new dim2 = 'a' translation is really defensible: if it considers a null return from NULLIF due to dim2 = 'a' equal to null, then it should also count a null return due to dim2 IS NULL (or empty string, which should be equivalent if replaceWithDefault is on). The old translations are both correct, I think, in their respective modes. I just tried a similar query in PostgreSQL 9.6 and got zero back, which makes sense since PostgreSQL behaves in "NullHandling.replaceWithDefault() is off" (the SQL standard) mode, and should be treating this filter as "always false":  SELECT COUNT(*) FROM test WHERE NULLIF(NULL, 'a') = NULL OR NULLIF('a', 'a') = NULL  I looked into this for a few minutes but didn't see a reason yet why the translation changed. @xueyumusic - do you have any idea?
Why is there a fromByteArray method? Why not call the constructor directly?
Well, it was just an idea :) But then we mix responsibilities already with this ProcessDefinitionList object. We don't register any provider for that, we just marshal it ourselves. Also I don't think we use any default providers because before returning the response object we already marshal it using our internal marshaller into String. Which (probably) means that JAX-RS will leave it as is. As I said, it was just an idea with less code. It would work the same also for XML whereas your approach needs to modify the Provider for XML as well. So it's up to you.
A null pointer exception is triggered here, fType may not be initialized as the empty constructor is used at least in one place. fType is used with synchronized in multiple places java.lang.NullPointerException at org.eclipse.cdt.dsf.debug.ui.viewmodel.SimpleMapPersistable.restore(SimpleMapPersistable.java:78)
If SQLException was unchecked, that would be great.
shouldn't need the throws declaration?
why are we changing the visibility of these methods?
can be used in loop
I'd do a ternary to chose the mode to a variable for all 3 blocks like this, then pass that variable to a single openFileOutput, to reduce copy paste. i don't know if android developer inspection handles that properly though.
No, this method should not throw interrupted exceptions.
selectorExecutorPoolSize can be removed from this class.
DynamicItem.bind(binder(), StartPluginListener.class).to(AvatarTracker.class) ?
nit: extra space.
redundant else
Suggestion: should it be > 0
You might look to the git blame / history on this one - I thought the same thing as I read this. I wonder if it is a problem anymore? I mean, when AnkiDroid first started it was API1, and now the WebView is Chrome, so...could be this should either be deleted already or sunsetted with a Compat implementation and an API cutoff where we know it's okay (and I'd think any API number that has access to current Chrome WebView at least would be okay, if this was just a historical thing)
This isn't a Messaging component and from other side using this one within a Messaging component, raising a MessagingException from here, we prevent re-throwing a correct MessagingException with failedMessage context. So, for me simple RuntimeException is enough in this context. WDYT?
I think so. A quick check on the docs didn't yield any positive results, but I remember seeing this somewhere. I can check it later, but I think it's fine to merge it without this use case.
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
Maybe it's better that we put in the ES module the time format that ES uses. I guess the TimeComparator is a bit more general purpose while I imagine (?) that ES is always using one specific date pattern.
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
the query returns the configuration from vm_static when no snapshot of type next-run exists for the vm, so this command would always create next-run snapshot I think, right? it is generally not a good practice to call queries from within commands, can we replace it with direct query from the database? btw, this way we can ask to update the specific snapshot we queried - if it doesn't exists we will get an error (which we can ignore) and this command could be non-transactive again. sorry for the back-and-forth transaction scope changes - let's give it some more thinking before changing it again.
Please reformat: else if ((getParameters().getAction() == FenceActionType.Restart || getParameters().getAction() == FenceActionType.Stop) && getParameters().getKeepPolicyPMEnabled() == false) {
We should probably prefer setReference and setAlternate to be private (or protected if used by a child class, but I assume that is not the case right now).
form is optional ,so please add if here
Did you take a look at this? <LINK_0>
Are you sure that replaceAll is not needed?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
These isCreative() checks should be replaced by if (!player.capabilities.isCreativeMode) { to match Vanilla, as there the item consumption is tied to the capabilities rather than the gamemode itself.
add wait condition for shell
final
I don't think this block is needed because you already set the value for ex in the catch block
Strings.isNullOrEmtpty?
you are only setting flag to false, but still unnecessary loop operations are executed
use logger instead of system out
We may consider using Apache CollectionUtil.containsAll(currentChildren, names) for allIn
It also doesn't allow me to change the destination branch if my change is in DRAFT state. I think for draft changes we should definitely allow to change the destination branch.
Sadly checkstyle isn't as strict as I would like. We could probably do a custom regex for it.
This is a workaround. site.getWorkbenchWindow() should not be 'null' at this point. Also, the workaround is wrong, since the reconciler can also be uninstalled from a non-active window, e.g. on exit.
I think I want to avoid an explosion of constructors. We are stuck-ish with the existing ones, but maybe make your new one private because you really just want to use it from fromPkcs8. Although, we seem to also have an explosion of methods with that name, too. Maybe we could even hide that one - someone could use the existing fromPkcs8 function and call createDelegated on the result to get what they want.
This now also deletes the underlying Firebase Auth account in addition to deleting the credentials. This has two new properties: - Will fail if there is no currently signed in user - Will fail if we don't have recent authentication (last 5 minutes) Did you intend to change this behavior?
this seems nice, however it exposes authentication info.
There is a NO_VERSION constant you can use here. you can use here.
you can make this a List<ExpressionTree>, I don't think you're using a feature of the SeparatedList
Java7: type inference.
It was args, not argb, that was supposed to be checked for null.
please remove else, code will be more readable
No need to use an else statement since the if block ends with a return statement.
OK I now see that these events get fired elsewhere.
Do we need to check key != null
this change actually breaks authentication. If you have an existing connection without stored password, it won't let you authenticate. Reverting the changes works
We need an 'else' clause here where we still end up calling SystemExiter.logAndExit(), just with an ExitLogger that's a no-op.
You can try to use the static fields at MetadataDiskDescriptionHandler, this way, it will be more related to the real scenario which we are testing.
Please add the Identifier of the Contentlet, for troubleshooting purposes.
Can you leave this method as-is and create a new method to strip wildcards?
No need for 'prev' to be a field
job
redundant parentheses
nit: if (p != null)
use return ... ? ... : ...?
maybe have org.kframework.kil.Sort#toBackend and org.kframework.backend.java.kil.Sort#toFrontend?
same wondering about fixture as before
This is basically parse one xml field to all the output fields, config.field is the only field we use in the transform
new lines
Should we put the check here too?
we generally use UTF-8 charset in Druid
A small thing, but maybe we can store destObj.getPid() in a variable to avoid the duplicate calls
parameter exemptionDate is never used, shouldn't it be passed on the exemption constructor?
Maybe better to return null
1. maybe dname could be declared as a globally constant string such as TEST_DNAME? 2. it looks like some of the declarations could be moved outside of the loop.
Why is this assertion here? There's no Morphia-specific code that's being tested. But see above for assertions that _should_ be here.
please use a better name here
Use a Visitor.
let's verify the error
don't need optional, just use ImmutableSet.of(ports.get(getNodeType()) should work
We also need to override that in NestedUDTMapper and EnumMapper (using an enum as partition key, though unlikely, is possible).
This does not need to be public. Instead, just pass the builder to the private constructor. See what we do in HtmlRenderer.
The String returned by trim() is ignored, this line does nothing
return right away if initialized already?
Please use ? ternary operator
ExtMadiaType?
Is there any reason to add the this. prefixes? Seems redundant when the member variables are already prefixed with m_.
nit: you can merge both lines above as checkNotNull will return the given argument
nit: you aren't writing any data, the numDatanodes can be set to 0.
very strange for the appendFragment, I would rather propose something where we have the SysMLResource.LIBRARY_ROOTPATH and SysMLResource.LIBRARY_PATH
The salting byte would be fixed length and non nullable, right? Why is this special case necessary?
All setters with Long as param should check on null since then Instant.ofEpochMilli() will fail on NullPointerException. We should safely set null to the base object instead.
Should we create the connector and connectorUI like we do in AbstractRepositorySettingsPageTest?
See getAllLifelines remarks
use hasNext instead of contains (do not use toIterable() we want to check Iterator)
Change to:  checkState(!spillEnabled || spillerFactory.isPresent(), "...
I think it would be better to use schemaName.tableName.familyName.columnName kind of syntax. Basically, what ever part is most specific, you can use as the parameter name. For example, if schemaName="foo", tableName="bar", and the others are empty or null, then it would be tableName=foo.bar. If you could use the SchemaUtil functions to get the display name, that would be good. Maybe have another one for getColumnDisplayName
remove empty line
same suggestion as above
Looks like nothing to complain about, unless I'm ignorance in bit operation and this part (and below switch) isn't clear to me . Would you mind to explain a bit how it works? Or at least share some doc to investigate Thanks
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Can you get rid of the parans around element?
map(Queue::getActualName)
You can use FiltersHelper.Constants.HEADER_AUTHORIZATION here.
You could static import getMimeDecoder to match the other file
nit: if (p != null)
I might be wrong, but I remember this object could be null. Please add a check here.
oops, I missed to merge with Stefans fix for annotated tags (calling getPeeledObjectID()). I'll add that again.
Shouldnt we have this defaulting to the common namespace (ICommonAttributes#COMMON_NAMESPACE) so that we can tell the user what this defaults to?
See my question regarding using mocks above.
This shouldn't declare throws Exception.
You should need to negate the condition or result.
isPreferred() is called only if isSupported() returned true. So, these checks can be dropped.
The return type for .getTrace() could be overriden in CtfKernelEvent too.
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
Moving that bits above and allowing the user to change the decorator via a public setter means you can completely shadow what AbstractTransactionSupportingCacheManager used to du using public API. Also, if CacheDecorator is a first-class concept, you should probably expect that more than one decorator can apply at a given time. This wrapping shouldn't be the responsibility of the caller.
Please mark resource parameter as final.
Why do we allow null key bytes? Are there cases where timestamp + seq is sufficient?
Why V1 is removed?
Please remove the extra stuff here.
I don't understand why you verify if filterChain needs to be updated with every message read. Maybe filterChain should be volatile.
This change is unacceptable. It will break existing Travis CI flows
How does replacing a NPE with an AssertionException help ? I'd rather try to annotate the method's parameter with @NonNull and watch out for "Null type safety" warnings in Eclipse and fix them.
Should this be putTransient because of IMap#putTransient?
if invalidSessionsEndpoint is true, then shouldn't this be set to null? Whether to send a session could then be determined by whether the endpoint is null rather than adding a new property. It would also reduce the odds of unexpected behavior if Bugsnag.setAutoCaptureSessions() is called after configuration.
still should keep the checkNotNull
Shouldn't this close the iterator before returning the list?
if you use dlmsHelperService.getAndCheck you reuse some validation logic that covers the checks in the next llines
does it make sense to send 2 versions of the verb to different hosts in the data center? (if one is older than 3.3 and other is 3.3) i think you should use storage pool compatibility to be consistent with all hosts in the storage pool.
> I would rather use the first version and avoid the cast to M. Is that OK? Please cast (M) map.put(key, value). We save an additional Tuple instance which scales for many calls. I see our collections as low-level, they should be as performant as possible. A cast is fast.
Is forEach better that putAll? I suppose we also need to take care of the case when params are null.  if (params == null) { namedParameters.clear(); } else { namedParameters.putAll(params); }
If you want to be sure to read from disk call persistAndReadAgain before the get.
This should be a Set to avoid duplicates.
209, 209, 209 instead of 0, 0, 0 previoulsy
There is no mention in the DASH IOP that this value needs to be -1 specifically. It just says "if the @r value is greater than or equal to zero" for one case and "else" for the other (=this) case. So can you check for < 0 instead?
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
throw an assertion here, i should probably do that in my code as well
It has been wrong before your commit, but as you touched this line could you use {} instead of string concatenation?
Why do the containsKey check? If its not in the map, then get() will return null.
We _could_ set the visibility explicitly to public. (Nice to have)
Use method reference
@vkdrn Thanks for contributing!! Would you mind to add all attributes in toString method too?
could metric == null?
Check first that target is not null.
I think we should use a WorkspaceJob here in order to ensure that resource change events triggered when rebase moves HEAD will be batched until the end of the job execution
@rakeshadr is there a potential race here between setting the shutdown handler and checking if it is null?
This will only work as long as the RSS 2.0 parser is the last RSS parser that will be checked. As far as I know this is depending on the order in rome.properties. I would propose to check whether the version matches (like before) or whether the version is null.
Is there a test that verifies that this fails (stochastically) for fault publishers?
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
How about inlining it?  if (!contains(o)) return false;
Would you also add an IS_NULL filter here?
This still has us redundantly check the loading and hasMoreItems values. It would be more correct to instead change the loadMore call below to onLoadMore
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
nit: We use fail() instead of directly assert(false). It gives you a chance to put in error message. Please check other examples in the same file.
These five lines should really all be in their own method, along with the parsing of the timestamp in the beginning.
it does not make sense to have both last repl id and chkpt for partition ...table ckpt parameter can be used to filter out invalid loads
why not to use for .. in here?
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
What ? Is there any reason for this if statement ?
Actually, in most cases HeaderChannelRegistry contains TemporaryReplyChannels which aren't beans and this exception message will see often exactly for gateways with some serialization during flow, but without HeaderChannelRegistry. So, my position to change it to more generic statement: > "Failed to look up MessageChannel with name '" + name + "' in the BeanFactory" + (this.replyChannelRegistry == null ? " (and there is no HeaderChannelRegistry present)." : "."
Close the client () :-)
DRY: would use this(username, password, null) instead
I dislike callbacks being part of the public interface of a class with other responsibilities than just receiving the callbacks. This class has a two-sided interface - e.g. submitLogEvent() on one side, and onConnect() on the other side, but a client on either side can see - and use - the complete "union" API. Both sides see too much! Consider using (possibly anonymous) inner classes for the interface used from TimberClientHandler.
can u fix the spelling mistake in file name s/Withe/White?
Good question. I'm tending to doing null-checks here to ensure that all values are non-null whenever something on usage side accesses them. I suspect that nobody will ever to a null-check there.... Can use Guava's Preconditions here.
Use EOF in the test.
I think I prefer "Invalid key" as exception message
This should return a URL
are you still creating new contexts here?
please don't touch old formats, whatever they do let them do that
We could shorten to one line return Optional.of(new Context());
Externalize strings.
i18n?
Should be removed.
Can be replaced by:  if (principal == null) { principal = Framework.getService(UserManager.class).getPrincipal(username); }
Could you mark the constructors @Deprecated instead of deleting them / reducing visibility? It makes it easier to transition between versions if we deprecate first, then delete later.
A diamond operator would suffice.
Add a method in GrillService to get the server domain and use it. The conf should be from server conf, not the query conf.
It would be better to use try-with-resources or close it in a finally block.
I think int is better, let's rely on auto-boxing.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
This should return 1 if the time difference between start and end is > 0 (in any unit), to ensure we never round something to nothing.
This code is repetitive. Appears also in previous file in your patch (the if... part). Please think of possible code reuse.
Put SAFE back here. This needs to be safe.
You are going to hate me here, but I'd rather have a <indexed-entities><indexed-entity>*</indexed-entities> form...
Why is there a fromByteArray method? Why not call the constructor directly?
return (source != null && source.isValid()) ? source : null;
If we simply not set the sorting order in the table settings this change and the _allowMultipleColumnSorting_ could be avoided right?
Can you use "," as the default separator? The thing is called "CSV" ... ;)
No need to parameterise the ArrayList.
nit: IMO it'd be easier to read if the enum had to define both the delimiter and the literal CSV(",", "comma")
remove 'throws IOException'
better to use the official way here true instead than "true"
This should be removed and the change should now be managed such that adding or removing the busy tag should re-style the folder tab.
why not just if(200 <= responseCode && responseCode < 300) ?
The best way to prevent the adding of duplicates to a Collection is to use a Set. I cannot see how this code will prevent the addition of duplicate names. Please review - I may have misunderstood the issue. If I am looking on the wrong place for the actual fix to this issue please let me know.
Better to not use a list here: Queue<Type> next = new ArrayDeque<Type>();
rename to member
the way jenkins (de)serializes is a bit confusing. In upgrades this.ports will be null because the field is not in the xml config. What you want is to guard against that, so just remove final (I don't think there's any reason to have it) and do this.ports=ports
Can we inject this feature directly ?
and here ;) string concatenation would we preferable.
This variable should be called something more generic instead of sort since it could be any int
The introduction of @Before allows this code to be refactored into a setUp method.
Can we add more context here about which consumer this is? Looks like you can log this instead of KafkaSystemConsumer?
This doesn't seem right... wouldn't this result in the file's path being the file path of the parent directory (and hence overwriting that directory)?
Since we pass info as the message param to the super, do we need a copy in the subclass?
[FindBugs] WARNING: SA: Self assignment of field KafkaSingleThreadedMessageReceiver.subscription in pl.allegro.tech.hermes.consumers.consumer.receiver.kafka.KafkaSingleThreadedMessageReceiver.update(Subscription)
make this synchronized.
you can use your find method here also
XD you sneaky mom! --- In reply to: [333121225](<LINK_0> [](ancestors = 333121225)
only add to responseObject
We may want to STATE.remove() rather than clear if these deques are going to grow significantly beyond their default size, to allow shrinking.
cols should probably be called colVal. You need the row and col. The entry in the outer loop has the row. The entry in the inner loop has col and value.  java for (Entry<Bytes, Map<Column, Bytes>> entry : ret.entrySet()) { updateColumnsRead(entry.getKey(), entry.getValue().keySet()); for (Entry<Column, Bytes> colVal : entry.getValue().entrySet()) { Bytes row = entry.getKey(); Column col = colVal.getKey(); Bytes val = colVal.getValue(); bet.put(new RowColumn(row, col), val);
This view can be set in the builder instead of in the built AlertDialog.
entry
looks like Intellij recommends Short.parseShort(idKey)
This line of code, view.getOverlay().add(this); is repeated in every single HighlightDrawable. For symmetry with ViewHighlightOverlaysJellybeanMR2.removeHighlight(), why not just put this into the ViewHighlightOverlaysJellybeanMR2.highlightView() method?
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
Please align with Double (no protected)
Since this is KafkaPollerIntegrationTest, it looks strange to mock KafkaConsumer. It looks like we should have unit tests for both the kafka and the RdfRepository side of this logic and an integration test which exercises both. Having this half integration tests makes it smell like we have too much coupling between the kafka and the blazegraph side of things to test them independently. This would be a design smell that should be fixed. Honestly, I have not read the code closely enough, I'm just speculating.
Why do we need to check that gluster service status here? Shouldn't this be checked in MaintenanceVdsCommand or HostMaintenanceCallback itself?
there are constants defined for these strings.
what's o? could use a more meaningful variable name
:astonished:
Consider extracting explaining variable for this large condition
Make a real test out of it :-)
double 's' at the end?
Is this still needed? We don't add any other elements, so parent.get(anythingElse) should return null anyway.
nit: let's avoid return null even it's unused. Instead we can return Collections.emptyMap()
consider quoting the offending uri in the exception message? Or is that too PII?
shouldn't this be taken out?
Also here, extract initialisation to a method?
Something minor: You could use ConfigValues.class.getSimpleName() instead of hard-coded class name.
This can be simplified by doing if (instantiated.remove(instance)) && instance instance Closeable) and thus dropping the remove after the block.
nit: if (p != null)
Is this the template or the actual path?
nit: IllegalStateException -> IllegalArgumentException/VerifyException?
shouldn't azureLeaderElector.amILeader() always return false at this point?
use hasNext instead of contains (do not use toIterable() we want to check Iterator)
Add .omitNullValues() before the toString() call
We need a single SharedPreferences to access all app's references
Are bed blocks and bed items paired? I suggest using Items.BED in checks.
I think this null == scheme  validation opens the door for a NPE. That can arise from operations like scheme.getId() or scheme.isArchived() if scheme is null then the condition becomes true and we could get a NPE on line 330 e.g.
duplicate 1
please remove this "assert", it is not required , it will do no good in future updates.
Give a name to this thread, so if it hangs or blows up, the stack trace will give us a clue who called it. i.e:  new Thread(r, "Hawkular Java Agent Stop Thread").start();  I also need to think about this some more before merging since we are now making the stop() method asynchronous. We have to check to see what kinds of thread safety/concurrency issues this might cause (especially in cases where the agent is restarted, for example, and the stop is followed quickly with start. We need to make sure nothing in start is initiated before this stop thread is actually kicked off and finishes). In other words, making stop method asynchronous could have some side affects that are "bad" without some synchronization/locking put in place.
Seems like a reasonable change. Can you extract formatter.withZoneUTC() into another constant to avoid additional overhead each time?
This line does absolutely nothing
Instead of List<ColumnDef> use List<PColumn> and then create the PColumn list in SelectFromClauseVisitor.createTableRef, since you'll have a MetaDataClient that you can use to call metaDataClient.newColumn once you make it public
Need to put this back - cannot change the API
Could really just make a separate data processor instead and register that one.
You should add a warning log also here
downloadsMenuItem would b a better name.
why would this be required again?
rather than hardcode the string, can use the class name
Is there a performance difference between this and original code?
nit: you can merge both lines above as checkNotNull will return the given argument
LOG.error("can not broadcast for job manager {}", e) instead
static import
Shouldn't it be key:value for cases where value != ""?
Since this is java we can overload the function and not have to send an unnecessary null.
Now in the category random useless things to know: .valueOf() returns a Boolean object, which then gets unboxed to a boolean. You can use .parseBoolean(), which returns a boolean directly.
use return ... ? ... : ...?
No use checking if the list contains() before remove(), let's avoid double iterations.
This is not needed at all.
What about testing the happy path - that a POST is made to a correct URL if correct arguments are provided?
While convenient, this has a massive performance impact unfortunately. Looking at the code, we know that T extends EventEntryModelDao. I think it's fine to change the interface EventEntryModelDao to expose the setters (make sure to also add the @Override annotations in BusEventModelDao). With these setters, you shouldn't need this anymore.
How about inlining it?  if (!contains(o)) return false;
check for postArtifact vs postArtifacts
why not have java docs to explain what this does ? ( why it does it in that way etc)
remove extra line.
delete this line
Don't shade names like this on purpose... Also instance variables on Block is not a good idea..... Threads kill it...
Unchecked Cast. I suppose you should use <code>Item</code> here (there are no other public implementations, but they may exist in closed source plugins).
this will kill clients pretty quickly if we're creating executors with single threads that quickly, perhaps some sort of autobatching @jeremyk-91 ? not sure the best way to handle this. I don't think we want to use direct executor to run the callbacks, but we might want it so we can "queue" it onto the autobatcher which will then act on the outcome of the callback.
default method visibility OK?
Was seconds an intentional omission here?
Maybe I missed something, but AppPrefs.getSelectedSite should not be used outside the site picker and the "MySite" fragment.
(Alt) Can we move the skip condition to the testSetup method just above.
Can this not result in loosing data? If a job is already running, a change happens and the system want to save again, would that lock not loose the new data?
return 'A'
Collections.emptySet()
the token will not always be " ", sometimes it depends on ldap.accountFullName
StringUtils.isEmpty(namespace) will take care of both (not important, just FYI)
Yes, I agree. We should change it in API
This entire method is identical to calculateGenotypeConcordance() except for this one line. Perhaps we could break it out into a utility method that the 2 public methods call into.
Must be AIDontUseIt (otherwise AI discard all hand). Same for effect's constructor (AI can't use that card at all).
I think this is unnecessary as the postBody doesn't have card_expiry so it will send null anyway.
Doesn't .get() also return null?
I don't think you need to do all this. Just add a method public void init(T data) { render(data); } Are there places where you need to call this Dialog where you don't have this data available i.e. you need to call init without any parameters and it needs to reuse the data that it was initialized with? If not, then the init(T data) approach should work just fine.
I suggest using Paths and then below you can call toFile on the Path object.
this assigment is not needed, since its default value is false
I don't see why you introduced mutability here? Local variables would have worked just as well. If you really want that, please at least make the setters package-private.
lambda?
not sure why we need to throw an Exception, catch it and then handle the invalid case. What do you think about calling this function as soon as you detect a bad range (which you can do if you get rid of ValidatedByteRange)? Instead of creating an exception, throwing it and then handling it.
just return _props.get(key); in this method
why we need http here doesn't make sense ?
Not specific to this code change, but what if the server is unreachable? Say, it returns 500 (internal service error) or 503 (service unavailable)?
getOnlyElement()
![CRITICAL](<LINK_0> 'Severity: CRITICAL') Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
Are you sure what that event must fire before real resolve, not after? It's named as RESOLVED_ABILITY (e.g. for event that has already happened).
Need to verify no interactions with log
Call to default super() constructor is implied. This is only a question of style, but it make my eyes hurt... Feel free to ignore.
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
This line has nothing to do with if block and should be placed out of it.
good catch, the missing job name was resulting in quite a few unnamed jobs in the progress view - reported by QE, found out via jstack what it was
This reads as if TenantIndex initializes the BoundedContext.
At first I was wondering if this should be tied to lifecycle stop, but it looks like WorkerTaskMonitor would handle that, and now I'm wondering why ForkingTaskRunner stop is tied to lifecycle stop.
Why don't you call the sleep method on line 45 instead of replicating this code?
Need whitespaces after colons
prefer to have // given // when // then sections
I would rather return another warning ("Blank job name in the list")
Annotations on top please
optional suggestion: since we're extracting helper methods... it's mostly "false * 4" or "true * 4", so consider adding e.g. whenEverythingIsInitialized and whenNothingIsInitialized.
The duplicate close looks strange to me. I think @rmetzger gave a nice idea above. You can just catch and log the error and move each close in a separate try block. You can take org.apache.flink.connector.hbase.sink.HBaseSinkFunction#close as an example. That will be much clean.
may be throw some sensible exception?
Issue is at #5057 .
add the type parameter even if it's object
In general I wonder why one should instantiate an (immutable) null Password. I mean passing a null parameter to the constructor. Should this be considered a bug instead and hence throw a runtime exception? Should we update the copyright date to 2017?
I use isA() to check the different Exceptions thrown by the client. This lets me validate all the different error scenario paths as they often have different Exception types.
Agree that we should not save it to content Providers. @ctsims we did remove it for Images sometime back in [here](<LINK_0>, so guessing no objections in removing them for audio and videos as well.
One try block and the response variable can be avoided with something like: suggestion try (ResponseBody body = executeGet(args.bucket(), null, null, queryParamMap).body()) { return Xml.unmarshal(Tags.class, body.charStream());
should reverse order as follows: assertEquals("",html)
Should we not terminate this thread if it's being interrupted? And reset the interrupted state?
suggestion return Arrays.toString(value);
The call to super() is unnecessary.
This string presumaby should match up with a string that is fired elsewhere. It should be referenced as a constant.
Can we throw an IllegalArgumentException instead?
I think we should use something that has the format of the IAM API key to help us identify any possible issues with encoding etc Looking at it the com.cloudant.tests.HttpIamTest#iamApiKey would probably be an appropriate thing to make public and share between tests. Of course the value would need updating to something useful instead of the current "iam" string value.
You should pass here message not group converted to string.
Illegal arguments?
> /var/tmp $ xxd foo.properties 00000000: 0a The test case between the issue and here is different. InputNewlineAtEndOfFileNewlineAtEnd will have \n or \r\n depending on the OS. Does the issue still happen with this file even though the file is longer than 1 byte? We usually try to mimic the same file that is being reported to us to show the issue is fixed. Do we want to use a file that is the same line encoding on all OSes that is controlled through the .gitattributes file like InputNewlineAtEndOfFileLf?
Shall give detailed error message with source/destination Db/table names.
maybe you can leave it as this.builder = base.retrieve() as in the only method of this class public GHGist update() throws IOException you're overriding the HTTP method
Why is prime in the method scope and SHIFTDISTANCE a class constant? Also note that SHIFTDISTANCE == prime + 1.
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
Why do you expect this one to return 4 and the previous (looks identical) query to return 6?
So this should be completely unnecessary, enums are inherently ordered. This is the culprit in Label, mucking up ordering  public static final Map<String, Label> TEXT_TO_DESCRIPTION = new HashMap<>(Label.values().length); static { for (Label label : values()) { TEXT_TO_DESCRIPTION.put(label.text, label); } }  This map doesn't need to exist, the only usage is when constructing this class. A list can be created out of Label.values() Also you could have directly referenced the bookmark eg labels.indexOf(Label.BOOKMARK)
Can we replace these 2 lines with createTreeWalkerConfig?
setErrorMessage
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
Use AbstractQC.UNSAVED_ID instead of hard-coding 0L. Same thing in impl class versions
Is this effectively adding the external context? Is it guaranteed that the external context will not be returned from request.getRequestURI() already? (otherwise, the external context will be in there twice).
This will effectively drop the Not. THere should be a test case for this.
This should probably go to System.err, as goes e.printStackTrace()
no need to define the type on RHS, replace by diamond <>
All hard coded strings that used as a key to get data the bundle should be declare as constant in Router.java.
if format string is non-empty then String.format(..) can not be empty, so Strings.emptyToNull(..) is probably not doing anything. did you want to do following instead?  String.format(format, Strings.emptyToNull(value));
Looks like indentation problem. Don't checkstyle complain on it?
you need slot + minSlot
Should be a different error message
Please include a translation text here indicating that attribute value cannot be null.
There's a View::hasPermission() method
add CDA here and return false, if it fails you'll end up with null vmTemplate which will cause to an NPE. as it shouldn't happen i assume that we can solve it in the opened bug.
In addition to methods, we could also cover functions and anonymous functions. That's what we do for [JavaScript](<LINK_0>
Can we verify the cause of the exception? connection closed related.
Looks like the 4th parameter is no longer needed. Since the PR targets master/, it would be fine to remove it altogether, no?
setReturnValue can be Guid? As the snapshot entity is not populated apart from Id, so is there any need in returning this?
Could you please put the else brackets on same line and add a space? } else {
I'd recommend to add process id to the name as well as there might be tasks with same name in different processes but still in the same kjar
The given state does not imply that the device is active. If you are going to make sure the device is active, I would prefer "an active device with DeviceID..." so you the scenario matches exactly what happens.
should we only on recurse here if ids is null? otherwise we will retrieve more than was asked for.
No if block required here either.
return angle == 0 ? this : rotate(mQuat.fromAngleAxis(x,y,z,angle));
Code duplication
I'd make this private rather than part of a public API. If we want it to be called by other things, it should be moved to an appropriate utility place (and perhaps renamed to make it clearer that it will return null if not positive).
would we need the lock if we used a ConcurrentHashMap and LinkedinBlockingQueue?
Same here: instead of calling constructor directly, let's use Tang
Avoid logic in this class. This is inconsistent with other collection fields. You can't do an update with this field set to null. Also, why a tree set?
Should check for disposal.
This will never throw
I see some improvement can be done here.Is it required to define method as synchronised.Can we use ReentrantReadWriteLock and get write lock here? It will be resulted in performance improvement
Good catch :-D
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
<LINK_0>
Maybe good to add a limit to the total number of events that can be queued (suppose the send takes a while because of network issues and lots of events queue up in the meantime, leading to high memory usage)
Should we add the navigator's dependencies when this is not supported?
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
This is not related to computed attributes in any way. Also, setting attributes would clear existing attributes, so I don't think it's correct. Also, I don't think using special keyword is a good idea. We need some different way of copying all attributes. For example, if copyAttributes is not specified it would mean copy app.
missing @since tag for new API
Used to be fileSystem.deleteFileOrThrow underneath.
optional: can narrow scope
Here too - use Integer.valueOf(0)
This assignment seems useless
Replace with Map.Entry::getKey
Double* variant of this class uses object == null ? null that is better
Can you please revert this file. It will cause bunch of conflicts with my changes.
It's not an issue but I think that it's better to put the both checks on a single line (if (!dir.exists() && !dir.mkdirs()))
- log warning that option is not supported by SNMP
we missed something on the last patchset, with the current code if getTargetStoragePool() return null we will fail on CDA on isStorageFormatSupportedByStoragePool() so there's might be no point in having else clause at all here. there's something else which is awkward here, let's close that f2f and update in here.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Ooops you forgot to change this one :D
I'd recommend to add process id to the name as well as there might be tasks with same name in different processes but still in the same kjar
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
^ is still needed here IMHO
this could be private, or is it used on other classes?
we shouldn't make the setting of the flag conditional on autostartup
please reformat code
as we discussed, this exception is inappropriate for user errors. use a conditional.
I get a warning here about the cast from Object.
We reuse the ignoresCase a lot with treating checks for the cloud platform. Lets put that in a variable so we can just do an enum comparison.
The method name sounds a bit strange to me (having the words "subscription filter" twice). I currently do not have a better name in mind, though.
constructModel already called merge up there.
suggestion Preconditions.notBlank(path, () -> "File [" + path + "] must not be null or blank");
Suggest druid.host instead of 127.0.0.1
Why don't we 'stick' with the previous String version, that is directly the type that we want?
I would remove this and keep the flow as it was before.
suggestion console.warn("Usage: \"changeShip module:shipName\"");
model.getGenericParams() is an expensive call (makes a List and walks the PSI tree). Please capture the value, then test and use it.
A save to DB is missing here (and above in ExportDms). Please adjust ExportMetsIT to test reload from DB.
Based on your code change, I may have been wrong about the meaning of that date. Looks like it means 'the moment they are submitted'. The case of manual publishing seems to be handled already.
May I ask you the purpose to check "retry_count" ?
Should these have some kind of validation, e.g., non-negative, from less than to?
why calling refresh() here?
Why should we use a comparator and sort those devices at all if when we get those devices from DB we can get them sorted already as we wish ???
Can the opposite be tested too?
What about putting this into the finally clause and do try/catch again inside it where you would again log warning that the stream cannot be closed in case close throws exception. By doing this, the stream will be attempted to be closed even if reading of properties fails.
The StickyHoverManager also added a filter for SWT.FocusOut, I wasn't sure why, but now I figured it out: If you move out of the tool tip but into another non-Eclipse application, the tool tip does not close. But worst, if you click or Alt-Tab to another application to make it go to the front, the tool tip remains 'always on top' and hides the other application. You have to go back to Eclipse and mouse move on it to make it go away.
can't foreach be used here?
What is this for? Feels like some unintended checked in code?
You can sample the value as a static variable. You will save an access to the system properties map
final
I personally prefer to use null != element.asNode() instead of element instanceof Node, having in mind that on javascript the inheritance is different and for a pure client side developer maybe results more familiar using the null (undefined).. anyway just a preference. Please also create a private static method on the class and re-use it, instead of duplicating the element instanceof Node, it's alway good to re-use code :)
negative test case for different hashtags
This property should be placed here: <LINK_0>
Do not start in an inconsistent state: the loader needs to know a super set of what the store knows. If that makes the test a duplicate, delete it.
StringUtils.isEmpty(namespace) will take care of both (not important, just FYI)
Why do we save within the loop? Wouldn't it make sense to only save once after the loop?
I would really appreciate if you rewrite this so it doesn't use -1 as startIdx. A year from now I won't remember why we want to load from position -1.
No need to call stream() here.
maybe have org.kframework.kil.Sort#toBackend and org.kframework.backend.java.kil.Sort#toFrontend?
should be renamed to found ?
Same here, if it's not supported we need a test checking that trying to set indexNullAs fails.
I don't see where it is used
can we remove the nested if statements by short-circuiting the method if both white lists are null?
"result" variable is never used so it could be removed too, right? Currently, executeOnMaster(operation) method is called twice ...
Same here. At least returning a Collections.emptyMap() would be better.
emptyTextView can be made View.GONE?
hmm, that method makes somewhat sense in core java, but I'm not sure I like that behavior for selendroid. We're expecting a boolean value, but essentially we only care about either true or "true" coming across... everything else is false. Is it going to be confusing to any users? I'd almost rather add an additional else clause to check for the string of "true" or "false", otherwise raise the exception. Since users of other programming languages (like javascript or python) may have a different impression of what a truthy value should be.
If you make the EMPTY_EXPIRES, you could use it here.
Can't we extract these duplicate intent.putExtra and startActivity(intent) to outside the if-else? (line 101,102 and 115,116)
Why did you add this deleteOnExit if you delete this file in any way inside the finally block?
is this class going to be created by the user?
s/Iscsi/iSCSI
Intuitively, since most of the time we are dealing with ArrayList, removing from the end of the list is more efficient than from the beginning of the list.
We shouldn't synthesize the brand if there is a BRAND_IA_ID value, since we can create the brand using that ID. Update: ah that's contained in canParseBrandFromEpisode. I think, for clarity, it belongs in this method. Its functionality matches the method name then.
you can't use the killCacheManagers method. It will stop the __acl_cache too soon and fail to destroy the site.
You dont have to use VoltFile as this is for new cli only right?
Same question as above. And below as well.
checking for nullable parent was added specially, cause going into project node simply has no meaning
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Could inline syncGet() in getCacheEntry() and use that here.
public isn't needed
Do you think naming it removeFromParent() could be enough?
I would retain the existing indexOf body to to avoid indirection in the most common case.
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
Clearing the pool to get rid of a single dirty connection is a bit overkill. It is also non thread safe as there is a chance that the dirty connection is out of the pool again when we clear it (and clear() only clears the idle objects. Using invalidateObject() is probably better. That being said, good catch ! We've been having the same kind of problems, but could not pinpoint the cause !
I'm concerned there might be a race condition here. Consider: 1. Another thread checks isClosed, finds it to be false because this line isn't hit yet. 2. This thread completes close(). 3. The other thread continues on to use cipherWrite / cipherRead; gets an NPE.
assertThat(gosecSsoUtils.userName).equals("anyUser");
You can use CollectionUtils.toImmutableList
InsertOrUpdateObject?
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
is this really needed here ?
This will never throw
ditto about "indeterminate" in error messages.
I saw the property names would be converted to lower cases, that means e.g. controller.upload.onlineToOfflineTimeout will become controller.upload.onlinetoofflinetimeout. Is that intentional?
Do we need some kind of synchronization here, or will next() never be concurrently called from two separate threads?
We could also try to use the icon theme here, for instance the user icon.
Again, you should determine these indices somewhere, not assume a fixed set of indices. They _will_ change once we start constructing the density plots from the quantiles.
Remove / update this log line.
This does not need to be public. Instead, just pass the builder to the private constructor. See what we do in HtmlRenderer.
Nit: add whitespace before "filtering". And seems miss a ' for columnfamily {}?
{}
I think this Map.class.equals(type) is a remnant from a previous implementation and can be removed?
ClientLogger.logAndThrow all exceptions. Please search for all cases because soon Shawn will check in his CheckStyle rule and it will break the build.
The exception happens when getting the filesystem, but the exception message says "Error listing directory", which is confusing as we are not doing file listing with listXYZ methods on fileSystem.
This will get sorted out once we have a proper story for concurrent operations + writer/loader setup. But it feels wrong as-is.
Did you change this to make item(...) happy? I guess it should be the other way around. item(...) should be adjusted to support RexNode argument.
return this?
Why not use null instead of ""?
return null to make this more explicit ?
You only take the first item from the list.. I'd just return it as a mono instead of wrapping it in a flux.
final
perhaps if not has permission?
Consider putting this in a constant
Change this variable declaration to something with meaning in the context. map is unclear here
I just noticed an error in one of my PR, it needs to be if (inexactSeek && selectedDuration / (int) DateUtils.SECOND_IN_MILLIS % 10 == 5) { Otherwise the seek durations get rounded up when opening the settings, even if inexact seek is disabled
+ on newline to pass checkstyle
requireNonNull
Cant we use the same path for all exceptions? We appear to be handling exceptions the same way in either of these catch code paths.
use return ... ? ... : ...?
Do you think it is worth logging if there was an attempt to set the timeout below 2 minutes?
Instead of creating a new instance of this type every time, could you create a single one that you reuse every time? (Same for all other Statistics classes.)
Assert.notNull()
Inside finally?
This should be called after KafkaRecordSupplier.addConsumerPropertiesFromConfig
checking for nullable parent was added specially, cause going into project node simply has no meaning
I think I prefer "Invalid key" as exception message
What will happen if exception is thrown here? Previously when we initialized everything beforehand we had a clear path: node fails to restore memory and shuts down. Now with this change we don't even have a checked exception to catch, it is wrapped into unchecked. Should we call FailureHandler directly in this case if something goes wrong during lazy initialization of cache store?
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
purge takes too long, just delete
Restricted?
Should we add: Objects.requireNonNull(record)?
setSelection takes an ISelection, no need to cast what you get from the viewer. you also do not need a local variable
No break needed here, people still get the option to pay even if nobody paid. I know, it's weird.
Please remove this print. It seems for testing.
@ivandalbosco IMHO it's better to move the call to isPrivate into isException
Ack. I hadn't considered the effect on the generated source.
If position() gives anything other than 0 then this will give a LimitReachedException won't it? Did you not mean capacity - position?
|| not && ? is storestate a requirement to make coalescing work ?
also assert forceWrite called times.
suggestion greeningNodeShouldBecomeLeaderRateLimiter::tryAcquire);
Everything is fine, just add this 36 in constants file. Rest i will run this on studio and if everything works finr, I'll merge
Should be switched -1 != lastIndex
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
This should return a builder with the current options set.
not related to this patch. But I feel CompactionDetails should take in a NavigableSet of Strings (log segment names) instead of just a List(Strings)
Same here re: flatMap
suggestion: how about extracting this into a method as exact code is being invoked twice and probably once VM.customProperties will be modified from String to Map it would be handy there as well ?
![Codacy](<LINK_0> Issue found: [Local variable 'indexStatsMap' could be declared final](<LINK_1>
Why not simply create a local method stackIsEmpty(ProgramState state) doing the null-check? As it's the only place you need it, creating a method in ProgramState seems over-engineering to me.
The indentation is a bit confusing here, it'd be nice if the overrides were shifter to the right past the first column of the new AuthorizationEntity line
Other scans show a tab/table with the reason and details of the message, we could do the same here.
I'd recommend to add process id to the name as well as there might be tasks with same name in different processes but still in the same kjar
Missing final
Add param for userlist so that the params are valid.
return flagdown; ?
whilst you where here changing this line is should be paramaterized logging to avoid string concat if unneeded.
The new channels which should be created have no id-s, so this assertion will prevent inserting new channels. Please see the failing integration tests.
The last parameter can be safely omitted since it's the same as default.
if i get it right: if response is null, we will not retry. i think we should retry even if response is null. btw what caused this in your case? so it would be:  response == null || ....
should have public modifier, for consistency.
put CURRENT_ROLE in RESERVED_WORDS_WARNING as well
nit: can we log the stacktrace here? IMHO it's better for debugging.
java * @param error a potentially empty error message. * @param errors the List of error messages, which @code{error} is appended to, if @code{error} is nonempty.  @damithc errors description stills seems too verbose, ideas for a better one?
There is indeed a behavioral change, the previous code was trying to lookup the files using the resource loader even if the string representation had no scheme, this one does not. The following change fixes the specific build failure. suggestion return uri.getScheme() == null || "file".equalsIgnoreCase(uri.getScheme());  I've verified this change makes for a successful build (with all extensions included, -Prelease):  [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 06:12 min (Wall Clock) [INFO] Finished at: 2020-05-06T15:36:28+02:00 [INFO] ------------------------------------------------------------------------
why are we changing the visibility of these methods?
NO_ID
suggestion if (!(parent instanceof WebApplicationContext)) {
I would actually recommend removing the throws IOException from the interface. Any checked exception can just be dealt with by calling callback.onComplete(null, ex). I think that this helps unify the failure handling paths that the caller needs to deal with.
Unless a variable is defined as volatile or is shared across threads, just setting the variable to null is probably faster than checking before setting.
also may need sync
can we add the exception to the log statement to make it easier to debug the problem?
@fanifieiev RequestOf is a better name than RqOf.
nit: runTime -> runtime
Might be nicer to return the file?
should be just getUser
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
must be package local
And the same here, just one casting on mFile.
Same issue here, double delete user.
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
Start should be GetText
Just a question: will we ever have to switch between HA and non-HA?
This should be Repository.class. The method is supposed to return the list of adapterTypes, i.e., the types to which this adapter can adapt objects to.
be backwards compatible
Thanks for checking, have you considered the trade-off of toggling the timeout to be something very short, like 5ms?
Shouldn't this close the iterator before returning the list?
I can't help but feel that there is a better way to format these than adding if/else statements everywhere and concatenating the string inside those blocks. Personally, I would: * Add a hasMuteReason method to UserData which does getMuteReason().equals(""); * Use a ternary operator when concatenating the strings instead of if/else blocks: java throw new Exception(tl("voiceSilenced") + (sender.hasMuteReason() ? tl("muteReason", sender.getMuteReason())));
You can use StringUtil.notNull() for this as well.
Um... This is getting trickier by the day, what's up?
Slight preference for the lambda variable to be rcc for ReadCountCollection.
hashCode -> System.identityHashCode
can you change this method to call your new method instead? Make sure to pass 5 seconds as the timeout to not change the meaning of this function.
Will it create Audit Log for every 5 minute?.
Why this needs to be hidden?
you can either remove else or add pair of curly brackets
java Map<String, List<FeedbackResponseAttributes>> responsesFromOneGiver = sortedMap.computeIfAbsent(giverEmail, (String key) -> new LinkedHashMap<>());  Prefer high-level breaking :)
combine with assignment this.outputType = requireNonNull(type, "type is required");
Unused code.
Please add final in the method.
exception, so STDERR
port should be fine instead of extraPort.
can builder even be null? if not, it is just getSslBuilder().build(), or in-line it.
Request.State.OPEN
Never use getBytes() without fixing the encoding. This is much slower, and makes the call dependent on the environment. One can pass UTF_8 Charset object into this method to increase the speed of lookup and avoid unneeded charset lookup exceptoins (<LINK_0>
this.streamsAddressSpaceMap = new HashMap<>();
I don't think the process deploy should fail in the case of temp file deletion fail
A little wary of this in production code, why is this necessary and has this pattern been used before?
It would be a bit faster to sample before applying the map.
Is this still needed? We don't add any other elements, so parent.get(anythingElse) should return null anyway.
need to add more information about dimension/index/length
Log message should get cleaned up to remove braces.
CheckReturnValue?
No need for final parameters?
nit: might want to rename it as signalShutdown or something to indicate that this method will be called before shutdown.
Instead of this loop I would use the deferredTags from above: for (Ref tag : deferredTags) { List<Ref> reachableFrom = reachableTags.get(tag.getObjectId()); if (reachableFrom == null && !updated) { // The reachableTag data is stale. Try to update it once. reachableTags = tagCache.update(gitRepo); reachableFrom = reachableTags.get(tag.getObjectId()); } if (reachableFrom == null) { continue; } for (Ref ref : reachableFrom) { This way if a tag was deleted since the cache was built we won't advertise it to the client. It may be slightly faster than your current code, because iterating an ArrayList is faster than a HashMap. It also removes all of the cache eviction code from ReceiveCommits. Performing an update on the cache when a new tag is discovered allows the server to always react to new tags correctly, no matter how they got put into the repository.
I'd do: this.origin = checkNotNull(shift, "shift"); Note I like using static imports for this. We and others use it so much that static imports are clear enough (same goes for things like Assert.assertTrue in tests).
lets avoid constructing strings to reduce GC pressure. Also, this will pollute the logs. What are we trying to get out of these log messages
To be more precise, shouldn't it be "atLeastOneIsQuantity"?
Don't know if FixedChannelPool#close is idempotent or not, but it would be better if we could make closed an AtomicBoolean and call super.close() only if it wasn't called before, via closed.compareAndSet(false, true)?
this.interval = Arrays.copyOf(interval, interval.length); to prevent mutability issues? Not sure if there is any risk (i.e. if internal only, probably not at risk, but may be still a good idea to play defensively here)
don't we want to copy the name from the model to BE?
These methods should have an @NonNull annotation for the return. public @NonNull Builder setDomain(@Domain int domain) {
Can we leave this out, or make it conditional on VDBG?
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
maybe test first char for empty letter as well to reuse s if possible?
this assigment is not needed, since its default value is false
Can be made package local
Could you please add message to the exception. Personally for me it is unclear why it is not supported.
please have intellij auto-indent this.
Any reason why the logic here is different than for userData just above?
move this to the previous line
sorry for saying this only now but endDefaultOps is a pretty bad name (yes, I know it was there before). Should be something like 'updateSnapshotOvf' or 'persistSnapshotConfig' or something (can be a separate patch as far as I'm concerned)
do not assing parameter! nowhere!
Hadn't noticed before now, but would you be willing to update this to pass in the AgentPrincipal versus having the service pull it from the current thread? That is how the other controllers are working, and it means the service doesn't have to be opinionated about how the groups are submitted. Also, the agent principal already contains the username so you could replace the username parameter with it.
Can we change this to for (Map.Entry<String,?> entry : entries.entrySet()), now that you've changed arg to map and improved generics usage of method signature?
minor: I noticed AmbryDataNode.toString() will print out DataNode, so you can remove Node in your log message.
Extract logic to determine index name into its own function since you could also reuse it in the delete action.
Can combine these two catch clauses into one.
use context.getComponentId() to inject into event sender
this class should probably also init current in the constructor, then we can just do if (current == null) { throw new NoSuchElementException() } here
keep requireNonNull
this looks like something that would belong in a finally block
If you don't want to use a bit operation for those cases, at least put an "else".
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
This is a bad reference ownership. I feel this whole class can be part of TableWriter to avoid issues like this
Assuming batching is enabled, shouldn't it take the runningTX from the batchContainer even if there is a transaction defined ?
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
Both of these work the same at the moment, but it would be correct to use the specific manager depending on case. Better make a disputeAgentManager and set to whichever type is being registered, or just move the specific registration code to their switch cases.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Let's rename locationModule to just module. Then we can bind SessionPropertyProvider inside the module. (The name is already bad, as it's no longer for location. I missed that when converting to Drift.)
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
@pynicolas WDYT about extracting this list? At least at this class level to have implementation of the method more concise
This will only notify waiters on "this", not waiters on "logs".
Wondering if we need to clean the folder when the test is done?
Does not handle entry being removed or not modified.
Use CollectionUtils please.
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
can we change it to.. if ("require".equalsIgnoreCase(verifyClient)) { ...
Here and elsewhere, the Fragment probably shouldn't force the host to do things by getting its internals and changing them. The dependency on a toolbar is clear because of the callback pattern but exposing the toolbar directly allows any Fragment to change it. It's ok to defer but consider pushing onSearchOpen() into the host and allow it to hide / show the toolbar.
Another example of setting null before loading...
Can you confirm that those four Concepts are a mix of retired and unretired Objects? You should prove that this setMembers contain the unretired concepts.
One thing I can imagine looking at this PR is that we can make this entirely contained within good try catch blocks like so: java try (SpongeFakePlayer player = setUpPlayer(profile, world, x, y, z null)) { EnumFacing..... // yadda yadda yadda }  In the sense that the SpongeFakePlayer would be AutoCloseable to call tearDownPlayer properly. This can also play into pushing onto the CauseStackManager for the game profile object etc.
need a more readable name
to round half to even we need to add 2 to the scale. Pow2max is 14. According to the check scale = 15 is allowed., this will fail down the line because 15+2 > 14
I get a compile error here: Error:(55, 63) error: cannot find symbol class Date Missing import...
What is a TIN? Maybe say what it is first then put the acronym in parentheses (TIN).
I know this is just a refactor, but please remove the return...super.tearDown() still needs to be called at the end.
Sometimes we call setZoomedList(null). So here your else should call the comsumer with null.
I think it will be better to use Objects.equals from JDK, to reduce external dependencies
What about the following to also prevent whitespace-only strings: suggestion if (((String) item).trim().isEmpty()) {
Should return true if super.hasIncomingChanges (the parent section may contain attribute editors directly, e.g. the bugzilla attribute section has attribute editors and also a subsection called Flags).
Again, the local variable ListData should be renamed to listData as per local variable naming conventions.
Call me a nitpick, but I'm wondering if it might be worth doing this more verbosely, to stay in line with the clarity of code we generally try to achieve by keeping the number of operations per line low?  limited = substring(...); isTruncated = limited.length < str.length; if (isTruncated) {limit = limit + "[...]"};
cols should probably be called colVal. You need the row and col. The entry in the outer loop has the row. The entry in the inner loop has col and value.  java for (Entry<Bytes, Map<Column, Bytes>> entry : ret.entrySet()) { updateColumnsRead(entry.getKey(), entry.getValue().keySet()); for (Entry<Column, Bytes> colVal : entry.getValue().entrySet()) { Bytes row = entry.getKey(); Column col = colVal.getKey(); Bytes val = colVal.getValue(); bet.put(new RowColumn(row, col), val);
Because we're not using the subscribe() functionality, we don't need to configure a consumer group. It will use a null group by default (<LINK_0>
I agree with @markoer Unless Kura is full of assumptions which turn into NPEs every now and then. So checking for NULL doesn't hurt, unless Kura would adopt proper null pointer analysis.
Sorry if I was unclear about this, did not mean to create a utility function to parse the string. It is fine to have the parse method in the individual plugin configs, since you need to give a plugin-specific error message. Just meant you should be passing the Map into the validation method instead of the string.
I think we should store ignoredRegions instead of ignoredLineNumbers. Single lines that need to be ignored can be stored as <LineNum, LineNum>.
How does replacing a NPE with an AssertionException help ? I'd rather try to annotate the method's parameter with @NonNull and watch out for "Null type safety" warnings in Eclipse and fix them.
Hint: if you use "generator=random" with "prop=pageprops" and "ppprop=wikibase_item", then you'll get the wikidata ID right along with the random titles!
I don't think we should throw an exception, let's just return null.
return true might be a bit more straight-forward and you'd save yourself one variable
No null check for zone?
try-with-resources; you could move the logging into the body which is a slightly different ordering, or before as it does not need the resources.
Maybe we should derive this from Prefs.getMediaWikiBaseUri() or require the client to pass in a default protocol. I think I prefer the latter to avoid complicating this nice and simple model type.
Try remove package
Maybe catch here more specific exception?
the path always starts with '/'. If it doesn't start with '/', then it isn't the path. (You're probably accidentally using '/' as a separator between the authority and the path. Actually the '/' is a part of the path.)
Since getParent() is defined on IASTNode, there is no need to actually cast to IASTDeclarationStatement on the line above: we can just no declaration.getParent().getParent() here.
Can you please follow coding guidelines and put the code in curly braces?
You don't have defined secondary attributes, do you? -> <LINK_0>
Does the condition above not guarantee that this is always true if we reach this statement?
use return ... ? ... : ...?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
This method should be for both ContentResolver and ContentProvider, as other methods in this class.
getting the same metrics on both cases
Directly call dSemanticDiagram.getDiagramElements() or org.eclipse.sirius.diagram.business.api.query.DDiagramQuery.getAllDiagramElements()
file might be a directory - message will then be misleading
So if there are 3 parameters, we include 3 copies of all parameters?
Grate! I think we don't need an if (file != null) any more after this.
IdentificationBarcode is not shown when present. List as unknown/"no barcode" when missing
Useless extra line
The argument wrapping is wrong. The style is to wrap either all arguments or none, so all arguments to format() should be wrapped (the existing code is wrong but we should fix it now since we are changing it)
Wondering if new interactive should be used in this method.
You don't need the new String[]. Just do Arrays.asList("pong", "pong-too").
Have you tested this? I wonder whether this index is more useful than one on queryId and fragmentId. I tried the indexes and at least postgres doesn't think there is a difference.  GroupAggregate (cost=0.00..10479.85 rows=315 width=24) (actual time=0.019..0.019 rows=0 loops=1) -> Index Scan using "public:logs__myria_indexes:Sending_0_1_4" on "public:logs:Sending" (cost=0.00..10417.18 rows=5952 width=24) (actual time=0.018..0.018 rows=0 loops=1) Index Cond: ("queryId" = 4) Total runtime: 0.055 ms   GroupAggregate (cost=0.00..10479.85 rows=315 width=24) -> Index Scan using "public:logs:Sending_queryId_fragmentId_destWorkerId_idx" on "public:logs:Sending" (cost=0.00..10417.18 rows=5952 width=24) Index Cond: ("queryId" = 4)   HashAggregate (cost=10476.70..10479.85 rows=315 width=24) (actual time=0.022..0.022 rows=0 loops=1) -> Index Scan using "public:logs:Sending_queryId_fragmentId_idx" on "public:logs:Sending" (cost=0.00..10417.18 rows=5952 width=24) (actual time=0.021..0.021 rows=0 loops=1) Index Cond: ("queryId" = 4) Total runtime: 0.069 ms
This needs to be commit.copy(). AnyObjectId can be a MutableObjectId, which can change after-the-fact. copy() returns you an ObjectId which cannot be mutated. If the input was already an immutable ObjectId, copy() just returns the same object.
This appears to me to be a redundant check as it is already done in updateActionAvailability so the action would be disabled right
I actually see this call blocking a bit now and then. It might be worth caching the result
I don't think args can ever be null, can it?
Is start check needed? Could it be problematic (somehow delay/miss the start when it should be immediate)?
So, should be SftpServerRule? Isn't it?
I'd prefer to remove the field itself. Feels a bit unclean to have a field which is only valid during the execute method. It should be a local variable in execute and passed as an argument to getTagTarget. What do you think?
I'e tried with this url and it didn't worked: <LINK_3> this url was OK: <LINK_0> but it required 5 and 4 http requests to get the final answer each time. I think we should start search from the begin of the path and not from the end to avoid spamming on server and delays on client side. I also would propose that we should recognize http*://git.eclipse.org/* urls and only try <LINK_2> in this case: Eclipse web master and also end users will be really happy to need only one single shot to get the result. Additionally as the example above shows the automatic Gerrit config for git.eclipse.org/gitroot/ URL's doesn't work at all.
this variable name is misleading, it contains not only the commandData but also Ne field (see also other ApduTest classes)
This block has shown up in another PR, which is a sign that we have dependent work, and is something we should strive to avoid in most cases. Additionally, database operations are slow, and lookups should be avoided in loops if at all possible. Change this to a bulk lookup.
I think you may have as well nested tuples: python try: ... except (A, (B, C)): ...  You may use TreeUtils.flattenTuples() to get all elements.
Please don't do cleanups in the same commit as bugfixes/features/improvements
For this, and all other xxxAttributes classes, are there well defined map key name constants we could use? If not, then I would be in favor of adding them as public constants to the xxxAttribute classes, to avoid raw string constant usage in consumer code.
Use a constant.
If the store is already started, I think we should return true. Same for stop (return true if the store is already stopped and don't try to stop again)
@xstefank I am not sure if we have localization on LRA yet but if we do a follow up tasks could be to localize this. Not required in this PR though /cc @mmusgrov
if super() is already storing the viewer, do you need to store your own copy?
Prefer not to have a null environment from start.
rename to p, prop, currProperty
That needs to use maskedSelectionFlags too.
Since we're using this header across two classes we should probably make it into a constant. Perhaps make a class of header constants similar to FcrepoHeaders? Also, we should likely namespace the property to something like "CdrBinaryMimeType" (CdrBinaryPath, CdrBinaryChecksum) to avoid possible conflicts. Doing so would also make it easier to clean out all of the headers we add later if needed.
I personally prefer the "fast return" style, so that "if" branches which don't have to do match are placed first and ends with a return. This avoids too "deep" nesting.
The above line will set the default_job_timeout to null if the user has not specified it in the request body. IMO, Server should throw an error if the default_job_timeout field is not specified in the request body. Use jsonReader.getString instead?
replace with ReferenceCountUtil.release(msg)
instead of a Random increment, why not increment by a fixed number everytime - say 100 or 110? This applies to all the other modified test cases as well.
If I understand this "fix" properly, we were basically creating a new appender for each test, which you're now auto-closing. Plus, you're creating a new logger for each test. Would it be possible to just have LogFixture take in a level, and auto-generate the logger name, so it does not need to be passed in, even if just to avoid copy-paste errors?
return new StringBuilder().append()....toString();
This cyclic reference is redundant and confusing IMO. Instead, we could have fields taskName, AbstractInvokable and flattenedChannelIndex info in some form. (not a very important thing, feel free to ignore and resolve)
Shouldn't this readInto() get the ClosedChannelException (if the future it returns is checked after the operation completes)? If so, could we check for that at the end as well?
use return ... ? ... : ...?
almost same for all the different events, consider refactoring? #Pending
Should be a SamzaException with a message, not NPE.
LOG.debug("Closed {}", region.getRegionInfo().getRegionNameAsString());
There should not be a need to set this to public. Perhaps private would be better.
Don't inflate it. Use the same paradigm as ListViewInitializer where the layout must include the View for the empty view.
result.add(queue.remove())
Apache license header is absent.
@Override this annotations is not needed in test inputs
you moved and changed these methods in the same commit, can you please separate such changes to separate commits. It is much easier to follow that way.
This is similar to Compressor
StorageException is a runtime exception, no need to catch and rethrow it (several occurrences).
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
this assigment is not needed, since its default value is false
damn. Common.getProjectCache().get(change.getDest().getParentKey()) is faster here (avoids a database query), but its not promised if the client were offline. maybe we should just promise it will be there if we ever get offline support implemented.
This is wrong. getUuid should return the uuid in the class. Since this one has none, you can just return the string version of its id
You shouldn't need to call printStackTrace, the log.error should print the stack trace
Could you extract this actions in separate method?
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
formatting
The removed bit is important! It needs to know if the dropdown is the focusedWidget (in other words, if it is the current selection by tabbing) in order to highlight the widget with yellow - that's what returning ACTIVE_MODE does. You can probably find another workaround to avoid using TabbingManager, but you need some way to tell if it's been tabbed to
Simple test is also possible to verify result stat. See #971.
We may want to move this test into a function so we can call like getApplicableAnnotationProcessors() to make the intention clearer and make this more readable.
maybe we can delete this line of this PR
if there is a style element in the list: this is not a DRepresentationElement, nor a DRepresentation but nor a semantic element...
Please change aLong variable name to tick as it was previously.
I think it would be better to use schemaName.tableName.familyName.columnName kind of syntax. Basically, what ever part is most specific, you can use as the parameter name. For example, if schemaName="foo", tableName="bar", and the others are empty or null, then it would be tableName=foo.bar. If you could use the SchemaUtil functions to get the display name, that would be good. Maybe have another one for getColumnDisplayName
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
please don't put any synchronous call in asynchronous method.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Close! There's still just an extra line here.
What about allAll, clear(), removeAll()? What about the iterators? There are all kinds of things that can bring this out of sync. Are we really gaining anything at this point by using a SortedSet vs a List?
This seems inconsistent. the methods are already configured with a fallback that looks for the Could not find key string. Why should that be treated in the fallback and this message in the error handler? And... are there really two different messages to describe the same error?
Why change to create?
can't conn be null at that point?
I think you want logical AND, so double ampersands. Can we use !license.isEmpty && !licenseShortName.isEmpty && !licenseUrl.isEmpty() instead?
IOException is never thrown
state is started but not stopped. Nothing can stop it if lookupName is already present
what about multiple storage domains?
You could combine these if-statements due to short-circuit evaluation. However, I wonder if perhaps getIdleChannel() should do this check internally and loop over all "idle" channels and return the first active or null?
rename - a bit more specific :)
This drops all rs and collapses all ns to  .
Some long lines with these throws clauses, here and below
Missing final
This is wrong. We still need to use the folder name for equality checks.
can we make this more readable something like  Total running and waiting tasks [], Maximum compaction queue capacity [] . Thanks
Where do we handle the different datastream with same source situation?
Maybe TUESDAY@09:00 ? It probably should be --W--2T09:00 but that is unpleasant. (These classes avoid spaces in the format).
Is this the recommended way in Karaf - do they not have an equivalent of JCA I wonder? I guess for the dummyxaresource it has to be this way but can we try a H2 datasource somehow?
+/- 1 confusion: suggestion return new Diamond3iIterable.Builder(origin, radius).start(radius);
We are usually using the FunctionalTestUtils class for awaits with timeout
this can be replaced with user.asJson()
Please move KieBaseConfiguration and KieSessionConfiguration before where KieBase and KieSession is created. The configurations are not used until KieBase and KieSession is created so it doesn't make sense to have it here. Also it improves readability to have code that is used at only one place to be near that place, because when reading the code you don't need to search for it.
not sure how this line was added here - this initialization is done in line 67 and needs to be removed.
Since the event is really a resource rather than a model, it would make sense to me for this to return the event resource instead. You can get back to the model in other places if needed by calling .getModel() on the resource.
please extract as constant
Same thing: I would prefer to move short if branches to the top and avoid else branches at the end of the code block
You can use getFieldValue(Long.class, getLayout().fieldLen()) here and then null check to be safer.
I think I prefer "Invalid key" as exception message
might want to change this to checkButton.setText(Strings.isValid(checkBoxMessage) ? checkBoxMessage : "<NONE>");
Duped code. Any way of sharing ?
Still an NPE if there's no Folder plugin installed. The acceptance tests should give you the same result.
extra space
We need to test ALL available DbColumnTypes.
To always be safe please use context.getApplicationContext()
This might throw exception
The arguments bundle is initialized to a variable previously. If you remove the generic exception catching block, and take it out of the scope of the if condition, then it can be reused.
The actual fix is this alone right?
Shouldn't we fail here?
This method can be implemented as return a - b;
Is it only available for enterprise users?
There are a few other mocks higher up in this method. This can be moved to be with them.
can you use some more realistic values for observations. The key is the concept name, am I right ? So please just use something like 'testConceptName'
Add a severe logging message here describing the issue to server owners (and maybe tell them they will need to downgrade for now).
Style issue: @Override shuld be on line above the method declaration
It seems that newSftpFile method also has retry. Do you have the special reason why a retry is nested?
This does not look like it is asserting the same thing about timeouts any more..
Empty list makes more sense.
sed 's/value == STRICT.value ? true : false/value == STRICT.value/' (Redundant inline if)
should repo be set here to null as well?
are you sure we need to use OSString ?
same here, don't set fields, just call save here
If this sample is just displaying data from a URL then we don't need read_external_storage permissions
maybe we should add a log here so we know that nothing has been updated to the corfuStore and not that it is complete necessarily.
why not: boolean ret = false; try( Connection connection = ds.getConnection(); PreparedStatement prepareStatement = connection.prepareStatement(selectQuery); ) { prepareStatement.setString(1, userName); prepareStatement.setString(2, domain); try (resultSet = prepareStatement.executeQuery()) { if (resultSet.next()) { ret = true; } } } return ret; no problem to continue check... we do need to understand if we can provide database access detach from the engine... but in this case it is not that important as we will not use this vdc_options in future anyway. you have the configuration information within environment ENGINE_DEFAULTS, ENGINE_VARS. maybe I will move LocalConfig to uutils.
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "id". [![rule](<LINK_0>](<LINK_2>
Maybe we can refactor this since it is hardly readable anymore. Should be extracted into methods. Too many nesting
do you want to create a new list if its null?
Replace passenger != this with !Objects.equals(passenger, this)
It might be nice to also have a test with a user in the administrator group, so we can verify that it gets the ADMINISTRATE_SERVER permission.
Why is this necessary?
I think I prefer "Invalid key" as exception message
Fixed in next patch set: - Made private. - Added dummy serialVersionUID to prevent Eclipse warning.
Add a message to checkState so that it's easier to debug if we ever hit it.
Here is also that unusual check.
This is just a nitpicky little detail, but it looks a bit strange to updateDiffStateAdapter just for the first diff. We might want to introduce the method updateDiffStateAdapter(List<Diff>) in the super class, to avoid that. Eventually we'll update the adapter on the comparison anyway, but this might change in the future and then we'd had more control if we'd have dedicated methods for one diff, several diffs, and the comparison.
Same. Should this be HTTP_METADATA_WRITE_OPEN?
The hook can't be null because the constructor ensured we assigned a non-null value to it. Should we be doing the hook stat test on each invocation? Or should we do it only once when the ChangeHookRunner is initially constructed? If we do it once during construction we avoid stat calls on each change, but we can't enable or disable the hook at runtime without restarting the server.
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
merge with the previous line
I personally prefer to check once if(!(obj instanceof Attribute)) instead of two checks for null and class.
Ignore?
In general I wonder why one should instantiate an (immutable) null Password. I mean passing a null parameter to the constructor. Should this be considered a bug instead and hence throw a runtime exception? Should we update the copyright date to 2017?
As before, this is shared code with File..CompareEditorInput. Shared superclass?
Don't think we need additional DB call hasBeenEmittedBefore(event) when doNotForceEmission=false. suggestion public void emitAndPersistEventForRefundHistoryEntry(RefundHistory refundHistory) { Class refundEventClass = RefundStateEventMap.calculateRefundEventClass(refundHistory.getUserExternalId(), refundHistory.getStatus()); Event event = EventFactory.createRefundEvent(refundHistory, refundEventClass); if(!doNotForceEmission){ emitRefundEvent(refundHistory, refundEventClass, event); } else{ boolean emittedBefore = emittedEventDao.hasBeenEmittedBefore(event); if(emittedBefore) logger.info("Refund history event emitted before [refundExternalId={}] [refundHistoryId={}]", refundHistory.getExternalId(), refundHistory.getId()); else { emitRefundEvent(refundHistory, refundEventClass, event); } } } private void emitRefundEvent(RefundHistory refundHistory, Class refundEventClass, Event event) { RefundStateTransition stateTransition = new RefundStateTransition( refundHistory.getExternalId(), refundHistory.getStatus(), refundEventClass); logger.info("Processing new refund history event: [refundExternalId={}] [refundHistoryId={}]", refundHistory.getExternalId(), refundHistory.getId()); stateTransitionQueue.offer(stateTransition); persistEventEmittedRecord(event); }
I don't think args can ever be null, can it?
We should warn that the attribute has been ignored via ignoreAttribute.
do we need case insensitive checks?
This for loop duplicates the one above. I'm almost certain you don't need to convert from a TreeMap to a HashMap. Even though the Map implementations are different, equals() will return true if they have the same contents.
Configuration configuration = new Configuration(); options.forEach(configuration::setString)  We can use Configuration to get option.
This is nice. How do this fail in the case of mis-configuration?
I think you can use freezing instead of pausing to have the player automatically save the playing state.
Same issue here, double delete user.
notification? i think that makes it more clear what is happening than notice
NGuid.Empty.equals(task.getVdsmTaskId()) could be a better practice Also I think a log here could be helpful
Why overriding it here? If you don't really want to add, don't initialize the variable when declaring it and use copyOf here.
IMHO it does not need to be public
I think I would prefer having a method setParametersDeclaredType(ParameterList parameterList) instead of having separate methods to clear and add
Can't this NPE as they're Booleans (i.e. objects not primitives)
Don't leave System.out calls in the code after you're done. Other use LOG.debug' or delete them.
requireNonNull
Shouldn't this be wrapped in a try... finally block?
Could the cipher suite be made configurable?
This will fail if the testCreateRole test fails. Better leave the assertions for the tests, not the tearDown methods.
Can't the default android.R.transition.fade be used? It's used in the reenter transition (line bellow), so it could be inflated once, and be used in these 2 places.
Another question, this is something I am not sure. No true or false passed in here as 3rd parameter in line 962. THe function signature has not default value. What value would be then for this invocation of fireDataChangeEvents?
Remove
Maybe could be stated in the changeToken parameter description that it forces the session to be saved, even if the save parameter was set to false?
I like the builder approach because .build() can throw if modifiers has inappropriate modifiers like private.
public ByteBuffer reset(ByteBuffer input)?
Can get rid of this kind of thing and error prone null checks
Would it be better to set to 2, to test the counting?
Even here, is there a possibility of an exception?
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
You'll want to use .setText("and 1 damage to each creature that player controls") here.
setErrorMessage
It is not, this change should be reverted.
@zjffdu - I think we need a fast way to abstract out the different launchers, instead of bringing everything in here (plus artifacts like kubernetes-client). Do you have any thought on that?
This method doesn't need to be public.
while at this, could you simplify this statement to throttleDown == rateInSecs > desiredRatePerSec ? (IntelliJ suggests this).
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
You may want to expose a mechanism for the client to cancel the AsyncTask or at least suppress the dialog show behavior. It looks like the easy way here would be just to expose a setter on Callback and do nothing if it's null when the asynchronous operation completes.
Think it might be worth doing this in scanHttpRequestSend as well? In case Jso is being POSTed, etc. The method could be changed from using the msg to accepting the body.
Could you please rename this variable to children. The current name is unexact in this context and can accidently mistaken for this.filteredChildern.
I think the Java 8 way is as below: List<Integer> list = Arrays.stream(items).map(item -> (Integer)item).collect(Collectors.toList());
getSearchTransformedNetwork should be called as a asycn method (@async annotation). turning the resulting network into json should be done in the method that checks for the results.
Arrays.asList?
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
This is invalid output.
you can also write this as return sql.replaceAll(TRIM_SQL_PATTERN_STRING, " ");
This method is bad! It should mark the thread as interrupted again, before propagating the exception (but not this pull request's fault). We also have a RuntimeInterruptedException that Peter added: creating one of those will automatically set the the current thread as interrupted.
Can be made package local
You could define the array with the ?: check on a separate line, makes it clearer. Creating a String + a new array *every* time this method is called seems heavy. How about saving the String in a lazy-loaded class field?
I would add an assertion to the message too.
0 is a legitimate option value for min. selectable choices. Why not -1?
For the sake of cleanness of the contract and maintainability, I vote for making the new unloadModuleLocal() to accept the module name only rather than name and module. Inside the proper unloadModuleLocal() we lookup in the the moduleMap anyway.
Style issue: @Override shuld be on line above the method declaration
Fix cyclomatic complexity sonar issue
please replace this line with: return StringUtils.defaultString(result); or the two lines with: return StringUtils.defaultString(getMessageOrNull(logType));
A bit a matter of taste but I'd remove the spaces here around the =, it would look more consistent with the "Contents" column, i.e. field=123, foo=345
mb it would be better  dtoFactory.createDto(LocationDto.class); .withLineNumber(b.getLineNumber() + 1); .withResourcePath(b.getPath()); .withResourceProjectPath(b.getFile().getProject().getProjectConfig().getPath());
This "synchronized" seems not needed as TLSNIOWriteStream.shutdown() already protects it.
worth adding the host values list
IMHO it does not need to be public
Maybe its just me, but this calculation looks wrong, since we are assign a = b, then b = a % b will always be 0, since a = b. Shouldn't it be: long c = b; b = a % b; a = c;
The call to super() is unnecessary.
... yes it does ...
given/ execute/ assert
Should be Refreshing_X and use NLS.bind()
throws Exception is good enough in unit tests. No need to be more exact.
Add newline before return.
The Keys in the Attributes Map ar not Strings but Attirbutes#Names, so this should probably be containsKey(new Attributes.Name("Multi-Release"))
Maybe remove the first :?
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
Add a single quote around the metadataAlias?
This should be using KeyUtil.encode().
return (source != null && source.isValid()) ? source : null;
this.interval = Arrays.copyOf(interval, interval.length); to prevent mutability issues? Not sure if there is any risk (i.e. if internal only, probably not at risk, but may be still a good idea to play defensively here)
Why make these public visibility? I don't think the requests need their own subpackage so you can move them into the main package and reduce visibility here.
Add final keyword.
I'd rather use a better name for "ds", everywhere (dataSet).
no need to set it twice. it can be just set in the last line of the method.
What's the intent behind this? Generally we want to allow this to be changed at any point. Is there something in particular that requires this with the update?
can be !isDisabled()
This will be the name of the first datastream but can be misleading for debugging if that datastream is deleted but is shared with Datastreams. What do you think about a topicName based on source?
@tarun0 why don't you use <LINK_0>
influencesString should be influenceStrings but lets rename to influenceJsons
Same here messager should never be null. Otherwise we can't report.
Interface appended to variable name.
in the case where the Bytes object is immutable, it would be nice to store this after computing. This way it does not need to constantly recompute for case when Bytes are used in hashset.
This should use Player::hasOpponent since we want it to be compatible with the 2HG mode that we'll never get around to implementing.
@kirankumarkolli - you need to update this file with the proper spotbug issue which is failing here : <LINK_0>
I never did like these local caches in the models that Carlos introduced. :/ Besides, creating one of those is dirt cheap. I have no idea why he wanted a cache.
IMHO it does not need to be public
are we using ancestors besides the parent?
pls. consider to use {...}.
This check would need to be synchronized too, depending on underlying implementation.
Make it immutable. new HashMap<>(properties). Otherwise clients can still be able to mutate the state of WireRecord using the provided map reference.
why is that needed?
Why not in-line 'enc'?
It seems like this path will definitely get hit if someone is using this functionality. So there is no point in adding soft assert here and we will likely need to disable this functionality in Android 11 if there is no other alternate provided in Android 11 for file searching.
Shouldn't this close the iterator before returning the list?
good practice: usually actions go before WS as they are injected into it and so they are grouped together
The problem with this is that the iterator gets consumed once and you then benchmark how fast an empty iterator comes to completion through the operator.
Can't you do this with a lambda?
If you're going to mock the QoS entity, then please mock it properly - generate an ID for it and only return it from the DAO when that ID is used.
return (source != null && source.isValid()) ? source : null;
1. Removed @throws IllegalArgumentException when alias is null. as it is not required to declare throwing a runtime exception. We haven't declared this in other places e.g. Database class as well. 2. Remove an extra empty line before if(alias == null) {. 3. Add a space between if and (alias. Should be if (alias == null). 4. Add . (full stop) at the end of "alias is null" -> alias is null. 5. Do the same for the other methods.
Should be a SamzaException with a message, not NPE.
transoromation is always processing (Optional) present element but the last element. IMO it would be nice easier if Transformation would have different method to read not consumed output.
please move the setUser and setHost to connect (if _vds != null)
perhaps if not has permission?
2 corrections: 1. Static imports 2. Have this as a constant, since it won't change its value during the entire execution (reading purposes, but more importantly avoid going to check system property per each time the code is executed)
We should save even more instances by directly prepending to Lists instead of appending to Queues:  java List<T> left = empty(), right = empty(); for (T t : this) { if (predicate.test(t)) { left = left.prepend(t); } else { right = right.prepend(t); } } return Tuple.of(left.reverse(), right.reverse());
why are we catching the InterruptedException here and throwing it at the end ?
We should use a URL builder here to handle URL encoding instead of just joining the strings.
Unrelated to this patch. Again this is a good change, but it adds diff noise.
Are these extra checks necessary since they all extend RealElement?
maybe get enclosing element before the loop ? or this operation is not very expensive ? Something like:  TypeElement methodEnclosingType = getEnclosingTypeElement( currentMethod ); for (...){ .... if ( elementUtils.overrides( currentMethod, (ExecutableElement) element, methodEnclosingType ) ) {
Looking at the docs for Future, I think this should throw TimeoutException if !done.
suggestion try (InputStream is = dockerfilePath.read(); BufferedReader r = new BufferedReader(new InputStreamReader(is, "ISO-8859-1"))) {
for comparison with an enum it's better to use ==.
And a toUpperCase() call without a given Locale fails the Turkey test.
Shouldn't be suggestion req.addCookie(cookie);  ?
error : Format '%s' is not supported. corrective action : Supported formats are: %s.
use a StringBuilder instead
I would change is back to 50 for consistency with CDT.
Use Constant enum instead.
This can fail with null pointer exception, hide errors reading the response, and log 2 errors for same issue (e..g first print stack trace when reading fails, then return empty string and fail when parsing the json). Lets this code raise the IOException and handle it in the caller - we already wrap all the calls in try/catch block.
Not needed this one either.
Must be object.change(db). The Change can be lazily loaded, and we may have the PatchSet but not the Change yet. So you need to pass the db through just in case, so the ChangeData can load the Change on demand if necessary.
final
Should an enum work better here, so users have a constrained set of options to use?
It looks like a time and memory consuming operation. Can we cache the result and re-used in case of re-calling?
Either with <>, or completely without.
![MAJOR](<LINK_0> 'Severity: MAJOR') Use "java.nio.Files#delete" here for better messages on error conditions. [![rule](<LINK_3>](<LINK_4> ![MINOR](<LINK_1> 'Severity: MINOR') Do something with the "boolean" value returned by "delete". [![rule](<LINK_3>](<LINK_2>
From <LINK_0> public String flushAll() Delete all the keys of all the existing databases, not just the currently selected one. This command never fails. Specified by: flushAll in interface BasicCommands Returns: Status code reply
You forgot to add the address to the toString() as you did in the patch on the master branch
And again, why 1? Doesn't work with multiple partitions?
this is not a good way to fix it. convertField already has a switch statement on the field type, you shouldn't duplicate that logic here, and shouldn't be creating a new transformer for each recursive call. Instead, just remove the outputAvroSchema variable completely. The avro schema should always be calculated from the cdap schema.
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Same as consumer. If parameters are null shall we throw exceptions so that deployment fails with required message?
Also test these?  a.. ..a a..b .a . ..
make "_" a constant
please avoid using printStackTrace(). Let's log the error stack trace with a message using log.error()
The User.setPassword method is already hashing the password, so here you're hashing it first before putting it as an argument, which means it will re-hash the hashed password. If you check the User class, both setPassword and setHashedPassword are setting the same field (one by hashing it first, the other without), so there is no need to call both setters. I'd remove the setPassword here, and leave the next call as is (setHashedPassword)
Style-nit: extra curly braces
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
- what about the table? - move .build() to separate line
Shouldn't this be ts - floorTS?
should this be in some MathUtils class?
We should remove previous call to setOnPageChangeListener a few lines above as it will be re-set here as well.
can use <> for the constructor
nit, do the same for the addResourceWithWeight method?
Should add the rule to config file?
I think this should be left out of this PR in favor of making the TwitterErrorHandler respect the Twitter4j RateLimitStatus reset time. I'm volunteering to do that, so unless STREAMS-311 can't be fixed without it I'd say to put this back to 10.
For now we should keep this method package visible only
You almost got me right now. :-) There is no need to test the injection point. You only inject instances of this interceptor to the injection points where it should do its work anyway. Because of that it is unnecessary to provide and check the injection point. Just delete this method and the field and constructor parameter and change java private void invoke(IMethodInvocation invocation) throws Throwable {  to java @Override public void intercept(IMethodInvocation invocation) throws Throwable {  and you should be fine. :-)
Why this needs to be hidden?
The indentation level shouldn't be changed.
use return ... ? ... : ...?
Would suggest to make it private.
I don't see why we need these sorts of constructors... We've never needed them before, and there's nothing special about the useLayerNormalization arg (it's just another boolean)... unless I'm missing something?
Throwables.propagate() should not be used in new code.
No security for getCapabilities?
Should this class be parameterized to run all tests both with and without HA?
campain in tostring?
Why return a value if you don't use it when you call the method?
This call should not be done before we set the initial datya received. Also, this call should be done from the FilesTabView class
Does this mean that statement.isClosed() is useless?
![MINOR](<LINK_2> 'Severity: MINOR') Catch a list of specific exception subtypes instead. [![rule](<LINK_1>](<LINK_0>
toOSString() gets platform dependent path - Consider the case where you are looking at shared indexing from different platforms win/lin/mac - wouldn't we get a different URL if it is platform dependent - shouldn't this be toPortableString() ?
Feel free to skip this feedback but I recommend holding a reference to the client so a later patch can do request management on Activity destruction
Minor: Or code conventions typically favor this style:  try { ... } catch (Throwable t) { ... }
This test is very similar to JmsConsumingTest.shouldPublishAndConsumeJmsMessageWithTraceHeaders. If possible it would be nice to make both test cases more concise to make duplication less obvious. If not then maybe we should share some code between these tests...
Maybe also add a check for circular dependencies (i.e. A -> B -> A)? This should be relatively easy to implement with a Stack
mb it would be better  dtoFactory.createDto(LocationDto.class); .withLineNumber(b.getLineNumber() + 1); .withResourcePath(b.getPath()); .withResourceProjectPath(b.getFile().getProject().getProjectConfig().getPath());
Where does the 5 come from? I feel like we should just throw an exception here.
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
I think an additional MongoDbFactory ctor would be useful too.
should be ...object instances can be deleted"
Since it is used multiple times, make this a separate function returning List<SampleRowKeysResponse>? - try (BigtableSession session = new BigtableSession(bigtableOptions)) { - BigtableClusterName clusterName = bigtableOptions.getClusterName(); - BigtableTableName tableName = clusterName.toTableName(configuration.getTableId()); - SampleRowKeysRequest.Builder request = SampleRowKeysRequest.newBuilder(); - request.setTableName(tableName.toString()); - List<SampleRowKeysResponse> sampleRowKeys = - session.getDataClient().sampleRowKeys(request.build());
It would be nice to provide some feedback if this check fails. Like "The file BLABLA doesn't exist in the directory you provided. Please try again..."
I tested, and this calls setData() with null, and does not really do anything better than doing nothing (the table is already empty).
Just curious...why the id + "" here?
Since keyFile,passwd & alias are used for both methods, I think it will be nice to put them as private (final) members of the class
This else {...} block can now become simply: throw getJobExecutionException(serializedThrowable, classLoader); right? We do not need to wrap the original exception anymore.
Should this be logged at more prominent level ?
The synchronized block should include stopThread = true and close.notify() before thread.interrupt.
Maybe instead of loading from the database using duplicated code, we do byId.get(pn.getId()) ? Its a recursive load through the byId cache, but then we share the same ProjectState in memory and don't duplicate it. And we're not duplicating the logic of how to construct a ProjectState from the database.
Please,a dd these lines and add NON-NLS tag TransactionalEditingDomain domain = ServiceUtilsForEObject.getInstance().getTransactionalEditingDomain(getRootOfTheModel()); domain.getCommandStack().undo(); modelTables = getTables(); Assert.assertEquals("The undo after the deletion of a table has no effect", amountBeforeDeletion, modelTables.size()); domain.getCommandStack().redo(); modelTables = getTables(); Assert.assertEquals("The redo after the deletion of a table has no effect", amountBeforeDeletion, modelTables.size()); domain.getCommandStack().undo(); modelTables = getTables(); Assert.assertEquals("The undo after the deletion of a table has no effect", amountBeforeDeletion, modelTables.size()); domain.getCommandStack().redo(); modelTables = getTables(); Assert.assertEquals("The redo after the deletion of a table has no effect", amountBeforeDeletion, modelTables.size());
Alex will say to use a linkedList instead if you do not need to access the items by index, though initializing with an initial capacity a bit higher than the number of items it will contain may make ArrayList more efficient. But Sets is also a good option, since you do not care about the order and it will avoid duplicates. But I would not block a patch for such a reason. Others may though... ;-)
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
I fail to see where the new organization parameter is actually used in this handle method. Currently, it's using the organization of the specified new default QP. It works, but I think it wasn't the point of adding a new organization parameter. The algorithm should have been: 1. retrieve key of organization param or default organization key 2. ensure user has permission on specified organization 3. retrieve specified QP 4. ensure QP belongs to specified organization 5. if specified QP is not already the default QP, unmake the current default and make the specified QP the default one If we're not going with this algorithm, then the "organization" parameter could just be dropped
This logic is perfect, but for a while I got confused with connection being Connection and this.connection being AtomicReference. Can we rename connection to connectionRef to indicate AtomicReference?
Should be a SamzaException with a message, not NPE.
You could print a result for println here and a different one for print later, so the output would be: println: X ms print: Y ms
May this dialog also limit resources with *.json as the other one that browses the workspace?
break up long line
Can you do this without running ConnectStorageServer first?
You added a parameter but this command is also used from other places, so this will cause compilation failures.
So hideEmptyPane = true and this is a modified file, I am unable to hide the left side?
why not null as value?
suggestion return getClass().getSimpleName() + '@' + this.id + '#' + this.version + ' ' + toJson();  IntelliJ thinks this is better
You can check if list of results is empty and our property ('numberOfPrograms') returns 0.
shouldn't this be: return setAddress(null); ????
I don't feel it right that in a class delivered by our library we have a method not signalled with @Nullable that returns a null. Of course we don't have anything meaningful to return because it's a fake client... But checking the code I see that in one of the methods there is one SphereApiConfig with fake data. Maybe we can go on that line and provide a dummy config with a project key and API URL that leaves no doubt this is a fake config. Maybe @katmatt has a better idea?
I think this needs to take into account that if the year is empty for both, we don't want to match them.
Is it possible that it is null here?
Resource leak.
We should throw exception here? Or it throws exception we need to handle?
No need to define it here - it is runtime exception.
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
It would be good to explain here, e.g.: // Friend results are all included. Own results are only included if some friend has a goal in the same category.
Or, assertThat(category.getAttributeList(), hasItem(Core.TITLE)) (this will print a more useful message when the test fails).
System.arraycopy(this.bytes, curPosition, **dest,** off + bytesRead, toCopy)
do we care to check the length to be positive here?
I think this needs to be payload = super.adjustPayload, otherwise it will be a stackoverflow error.
the sql statments should be in a db transaction
Is it correct that this class uses CryptoMigrationUtil instead of the StudioEncryption class?
it seems that the first part of if statement is only good for improving performance, but this isn't a performance bottleneck. is it needed for anything else?
Where all is the outer setAddress method used? The AMQP Properties section is part of the immutable bare message so we shouldn't in general be setting the 'to' address in it or creating the section if they weren't present. Exception might be made during cases like protocol conversion, but it seems like it should be explicit rather than a side effect that might see unintended use as here.
refactor with a handleException(Exception e) method and maybe some optional parameters.
Is there a more descriptive name than element? if so lets use it if not no worries
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
String.format
Should use parameterized logging instead of string concatenation.
Duplicate code
do not change this test, it should still check if proper encounter is returned from createEncounter service
nit: you can merge both lines above as checkNotNull will return the given argument
final
Missing @Override annotations?
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
missing this.
This looks like it's impossible. Given L68, sampleRateIndex can only be 0,1,2 or 3 here, I think? If you agree, please delete this block (and the TAG constant near the top).
I never did like these local caches in the models that Carlos introduced. :/ Besides, creating one of those is dirt cheap. I have no idea why he wanted a cache.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Just to make sure I understand it correctly We only optimizing simple projections/filters of a bucketed table into the other bucketed table? It doesn't save any memory, but potentially saves CPU cycles on doing shuffle.
Again, multiple exception types that are handled identically can be grouped in a single catch block.
not null check would be nice here
I think that may have been an oversight in longSum. Try a query that results in +Infinity at the historical level and you will see why it is needed to deserialize at the broker level
why is this condition required?
assertTrue is redundant here.
Since InvalidChangeOperationException cannot occur anymore, I think it would be nice to remove it from the method signature here. If we do this, we can also remove InvalidChangeOperationException from the AbandonChangeHandler.call() method.
@Josephblt in cases like this you can use a more functional code like List<String> uuids = elements.stream().map(Element::getUUID).collect(Collectors.toList()); I think it is cleaner and easier to understand, but just as a suggestion.
Maybe better to return null
Checking this is probably redundant now when we return an Optional<LabelMeta>?
You're calling params.getString("sha") twice, it would be better if we called it once and used a local variable.
This might cause a concurrent write to the list. please use Collections.synchronizedList(new ArrayList<String>());
WDYT about moving such logic to InternalRuntime and do not bootstrap at all if installers are missed
Shouldn't it be key:value for cases where value != ""?
1. Removed @throws IllegalArgumentException when alias is null. as it is not required to declare throwing a runtime exception. We haven't declared this in other places e.g. Database class as well. 2. Remove an extra empty line before if(alias == null) {. 3. Add a space between if and (alias. Should be if (alias == null). 4. Add . (full stop) at the end of "alias is null" -> alias is null. 5. Do the same for the other methods.
assertNotFrozen(); call is required.
out should be never null since it is created out of the try catch block
RECIPES, correct the typo
Same here but with publicShares
Can you please add isTraceEnabled check?
Feature abort has a parameter to indicate which command it is aborting. We should also verify it is aborting <get menu lanaguage>
You should assert something around titles, URLs, and name, not jut print them out. Similarly, assertNotNull(ie), the test should be failing when you see something unexpected, no need to print "null encountered", that would be a bug.
are you sure this is the best way to handle this exception?
static.
The super() returns "" on null. Why should we differ?
getSES(true).submit( new Runnable()
Please follow our code style: Space after if, always use braces. In case I understood the code correctly, this statement is a fail-fast one. In this case, I would change the code to java if (isFirstCharDigit(value) { return Optional.empty(); }
Domain ->Storage Domain message is not clear
return null to make this more explicit ?
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
Get the conf directly from GrillServices class. Dont create another one here.
Wouldn't have been possible to override the afterFromProto in the ForwardNatRule class, adding there any initialization code as needed?
This may be null - are we just relying on never calling this before loading the column?
All of these parsing methods need unit tests to cover all the scenarios.
nit: you can merge both lines above as checkNotNull will return the given argument
Seems that's never overridden. Should it be private then?
This seems to be changed by accident. summarizeTaskInfo is boolean :D
why only removal of this event, is throwable accepted here? I expect that the flow gets restarted from the beginning upon exception. we should also log error on this throw block.
@bkmeneguello Are you sure that <code>!=</code> is correct?
please remove else, code will be more readable
Might consider using a [SimpleConfig](<LINK_0> here. Won't make a huge difference with the class as-is, but will make it easier to make changes in the future if we ever want to expand on the configurability of this predicate.
If this is debugging info, you should simply log.debug
emptyTextView can be made View.GONE?
Declaration should just be Map
This way it won't return any VMs unless unregister param is provided, no good...
getUndefinedMetricValue() is going to return null if the constructor param is null or undefined, so in that case we can skip constructing a ModelNode and just store null. Same applies for the defaultValue treatment above (which I wrote.) I've been working a managment perf support case, so I have perf on my mind today. ;)
Yes! Drive by fix!
Since there is an explicit coupling between lines 371 and 373 (if you were to reorder 370 and 371, it would break), can we factor those into a method that just returns the appropriate value?
2 things: 1) If a DataException is thrown is it a good idea to go on? 2) Did this kind of error logging work with casting exception object to string message?
Can't we throw a FunctionalException here !?
It looks like there's a testSame() method you can use for this one.
In practice, nobody with deep knowledge of EMF uses interface EClasses, but we are technically susceptible to letting them slip through here.
Type for Field + config.field + must be String
another format nit, but breaking between equals and ( is very confusing
this is repetition of code in checkRequiredFields()
Is statePath shared for all logical operators? What happens if there are 2 operators in a DAG that are using the window data manager?
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
Can be made package local
No shallow copy as it was the case before?
nit: you can merge both lines above as checkNotNull will return the given argument
What is the 6th item? Should there be an assertion for that?
Maybe its just me, but this calculation looks wrong, since we are assign a = b, then b = a % b will always be 0, since a = b. Shouldn't it be: long c = b; b = a % b; a = c;
Unless I am missing something, the array creation with new Object[] { ... } is not needed, and had better be removed.
This whole convoluted mess can be replaced with Paths.get(config.getPKIDir(), "certs", String.format("%s.cer", name)) Although not sure if it will be better to have it in this patch or a subsequent one.
We can drop an unnecessary boxing here and make a tiny optimization by just using 0f instead of new Float(0) (also clears a lint warning).
is this change required?
Spacing.
why not just getResourceManagerRoot().toPath();
If an exception is logged, it should be logged entirely (stacktrace).
I tend to put ">=" for these kinds of things, juuust in case something weird happens. Maybe it's just me.
This is repeated everywhere and then, don't this class have a common interface? e.g CatalogInfo?
try-with-resources
Can we avoid the null check here by pushing the future de-ref inside the if, and make associated scope change too.
@odockal can you please move this to constant?
leftover from debugging?
![MINOR](<LINK_3> Make "getSystemPropertyLength" a "static" method. [![rule](<LINK_4>](<LINK_1> ![MAJOR](<LINK_0> Private method 'getSystemPropertyLength' is never used. [![rule](<LINK_4>](<LINK_2>
needsComma I think would be a better name than hasComma
Try to use constant non null values in front for comparison methods, as their is less chance for a NPE. "COOKIE".equalsIgnoreCase(name)
I think this pattern will work throughout the whole string, while we want that it only works for the suffix of the string, which is not enforced. To enforce it, it should be "_[0-9]+_g\$$" or "_[0-9]+_g\$\z" or something similar.
I think is fine as the order is preserved. Let's see if tests are passing and I will merge it.
You sure you don't want to propagate the InterruptedException? Looks like run loop in ReplicationSourceShipper is designed to handle that exception. return here would continue the thread executing, which I think is not what we want.
This assignment is redundant.
this test is failing line 47 assertion error
again same.. why getters for local variables?
rm
stopGrid(0)
this variable name is misleading, it contains not only the commandData but also Ne field (see also other ApduTest classes)
Instead of duplicating the logic here I would prefer to encapsulate it in the respective filters, i.e. * KotlinGeneratedFilter.isKotlinClass(IFilterContext cts) and * KotlinDefaultArgumentsFilter.isDefaultArgumentMethod(String name)
> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
Very minor, but a bit redundant?
It's possible to use try-with-resources for both scanner and csis in the same block. I don't recall if the separating character is a semicolon or a comma. java try (Scanner scanner = conn.createScanner(tableName, Authorizations.EMPTY); ClientSideIteratorScanner csis = new ClientSideIteratorScanner(scanner)) { // ... }  You can also nest them, but that's uglier.
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
what if tDNode will be not TestDetailsNode, but MetricGroupNode?
Then put an assert here? Just so there is an exception, that indicates that the connection was null.
Not sure what the typical style is here, but there are two spaces after the -> operator.
public static? Is that keyword ordering important in this codebase?
can be shortened URI ssoRevokeURI = ssoRevokeUrl != null ? SsoUtils.buildUrl(ssoRevokeUrl) : ssoToken != null ? soUtils.buildSsoRevokeUrl(url, ssoToken) : null;
This check does not belong here, this method should never be passed a null value...
Stream to bytes should be in a method in Utils.java.
Would it make sense to make this return the string, rather than assign it to the instance variable result. Longer term, perhaps we need a bind method like: IO<A> bindLeft(IO<A> io, F<A, IO<B>> f) which binds, but returns the a from the left argument. But this would be another issue. I would have to check the Haskell doc to see if this exists.
now you can just do int scanId = telephony.requestNetworkScan(
- check mKeyPair.getPrivate().getEncoded() != null
Maybe its just me, but this calculation looks wrong, since we are assign a = b, then b = a % b will always be 0, since a = b. Shouldn't it be: long c = b; b = a % b; a = c;
Nitpicking: do you mind splitting this in 2 tests for readability / style.
Check args?
Add message to new RuntimeException
You should instead be asserting that UserService.getUserActivationKey returns the same user and not this dao call
I think the braces are redundant now.
please remove else, code will be more readable
We can just use == instead of equals:  if (type == BOOLEAN || type == DATE || isVarcharType(type)) { return value; } if (type == BIGINT) { return ((Number) value).longValue(); } if (type == INTEGER) { return ((Number) value).intValue(); } if (type == DOUBLE) { return ((Number) value).doubleValue(); }
Seems issuing token even if renewer is not passed seems to be legit case.
why not directly return connector.eContainer() instanceof Pool; ?
This makes it feel like the setAttachments call creates a new revision. Why doesn't setAttachments actually set the attachments on the revision, as it looks like it does from the call? It does so only in the database, which makes it's name now misleading.
Redundant condition.
minor: this not required
Must be ANY, not YOU (At the beginning of each end step)
can you call it first, just for consistency..
I think that may have been an oversight in longSum. Try a query that results in +Infinity at the historical level and you will see why it is needed to deserialize at the broker level
is parent + basename part of the exception string here ?
we should handle return types java.util.Date and java.sql.Date
what is I used for?
why do we check/break here , it is already covered in the while clause condition.
spacing *sigh*
Is this thread-safe? I guess, maybe, although it might do extra work since not all threads will see the update at the same time. I'm also not sure if ParseSpecs need to be thread-safe; if it's an issue could you please double-check it?
now that the expected value is updated, is the replace all still needed?
Missing blanks around "=".
No status key should be in the JSON body only the account
Can be transformed into an if statement.
currentType doesn't seem to be used, so it can be removed from here.
Same recommendation for using a constant for the content.
please don't swallow exceptions. Re-throw up the chain.
Please don't print the stack trace.
this exception is caught immediately below and effectively swallowed. Either logger.error here or before connection is closed so we see rational for closeConnection call in the logs.
this code doesn't seem very safe. If the call to db fails, the class construction might fail, and then it's hard to troubleshoot it, no proper logging, etc. Isn't it better to first get the domain from db, and if it returned OK, pass it to constructor?
Change name of method maybe?
A random header id should be added if httpHeaders is null.
Broken alignment.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
missed to implement
Perhaps single quotes around actual code
Please use ? ternary operator
why does this need to insert a listener in the middle of the callback chain? Can the queue reader manage its own queue?
Please, remove all of these changes from this PR. We have figured out that the solution to this problem is more complicated and I will create a separate PR resolving this problem.
Use " List<String>" instead of ArrayList<String> in declaration.
The RedundantModifierChecker will say us that we are bad here: the class is private.
Here you can check the entire set of values that you would be getting after the acquireToken call.Also this can be done for rest of the acquireToken test cases.It will help us get a high test coverage. #Pending
final
I think it will be better to perform the removal of the managed block disks after we start the async operations to remove the regular images because the removal is currently synchronized. (as the removal of the cinder disks)
why is all the logs statements flipped? Like "While trying to instantiate, some error" instead of "Error while trying to instantiate"?
You shouldn't need to clarify the variable location since it's a different name then the local mapboxMap, TrafficPluginActivity.this.map should just be map = mapboxMap;
Remove the catch block and let the exception propagate normally (which fails the test)
would it be better to throw an UnsupportedOperationException rather than return something that won't work?
Must return true. Also must return false on code above (targetPlayer == null).
Can this bit can also be used to scan for command log snapshots too?
You can use e.ordinal() instead of e.value, and remove the value field.
Would it make sense to make this return the string, rather than assign it to the instance variable result. Longer term, perhaps we need a bind method like: IO<A> bindLeft(IO<A> io, F<A, IO<B>> f) which binds, but returns the a from the left argument. But this would be another issue. I would have to check the Haskell doc to see if this exists.
It may also be fine in a lot of situations to just cast it, since presumably nobody is actually trying to cast the returned Void value to a Void, so there should never actually be a bad cast at runtime. But, eh.
log statement at line 296 has to be fixed. Not just w/o a request. either w/o a request for a content for already processed request
Making only this message a constant only makes it less readable, and is essentially meaningless. It's a good idea to undo the fix or standardize the argument checking.
Seems like we could use the check here too?
Please rename this variable list to pushResults for example
This log statement is wrapped in a isDebugEnabled check, but logged at INFO. Should it be logged at DEBUG or should the isDebugEnabled check be removed?
use return ... ? ... : ...?
Why this change should be a part of this PR? cardinality < 0 probably means that completely different approach should be taken to compute topN, setting just to Integer.MAX_VALUE may result in a lot of excessive work and allocations in run() method.
Should also have tests for strong with preceding character content, and following character content. (those are areas where we've had troubles before)
assertThat(collection).isNotEmpty() is shorter and will give better error messages. The same 8x in this PR (Ctrl+f "isEmpty()).isFalse()")
if using processSoftwareCapabilities, then you can call the methods above (or a new method) from within this one.
I think something like this should be discussed in #3788. We already cause quite a lot of traffic to iTunes and I want to keep it to a minimum, so we do not get locked out one day.
assertEquals(boolean actual, boolean expected)
Exception should contain some details like length and related size to help understand the problem when it will pop up
Why remove the timeouts?
Won't passing null here cause an issue down in getOrCreateRepoLocalTeam when githubUsers.isEmpty() is called?
there is RepositoryFiles.trash, can you please use it here instead of getPathToArtifactInTrash?
This will forward the child's requests and will hang because the child doesn't receive an element and nobody is requesting more. I'd instead write this:  java Subscriber<T> result = new Subscribeer<T>() { ... } child.add(result); return result;
don't need this flush
Instead of repeating the addition assign it to a value on the stack.
logically, it may be important to check if it's empty and if it's null. Not sure.
If we're returning the activation outside of synchronization, is there a chance some other thread is updating it (e.g. a call to reinitialize), and we could get a partially updated copy? General question: Will each thread deserialize its own ActivationHolder objects, or could these be shared?
Just throwing RuntimeException client-side? Not sure about this error callback on client side. How about relying on default error handler (which I think would lead to "Unexpected error modal" with the exception)?
suggestion String.format("Entry with id %s already exists in directory '%s'", id, directory.getName()));
This can throw if there are no principals. It should probably have an explicit check to throw a proper error message
It looks like we have duplication of code in the ingest file filters tests. We should look into creating some new utility methods for creating and deleting a case.
rename to event
Request.State.OPEN
Shouldn't this close the iterator before returning the list?
I think I prefer spaces before "leap-day" and "year-day", but not too important. Wikipedia has all words capitalized (and no hyphen before "Day", either), so you may want to check some of the original references.
Is replacing separators enough? We should look into something that will work for any special characters.
How about to use the following, which is more intuitive as I think..? final int numMiniBatches = numTrainingData / miniBatchSize + (numTrainingData % miniBatchSize != 0 ? 1 : 0);
I still think a couple of helper methods will make the tests easier to read: private void setBare(File gitDir, boolean bare) { Repository repo = new Repository(gitDir, null); repo.getConfig().setBoolean(ConfigConstants.CONFIG_CORE_SECTION, null, ConfigConstants.CONFIG_KEY_BARE, bare); repo.getConfig().save(); } private void setWorkTree(File gitDir, File workTree) { Repository repo = new Repository(gitDir, null); repo.getConfig().setBoolean(ConfigConstants.CONFIG_CORE_SECTION, null, ConfigConstants.CONFIG_KEY_WORKTREE, workTree.getAbsolutePath()); repo.getConfig().save(); } Then the tests are a bit more declarative as they setup their condition to be tested.
this method is big, please refactor to more readable code
We shouldn't ignore an invalid enum value.
shouldn't we name this "channelActiveToFirstMessageReceiveTimeInMs"
As a small improvement you could switch L:86 and L:87, declare Class memberClass as final and reuse memberClass within the ternary expression.
Return an empty map instead of null (same for L59)
Why don't we store the build folder as a full path, so we don't have to relativize again and again? We need to keep in mind that this is called for every folder that is ever added/removed/changed.
I do not think this will work on PostgreSQL. If it were as simple as this, i would not see a need for a custom java changeset. You would just use a liquibase sql tag. My thinking was that you were going to loop through the records in java while assigning an incrementing id. That way it would not be a database specific sql. Does it make sense? :)
What's the value returned if the default value is an array? On the other hand, the check !(result instanceof NullNode) seems redundant, because a string value is only returned for SYObjectNode and SimpleTypeNode.
Shouldn't we check if longChanged and stringChanged is true?
response entity is missing
I'd recommend to add process id to the name as well as there might be tasks with same name in different processes but still in the same kjar
How about using something like org.apache.commons.lang.math.NumberUtils.isNumber()
Same here? if (e.widget != widget) { return; // Not for us. } Though I wonder how that could ever occur.
This should be put into a constant.
The value returned by isPlaced depends on the mapped flag as well. It would be a lot simpler if this provider had tuples of [seqID, start, mappedFlag, usePositionDeltaEncoding, expectedIsPlaced], with test cases for each possible combination, and the test just created a new record for each case using those values, and verified isPlaced.
I would prefer IllegalStateExceptions in such cases.
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
Missing codes.
How about changing code block (line 141 ~ line 147) to following loop:  for (RequestOrResponseType requestType : EnumSet.of(RequestOrResponseType.PutRequest, RequestOrResponseType.GetRequest, RequestOrResponseType.DeleteRequest, RequestOrResponseType.ReplicaMetadataRequest, RequestOrResponseType.TtlUpdateRequest)) { requestsDisableInfo.put(requestType, Collections.newSetFromMap(new ConcurrentHashMap<>())); }
Pass settingsRepository as argument to DownloadLanguageTranslationUseCase is not necessary
Rename variable to cards.
reference would be concatenated w/o a separator. Is this intended?
This is a very tight loop, you should at least sleep a little bit at each iteration. Or better yet, replace with:  checkThat(() -> simulacronRule.cluster().getConnections().getConnections().isEmpty()) .before(1, SECONDS) .becomesTrue();
Why not change the if statement to be online && text != null && !text.isEmpty() ?
why are we indenting in the logs?
return Arrays.asList(boolean.class, Boolean.class)
Why remove the timeouts?
you may add the error message as an additional third argument here, in order to give the users a chance to understand why that is
Empty catch is a nogo, use a logger
We should move this to a utility to avoid duplicating code (be careful about tangles, though )
please remove the hashmap size
What's wrong with setting the listener to null if it should already be guarding for null listeners
You also have to notify the m_shortCircuitReadLog whenever the truncation handle advances or the reads queued up in there will have a long latency and if there's no more txns after a read, that read will be stuck in there forever.
could use TmfNanoTimestamp
as we are changing how the digest is computed anyway, we can simplify this as buf.append(',');
outside of the try block
potential NPE, exactRef is @Nullable flip order with lines 303-306 ?
This patch LGTM. Any reason, you want to convert this to a String and not use it as it is?
Consider setting up the SMILES parser in the @BeforeClass ...
1. Did you mean support only Firefox for _testing_ right? I assume the difference in behavior affects testing only? In that case we should keep the production code clean and apply any workaround in the test code. e.g. do an if-else based on WebDriver. 2. Yes, I think at some point we stopped using Chrome for testing. There are many other quirks between the two versions that gets in the way of comparing html. We can check if anyone is using Chrome.
You can move this check to superclass
There is a local variable file set to getFile() 13 lines above; I would use it instead of calling getFile() again. EDIT: Indeed, would be safer to use instead getCurrentDir(); if I recall correctly, getFile() will return the selected file in a tablet in landscape, when a file is shown in the right pane.
Technically, that should never happen, but why not ^^
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
maybe worth adding an assertion to ensure its a boolean? Is this ensured somewhere else? otherwise it should throw an exception here.
You do not have to push a new IllegalArgumentException to error logs. Just print the log line.
In that case not only host will be put in that header but host + path +query. @l0rd Do you think it is OK or only host+port should be put in that header.
This fits properly in the previous line
we need the sleep even if there are more lots being generated. otherwise, this will consume lot of cpu.
Why remove these?
what is the rationale for changing this return type to File[] ? I think it's probably easier to make this.dexFiles a List<File> and have getDexFiles() return a List<File> too
Maybe catch ClassCastException and rethrow as ArrayStoreException?
why parallelStream?
I would prefer this code to be done in the KeyStoreHelper constructor and keep a Map<String, TrustManagerFactory > so can be detected at this moment and this is also like how we do for the SNI key manager mapping.
won't this fail after the fromMessage calls?
Enclose your blocks with if ... { ... } else {
any reason for explicitly invoking super.toMap() ?
Would it be possible to use "warn" only, if the request uses OSCORE?
Why don't we assert message here any more?
@vilchik-elena I think the message should mention that this is about a coverage report and ideally it should give the line number. Minor: it would be better to avoid the duplication of the message of the cause (if we log the cause, then why concatenate its message?).
java return (bundle.getState() & (Bundle.INSTALLED | Bundle.UNINSTALLED)) != 0;
On the web , there is three formats: 1- More than one year: Month day, year ex: Jan 10, 2015 2- Not today: Month day ex: May 13 3- Today: hour:min AM/PM ex: 10:05 AM So even the longer format, number 1 is shorten than what is being used in EGerrit
personal preference (aka your call)  return new InternalNodeProbe();  Rather than have the dumby constructors in InternalNodeProbe
Activator.PLUGIN_ID use activator of tmf.core
Maybe we should derive this from Prefs.getMediaWikiBaseUri() or require the client to pass in a default protocol. I think I prefer the latter to avoid complicating this nice and simple model type.
Don't we need this step even if addedEval is true?
Please use int[] instead of list to avoid unnecessary import and large diff in test
size is calculated here. Do you want to change sizeCached to true?
Shouldn't be more like return getConfig(STACK_DEFINITION_URLS); ? this is always different than null as you call this method, and getConfig(STACK_DEFINITION_URLS) is set with a default empty list.
does it have to be public?
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
Why log.info and continue, instead of directly throwing exception?
final
Could we please replace all element.getContent().getDefinition() by DefinitionUtils.getElementDefinition(element)?
You need to use a RunListener or similar to ensue that any locks acquired by a build are released when it exits even if the user forgot to use the release step (or forgot to put it in a finally block, or the CPS VM crashed and the build did not exit via the Groovy call stack).
what do you think about using org.apache.commons.lang3.builder.EqualsBuilder  return new EqualsBuilder().append(company, that.company).append(firstName, that.firstName)... same suggestion for future implementation of hashCode by using org.apache.commons.lang3.builder.HashCodeBuilder
common format
Catching JsonProcessingException here will encompass JsonMappingException and JsonParseException. Or catch both explicitly.
Why this needs to be hidden?
please use our Unchecked.function/supplier for this sort of thing (inspired by jool, if you're familiar with that). I assume both methods throw, so you'll have to uncheck a lambda rather than the preferred method ref.
use s.toArray(new Field[0])
It's vaguely worrying that this function has multiple failure modes but its only indication of failure is a debug message if DBG is true. I imagine the API is set in stone and the function can't be changed to return a value? Failing that, if addRoute fails, perhaps it makes sense not to set mDefaultRouteSet to true?
I feel that we normally don't do this in Presto but explicitly create a new object with old parameters.
The 'Network' should be omitted from this context since this is not a specific provider.
You could move this line inside the experimentPageContentForExperiment method, as the number of cells are also content.
ObjectHelper#isEmpty already contains null check. suggestion return ObjectHelper.isEmpty(field);
The two statements above can be conveniently combined to: java Map<FeedbackQuestionAttributes, List<FeedbackResponseAttributes>> responsesForOneRecipient = sortedMap.computeIfAbsent(recipientTeam, k -> new LinkedHashMap<>());
Any way we can clean this up? It seems to only be needed for example commands, but hard to check what the command is here since it's wrapped in decorators.
Should we only assign the external ID if it changes?
I find this more readable. You?  .filter(file -> { String name = file.getFileName().toString(); return name.startsWith(formName + "_") && !name.endsWith(".pem") && !name.endsWith(".tpl"); }).forEach(file -> {
Could this and the above constructor be changed to use the below contructor? e.g.:  public Region(){ this(null, 1, Integer.MAX_VALUE); }
PsiTreeUtil.getParentOfType(o, GoForStatement.class)
if there is no other case, then we have to use the if statement instated of switch.
Could you make a function like canonicalize(functionName) and use it here and also in registerFunction method where FUNCTION_INFO_MAP gets populated so in future we won't miss converting to lowercase?
Same question as above
throw error here. I can hardly imagine what we can do with empty configuration.
We prefer nested try/finally blocks: InputStream in = openRobotsTxt(); try { OutputStream out = rsp.getOutputStream(); try { ByteStreams.copy(in, out); } finally { out.close(); } } finally { in.close(); }
these new methods should use getAttribute(tag.getBinaryTag()) when possible to avoid redundant conversions
You should verify the student has answered the session first?
here we'll want to throw only if we are not already tracing this packet.
Deprecation was added in [1] but the commit message does not have detail. [1] <LINK_0>;a=commitdiff;h=18bcdf797dfba5e462413a6ccce9dd6d3da2025b
I would prefer to use String.valueOf(value)
You could make tryList final and perhaps inline initialisation in declaration.
I think the annotations should be on separate lines
use return ... ? ... : ...?
Remove the brackets so it fits on one line: () -> scrollBarView.requestLayout()
curly brackets would be good here as well
Use _int_ instead of _byte_ to allow for values > 127...
What is the use of expectedException
@edugfilho what about changing from elseif to switch? :-)
We were generally trying to wrangle in the exposed surface area of the SDK in the parts we touched that we deemed probably should have been package internal to begin with, but yeah a breaking change is a breaking change. Do you have a strong opinion one way or the other on this specific change? It would imply making this a public method on the KeenQueryRequest abstract base.
remove unnecessary white space
I think you need to check for a null fetched user; could be an incorrect id.
@xpadro , Thank you for the update! But the review is still here I think this is not true. We definitely need to have queryExpression. So, the last oneRequired should be true for this createExpressionDefinitionFromValueOrExpression() invocation.
Could you simply throw the exception? I think that makes the code more readable and has the same effect. Or do you explicitly want a failure and not an error here?
>80 chars and extract.
-1 The jgroups-channel and jgroups-stack does not allow expressions in the new messaging-activemq. We can not copy them. We can neither resolve them before copy because there is no guarantee that the resolved value on the DC would be similar to the resolved value on any domain servers.
I'm wondering why do you use RtForks in MkForksTest tests. We should test MkForks instead
nit: throw new RuntimeException(e); so if this ever happens (unlikely), the error will be more obvious in the test
While this works, it's a little confusing because someone might think writeJson only happens when debug is active. Consider something like this instead:  java String result = writeJson(request); logger.debug("Write JSON: {}", result);
Try/catch can be removed
Add the info log back after this line?
use getVmDeviceDao() instead of getDbFacade().getVmDeviceDao()
String.format
throw UncheckedIOException(e)?
IMHO this should include a descriptive reflog update, since this is a local repository that a user might be poking around in. cf. the output of "git reflog refs/remotes/origin/master" in a repo of your choice.
How about making use of a try-with-resources block to simplify things a bit? java @Override public Object getSparkObject() throws StandardException { try (ByteArrayOutputStream bos = new ByteArrayOutputStream()) { ObjectOutput out = new ObjectOutputStream(bos); out.writeObject(value); out.flush(); return bos.toByteArray(); } catch (IOException e) { throw new RuntimeException(e); } }  Also, why are you throwing RuntimeException instead of StandardException?
I'd guess that findbugs (the reason for the build breakage) is complaining about the unsynchronized access to diskLruCache here.
Any reason for the specific guard? I.e. GTK3.14.13 instead of 3.14.0. If there is no specific reason then please change this to: if (GTK.GTK_VERSION >= OS.VERSION (3, 14, 0)) {
We should use structured logging where possible:  LOGGER.warn() .setMessage("Failed to get tag names for metric") .addData("metricName", message.getMetricName()) .setThrowable(message.getThrowable()) .log();
TogglzEndpoint.java:[58,63] lambda expressions are not supported in -source 1.7 <LINK_0>
suggestion public @Nullable ImageIcon getImageIcon(int size) {
If this sample is just displaying data from a URL then we don't need read_external_storage permissions
Would it make sense to instead - Have WrappedNetworkMonitor always create a mock TcpSocketTracker. Maybe it would have to set it to not operate or something. - Have a getter for the TcpSocketTracker in WrappedNetworkMonitor. Methods that want a particular behavior from it could call mock methods on the caller.
Change 'else' statement to block i.e. add braces.
We should either do a info log to inform users that we are still waiting for the operation to complete or we should timeout at some point.
Extract this try-catch block to a method to avoid code duplication
I'd make this private rather than part of a public API. If we want it to be called by other things, it should be moved to an appropriate utility place (and perhaps renamed to make it clearer that it will return null if not positive).
name can be null, causing compareTo to NPE if its on the wrong side. In these cases maybe treat the name as though it was "".
Don't use stream apis please
Maybe consider String.valueOf() to circumvent NPE.
No need to cast, a ServiceProvider has the method you need
FYI: You don't need to over specify generics in Java 8 anymore, so:  List<Integer> list = new ArrayList<Integer>();  can simply be:  List<Integer> list = new ArrayList<>();
Is the executeSingleUpload the right place for it? There are also delete blob, read blob, and other methods of BlobContainer. Is it possible to do it somewhere in S3ClientSettings?
s/2/routerConfig.routerGetRequestParallelism ?
The constant must be before the variable.
public isn't needed
Please remove this check and adding validations = PositiveNumber to the imageStoreId @Parameter annotation.
No need for null check
id -> Id
@Override
For this, and all other xxxAttributes classes, are there well defined map key name constants we could use? If not, then I would be in favor of adding them as public constants to the xxxAttribute classes, to avoid raw string constant usage in consumer code.
Think it might be worth doing this in scanHttpRequestSend as well? In case Jso is being POSTed, etc. The method could be changed from using the msg to accepting the body.
if the disk doesn't exist you'll fail with NPE here, please first verify that it exists.
Could we test multiple operations and verify that after the first one fires the rest don't continue to sleep?
Why making a real object here? How about just Mockito.mock(Github.class). The same for the other method
off topic: I've been writing this as "client == null". I think this conveys just as much information in fewer characters, so by Shipley's law I should switch over. The drawback is that "client == null" is a boolean expression, and is consistent with "limit < 0" etc. . .
You do not print in exception message any context information, it is sign of improper place to process exception.
Is this done on group picture also? Maybe a general helper and use would be good :)
Minor: Can inline, won't be called anywhere else.
if i get it right: if response is null, we will not retry. i think we should retry even if response is null. btw what caused this in your case? so it would be:  response == null || ....
Should we add null check?
I don't think it is right to return always return true for two different AuthorizationContext instances.
List
In the case that it's loading only the structure, is it still building up the response rows, just not showing them? Should responses be an empty list in that case, or isShowingResponseRows (in the called method) be set to false, or is this handled elsewhere already?
I don't think this is right. AIUI "remove" is never a param to an operation model node, it is the value of its "operation" child node.
This lost the refs/dashboards prefix, which may cause it to fail to resolve because JGit won't look for "foo:bar" in refs/dashboards/foo".
LOG.warn("Failed to publish to kafka topic {}", topicId, exception);
Wondering if we can combine the two get methods and have it return Collections.unmodifiableList(replicas).
else throw an error about invalid class.
minor: would be nice to define the Void/null key for control messages in ControlMessage.getDefaultKey(), or, defining OutgoingControlMessageEnvelope(systemStream, partitionId, controlMessage) to be used here.
/s/in/is
Call RxJavaHooks.onError so no exception is lost.
Here reset should not be inside update() method, otherwise since StampedLock is not reentrant, this could be deadlock
only one element? maybe try to use singleton set
same....I'm just going to stop and wait to see if this actually gets caught
I guess you are putting it twice. Here and in line 181.
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
Maps.newHashMap()
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
We require brackets on if statements.
These 2 try/catch blocks could be combined into 1.
Looks like this should be withoutActionBits(permission.getActionBits()).
This check is unnecessary. context can never be null for a properly constructed object.
Could there be a case where savedInstanceState would not be null? If yes, how would we handle that case?
This must be unique, as it is the ID jclouds will try to find when calling the computeService.getImage(id) method. Is this label unique?
Shouldn't we avoid the asset keyword ? Are we sure that Eclipse is started with the -ea switch ?
suggestion fetchLiveInstanceData(force, 25);
Might be interesting to add some more information here, e.g. the iOS SDK also logs the OS version.
I think we can do away with this condition because its already been taken care of by the other two edit checks above it.
nit: if (p != null)
This does not need to be public. Instead, just pass the builder to the private constructor. See what we do in HtmlRenderer.
How does this work if the app image is loaded? Won't the test fail?
If this is only for testing, use stream api
Please add also VOOBSERVER.
No need to use UriBuilder
we should keep the implementation so developers can override how the notification is built if they want to add new features or modify settings (that's why makeNotificationIf... methods were protected if devs are overriding MixpanelFCMMessagingService). We need a way to let developers override the notification before its posted to the notificationmanager
Can we do like this? First check whether connection is null and throw error from there. Else, call the setClientID method ? Basically, reverse the if condition and remove the else part
My personal preference is to use brackets even for one line loops and condition. Not a blocker to merging.
Will this test pass after the year 2100?
Could call the method addCookie(String domain,....) instead.
This should be set instead in the if (ignoreDTD) statement. If ignoreDTD is false, then we should allow DTDs.
since permission is required on cluster, the cluster should be initialized in the constructor, so i suggest moving this line from the canDoAction here: setVdsGroupId(volume.getClusterId()) (of course add a null check on volume before) that way, if volume and cluster supplied, permission will be checked on it, if not, user will not be authorized to run the action
Can you leaves these timings unchanged as currentTimeMillis()?
should this be error?
Reuse pointable for each evaluation call.
I'm assuming this is null for future use for when we'll be able to pass disk custom properties from the UI?
Why the heck are we painting all columns ourselves? We only need to draw column 1 containing the graphical commit tree. This suggests a nice two-liner to fix this: replace above by event.index == 1 and...
don't do this, instead, you should modify resources/log4j.xml
there is method Misc.free() that does something like this
Doesn't there need to be a translation call in the case of getCanDoActionMessages() containing a single message? This code drops it right through to the failure event handler. The previous code would translate it first.
end method should be executed afterwards if no task has been created..otherwise it'll never run.
This is not how it should be. This should be:  if (log.isDebugEnabled()) { log.logDebug( message ); }  Do not use "if (debug)" because this is hardcoded and will never be enabled. Do not use "setLogLevel()" because you're overriding the system administrator's configuration.
What is the default category? I'm a little bit confusing the definition. But this component is used by "agent" and uses "database" for task queuing so :-) of course we can change later.
this(clazz, Collections.EMPTY_LIST)
You can use Preconditions.checkArgument() here, if you like.
I believe you should verify that the results caret button is disabled here too.
I think you want logical AND, so double ampersands. Can we use !license.isEmpty && !licenseShortName.isEmpty && !licenseUrl.isEmpty() instead?
You need a check for packs.length == 0 here to just return early. Its a protection against an empty repository throwing ArrayIndexOutOfBoundsException when it was given a list of objects to find.
use assertEquals instead of assertTrue
Unclear if this has been a convention throughout Lock Watches, but the decomp - in particular, rejecting a success from post-leader election without a snapshot _here_ - seems a bit unexpected. I'd prefer this just return the version, and updateVersion take care of that filtering. It looks like you do that anyway in updateVersion!
I would rather use plain "true" here. It is sufficient.
what if all of those vms are down? why would i care to deactivate the iso domain? after making this change please also merge the used query with the one at line 132.
Merge these two if statements.
Correct me if I am wrong. If updateAccounts throws exception, where it would be handled? And the exception parameter is still null in onCompletion ? Same question in GetAccountsHandler.
This would probably not be a problem in this case, but as a general rule, avoid string concatenations using +. There are cases where the compiler can produce optimized code, but not always and it may produce code that creates a lot of intermediate objects. Except in very simple cases, the recommended pattern is something like this: StringBuilder sb = new StringBuilder("initialString"); sb.append(var).append("fixed string"); ... sb.append("something else"); return sb.toString(); In this particular case, the loop can also be replaced by: com.google.common.base.Joiner.on(", ").join(hashMap.get(element)) which does the somewhat tricky (and very common) logic of inserting a separator between elements but not after the last one.
Should be a SamzaException with a message, not NPE.
Do we want to include secondary reads as well? I think not. we should probably filter secondary reads here. Even if they are filtered upstream somehow (I don't think that they are) this program should be clear that secondary alignements are filtered out.
why does this not use Utils.assertTrue ?
Shouldn't this be assertGreaterThanZero?
same as above for log message.
should this be public?
Let's make commit on each 100 nodes e.g. (it costs effectively nothing) but may prevent write buffer overflow when running with extremely low mem (write buf size is e.g. 1M). It could be also more effective to make commit on FastSyncDBWriter thread since it can cause DB flush synchronously
![Codacy](<LINK_0> Issue found: [JUnit tests should include assert() or fail()](<LINK_1>
This evaluates different value that it stays isLeftTurn will return true, in case it is slight left turn
If we continue to use a StringBuilder here, we should use it in a way that makes sense.
Optional: use Boolean.TRUE.toString()
can we remove the version completely?
Is this register call needed since the new API used will create and register with metrics registry?
Would be nice to circumvent the creation of the Text and go straight from String to byte[]. Same applies to the other Step interface methods.
Do we really have to fix this here? I think simply rejecting _id in  .addExclude( ) should be enough, shouldn't it?
If this sample is just displaying data from a URL then we don't need read_external_storage permissions
It would be simpler to get TmfTimestampFormat.getDefaulTimeFormat() and set its time zone to UTC, here or perhaps in the setUp method.
catch IOException and rethrow to avoid wrapping an IOException with an IOException
are you sure this is the best way to handle this exception?
will be null after view disposal. PlatformUI.getWorkbench().getDisplay() is our friend.
Please add import to avoid fully-qualified class references. Also, why not simply do this: Locale parsedLocale = LocaleUtils.toLocale(underScoredLocaleKey); result.add(parsedLocale.toString());
Define "data-agent-conf.xml" as a constant
Again, why removing test logic?
Constructor can be package now.
why a file here instead of BAOS like others and before?
just return "" instead of new String()
Consider using Uri.getLastPathSegment()-it seems to do what you want and is probably more efficient.
Setting the status to COMPLETE if it is could save an update
You should pass here message not group converted to string.
Define this constant somewhere else for reuse.
try-with-resource opportunity here (and another one down below).
I this refactoring, very nice. Could make this method protected.
What about allAll, clear(), removeAll()? What about the iterators? There are all kinds of things that can bring this out of sync. Are we really gaining anything at this point by using a SortedSet vs a List?
You can use CollectionUtils.toImmutableList
this whole method could be a oneLiner: return find(...) != null
why hardcode?
Looks like there is a Java 8 construct left.
Now you could directly specify the branch in the query: final Branch.NameKey branch = new Branch.NameKey(new Project.NameKey(tokens[0]), tokens[1]); db.changes().byBranchKey(branch, key) This should simplify the code.
suggestion dataMap.put(toData(key), toData(new DataCollection(dataCollection)));
Don't catch bare Exception
In the SmartMeteringMonitoringEndpoint I saw the response data being retrieved by a call to the meterResponseDataService. Calling the configurationService here to obtain the response data seems inconsistent at first sight. If there is no particular reason for this difference, I think it might be cleaner if obtaining the actual response is treated alike in different endpoints.
NIT: LOG.info("Executing {}", umountCommand);
nit: this definition looks really awkward
use multiple log parameters for the logging LOG.info("Created id from ssn identifier [organization: {} ][id: {} ]", ssnId.getOrganizationId(), ssnId.getId());
Why is this check removed ?
WDYT of changing the condition to "OTP-Token".equalsIgnoreCase(header.getName())? It's safer.
Hmm, didn't think of this earlier, but it might be neater to do this using the VerificationWithTimeout mock methods. So you'd mock the eapCallback, then assert that the callback was fired within a timeout. I think that gets rid of our locks and booleans entirely, and make sit easier to read.
perhaps do this in multiple lines
This var should just be named wifi, right? since it's not an instance var?
just str, we normally don't use "lC" prefixes.
can you remove the log?
expiring.remove(key) can be moved to line 403 and avoid creating a new lambda :)
method name no longer correct.
no need for the new empty line
Instead of calling this, please move the progress bar further down in the layout xml file.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
We should externalize error messages too.
Please, rename this parameter to oldCluster here and in other methods. It is named 'group' because Cluster was named VdsGroup in the past. Now it is just confusing.
I think there is some findbugs issue with not using {} not sure.
just return _props.get(key); in this method
The else is not necessary.
Maybe better to return null
do we care to check the length to be positive here?
let's add a valid :abc parameter in here too, not only invalid bait
Call to default super() constructor is implied. This is only a question of style, but it make my eyes hurt... Feel free to ignore.
I'm seeing most of the string literals used for property names, etc are re-used in quite a few places. Let's introduce appropriate constants upon them to be able to make the code more maintainable.
Can StringUtils.fromUtf8 be used?
what about 'else', if it was not set by user, you should take it according to the vmConfiguration mentioned in line 135 (i know it's not in vmstatic, but you could figure it by vm.template i guess)
All the implementations for the throwableFunction are the same in this test. Maybe there is a way to de-deduplicate this line:  final SupervisorActor.ActorRegistration actorRegistration = startResponse.orElseThrow(cause -> new AssertionError("Expected the start to succeed.", cause));
Not sure if we rather want Cipher.getInstance with second argument to be "BC" security provider as used for example in AesCbcHmacShaEncryptionProvider? AFAIK that may have bigger probability to avoid issues that some stuff doesn't work as expected on various JVM versions etc.
I think just passing file is enough instead of file.getPath()
How does the retry handler distinguish "failure in initialization + failure in handling all items" from "success in initialization + failure in handling all items"?
this should already be T so no cast necessary later
A slightly easier way to express this logic would be to use a queue from which you pop and you populate the queue with the answers you want to have.
do not assing parameter! nowhere!
What about adding a validation method in the property reader:  this.port = propertyReader.property( OgmProperties.PORT, int.class ) .withDefault( defaultPort ) .validate( Validators.PORT ) .getValue();
Wasn't there the intention to exclude information_schemas and pg_* schemas from the result? I think in this class would be the appropriate place to filter the returned list.
As above, this one is called through getRowsPartition() which is called through getRows(), so the list should already have at most PARTITION_SIZE elements. So I don't think we need this outer loop, or this was supposed to read batchSizeForReads.
@dalifreire looks like after your changes we'll have two ways of creating lowercase strings - either using dedicated class or Utf8String...
Should not this read : + (multiCf ? columnFamily1 + ".": "") + "f varchar, " if so, the remaining references should change too.
The System.out in a few places should be System.err to make sure that messages go to stderr. I think there are a few examples of this in other bindings.
Timeout seems to be related to CON messages. According RFC 7252, 8.1, page 65, all multicast messages MUST be NON so a timeout would not apply. Try cancel()?
Please use consistent formatting (spaces vs. tabs) so that the alignment of text blocks in the file doesn't become any worse than it already is. I realize that the text formatting is already inconsistent, but I would prefer to not have new inconsistencies added.
I will be nice to have more meaningful error message. E.g. "Text condition must not be empty string." or smth else which explain the problem with comparing actual text and the empty string.
nit: you can merge both lines above as checkNotNull will return the given argument
We should close the dispatcher as well. <LINK_0> According to the docs that will unsubscribe everything as well, but we should verify that's the case if we go with that
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
Should we have the monitor test here as well?
debug instead.
I foresee clashes here. Should at least use <type> + "/" + <name>
Can we just dispose() all subscribers here and remove dispose() call below?
The split between one fixed compounded and periodic payments should be on the fixed leg, not on the other legs.
I've got a fix in a PR that [removes the watchManager](<LINK_0>, so let's just make sure that doesn't get squashed by this :)
It seems like we should add some new constructors to help make this cleaner...
Do we want to check both getProjectId() and getJobProjectId() here?
Why do we need this?
Here, we need to check value also along with key. A case like createBucket, DeleteBucket, we will have the key in the cache for that bucket, but with the value null. And also is this isExist will be called with the lock? As someone can modify the same key while checks are happening.
This and similar blocks could use the NULL_LITERAL constant
We should probably prefer setReference and setAlternate to be private (or protected if used by a child class, but I assume that is not the case right now).
I don't understand why you verify if filterChain needs to be updated with every message read. Maybe filterChain should be volatile.
I wonder there is a better place for these 2 methods. If I was looking for this functionality. I wouldn't think to look to AbstractFragment. I don't really have a suggestion though, just thinking out loud, I guess. Edit: I just noticed that these 2 methods are the only static ones we have in AbstractFragment, which I guess can be a good reason to think about moving these elsewhere.
I don't think it's possible for the sender to simultaneously be a Console and an IUser at the same time, so the previous !(sender instanceof Console) check is redundant.
channel.close().sync();
we should pull the ObjectMapper out as a static final and use Afterburner, to avoid thrashing and testing too much serDe  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper().registerModule(new AfterburnerModule());
suggestion public @Nullable ImageIcon getImageIcon(int size) {
Can you move this function closer to where you have waitForEventThreadToJoin?
Avoid the scannerLock object and synchronize on KieRepositoryScannerImpl.this. I believe this will make also clearer that you're sync'ing on the same lock of the scanNow() method.
What kind of class is this expected to be? Is it an annotated one with the remote method number? Perhaps would be more clear as something like RemoteMethodAnnotatedClass
campain in tostring?
"Data without types received!" -> "Type information is missing" or sth like that
Isn't the trade "quantity" missing?
Can you also rename the other instance methods named compile? The only usages are in CompilationTestHelper and ErrorProneTestCompiler.
primitive (int) would be sufficient
cached field value is not used for some reason
minor nit: can we pass time column selector before field selector to be consistent with buffered aggregator ?
do we want to have actual percents? not rates as everything else is in Picard?
Why this get deleted? Your code depends on this function?
this could be encapsulated on a method called findFirstStepByContentlet, that returns just one WorkflowStep or null if does not found
Can we put a condition on this? Otherwise it will be injected on every request. have a private method autoWireService Check if backupService == null and call this method
If you'll eliminate the lock, accept method will contain just "this.value = value;" statement
NACK. this undoes #1272
Not sure, why not use @NotNull?
Ideally we are as specific as possible with exceptions based on what developers might see.
I think there is a concurrency issue when multiple queries that have the same appId are submitted at the same time. We need to fix it.
You could just do ResponseHelper.writeResponse(params, userLayer)?
This works, but we have static factory methods for specific use cases. GatewayError.baseError(msg) ?
This change breaks null-safety. null.isPresent() will crash and burn.
The initialization of length needs to be done only once and not all the time getClonedStream() is called. If we would like to handle file length changes it does not work (IIRC) as the file size could change also after the file input stream has been created. So, I think this line could be moved above after file = new File(outputFile); Or is it because you don't want to handle FileNotFoundException twice? But reset the size all the time... Hm WDYT?
I think you meant to include input in the message, not op. Also, the message needs to account for SUM as well:  throw new IllegalArgumentException(op + " on " + input + " is invalid");
put else in a new line
The status should never be null, instead it should either throw generic exception (including NotFound if that is what the response from the coordinator indicated).
To always be safe please use context.getApplicationContext()
getFirstName() considers empty getNames(), getConcatenatedName() doesn't.
overflow = ((xl ^ yl) & (xl ^ zl)) < 0;
I think in maxDatagramPacketSize != 0 case, we should pass min(byteBuf.writableBytes(), maxDatagramPacketSize) here, and similarly below where you changed lastBytesRead it should use the same min value ... (could just use allocHandle.attemptedBytesRead())
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
remove the explicit initialization?
Consider changing it to "command.getName().equals("OnRemove")" so it will fit the 'else if'
child
could we simplify the logic as:  if (childType == null) { return new MessageType(rootName, ImmutableList.of()); } typeBuilder.add(childType); parentType = childType;
Why are you building JSON by hand?
shouldWrite?
you can inline memo
I don't think this is a good idea. Removing reserved pool does not necessitate removing reserved system memory. I suppose we will always need to set aside a part of our heap to things we don't track, various overhead, etc. We can probably now set reserved system memory to a lower value.
Does this need to be a singleton?
Remove or log.
check for non null?
I like that you use an identifier here. However I would expect its value to be equal to null.
We want this to be 1000 or so, some thing completely beyond the output we should get - we basically want to keep all output so we can check all output.
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
We need to validate that provided namespace is not null or empty.
I believe this is the cause of your failures as you are setting up a Java17 project which will be called TestSetup17project or something like that.
Can this response be read and verified?
How about using something like org.apache.commons.lang.math.NumberUtils.isNumber()
static import for milliseconds please :)
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
use fieldType rather than fieldSchema in the message.
Should be getStartTimeAsLong() and not getGenStartTimeAsLong().
It would be good if you can applytrimming for white spaces on platform.
I'm still having a hard time groking end > start. The typical pattern is to say start < end, its easier to visualize. I think we can also drop out a subtraction instruction from the inner loop here if we are a bit smarter about how we handle the bounds: int ptr = end - 1; while (start <= ptr && isWhitespace(raw[ptr])) ptr--; return ptr + 1;
maybe, for readability, it is better to move the content to a specific method.
assertThat(c.getParentCount()).is(2);
Minor : parentheses are not needed
I don't think args can ever be null, can it?
We have a generic FSM implementation in Shuffle. We should extract it out as a cay common component to avoid duplicate FSM code.
return null to make this more explicit ?
This case should no longer occur, right? In that case I think it should be removed.
Same issue here, double delete user.
Why is Fqn and what is he doing here?
add style as parameter to above 2 methods
Do you think it's worthwhile to check !targetAccountName.isEmpty() as well? Same for container's check.
Shall we return the updated Registry object in response.
We have different conventions. Please see the spaces around brackets and method parameters, and brackets on new lines. The checkstyle plugin would crash the build. Did you try to run "mvn install -P run-its"? It would take quite long time to complete the build, cca one hour.
I think that this loop would likely be better if it used split()
This key string should be a public static member of some class, probably of Start.java. It should be named something like KEY_MOTIONTRACKING_AUTORESET.
If you'll eliminate the lock, accept method will contain just "this.value = value;" statement
If It use getLeaf() on this, will it return an unversioned ref?
@yingsu00 use toStringHelper
since this is already exist in ActivateVdsCommand, can it be extracted to a method in VdsCommand which is the base class of the two host commands ?
Should remove this logic. Enforcing node labels is the original queue enforcement mechanism. With the dynamic-allocation aware queue enforcement, we should use the logic for handling queue enforcement, and handleNodeLabeling method should now only deals with auto node labeling.
nit: if (p != null)
- you need to explicitely add the null here if you want it to be selectable. - this should also take into account the selected OS. Ideally, fill this list according to the values returned by osinfo.
should we do some better handling of IO issues?
More magic numbers; use variables for longitude/latitude?
why not use builder.append(SEPARATOR).append(value) . In this way , there is no need to remove last ":" in build method.
Checking whether text is null seems properly defensive. If text is not null, I believe that text.getData() is guaranteed not to be null, so that part of the check is unnecessary.
this method should not be public, otherwise doesn't make sense the arguments for the flush(ClientSession, String) method, as each session (editor) will have a different associated FormsContainer instance, which could not be the one set in setCurrentContainer... Can you please change it to package protected access (so no access modifier set)? Does it work/make sense for you?
* Did you have a look at this <LINK_1> ? * Is this also of help <LINK_0> ?
Don't log and throw the same exception
You can combine this into one function "initializeSystemColorsTooltip" and do the version guards in that function.
Just a tiny nitpick - maybe we could put this into a default case of switch statement?
This line is long:  ElasticsearchSplit split = new ElasticsearchSplit(table, index, group.getShardId().getId(), nodes[nodeIndex].getHostName(), nodes[nodeIndex].getAddress().getPort(), layoutHandle.getTupleDomain());
You could use here instead the Apache Commons StringUtils#isBlank.
I'm not sure why this variable is needed here. Could be: java public static String getAttributeValueFromString(String string) { if (string.length() > 0) { return string; } return null; }  This functions also will fail if string == null. Should be something like this: java if (string == null || string.length() > 0) { return null; }
you may put setEnabled on a separate line to make it more obvious for the user since this is a sample code.
any reason you're assigning to the local variable 'id' too?
Can we setup the listener using the same options as the org.opennms.netmgt.telemetry.listeners.udp.UdpListener? (We should probably update org.opennms.netmgt.telemetry.listeners.flow.AbstractUdpListener with those as well.)
Code style
public isn't needed
Shouldn't null here just be interpreted as an empty array?
This is a way to see how many entries are there in index. With this we need to make sure the query has used index. Along with that it will be nice to validate the index storage size: it could be done by calling isEmpty() on Index class or using the index stats (as done in other places in this test)
Maybe better to return null
why are we changing the visibility of these methods?
Do you think is better to replace it with Collection.addAll? suggestion arguments.addAll(Arrays.asList(values));
return new Job(name)
where's the hashcode override?
I'd suggest not assuming an ArrayList will be returned since we might switch implementations
I would create a private static checkArgument method for these checks
nit: checkState is more appropriate here.
How about inlining it?  if (!contains(o)) return false;
This is not 'per node' It is the count of all CPUs defined in all NUMA nodes.
It seems doubtful that without the Jenkins singleton, we have enough working that ending up in retrieveAuthFromCookie will ultimately be successful (User#getById?). Just return null when jenkins == null, and return?
Not a huge deal, but can we do these removeAlls against a Set instead of a List?
Use isZKLogAvailable() instead
I do not think we need to send schema URL every time as it is a single schema for topology. JsonNode schemaNode = JsonLoader.fromURL(jsonSchema); JsonSchemaFactory factory = JsonSchemaFactory.byDefault(); JsonSchema schema = factory.getJsonSchema(schemaNode); schema instance can be cached here and pass it to the API.
You may refer to PartitionSegmentPruner where we do batch read for init() and single read for onExternalViewChange() because usually external view change only involves change for one segment.
Use the Json object, as you did with [here](<LINK_0>
remove this local var . It is not needed realy. In the next line just write "general"
consider extracting to create params method
Can we do this?
Not resolved
The removed bit is important! It needs to know if the dropdown is the focusedWidget (in other words, if it is the current selection by tabbing) in order to highlight the widget with yellow - that's what returning ACTIVE_MODE does. You can probably find another workaround to avoid using TabbingManager, but you need some way to tell if it's been tabbed to
Is it correct that this class uses CryptoMigrationUtil instead of the StudioEncryption class?
Should be existingVals.length + values.size()
As IOUtils has been imported why not just use IOUtils.closeQuietly()?
Is the throws Exception needed here?
Why is this behavior changed? It used to be NOT waitForWrite, but now it waits instead. Is that true?
Newline missed (codestyle)
Can we reduce this sleep? Or even get rid of it if that makes sense for the test? If the check is to see no data is sent in the windows, then that should work?
Assert not necessary since the elements are counted below
Please use a for loop for this. This kind of construct uses a lot more RAM in terms of class metadata. for (Property prop : currentList.asPropertyList()) is simpler code too.
We prefer use null != xxx
I think that we could remove the ifs related to ActionWorkItemInsertFactCol52 and ActionWorkItemSetFieldCol52, since they extends respectively ActionInsertFactCol52 and ActionSetFieldCol52.
please test the value presented in the above example also:  java assertThat(sumOfFactorialDigits(10)).isEqualTo(3 + 6 + 2 + 8 + 8 + 0 + 0);
suggestion return all.size() > index ? all.get(index) : null;
Hi @mzorz could these methods be moved to another class for testability and line reduction reasons? LMK
need a toLowerCase(ENGLISH) here to be locale-safe
Shouldn't we assert the result of this is not null? AFAIKT, that means the promise never got a result (or exception) in the default/environment timeout. (Which implies the start failed?)
Are you sure you want the properties involved in equals/hashcode or is the actionId sufficient?
I presume this was to avoid log noise. Why change? If your intention is to alert the user of the problem, it would be better to log rather than the task executor printing the stack trace.
Add a check here to verify that the serialDataReceived method was not called.
Shouldn't this be INTERNAL_SERVER_ERROR as error is generated in server code while handling the request?
@Override should be on line above. Checkstyle/formatter config?
Now that we have the member idTokenValidator, let's ensure validateIdToken() is using it.
This looks like something Jack might optimize out (we're still using dx for Checker tests). Could you acquire the nulls through an inlined method and test the later constant folding? That seems more future-proof.
Missed it at previous review. Question - why via getVmDao()? and not via VmStaticDao()?
It's good to split the two different (logical) cases: * value is String * value is some Number Note that in Java, value instanceof FooClass will return false when value is null, so there's no need for null check when using instanceof operator. Consider following code: T parsedValue = null; if (value instanceof String && !StringUtils.isEmpty(value)) { parsedValue = parse((String) value); } else if (valueTypeCheck(value)) { parsedValue = (T) value; } String msg = ""; // rest of the code
Maybe you could do this with only 1 remote call?
no need for the additional check if propertyParts.length is ok?
Put this static method after instance methods.
Why do we need those queues? Can't we just invoke handlers in add(), delete(), move() methods? Are there any benefits of using queues that I've failed to catch?
duplicate code, you can just set the string as a variable
Could we please do not mix doReturn when and when thenReturn?
Not 100% sure if we want to swallow Errors - should this just be Exception?
why not null as value?
same... two separate parameters, one for file and one for level, these should be detached.
I think you can use Charsets.UTF_8 or some such and avoid the try catch
You can just say name.isEmpty() here instead of name.length() == 0.
The same as for connect above holds here
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
nit: can we consolidate producerFencedOnCommitTxn to the more-general commitTransactionException? I.e. if you want to fence on commit, you just register the commitTransactionException as a ProducerFencedException
Ahh, I see. Please make the catch more specific and restrict the try block to only the places where the throw is expected to occur. I'm also not sure if the log level should be warning, all other logs are just 'info'. But maybe a warning is justified in this case.
java itemGroup = ((Item) itemGroup).getParent();
unsubscribe()
Why change the access of all list methods to private?
you can introduce new interface that you can ask if the run should use fork or not. default would be true, also if the new interface is not supported by context (as before)
"return DefaultSessionEditorPage.PAGE_ID.equals(pageId)"?
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
add null check for transcription id
It looks like there's a testSame() method you can use for this one.
Move this to a constant so the value is shared by the APIs too? (consider this elsewhere).
I would check for null and make a copy of the map
I understand what you want to achieve, but can't it be fetched only once on Container initialization ?
do we care to check the length to be positive here?
These empty implementations can be removed I guess
Is start check needed? Could it be problematic (somehow delay/miss the start when it should be immediate)?
nit: you can merge both lines above as checkNotNull will return the given argument
Ah, OK, that would be clearer.
Maybe /accessTokens/ should be a constant defined in this class? Not a show stopper - just a thought
we're calling w.toString() 2 times, payload local variable already has the String value, apologies for not catching it earlier
this part is the same as in restoreDatabase, could you refactor it into a separate method?
Still wrong index... It really must be dependent on the TmfEventTableColumn, we cannot assume that the received 'columns' list is either in creation or visible order.
suggestion this.downloadService = requireNonNull(downloadService);
should be called resource
IntelliJ has a "Reformat Code" option which will clean up a lot of the stylistic issues that I might list here: - fewer empty lines - space between ']' and '(' - space after ',' - space between ')' and '{' - no newline between ')' and '{' - space around operators - space between if/while/for and '(' - no space between method-name and '(' - if/else with brackets and the else line looking like '} else {' -make final any variable that can be (method arguments included)
debug instead.
Can we assert order on an unsorted set? I'd assume not.
This is already done in the super class of this presenter
What about dumping the missing indices into a file ? The purpose should be creating an upgrade script - that would ease the process for the developer.
@tmjee before awaitTermination you should call shutdown Then assert that awaitTermination returned true Than then shutdownNow
Space after comma.
Nit - please fix spacing.
please move the isEmpty methods to the scimSchema
requireNonNull is redundant
Maybe good to add a limit to the total number of events that can be queued (suppose the send takes a while because of network issues and lots of events queue up in the meantime, leading to high memory usage)
please also add the GUID which is important.
When opening a trace in the unit tests, the resource is often set to null, it is not required. But then we'd have to see where the supplementary files are stored... (path of the state systems of analyses generated for this trace), so that we don't have orphaned files. Does having the resource make the supplementary files deletable?
Please align with Double (no protected)
Suggest druid.host instead of 127.0.0.1
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
@onursumer wondering if this function should maybe be private just to avoid people from accidentally using it?
Please add message entity here by describing the error.
NoSuchChangeException should be converted into ResourceNotFoundException so that the caller gets 404 Not Found instead of 500 Internal Server Error.
Should this be synchronized?
I think the annotations should be on separate lines
should add some context in the exception message here
The initialization of length needs to be done only once and not all the time getClonedStream() is called. If we would like to handle file length changes it does not work (IIRC) as the file size could change also after the file input stream has been created. So, I think this line could be moved above after file = new File(outputFile); Or is it because you don't want to handle FileNotFoundException twice? But reset the size all the time... Hm WDYT?
also use a map here (this is likely to be extended I guess)
Nit: spacing between + and recommend adding it like "V_" +
Same question/concern as before. Wouldn't updated resource configuration simply result in the previous configuration history to appear on the resource's configuration history page?
Better with other example domain (e.g. example.org).
I would not silently ignore one passing a null parameter. In other words, i would remove the if check and assume that the condition is not null. If it turns out to be null, better for the caller to automatically get a NullPointerException than chewing it quietly.
it looks like a constant
Ran into a spark bug a few days ago where a shutdown hook firing during a "clean" shutdown causes problems. This method actually needs synchronized or else a shutdown hook fired from a SIGTERM won't wait for runCallbacks() to finish
Same issue here, double delete user.
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
Move these to tests and use stepverifier.
This looks good, but the bindingResult check should be executed only if the storageId exists. In other words, something like this: suggestion if(configurationManagementService.getConfiguration().getStorage(storageId) != null) { if (bindingResult.hasErrors()) { throw new RequestBodyValidationException(FAILED_SAVE_REPOSITORY, bindingResult); } // rest of the code... } else { // }
this should be in the doPopulate() not in deprecatedPopulate()
This is pretty dangerous because alerts bigger than 1MB will break the emitter
It would be better to run checks in the constructor to make sure no reconciler is null, or to create an actual list of non-null reconcilers that would be dereferenced here.
The Exception is never thrown.
1 =
You also have to replace anyMatch with allMatch here, otherwise there is only a validator error if _none_ of the media are in the physical structure tree. However, there should already be an error message if _only one_ is not in the physical tree.
I think this causes the authz groups to be loaded when just viewing the contentresource. I was hoping we could just rely on authz checks when viewing the ListItem and only when changes the roles or editing an item actually have to load the authzgroup/roles.
You need to use the attach event even if it's an Element? I thought it was only when selecting widgets. I might be confusing things though :P
This now fails the case where destBranch doesn't exist but HEAD points to it. For example a brand new repository with no commits and a change being submitted to master, which HEAD points to.
Log messages appear to be incorrect here too.
shouldn't call protected method. Should only interact with methods defined in the Service interface. Please fix all other places.
@zack-shoylev Do you know what the underlying issue is here? Waiting for locks to be released, or..?
The client here is not closed; you should do that at the end of the test or, better, in the @After annotated method.
this block looks NPE fragile. Do you think it would make sense to catch NPE and rethrow with some meaningful message? Or check potential NPE places for null ?
"SAP Web IDE is not configured
I don't think args can ever be null, can it?
I am not sure, but we tend to use the returning values of such methods as plain Lists and then eventually wrap them into ImmutableLists over and over again. So if we can declare the ImmutableList as a type of the returning value, I would do so.
Placing this here could allow "missing" value for date variables
Can't this NPE as they're Booleans (i.e. objects not primitives)
line > 120 chars
This test is incorrect (L122). It should be like Assert.assertEquals(invoke("toString", CalenderParser.parseAsOffsetDateTime("2013-06-01"),"yyyy-MM-dd"),"2013-06-01");
Maybe a bit extreme? timeoutInSeconds * 1000 would be clearly in milliseconds.
<LINK_0>
Sad times, but I don't think we can easily work around this.
You aren't populating this list. I'd just not create entriesList and pass b.getEntries() to the callback. It's an unmodifiable list, but that should be alright.
ohh.. actually we should default to 443 if https!
These will never be equal because run.id was never changed. The check is unnecessary now though. A similar check was used previously because the generated name was based on a predicted ID before the Run was actually saved. Since it is now saved first, the ID is solid. Above (L1535) should be changed to run.setId(runStore.save(run)); though
DatasetException or a subtype would be better here.
We don't want to invoke setVds, because get the whole VDS object is fetched from db during saving audit log to db. If we invoke only setVdsName, then we can spare this unnecessary VDS fetch. if (host != null) { event.setVdsName(host.getName()); }
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
This looks very nice! What about adding a throws JSONException to the signature of getValueForOptionalKey() and parseImageLicenseMetadata() since you have the needed try / catch already in place for processPage()?
To be more explicit, should we throw an error here if "clean-on-flush" is specified without neither "flush" nor "flush-size" being present?
sysout???
I would prefer the method following the double-checked-locking pattern as applied in the pair of convertedType/computeConvertedType, given the fact that you went for a volatile optional already. Thanks.
map(Queue::getActualName)
Where all is the outer setAddress method used? The AMQP Properties section is part of the immutable bare message so we shouldn't in general be setting the 'to' address in it or creating the section if they weren't present. Exception might be made during cases like protocol conversion, but it seems like it should be explicit rather than a side effect that might see unintended use as here.
nit: if (p != null)
compare object instead of reference? Why don't we just always wrap it since it is cheap now?
What there is a random text?
use constant
SWT.VIRTUAL Tables/Trees are very performance sensitive, as they are used with a high (sometimes 1000+) number of items. Because of this we need to be careful of anything that loops over the number of items, as it can be costly. The item's height is always the same, so we don't need to call this in the loop.
I'd use .forEach
I'd prefer to remove the field itself. Feels a bit unclean to have a field which is only valid during the execute method. It should be a local variable in execute and passed as an argument to getTagTarget. What do you think?
make this method synchronized. just in case it gets called twice in same time.
use switch
I'm almost certain that this is intrinsically checked by the tracker since things are only captured for spawning if the spawn events are being listened to.
trivial: window/tumblingWindow
exception should say "could not" rather than "cannot"
Any reason this page specific logic can't live directly in PageFragment where this method is invoked?
Use String.format instead. It'll make the code more readable. E.g.  java String.format("%s://%s:%d/%s", protocol, host, port, path);
make sure to propagate cancellation to the completableFuture
![Codacy](<LINK_0> Issue found: [Local variable 'indexStatsMap' could be declared final](<LINK_1>
fullName can be null for an "Anonymous Coward". So this will NPE. We need to invert the order of the test.
I'm pretty sure this should be before if (getSupportFragmentManager().getBackStackEntryCount() > 0) { .. because if there is something on the back stack pressing the back button will not cancel the highlighting. you could probably combine it with the isCurrentlyMoving(..) call above, because for both states you will have to be in the ScriptFragment. I'd suggest something like this:  Fragment currentFragment = getCurrentFragment(); if (currentFragment instanceof ScriptFragment) { if (((DragAndDropInterface) getCurrentFragment()).isCurrentlyMoving()) { ((DragAndDropInterface) getCurrentFragment()).cancelMove(); return; } if (((ScriptFragment) getCurrentFragment()).isCurrentlyHighlighted())) { ((ScriptFragment) getCurrentFragment()).cancelHighlighting(); return; }  although I'm not 100 % sure if that is the correct behaviour now. can highlighting happen at the same time as drag and drop?
I believe you forgot renaming the variable name secureArgument while refactoring.
Component type for the inactive device exception should be DOMAIN_PUBLIC_LIGHTING here.
minor: since this one is not under a lock, could you use AtomicBoolean and compareAndSet()?
index
Iterator could return multiple items erroneously and pass.
this variable name is misleading, it contains not only the commandData but also Ne field (see also other ApduTest classes)
we don't use braces around single line blocks, many more occurrences in this patch
please add brackets to all of these ifs
Also check to make sure it "taco" still has symbol ID 15.
What about keeping the public constructor and instead adding the default properties if missing:  public HdfsSinkConnectorConfig(Map<String, String> props) { this(CONFIG_DEF, addDefaults(props)); } private static Map<String, String> addDefaults(Map<String, String> props) { ConcurrentMap<String, String> propsCopy = new ConcurrentHashMap<>(props); propsCopy.putIfAbsent(StorageCommonConfig.STORAGE_CLASS_CONFIG, HdfsStorage.class.getName()); propsCopy.putIfAbsent(HdfsSinkConnectorConfig.FORMAT_CLASS_CONFIG, AvroFormat.class.getName()); return propsCopy; }  The benefit is that the public constructor stays the same, just in case people extend this connector/class. Not sure if that's a worry. But it would reduce the number of changes where the constructor is normally used.
Proxy unwrapping should never happen in client code. Why was it done?
Should be a SamzaException with a message, not NPE.
It's so unfortunate that we cannot use try-with-resources with CommConnection, unless we wrap it in an AutoCloseable stream... But it will be for the next release
This defines what we are migrating from, and we are migrating from boxc3 data which currently uses the Normalization event, so you'll need to leave it as NORMALIZATION in this case
This doesn't work for an existing set of workbench windows.
why not just throw the error here?
Camel case
Do the methods need to be static?
The current flow doesn't set the job as healthy in the event that all the containers are from the previous attempt and there is no necessity to spin up a new one.
what's the reasoning behind this change?
There are not parameters though. I really do not want to go through and make these all final, since we have not configured checkstyle to do that. I also don't see a big benefit, as I don't think I've ever accidentally modified an exception reference in a catch clause.
because writer.put() can fail, you should enclose it in a try/finally like: try { writer.put() } finally { writer.close() }
You can extract a method to checking tags
We could merge this into a single line check. Remove the if else branch.
Please check your code formatting and save rules. I would expect the 'this' keyword for the calll to mergeOutputSettings().
@Nami this is still mutable na, only not by us. It doesn't guarantee that the original input map will not change.
I think logically these should be after the next paren, to keep the commit at the same level as the start of the transaction.
Why add mutating methods? Just put this in the constructor.
Do we ever expect this to happen?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
There is need to say anything using WARN that 'final' channel doesn't support interceptors
Add a null check, if it is null add a menu item or invalidate the menu. Find some way of adding the menu item back in the view
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
Does the operand really can be null?
If the flag changes to "visible only", then this will change to default "true". As this will have a possible impact to projects as they might have been getting some unexpected behaviour (i.e. the invisible components being updated). This will need to be identified as an impact in the change log.
Sleep might make this test flaky. Would it be ok to do future.get() here instead?
Injection constructors should be package private. Remove the public modifier.
This should be Repository.class. The method is supposed to return the list of adapterTypes, i.e., the types to which this adapter can adapt objects to.
should this say throws PatternSyntaxException ?
what is the difference between the gluster/posix tests here besides the storage type? if there's no difference..let's share the code.
if you do this, better put N/A :)
Please use StringHelper.isNullOrEmpty()
IMHO it does not need to be public
This can be a List.
Confused here - you can't remove it but you fire an event?
use subjectDataService.deleteAll() instead of this loop
I'd enclose url with ': log.debug("Redirecting to '{}'", url);
This looks like a functional change, not a logging change?
Create a constructor without the last field?
nit: parenthesis are extra
Assert fail here to protect the test. Otherwise if expecting exception is not throw, the test will still pass. It should fail.
This will probably not compile Why do you need a try catch here anyway?
Huh?
more specifically, it's going to try and use writerFor(JavaType)....but that's just a nit
Not sure if I just can't see it, but should we close the zkWorker if we get an exception?
FYIY, it is often considered bad style for a sentence to end with a conjunction :) How about this? By registering, you consent to us storing your data, perform scientific research, and publish it in a completely anonymized form. We could also link to <LINK_1>
It may be better to return an empty string here instead of null. Unless others look into this code, we may be pushing the null pointer higher. Thoughts?
The stack trace should use the same level than the message.
While getClients should have no initialization.
![MINOR](<LINK_1> Make this line start at column 25. [![rule](<LINK_2>](<LINK_0>
isn't that overriding the user pinning? needs a check does the rest code check if user specified index, is the node is set to pinning?
Wouldn't it be easier to use Mockito here? Or is there a reason not to use it for this test?
should use {}-placeholders instead of string concat
I suggest to move this a few lines up - we can put it into the else block for the headless check. No need to enable this when running a headless server.
Human readable strings belong in strings.xml.
I believe we should not ignore the NoNodeException here as the Stream/JobDeploymentListeners would have always created the modules node under the corresponding stream/job deployments path when the DeploymentSupervisor initiates the first time deployments for the given stream/job.
Returning ISelectionListener from this method blocks the possibility to add predicates in a "chain" like  addPredicate(p1).addPredicate(p2)  What was the reason for this change?
I believe that setters normally return the type/value they just set as well.
Please introduce a new method rather than adding a new argument that is the same non-obvious value almost everywhere.
If previousFormatParameters is empty you will enter this if while it used to not be the case before.
is it intentional to not have the suthdownLatch.countDown in a final clause? Current behavior is for server to keep running in face of error and for awaitShutdown() to continue blocking (i think). Not sure if this is intended behaviro or not.
It should be new TajoRuntimeException(new UnsupportedDataType(...).
Cleanup data after finishing the whole job, not an iteration.
The builder has a method: <LINK_0> that will copy the whole contents of a multimap, you shouldn't have to manually perform the copy.
This looks as if it were copied from the CVS one. Does HEAD make sense in a Git checkout anyway? The idea (behind CVS) was to not write out the 'default' one for everything that needed doing e.g. default to HEAD. Should Git default to 'master' here instead?
Request.State.OPEN
Looks like the 4th parameter is no longer needed. Since the PR targets master/, it would be fine to remove it altogether, no?
We always put "XXX is null" as the error message for requireNonNull
This implementation would be fine for the filtering because it is executed only once per searched value. But for building the bloomfilter at write time it has a huge performance penalty because it is invoked for every value. I would suggest keeping the different hash functions for each parquet primitives to support write time performance. You may implement a convenient method for type T to be used for filtering.
If not mistaken, exchange().getOut() has been [deprecated](<LINK_0> in favour of exchange().getMessage()
change variable to something more meaningful
!symbols.isEmpty()
Let's just inline Thread.currentThread() call here and below?
This test isn't testing anything.
This involves a look up of the character encoding type table. Use MessagePack.UTF8
Is this expected to be null?
path
map(Queue::getActualName)
there are constants defined for these strings.
You don't have to test if the hive is in the nether, because the nether hive is from binnie and not from forestry.
be backwards compatible
Using an enum as mentioned above, this would become if (savePaths != NONE) which seems cleaner to me.
have we change it in scope of this story?
Style issue: @Override shuld be on line above the method declaration
config is a non-primitive object, cast to Map<String, String> here before serializing and adding into the map; similar to how containerModels are added above.
Make this variable final
If I understand this "fix" properly, we were basically creating a new appender for each test, which you're now auto-closing. Plus, you're creating a new logger for each test. Would it be possible to just have LogFixture take in a level, and auto-generate the logger name, so it does not need to be passed in, even if just to avoid copy-paste errors?
This may not be thread safe if only one sender is instantiated. We probably only want one sender or at least only one httpclient.
No need to break as it is already in the while condition, or if we want to break before the while loop remove from the loop.
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
Wrong variable, should be memberResourceAttributesDef, but you don't use this lists later anyway.
ipAddress not set
This seems like a pretty weak version of hashCode(). How about using things like HashCodeBuilder to generate the hash code?
NullPointerExceptionis more specific. You can use Objects.requireNonNull(request)
Maybe add localName to the thread names? Makes it easier to debug when logs from multiple instances are merged into the same logging system
Are you actually using this anywhere, or are you just adding some flexibility "in case"?
Maybe it would be useful to change level to info. It would be hard to debug this configuration running on CI server.
nit: can we consolidate producerFencedOnCommitTxn to the more-general commitTransactionException? I.e. if you want to fence on commit, you just register the commitTransactionException as a ProducerFencedException
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
With set() and find() now bypassing Square and using Entity directly, should we have get() return List<Entity> ? That way the Square class won't have to be public, it'll be an implementation detail.
we don't search for primary email anymore
return new StringBuilder().append()....toString();
should GeoCodingConstants.COUNTRY_GAZETTEER_SORT_VALUE also be added as a secondary sort value to this list?
This relies on the order in which the properties comes back from the cursor. I think that's over-specifying.
GeneralFunctionEval can take TajoConf instance, so it may be not necessary.
This is neat! We'll have to remember to use it elsewhere!! :smiley:
Can you change to static variable ?
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
innerInterfaceOrClass checks parentType, but in line 236 similar check is performed. They can be merged in one method
Could be a try-with-resources.
We should use RemoteServiceInterface.FAILURE here as well. Also, we should create a contstant for 100 as well and use int respective tests.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Could we please replace these any() with eq() as we do in <LINK_0> ?
Please log this exception, maybe with a WARN level
Any reasons why this is a double-/?
You should always compare strings using the equals method in Java. Testing using the == method might only return true accidentally.
remove public
I would extract this logic (as well as some other logic in this method) in seperate methods. This entire method is 30 lines long. In my opinion way too long. This does not only provide better code readability but also code reusability.
simplify this
Stack overflow? :)
What if a student or unregistered user calls this endpoint?
Please externalize these strings.
Personally I prefer to set all fields using this. in constructors, but you call the shots.
Assert it
I think this should be "Unfiltered"
return result != null && result.getCoverage(CoverageMetric.LINE) != null;
suggestion LOGGER.error("ISBN { } not found at ottobib", identifier);  This is the recommended way
Collections.singleton() should be used here.
use default, no need public.
do not set the correlationId for the request. It is only applicable for the reqeust of the response.
This change is completely unrelated to this PR. Any particular reason for adding it?
Maybe rename to rootSelectionFields.
personal preference (aka your call)  return new InternalNodeProbe();  Rather than have the dumby constructors in InternalNodeProbe
Can we check first for the directory and afterwards try to load the class? There is no need to load the class, if nothing needs to be done.
Here merge gets too complicated. More readable solution would be: map.computeIfAbsent(year, k -> new HashSet<>()).add(geoAreaCode);
Inline occurrences
zoomIn and zoomOut code differe only in single line 'plot.zoom[Out](zoom)' please avoid code duplication
It concerns me quite a lot that this is a problem. This should only ever be a problem if the progress listeners do not work and the case 2 is not triggered. It shouldn't be fixed in this PR, but please add a FIXME here instead so we remember to follow up on it.
I think the old way is correct as these methods are public factories for the class and thus are logically part of the class' public API. Visibility is controlled at the class level. Similarly, if we have a top level package-private class, we'd make the methods public rather than package-private. In addition to being more clear about the public API, it's a one line change if the class later needs to become public (instead of changing / thinking about each method).
use a final boolean in <LINK_0> to the redundant check again
I saw @cmelchior remove this line last time?
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
[StringUtils.isNotEmpty](<LINK_0> will return true for " " strings as well. [StringUtils.isNotBlank](<LINK_1> might be a better choice. WDYT?
Don't change these please
use the ParseResult and location to store messages back to the user. In this case, url is a mandatory field and if it's not present, you can tell the user that it's missing
See if some of these updateFeedbackResponse methods can be private. I have a feeling you won't need them all to be public, at least now.
its kind of weird having this happen for every test. I'd suggest moving it down into testIsMarkedForDeletion. It would be good to test the negative case as well to ensure that everything isn't getting marked as deleted
(Hmmm, I think both the original and the suggested fix might be wrong. <LINK_0> ) I think for now, continue the pattern. Create an issue to investigate whether we're affected by the issue described.
SetPushSetupAlarm should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
You can also use something like return url.replaceFirst("^\\w+://", "");
Do you need to close the input or output stream? WRT: Invoking the close() methods on the InputStream or OutputStream of an URLConnection after a request may free network resources associated with this instance, unless particular protocol specifications specify different behaviours for it.
Do we validate spill actually happens?
Please try to use the same convention for the property value in this test.
the test seems only test the basic input, not the json string input as one column value, best to do adjust if i am right.
Same here. Add clarifying parenthesis
suggestion JarFile j; try { j = new JarFile(p); } catch (IOException x) { throw new IOException("not a valid JarFile: " + p, x); }  so that we do not need null checks.
truck is unused
@sbespalov : What is isLsm(...)? What doest this abbreviation stand for? Layout-specific metadata, or is it something else? If this is it, could you please rename the method, so it's clearer? Thanks! :)
It's really hard to come up with a name for this.. not happy with this because it suggests action with DO but doesnt specify the action. I am unable to come up with any better though. Will post if I do.
I think you are right, exception best fits this case :).
suggestion return Arrays.toString(value);
Since end is optional this will need an update I believe
rename variable to referencePointID
Why do you need another set? Just use fTagLocations to check if it is there or not
Why is there a fromByteArray method? Why not call the constructor directly?
Please use proper variable naming.
I usually prefer the depth comparison, a single integer comparison, over two String equality checks.
FWIW this can be written as: for(Account matchedAccount : rs) { result.add(matchedAccount.getId()); } The ResultSet<T> type is Iteratable.
I think an additional MongoDbFactory ctor would be useful too.
Let's be consistent and use DiskImage::isWipeAfterDelete here too please.
Once this works, I plan to check scenarios where the URL is changed, etc.
Is this supposed to be a valid URL?
These five lines should really all be in their own method, along with the parsing of the timestamp in the beginning.
Check for null, empty string, and "--" (after trimming leading/tailing whitespaces). These are considered no value and should not be part of ID.
It might look better to start the new line from the .show() instead of breaking in the middle of the arguments. Also note that you aren't breaking the lines in other places.
ProtocolAdapterException is not thown anytime in this method. Could be removed.
I tend to prefer having all code at the same level =>  if (0 != context.prepareSelect("select count(uuid) from quality_gates where is_built_in = ?".setBoolean(1, true).get(row -> row.getLong(1))) { return; } context.prepareUpsert("insert into quality_gates (uuid, name, is_built_in, created_at) values (?,?,?,?)") ...
Prefer return Objects.hashCode(blobName, contentLenght, committed);
wow, can we just keep totalLifespans and use totalLifespans.getAsInt() every time the value is used ?
This is now complicated enough that I would advocate moving back to non-lambda format. also needs { and } in if/else
can we check for value equality and not reference? equals. thx!
should this be in some MathUtils class?
How about inlining it?  if (!contains(o)) return false;
java8-isation [forEach][filter]
@rakeshadr is there a potential race here between setting the shutdown handler and checking if it is null?
any reason for explicitly invoking super.toMap() ?
normally we use italic text for info icons like this: numaInfoIcon.setText(applicationTemplates.italicText(message));
Add this exception in imports.
Put the deleteQuietly in a finally block, with the try just after the creation of the temp directory.
Not needed
This list should only contain expectedConceptEntity1's since expectedConceptEntity2's name is different.
just FYI: sometimes when i debug the code, i found seemingly redundant assignment before return very convenient. I know Intellij can help me if there was no assinment, but it's not nearly as convenient. (i don't mind your change here though, this is only FYI)
The ClusterRegistry also disabled authorization for internal caches, which no longer happens here. Was that an unwanted side effect?
make this synchronized.
Why setting Token or MID imply sent = false ?
only one of isJavaxScriptSource/isJavascriptSource seems necessary
Did you mean getImageFileName here?
Can be made package local
Can you use placeholders with {} for all arguments?
How about handling exceptions?
Enclose your blocks with if ... { ... } else {
I would use method reference as per below suggestion String[] nodeIds = logs.stream().map(NodeInstanceDesc::getNodeId).toArray(String[]::new);
Might as well cache this in a field. Might be useful to expose later.
essentals > essentials, if you were wondering
Suggestion: Consider to use getVmDeviceUtils() since you already added it?
Isn't a LinkedList better if we don't know the size (to reduce reallocations and copies)?
remove return val never checked. Suggest adding in log (info maybe?) if task is attempted to remove but not removed.
@szczepiq Is this really needed? [MockingProgressImpl.mockingStarted()](<LINK_0> filters already for MockCreationListener.
Why do you need the same log 3 times? Can't you just print the absolutePath? I would prefer not to add a lot of redundant information in the output of the log,
Should we have a wrapping try-catch block? What happens if there is an exception? Does it log or fail silently?
static?
This won't be how Jackson default handles a JsonProperty annotated method, it'll attempt to remove the Java bean prefix of get or is.
Is this the right thing to do since the flag isn't there anymore? It seems like it should be removed to me, since the behavior without fromPigAvroStorage set was to skip this section, which means that it would likely get picked up by the if (field instanceof List) { .. block below, which does a different transformation.
Do we have any existing test case for CMCleaner ?
Assert that the voided user is the currently authenticated user.
lowestTimeAxisOffset is used above. Looks like a bug in findbugs.
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
Why do we need frontend changes when we don't plan to expose Jobs in webadmin within its own view like other entities (hosts, VMs, ...)?
essentals > essentials, if you were wondering
I know that checkstyle is disabled for this project (not sure why actually), but the EMF Compare checkstyle config discourages ternary expressions, so I'd replace this with a common if statement here.
check response code.
This pops the back stack in case we have a (favorite) user in the db but e.g. the network is currently off. This is bad as we have enough data to show the user - it just might be outdated. Please, add a check whether mUser.getValue() is null and only pop in that case. Eventually, we would like the user fragment to show that there was a connection error and allow the user to reload the information as soon as they think they resolved the issue.
This is probably original copy/paste bug. We should check if Facility is present within the beans and not User, since we delete all Facility attributes here.
An early return saves a lot of indentation.
please remove else, code will be more readable
Unless you're seeing issues with the current logic I'd rather keep the order unchanged here.
invert
use BaseValidator
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
Why do you need to add this check here, but not this one ? if (!"".equals(adapter.getSearchQuery())) { showSearchBanner(); }
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
asserttrue
You can iterate over the entrySet.
how about making the delimiter a regex as well?
So we basically use this to bypass hostname verification?
Is there a way to "track" the number of consecutive failed attempts to open that pack file?
Seems we can do this in the if as well.
Hmmm this should've caused failures and yet it doesn't. It should be not covered by our tests, but that can be a separate issue. For now, restore this line back.
Can the error message be more descriptive?
nit: you can merge both lines above as checkNotNull will return the given argument
So... what's the purpose of this...?
extractGeometry converts code into GeometryTypeName and checks if it is GEOMETRY_COLLECTION on each loop iteration unnecessarily; let's check this once  if (input.readByte() != GEOMETRY_COLLECTION.ordinal()) { ByteBuffer buffer = input.slice().toByteBuffer().slice().order(LITTLE_ENDIAN); Geometry esriGeometry = local().execute(0, Unknown, buffer); return createFromEsriGeometry(esriGeometry, null); } else { <the original while loop> }
please replace with TextUtils.isEmpty (i.e. instead of the static import that's there now)
Is there a reason to create an ArrayList here instead of using Collections.emptyList() ?
Might it make sense to use the new @NonNull annotation on the parameter here, so that this check becomes obsolete?
How about "Access to folder '{}' was denied, therefore skipping it." ?
Also check data type, should be BYTES. Same for other classes
selectorExecutorPoolSize can be removed from this class.
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
You didn't add the macPoolCommand to 'executeCommand' of this class. Maybe I miss something, but I'm not sure how it suppose to work...
seems like this should be config.maxSplitSize
I think you can write this method as: int s = str.indexOf('*'); if (s < 1) return true; if (str.indexOf('*', s + 1) > s) return false; if (str.charAt(s - 1) != '/') return false; if (s == str.length() - 1) return true; return str.charAt(s + 1) == '/'; although that version does fail to check for the // case, but we didn't check for that before either.
Please remove all System.out calls in your code.
Actually the concept with id 88 in the test dataset is a drug and not a test, so this should be Drug Order type
remove finally {
consider moving the if to the addVmCinderDisks method.
Isn't it better to ensure that actionButtonPluginHandler.getButtons() always returns some (even empty) list rather than null?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
The "equals" method in this class is only checking the ID field. It's my understanding that equals and hashcode have to always return consistently (i.e. if equals returns true for two objects then they had better have the same hashcode). While I'm sure it's very unlikely that they would be different, shouldn't either equals be changed to check all these fields or hashcode be changed to only check the ID?
don't do this, instead, you should modify resources/log4j.xml
I'm a bit confused about this method. Do you want to output to files and to a json stream in the same compilation?
String.format
How to process the version like 1.11? I think it have problem. Can you use org.talend.commons.utils.Version, it implements the interface Comparable.
nit, adding parenthesis to the calculation so it is cleaner and safer.
Why not just return categorizeMutableRealmIntegerField(field)
InsertOrUpdateObject?
This textView can be named accountText
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
Don't change these please
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
are you sure we need to use OSString ?
Style-nit: Parens aren't necessary here around the new operator.
If it's suppose to throw an exception you need to call fail method or migrate to catchThrowable.
Why a buildClassDesc and not a registerClassDesc like you did for CTOR_DEF?
Oh, right, that was me. Sorry!
I guess this call is not really necessary. Because the current sort buffer can still be used in the followup small data after flushing the large record to file directly.
What was PMD complaining about here?
are you sure we need to use OSString ?
you should probably create the scheduler in the start() method.
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
Remove *************
This should be declared as CacheWriterFactory.
Why is hard to read generic coding used here?
Can be simplified  case1: pluginInfo === null => return RecoredNotFound case2: isBadPluignInfo => return response(instead of record not found) else return pluginInfo
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
This logic partly duplicates the loop above that is using GoImportOptimizer#findDuplicatedEntries. This leads to duplicated error message ![screenshot 2015-09-09 21 44 35](<LINK_0>
This is cleaner: return (student != null) && (student.googleId != null) && (!student.googleId.isEmpty())
One more.
isReportting => isReporting
hm... that's very wrong. I think we should split the string first (by spaces) and then use the second part only.
How about reverting negation?
Here it is going to depend on the resilience strategy ... so hard to say. I would drop the operation result assertion though.
Maybe better to return null
use this utils method to show error <LINK_0>
This can be static.
IMO, you can merge both ifs  if (rv == null || !needsUnboxing(ctx1)) return null;
You can initialize directly in the try
There is still the public parse method which returns plain Object. I believe we don't need it as public method here, right?
I would rather see this if being part of the constructor and not the getter.
List<Throwable> list = new ArrayList<>();
why is this needed if whole transaction is rollbacked, then table should be dropped as well, am I right? Also JdbcPageSink has not created this table, it looks fishy that it drops this.
this.monitor to avoid confusion with the parameter of the same name optional: this whole block could be a ternary: this.monitor = monitor != null ? monitor : NullProgressMonitor.INSTANCE;
this is generated client, please don't write anything by hands. You can update it only from codegen.
This shouldn't be commited
Unnecessary log.
This filter should be part of the "isDebugArgument" function to avoid an implicit coupling between the "isDebugArgument" and the cast to AssignmentExpressionTree. I would make the "isDebugArgument" to a "getDebugArgument" possibly returning null and then filtering on non-null values.
What is 3 (use a constant)
Then put an assert here? Just so there is an exception, that indicates that the connection was null.
\s+
Can we extract this repeating expression into a helper?
We name the boolean below isNonNestedColumn, what's the difference here?
You can use StringUtil.notNull() for this as well.
See getAllLifelines remarks
enforce the opposite in the other case?
Good idea. Will do.
Please replace this direct string 'voadmin' for ? and argument Role.VOADMIN.
Can this LOG/validation be moved to AbfsInputStreamContext.build() ?
Converting to Java 8 is fine with me Would improve the readability quite a lot for this.
Code changes look good. Here we should use Limits.DB2_VARCHAR_MAXWIDTH instead of Limits.DB2_CHAR_MAXWIDTH.
@merciesa maybe matter of taste, but why not i-- instead of i -= 1?
This looks like something Jack might optimize out (we're still using dx for Checker tests). Could you acquire the nulls through an inlined method and test the later constant folding? That seems more future-proof.
new ArrayList<>(causes);
ImmutableList.Builder<...>. You should have gotten a warning from IntelliJ when you passed builder.build() to newExpression.
You can also do  try (FSDataOutputStream stream = fs.create(new Path("s3n://test-bucket/test"))) { assertEquals(CannedAccessControlList.Private, s3.getAcl()); }
It's better to pass **ex** variable to fail() method to have additional info about the catching exception.
Isn't this supposed to create and return a new (not yet in the database) allergy?
Print a warn log if participant is null
you can use instead: return Version.v3_5.less(version);
If not inlined, requestedCount reference should be read into a local variable outside the loop.
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
Before, if there was an error, it would setToolTableJson(null). Now you don't set it at all. Do you want that? I don't know the answer, just raising the question. In theory, without understanding the whole flow, it seems like if there were already a value in that fiel, it would get cleared before your change, and now it doesn't. This happens in at least 2 other places (ran across this one first). Checking that this is as intended everywhere. Could very well be the bug fix :) But I'm still concerned about old values not being cleared.
we need to check if animator is not null and cancel it before creating a new animator
this can be set by user
I'm a bit picky here, but the tests would be clearer by replacing those 3 lines by a call to a method, such as  this.store = getStore(KEY_SET_A, KEY_SET_B); private Store getStore(Set<String>... sets) { Map<String, String> originalStoreContent = getEntryMap(sets); FakeStore fakeStore = new FakeStore(originalStoreContent); return spy(fakeStore); }  especially since there's a getCache() method to encapsulate the cache creation
Can we use method reference here: getBlocksLocalityWeightInternal(host, HostAndWeight::getWeight) ?
I see some improvement can be done here.Is it required to define method as synchronised.Can we use ReentrantReadWriteLock and get write lock here? It will be resulted in performance improvement
![CRITICAL](<LINK_0> Possible null pointer dereference in org.carlspring.strongbox.providers.storage.FileSystemStorageProvider.getArtifactPath(String, String) due to return value of called method [![rule](<LINK_1>](<LINK_2>
Do we really need to keep these here for backwards compatibility (i haven't checked)? It seems like even if we support the old mode of having this set on the entire project that this would be represented by a 'refs/*' entry instead? Perhaps this is just needed until the new UI is merged?
This will not insert commas as required.
I would log it as a warning not an error so Timber.w(e); Since it's not something very important and on the other hand not necessarily our fault.
it is safer to perform the comparison the other way: VmDeviceType.VIDEO.name().equalsIgnoreCase(device.getType()) no risk for NPE.
I'd add a check that looks to see if any of the aggregations contains an ORDER BY clause and bail out early if not. These rules get applied many times throughout the optimization process, so the no-op case should be as lightweight as possible.
This println shouldn't be here, really
Since Preference changes may occur due to outside stimulus, we should bail if getActivity() is null here.
I think that may have been an oversight in longSum. Try a query that results in +Infinity at the historical level and you will see why it is needed to deserialize at the broker level
We should add Assert.isNotNull() check here, to make sure that the new contract between hasAttribute and getAttribute is not broken unintentionally.
We're abstracting accesses to _parallel property by moving related implementations to ParallelControl. Why don't you move this direct access to _parallel property to the class by adding like ParallelControl#copyIfNeeded(Config src, Config dst)?
extracty should be extract (extractyAnnotatedFields)
!"import".equals(scope) should work too ;)
Is every managed table going to be converted to an ACID table on the replica? If not, should we just restrict those managed tables which will be converted?
Any reason to not use Collections.emptyMap() ?
why was this done?
Useless extra line
please move the setUser and setHost to connect (if _vds != null)
do we need to synchronize on 'this' or can we have a lock?
purge takes too long, just delete
you no longer need the second part in this if, right?
This whole logic is not supposed to be in the widget (expect the one which has been here already: subTemplateExpanderContent.setVisible(model.getIsSubTemplate().getEntity()); because this is a widget, it should only define the view and it's binding to the model. It is not supposed to manipulate the model, even less doing some real logic. Since the rest is a logic, it should be on the model (or better the specific model behavior). In this case NewTemplateVmModelBehavior
we should rethrow this as an IOException
This involves a look up of the character encoding type table. Use MessagePack.UTF8
I would use mMap instead of map inside of this method. Doing so makes it clearer that you are modifying the internal state of the class, not just some local variable
I prefer additional "(" and ")" to prevent errors in order of execution and enhances readibility. So : if ((requestBody != null)) && (..))
Can you wrap this? Maybe log locally and return just the message in a map of "error"->e.getMessage
Might be my math skills, but 5 + 20 != 35 ;-)
Can this (and other instances of "Entering Class.Method") either be changed to trace level, or removed in favor of a more meaningful log message?
are you sure we need to use OSString ?
This will fail if tree is disposed because view is closed already. Better: use PlatformUI.getWorkbench().getDisplay() which is always there.
Please use ContentPosition.isBefore here
Not every id record has an email address.
Are you aware that this very expensive use of String.format is executed every time, not only when debug is enabled?
do we care to check the length to be positive here?
immutable copy
we should use {} and parameters instead of string concatenation
Can't this NPE as they're Booleans (i.e. objects not primitives)
Not crazy about it, at the very least, clamp it.
I would remove this and keep the flow as it was before.
nit: you could also move all the setUpServerChannel() calls
We could shorten to one line return Optional.of(new Context());
No need for monitor.done() if we're using SubMonitor everywhere.
any null checks for plainText and secret neeeded?
use java.util.Objects.equals
Causes ctf tests to fail
partitions.length is final, because partitions is final, so this doesn't need the lock. Are you adding this to get a code analysis tool happy?
please remove else, code will be more readable
I think we may have FP in the following cases: python smtp1 = smtp2 = smtplib.SMTP("smtp.gmail.com", port=587) # FP smtp2.starttls(context=context)  python smtp1 = smtplib.SMTP("smtp.gmail.com", port=587) # FP smtp2 = smtp1 smtp2.starttls(context=context)  python smtp1 = smtplib.SMTP("smtp.gmail.com", port=587) # FP start_tls(stmp1) def start_tls(x): x.starttls(context=context)  To implement this properly, we would need a points-to analysis, which is definitely out of scope for this MMF.
Use Version.greater(). More reabale.
Since we're changing the exposed contract anyways as we rename the file, could we fix the visibility of this function as well? I know the visibility is copied over from the old location, so we can leave it as public as well. I'll provide a separate patch set for that then.
Use component instead of this. this in this context will refer to the WebViewClient object, not the Web component (which is what it needs to be).
why not null as value?
you're never closing this
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
It looks like there's a testSame() method you can use for this one.
GroupOperationException.
A dedicated method to check this would be nicer.
This method's logic appears to be an exact copy of serialize(Page page) except for slice = Slices.copyOf(slice); line. Would it make sense to extract this logic into a helper method and make a copy logic conditional on slice.isCompact() or have a boolean flag that tells whether the copy should occur or not?
Do you mind explaining the reason behind replacing contains with indexOf?
not sure if this change is needed. If you leave this in, you probably don't need any changes to IncrementalIndex
Being composite is indeed 1 criterion (as it makes preview useful), however I think another criterion is more about whether the rename wizard would show some options. I imagine the condition would be if (previewIsInteresting || refactoringWizard.hasOptions() { op.run(...); // show wizard } else { refactoringWizard.applyChange(...); // don't show wizard }
what is $$ ? please use ObjectUtils.objectsEqual(trustedService, other.trustedService)
You may want to test this with multi-line strings.
declare as final static or remove declaration.
add fBot.waitUntil(ConditionHelpers.xyViewerIsReadyCondition(chartViewer)); here too
This will forward the child's requests and will hang because the child doesn't receive an element and nobody is requesting more. I'd instead write this:  java Subscriber<T> result = new Subscribeer<T>() { ... } child.add(result); return result;
same nit: mockZkAdapter2 to 0, here and other places.
formatting and missing brackets?
Can just return true if it's incoming and fall through to returning false.
don't we want to copy the name from the model to BE?
Same here indent wise. sorry its annoying I know =(
simplify with conditional operator? java return handlers.isEmpty() ? null : handlers.get(0);
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
I think there's no need to copy the entry part of the array in order to compare it with DOT_GIT_ATTRIBUTES_BYTES. Instead use RawParseUtil.match() to directly compare the entry name
If this is called before recomputeDigest(), we will get a different description string than the original implementation. Is that you want?
This method can be simplified to  java if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) { return SupportedAbiWrapper.getSupportedAbis(); } if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO) { return Abi2Wrapper.getAbi1andAbi2(); } return Build.CPU_ABI;  Also is it worth wrapping Build.CPU_ABI in an array so that the output format is always consistent regardless of API level?
name can be null, causing compareTo to NPE if its on the wrong side. In these cases maybe treat the name as though it was "".
suggestion checkArgument(!env.getPodsData().isEmpty(), "Environment should contain at least 1 pod or deployment");
this.configuration = Assert.requireNonNull(this.configuration, "this.configuration"); We should use this pattern for each final param that is created by the constructor. By doing so exceptions in case of a null value will be thrown as early as possible
+1. That's the thing with these manual implementations - it's really easy to forget things.
Symmetry (throw)?
style nit: no braces around single line blocks
Should we add: Objects.requireNonNull(record)?
Remove Coinmarketcap ratesource.
I would modify this message to be is defined multiple times
Just out of curiosity: does this test fail with 60 seconds timeout?
WikipediaApp.getInstance() or change Context parameter to WikipediaApp subclass.
consider to consolidate into a single if block as both do the same, unless there is a particular reason.
setName(newName)
This can throw if there are no principals. It should probably have an explicit check to throw a proper error message
Should this constructor one just delegate to the new one with Function.identity()?
You can make this method private
This String should correspond to the name of the called method. suggestion throw new PrivilegeException(sess, "getResourcesWhereUserIsAdmin");
You should use ThreadContext.putAll() here.
This could be considered a strange implementation of MVP; as your P is calling V.init(..) which then calls V.setup() which then calls the P to call the V to setup some UI elements. Why not have P call perform the complete setup rather than have the V call the P to call the V to complete setup? Or did I miss something?
This line of code, view.getOverlay().add(this); is repeated in every single HighlightDrawable. For symmetry with ViewHighlightOverlaysJellybeanMR2.removeHighlight(), why not just put this into the ViewHighlightOverlaysJellybeanMR2.highlightView() method?
I don't see why we need these sorts of constructors... We've never needed them before, and there's nothing special about the useLayerNormalization arg (it's just another boolean)... unless I'm missing something?
My personal preference is to use brackets even for one line loops and condition. Not a blocker to merging.
I don't know if this is the correct operator, what if there are multiple instants? .single() would throw an exception if there were more than one element.
@lautarobock I believe there is a need to forward exit call on the Pass instance corresponding to the index.
You may have just copied this over, but is there a reason this returns null instead of forwarding the result like the previous method?
nit : consider expected size = 2
The defined contract from the API might not be fulfilled: "The repository implementation must ensure that subsequent calls to {@link #getFeatureState(Feature)} return the same state as persisted using this method." A subsequent call might return the old value until consumer catchup.
fValueUpperCase is derived from fValue so it does not need to be considered for hashCode() and equals().
Should be a SamzaException with a message, not NPE.
Put suppress warnings annotation to method and change to direct returning the getted value to avoid temporary store the return value.
What about synchronous call? Also there are several places where we call logout (for example see login() and loginWithFacebook). These error codes are not handled there.
extract to constant, or even better, have something return the base quark to use for edges, so that analyses don't need to know about this path.
nit: if (p != null)
the new code that are added to the SymbolicRewriter are far from straightforward; could you try to spend some more time to polish it?
Please extract Globals.prefs as a constructor argument (probably replacing PreviewPreferences) as we want to get rid of Globals as much as possible.
white space after return
One more minor change, that we could apply in general from now on: Use org.candlepin.util.Util.toDateTime() to as a utility converter from Date to OffsetDateTime
Add newline before return.
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
Might I suggest changing this to something like playerMsg(player.getName() + " is already OP!"); (I havent put that into an IDE so you will need to, but that just looks cleaner I think)
Isn't a Set better here? The keys will be repeated across stores.
final This should probably contain this.value = value at some point... and it should only do so if isListening = true.
typo
1. Did you mean support only Firefox for _testing_ right? I assume the difference in behavior affects testing only? In that case we should keep the production code clean and apply any workaround in the test code. e.g. do an if-else based on WebDriver. 2. Yes, I think at some point we stopped using Chrome for testing. There are many other quirks between the two versions that gets in the way of comparing html. We can check if anyone is using Chrome.
Input an empty list?
this can be moved into the else block
else is unnecessary here, since when previous 'if' is true, we jump out of the method. extract vmNamesList.size() and removedNetworks.size() to variable so it's not calculated multiple times.
double check that no group has been created and maybe that the default anonymous permission are still here
Why not make the test timezone-independent by either calculating the correct long value for "00:00:00" based on local time, or changing the timezone of TmfTimestampFormat.getDefaulTimeFormat() to GMT in the test case.
Here and elsewhere, the Fragment probably shouldn't force the host to do things by getting its internals and changing them. The dependency on a toolbar is clear because of the callback pattern but exposing the toolbar directly allows any Fragment to change it. It's ok to defer but consider pushing onSearchOpen() into the host and allow it to hide / show the toolbar.
make BUCK a constant
Is it correct that this class uses CryptoMigrationUtil instead of the StudioEncryption class?
StringBuilder
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
this seems like an unnecessary step - let the factory do it or better yet, let the constructor of the CryptoJobHandler do it?
this method should return Response
Met List:  @Override public boolean inputsAreConnected() { return inputs.stream().allMatch(ConnectionAnchor::isFullyConnected); }
please use error level and log also whole stacktrace from exception (use exception object as a second argument)
findValue(x) searches x recursively in the node, or its children. Is this really what you want here? I think you should use get(x).
Make static
Just asking: Should this happen, that null is passed? If this is the case I think we should think about passing an Optional object to the method.
In general with these kinds of callback-centric workflows it's pretty dangerous for the way that the callback to be completed to rely on the callback being handled in this kind of manner. (sorry, clicked enter too soon, elaborating)
public static? Is that keyword ordering important in this codebase?
It might not always be a lambda - someone could implement their own concrete flow.define(). We should check bean.getClass().isAnonymousClass if needed, but I suspect we don't need to know whether it's a lambda or not.
nit: you can merge both lines above as checkNotNull will return the given argument
Did you check here what happens if you don't pass ldapServers parameter to cmd line? Do you get an empty string, or null?
This one is not necessary, the next statement already returns.
wtf?
I agree to Robin's proposal
Would it be better to use:  java if (thing == null) { continue; }  If there are two factories that could create the thing, you will return "null" here and do not try to use the other factory.
merge else if?
Shouldn't we avoid the asset keyword ? Are we sure that Eclipse is started with the -ea switch ?
Maybe we should derive this from Prefs.getMediaWikiBaseUri() or require the client to pass in a default protocol. I think I prefer the latter to avoid complicating this nice and simple model type.
can't you use constants.empty() here as well?
String name = StringUtils.EMPTY;
I think we should make it file(s)
I would replace this if-else with ternary statements to make it shorter. but that's a matter of style - so just consider it
Need to declare the adapter type here, too.
you should check if the message severity is ERROR
I think I prefer "Invalid key" as exception message
This test show our STRICT mode is not ok, as if we respect strictly the specification resuming session should not be allowed. the spirit of the rfc is same epoch/same connection.
The Scan constructor throws IOE now?? Not an issue for this patch, though
an opened repository needs to be closed in a try/finally. these are reference counted resources that could leak in memory if its not released after use.
Can return directly.
Optional: use a StringBuilder here to avoid String.format entirely, and pass that StringBuilder as an argument to toHex.
Moving that bits above and allowing the user to change the decorator via a public setter means you can completely shadow what AbstractTransactionSupportingCacheManager used to du using public API. Also, if CacheDecorator is a first-class concept, you should probably expect that more than one decorator can apply at a given time. This wrapping shouldn't be the responsibility of the caller.
- ImmutableMap -> Map - formatting  Map<VariableReferenceExpression, RowExpression> dereferencesMap = expressions.inverse().entrySet().stream() .collect(toImmutableMap(Map.Entry::getKey, entry -> castToRowExpression(entry.getValue()))); Assignments assignments = Assignments.builder() .putAll(identityAssignmentsAsSymbolReferences(source.getOutputVariables())) .putAll(dereferencesMap) .build();
IMHO it does not need to be public
shouldn't we use Builder here. coz, no one outside the package will have access to constructor.
Should have a different identifier than RenameResourceProcessor.
@fanifieiev ResponseOf is a better name than RsOf.
This logic is perfect, but for a while I got confused with connection being Connection and this.connection being AtomicReference. Can we rename connection to connectionRef to indicate AtomicReference?
do we need to return the whole stack as the result? that seems a bit much to the user. how about just the message as before and log the exception?
there is a function in DiskReformatter that you can move here maybe.  /** * Deletes {@code location} * @param location the location to delete * @throws IOException if there are any problems deleting {@code location}. */ private void delete(File location) throws IOException { if (location.exists() && !FileUtils.deleteQuietly(location)) { throw new IOException("Could not delete " + location); } }  Would this implementation do the same thing?
Use Logger instead of System.out.println
0 is a legitimate option value for min. selectable choices. Why not -1?
I think this is good for logging purposes and metrics collection. As for the fault detector I think it should ultimately evaluate the end-to-end metrics and not just IO. Why not gentrify this to also capture rpc level stats?
If no dbname is available, won't this try to write one anyway?
possible NPE
can the inputStream be null? If yes, than what will happen to convertStreamToConsoleConnectionDetails if you pass it null?
2 or 3?
I noticed the change to the enabling/disabling of conditional nodes. The explanation above is not clear to me. Can you please rephrase everything in a new explanation?
Might as well just pass this event type to createEvent instead of EVENT_TYPES. Also, shouldn't the event type begin with EVENT_NS?
fos can be inside try ()
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
without **a** 'MessageHandler'.
Add a message to checkState so that it's easier to debug if we ever hit it.
Iterables.filter(fEntries, CounterTreeViewerEntry.class)
You added a parameter but this command is also used from other places, so this will cause compilation failures.
Shouldn't use t=0. Anyways, I believe all new attributes are already initialized to nullValue by the state system.
I would prefer to have this as if (!approvals.isEmpty()) { ... } with the block at lines 176-184 moved inside the if-block, rather than having the return statement. This is just a style nit; I'm not going to insist on it if others think it's OK like this.
This variable is not used.
No one is passing to command a storageDomain, it is usually ""
Really minor and not something worth blocking this over, but would you mind renaming this to cuCtx or similar to indicate that it's not actually a compilation unit please?
Missing call to super implementation of onResumeFragments()
You can rewrite this with try-with-resources block
I think you try to reinvent here executeWithRetry which we use in other places.
change variable to something more meaningful
Thinking through this logic and I'm not sure whether this is the right thing to do. This will return an empty report for the attribute if any one of these individual value reports passes (by returning no violations). Now that we're validating each value individually, there could be other reports for failed values later in the list, right?
True. I've never seen a case with -1 as the default. 0 has special meaning in the JVM, so best to stick with 0 as the default and adjust the size to cope (add one or size 0 -> -1)
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
please move the isEmpty methods to the scimSchema
Exception is occured! Retry. - > Exception occurred!
minor: doc
I'm fairly certain that you could replace all of these with method references. e.g.: .map(this::convert)).
Can you please add a message, so the failure looks human-readable?
You could probably use the same URL as in getResultById here.
we should really avoid exit at middle of program... better use conditionals and/or divide to smaller functions.
unnecessary semi-colon ?
If opening is true, doesn't it mean it's still opening but not done opening yet?
Does this need to be a singleton?
Even this is not necessary. This is not really hiding anything.
When opening a trace in the unit tests, the resource is often set to null, it is not required. But then we'd have to see where the supplementary files are stored... (path of the state systems of analyses generated for this trace), so that we don't have orphaned files. Does having the resource make the supplementary files deletable?
== -> .equals or better, just lift this logic into the place where you set printStyle to TEMPLATE_STYLE_ZPL
@weisebrazil all indentations should be 4 spaces, not 8.
Standby task should never be in RESTORING since we always transit from CREATED -> RUNNING -> RESTORING in one call. Did you observe this was not the case from failed system tests? Even in unclean close case you described I did not see why it could be possible..
Should we try/catch here and return a 500 when the delete fails?
first instruction
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
Let's use a more descriptive name than things.
A lot more vals please
IMO makes more sense firing the CommandRegisteredEvent from the registry component (getRegistry().register), instead of from this RequestCommandMananger class. So any other component that is using the registry API will also take benefit from this, as the event will be fired internally.
at least or exactly one address?
Please use RestJmsSharedBaseIntegrationTest.assertClientException for negative tests to check response HTTP status and error messages.
Perhaps we should name this directory _resources_...?
be a good citizen and call System.exit too :wink:
This is impossible, blockLength is an int.
Why did you add this parameter? It always has the exact same value as the other. So maybe just drop it?
use return ... ? ... : ...?
is this supposed to be result.toArray(...) ?
Is this equivalent to org.ovirt.engine.core.common.businessentities.OsType#Other ?
Does it work? Aren't we still skipping the access token lookup even it's still valid?
add null information
There's no locking on this? Also, isn't this the functionality you wanted in the Facade layer?
@pohh just to make sure I have this right - here's my understanding of the general Wear lifecycle: - User must start the oba-android app at least once to start the NodeService service. After this, NodeService will continue to run indefinitely in the background, even when the oba-android app is not running. - When the user interacts with the oba-wear app (running on the Wearable), oba-wear passes messages to the NodeService in oba-android to fetch starred stops and trigger API calls, which passes the resulting data back to oba-wear. Is the above generally correct? If so, I guess NodeService would need to be setup to run on device boot as well, perhaps within [BootstrapService](<LINK_0>
See my commend above about upstreamDataSize.
I feel the variable names are a bit confusing. I'd like to rename them: numWorkersToSync -> numWorkers (or numExistingWorkers/numRunningWorkers) numWorkersToRelease -> numWorkersPrev (may differ according to the previous one) How does it sound?
Debug log.
Earlier in the file, a semantically same variable/parameter is named localBlogId. I'd suggest naming those two the same. I think that localTableBlogID is the more suitable name so, may I suggest renaming the parameter of the refreshUsersList() method above? Cheers!
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
I don't understand why you verify if filterChain needs to be updated with every message read. Maybe filterChain should be volatile.
fOffset = offset?
I would prefer to combine this with the above loop. Make the above loop use this for construct so it iterates all groups, and then on the if (c.isOwner()) line also add a || c.isVisible(). Move the isVisibleToAll check into the GroupControl.isVisible method.
Don't we need to hold onto the result of FileSystem.newInstance(path.toUri(), conf.getHadoopConfiguration()), which is a closeable FileSystem object, and then close it in close()? I'm not sure whether we need to hold onto and close the FSDataOutputStream instance, if it is already closed in the DataFileWriter instance.
make this final I think
use != null. the config getString(a, b) form returns null if its undefined.
Have you intentionally omitted index check?
suggestion private <A extends Annotation> Optional<A> getAnnotation(Class<A> annotationClass) {  Avoids the "suspicious call" warning on annotations.get.
missing space after if
Sorry we missed this before, but ThreadLocalRandom's nextInt() upper bound is exclusive. Could you change all these to 10001
I don't think args can ever be null, can it?
rename to val or v
No need for final parameters?
This local variable is only used once. Please consider collapsing into lint 1122. Also, please add the message from the exception to the message to provide greater detail for debugging efforts.
Can be simplified as "return (authheader != null && authheader.startsWith(Constants.BASIC_AUTH_HEADER);"
CODE_200?
I missed this... we should at least log the error if something went wrong
Do we need to throw the exception here?
why would this be required again?
filters.addFirst(filter) ? <LINK_0>
unused
Maybe instead of loading from the database using duplicated code, we do byId.get(pn.getId()) ? Its a recursive load through the byId cache, but then we share the same ProjectState in memory and don't duplicate it. And we're not duplicating the logic of how to construct a ProjectState from the database.
the key set will be modified in #newEnsembel(). It seems to me you have to create a new set from current quarantinedBookies's key set
I'm wondering if any code be moved outside this try block to clarify what can throw an IOException and what can't.
Could you please explain why has this number changed so drastically?
Could you keep it as it were? Thx
This check is redundant; the projection in the query is just 10 lines up and there's only one column.
This will probably not compile Why do you need a try catch here anyway?
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
No need to do this, long strings are fairly common and the checkstyle configuration accounts for them, so they shouldn't trigger a warning.
The cleaning case is handled in buffer == null branch on line 137 below. I would expect to add also closing of input stream there, where the output stream is closed: try { in.close(); out.close(); } finally { [...]
We don't really need the { and } here.
This can be static
If you're going to break this, add moustaches {}.
You could just do a toolSection.some() in the test, the EObjectQuery.getFirstAncestorOfTypeContract is to give you an Option with an element of the asked type inside.
Should just return properties.get(), the containsKey() call is redundant.
registry has a getAll(Class) which will mitigate the need to run through the following sync block
After trying it, we would prefer that the black highlighting would be drawn with two lines. The reason is that when the 'real' state interval extends beyond the window limits, a rectangle highlighting gives the false impression that the state starts and ends at the window edges. We tested this code which seems ok: gc.drawLine(rect.x, rect.y - 1, rect.x + rect.width - 1, rect.y - 1); gc.drawLine(rect.x, rect.y + rect.height, rect.x + rect.width - 1, rect.y + rect.height); Or I guess alternatively you could draw the highlighting rectangle first then fill the state color which would overwrite the left and right edges...
To note potential further benefit of a value object, a value object for bonus type could encapsulate this logic and remove redundancy, eg: if(rule.getBonusType().isOldArtilleryRule())
Bit of a strange message, maybe something like: "No user currently logged in" or "No currently logged in user"
Instead of defining this same block twice, do the logic check on opaqueUser above and save the user principal (or null) in a local variable.
Please use SUCCESS_NO_ALERT
static?
It would be more type-safe to do something like jsonMapper.convertValue(parser, JacksonUtils.TYPE_REFERENCE_MAP_STRING_OBJECT), on a parser you create using a normal constructor.
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
Request.State.OPEN
This branch can be extracted into a static method? I noticed the same code appearing again in a test class below.
I don't get this method name.
Please change this to follow the pattern of using an externalized string
We cannot assume all UUIDs represent Item objects. If you look at the original code, DSpaceObject is the thing being indexed. This is because Communities and Collections are *also* indexed in Discovery (so that you can search on their names/descriptions).
I would prefer IllegalStateExceptions in such cases.
explain this
can drop times(1)
Please use ? ternary operator
it is better to have a log here
not sure why keeping track of removals and performing the line above does anything given that searchResult is not added to results inside this logical block.
This will need to be revisited to throw proper exceptions.
It seems this check is not necessary because it is covered by the scheduled.compareAndSet logic.
checkState
Add a private final stripeMask field that is initialized to stripes - 1. This will eliminate an arithmetic operation from this hot path.
Same add/offer issue.
Are we happy to have a ClassCastException here or would it be better to check the type before the cast and throw IllegalArgumentException?
same filtering...
Use the activePlayer object instead of retrieving it again
make this synchronized.
I think this one could be private
If this can retry it is not an error. Suggest just throwing a RE and letting the retry wrapper handle the logging
shouldn't the delete be made at the beginning of test? maybe test both cases (one where a pre-existing version of the doc exists => update, the other where it is deleteIfExist => insert)?
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
Since each person's ID is different, the list can be optimized by returning true for hasStableIds(), ex:  @Override public boolean hasStableIds() { return true; }  Explanation [here](<LINK_0>
why are we changing the visibility of these methods?
The management of the enabled radios is currently in 4(?) places in this file. Although the cases aren't too long, it may be worth extracting them as a method.
Give tvp1 names that describe the data it represents: key or value (tvpKey1, etc.).
Better to use the pattern described in "Unknown progress" section of <LINK_0>
Why the conversion to array? Also probably better to use the log call that only creates the string if the log level is high enough, but it seems the SLF API doesn't support that.
Don't forget to delete this
please use a for loop
This can be removed.
When testing, I got an NPE when studentProfile is null. This needs a non-null check. Also needs a test to prevent that from happening again.
no need to add the same message to the secondary location
Please use any(State.class) with never() to be more reliable
Should one of the following happen in case contentType passed is null? - throw an exception, or - set this.contentType = null
If opening is true, doesn't it mean it's still opening but not done opening yet?
Did you take a look at this? <LINK_0>
How about inlining it?  if (!contains(o)) return false;
IMO, it is better to keep the private static string label for the error message, having strings like this is not good for maintenance. What about having 3 static strings  private static String EXTERNAL_DEPEPENDENCY_ERROR_TITLE = "Class ''%s'', is a class from external dependency. . You should not use it as a"; private static String EXTERNAL_DEPEPENDENCY_ERROR_RETURN_TYPE = "return type"; private static String EXTERNAL_DEPEPENDENCY_ERROR_ARG_TYPE = "argument type";  then we can have a method like getErrorMessage( EXTERNAL_DEPEPENDENCY_ERROR_ARG_TYPE) to use the error title with what ever ending string we need.
you could do getNbPackets()
ScanQuery -> ContinuousQuery
@ivange94 what happens when importing an invalid templ? It shouldn't blow up. The user might know what to do with the right Info's ;)
please just reverse this condition (switch if and else blocks to avoid negation)
No need for try..catch
please remove else, code will be more readable
Did you consider to make this return Color instead of Integer?
Here is another use of sorting via TreeMap. It's just a debug method, but I don't like the functionality change
latch
return new StringBuilder().append()....toString();
Please add spaces next to the + sign
declaredOuputStreams is too verbose. the variable/method can be outputStreams/addOutputStream.
This methods should return the index of the max/min axis: x = 0, y = 1, z = 2, but it would probably be better to remove them from the interfaces.
size is calculated here. Do you want to change sizeCached to true?
:notebook: [System.out.format](<LINK_0> may be able to help here
@fanifieiev RequestOf is a better name than RqOf.
READ_EXTERNAL_STORAGE was added in API level 16, so this check should will fail always in < 16. Can you check this on ice cream sandwich?
Maybe better to return null
remove unnecessary checks
minor: simpleName() != null could be extracted to isAnonymousClass method, so the intent of the test is more obvious
We should check delay!= null before calling toString().
WordsEnvironment.getObject() should throw this error if the object isn't found.
Is this line formatted?
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
both filtering methods should also be abstracted I believe. edit: by both I mean this one and the one above. the only difference being && or ||.
Why not use MethodMatcher for this?
return new BillTrade(...)
What is this for? Feels like some unintended checked in code?
Instead of declaring capturedImagePath as global, you can declare and initialize it here and pass it to CheckAvailableSpaceTask(), look the answer of [<LINK_0>](url)
This should be package scoped, not public.
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
Please double check in decision table with multiple outputs and invocation header cell where BKM name is filled.
why not simply check whether domainModel oder domainModelReference is null before?
This change does not seem necessary for this PR. I would like to know why this line was changed.
suggestion Stream<URL> resourceStream = Stream.of(classResources, contextResources).flatMap(Collection::stream); // Accept resource that doesn't contain // 'jar!/META-INF/Vaadin/config/flow-build-info.json' URL resource = resourceStream .filter(url -> !url.getPath().endsWith("jar!/" + tokenResource)) .findFirst().orElse(null);
Nit: No need for final.
A List<String> would probably be simpler to use as return value
Unneeded parenthesis. You probably can one-line this method anyway :)
Wouldn't this be problematic when detaching the network from cluster and this code will run?
From disk cleanup, it looks like it takes ~1 hour (up to 2 hours) to remove ~1000 project directories. Removing 1 directory would then be about 3.6 seconds, if this scales.
Yes, the change @yfarjoun suggests is needed to address <LINK_0>
I think an explicit check that the argument is present is better than extracting an optional value to present value and then back to Optional. java Optional<Argument> argument = ctx.findArgumentFor(propertyType, propertyValue); if (!argument.isPresent()) { throw new UnableToCreateStatementException( String.format("No argument factory registered for type [%s] for bean property [%s] on [%s]", propertyType, propertyName, bean), ctx); } return argument;
I think these variable names should be changed to be the same as the field names now.
I think we need replace op too for updating existing
The key should be sourceEntries.attributes to match the names returned by the web service.
As you rely on semantic anyway, I would rather check if owner of method is abstract, that would avoid a loop. Moreover, what happens when there is no semantic ?
Perhaps single quotes around actual code
What I mean is: we should accept metadata records if at least one author full name was defined.
In theory, this is not the JMSCorrelationID. The JmsMessageReader generates a new CorrelationID if none is received via JMS. So it is more the Scout Correlation ID.
Shouldnt we have this defaulting to the common namespace (ICommonAttributes#COMMON_NAMESPACE) so that we can tell the user what this defaults to?
Can you confirm that those four Concepts are a mix of retired and unretired Objects? You should prove that this setMembers contain the unretired concepts.
Is there any reason not to compile now in the constructor as well so compiledObjects is fully initialized?
rename src - sourceFile dest - destinationFile
The description states "The test shows that attributes of features returned by JDBC-FeatureWriters are ok if retrieved via {{feature.getAttribute(index)}} but are {{null}} if retrieved via {{feature.getAttributes()}}." But I don't see any call to getAttributes() here? Is the test actually failing if the change above gets backed out?
code format
This is not right - we need to tell the receiving side that the transport did a String-to-bytes conversion so he can reverse it. The original content type is saved off in ORIGINAL_CONTENT_TYPE_HEADER and restored by the receiving side.
suggestion if ((entity.getCamoCategory() != null) && !entity.getCamoCategory().equals(IPlayer.NO_CAMO)) {
What else can this be?
Unhandled
there is already a constr, which takes (id,groupId,resource, dataSource,interval) Can we use that in indexTask, instead of adding a new one ?
Unnecessary log.
Don't do this. It is not a good practice to change the field in an object (although it is public). Try shift the logic before the building process
throw RuntimeException?
disable table has some validity checks, should this?
Need to change the name here too
Replace 'commit' with 'committed'
prop: It seems like we do not need statefulTasksToRankedCandidates anymore. We could directly build tasksToCaughtUpClients from statefulTasks, clients, and configs.acceptableRecoveryLag. Also in assignStandbyReplicaTasks(), we only use the keySet() of statefulTasksToRankedCandidates. So, we can remove statefulTasksToRankedCandidates.
The test case description is misleading here. Write as "defaultTimeStamp for updatedAt date" instead. Similarly for the createdAt date test case.
And then else if this
I don't understand why you verify if filterChain needs to be updated with every message read. Maybe filterChain should be volatile.
Since you're only going to be using the fact that these get pressed, consider just passing Events instead of Booleans. (Igneous.joystick2.getButtonSource will give you EventInputs directly.)
Use direct check, not callback
You could use org.kie.workbench.common.stunner.core.util.StringUtils.nonEmpty(..) (but how was you to know!?!)
nit: Appending a char instead of a string with one char would perform a little bit better suggestion result.append('\n');
Maybe you can .map(line -> line[0].toUpperCase().trim()) and then filter/collect?
It's usually bad practice to mutate passed in data. Can we return a Map<JobName, Status> instead? Also, if we do that, we don't need a Collection<Job>, just a Collection<String> of qualifiedJobName.
You shouldn't use 'Z'... it's just Z it is the flag for the timezone. 'Z' is UTC, but if I put +03:00 it's also valid ISO.
Wouldn't it be better to wrap and throw as a RuntimeException instead of suppressing with a log message?
is this something like /system/tasks ?
Not sure about this; I'd class Error as normally fatal as well (e.g. OutOfMemoryError etc then all bets are off).
These five lines should really all be in their own method, along with the parsing of the timestamp in the beginning.
v1
Shouldn't "py4j-0.10.1-src.zip" need to be in the array for in case of spark 2.0.0?
Add this to WireMessages localization resource
this validation shouldn't be here I think so
never catch NPE
Should this constructor one just delegate to the new one with Function.identity()?
why is this done again? looks like it was done already in line 111
good practice: usually actions go before WS as they are injected into it and so they are grouped together
Sorry to insist, but it is not only the setExecutable method, setReadable and setWritable don't work either the way you want. They can only add permissions, but not remove them. Only alternative before Java 7 is chmod, or some native code.
item.getSummary() returns unparsed text, not HTML...
((Server)server).setModuleState(temp, state) is called twice in this loop
wtf?
unrelated change
Why guava SettableFuture over java8 CompletableFuture?
nit: extra line
I don't think args can ever be null, can it?
I'd like to have a dedicated method for Class/Interface/Enum/Annotation checking. Something like TokenUtil.isTypeDeclaration(tokenType)
hashCode -> System.identityHashCode
There should be a check of scheme here i.e. 'org.edx.mobile.innerlinks' before getting the relevant data.
Please use the form given before
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Can be moved to a constant.
use return ... ? ... : ...?
Instead of using large number this should be function on total executors requested by topology.
Not very readable. Also, did you consider DictionaryBlock constructor that takes idsOffset instead of copying the array?
Remove
why not put image?
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
Maybe I'm being daft, but where are the CDA message being added?
if withTracker returns the generic type of the OperationContext (C in your implementation), then is it necessary to include the cast to CreateDirectoryContext? It just doesn't seem clean. edit - I looked into it and figured out the issue. Poor use of generics. Change the class definition of CreatePathContext to remove the need to cast old: java public abstract class CreatePathContext<T extends GeneratedMessageV3.Builder<?>, K> extends OperationContext<T, CreatePathContext> {  new: java public abstract class CreatePathContext<T extends GeneratedMessageV3.Builder<?>, K extends OperationContext> extends OperationContext<T, K> {
SERVLET_CONTAINER_SERVICE is never put into attachment which causes test failures.
this should call getView(event).expandNodeForGroup(group); instead
nit: Consider putting into a function instead of the redundant checks?
Does this mean the default behavior is to store tokens in ZK?
The return terminates the if - you should remove the else
This can delegate to the two-argument createSystem variant.
I think you need another null check on the file here to protect against an NPE
Double* variant of this class uses object == null ? null that is better
why is it required to save the data to db twice in this flow ? see also in line 103.
Is it ok to go from WAITING straight to RELEASED?
This is unnecessarily slow when change != null and we know the branch name from the change object.
I made some modifications to this part (*rewrites everything*): private static final Pattern WILDCARD_PATTERN = Pattern.compile("\\*"); public List<Integer> getQuarks() { /* Get the list of quarks to process with this path */ String[] paths = fPath.split(SPLIT_STRING); @SuppressWarnings("null") @NonNull List<Integer> quarks = Collections.singletonList(IXmlStateSystemContainer.ROOT_QUARK); try { for (String path : paths) { List<Integer> subQuarks = new LinkedList<>(); /* Replace * by .* to have a regex string */ String name = WILDCARD_PATTERN.matcher(path).replaceAll(".*"); for (int relativeQuark : quarks) { subQuarks.addAll(fStateSystem.getSubAttributes(relativeQuark, false, name)); } quarks = subQuarks; } } catch (AttributeNotFoundException e) { /* * We get all attributes from the state system itself, this * should not happen. */ throw new IllegalStateException(); } return quarks; } * If you use a regex many times, it's faster to compile it beforehand. * You can use .addAll(Collection) to add all elements of one Collection into another. * Moved the 'try' outside of the for loops. AFAIU, you should never hit the exception in normal behavior. try has a slight performance impact, if possible it's better to not do it every loop.
Please add { and }
There should be a null check on this.
if i get it right: if response is null, we will not retry. i think we should retry even if response is null. btw what caused this in your case? so it would be:  response == null || ....
RestRepositories generally don't return JPA entity objects. They return RestModels. So in this example, it'd be BitstreamRest that would be returned.
How about inlining it?  if (!contains(o)) return false;
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
The cluster is both a child and an attribute? Feels a bit roundabout.
what happens if the future is already completed?
You should use getter instead of raw variables
Can we make it compatible with only version ? Just handle the case in which you have only one parameter
I've got a fix in a PR that [removes the watchManager](<LINK_0>, so let's just make sure that doesn't get squashed by this :)
This should call down into the two args constructor.
EINVAL is expected for FileDescriptor.out / FileDescriptor.in. This is only expected to work for descriptors to "regular" files, and won't work if in / out are pipes or sockets (which they are, in some configs. The man-page uses weasel words to say this "EINVAL... or an mmap(2)-like operation is not available for in_fd,".
throw new RuntimeException(ex); so that we will just wrap the original exception and it's message and stacktrace is visible.
I don't want to have us get in the habit of manually building JSON strings. We can use the JsonObjectBuilder from the javax.json package, or we can build maps and pass those to Jackson (ObjectMapper) directly.
The groups should be inside ProjectControl.
is there no common place (at the broker level) we can add the unioning query runner?
I would really appreciate if you rewrite this so it doesn't use -1 as startIdx. A year from now I won't remember why we want to load from position -1.
Please don't use string concatenation (the 'methodName' variable).
Can't we use try-with-resources[1] here? Then you don't need to specifically close the resources. [1] <LINK_0>
When version is removed, you can use Factory.getCRUDController(ei.getDataStore().getBackend())
You should use the index variable for the message, like you do on line 186.
What happens if a checkpoint fails? Wouldn't cancelAfterCheckpointId <= checkpointId be more safe?
this method deserves a description
Is this placeholder correct, looks like if my search includes a ' I can SQL inject here?
Please use getDbFacade() - it makes it easier to unit test.
I recommend using Collections.emptyMap() instead
Are we assuming that if oVirt is installed and managing the cluster, scheduling will be done from oVirt? I think we should disable the CLI scheduler only if there's an existing schedule setup from oVirt. How would we handle the case of multiple schedules on a volume, if a customer wants it. Currently that can be done through CLI. Meta-volume could exist because of geo-rep use case too.
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
I don't follow this logic. If the node _does_ have an ACL child node, then this method returns an empty list? And if the node _does not_ have an ACL child node, then we return an iterator over the AC policies?
I guess this last change in non-intentional.
If this is only for testing, use stream api
this is slightly inaccurate, it's just the number of keys. number of mutations would be the sum of the sizes of the List<Mutations>s, I think
You can write this shorter: int size = Math.min(raw.length, FIRST_FEW_BYTES);
Method could be compacted to one-liner using computeIfAbsent.
This is an info message that is visible to the customer so make it "Released bytes resolve export gap. Resuming export..."
double check that the group is still here
hmmmm.... how is this done for this specific session? nevermind... I think yo can just call getData with refersh and the soft timeout will set for you, no?
All actions from
Undo
Might as well synchronize, unless this is being called somewhere safe that I missed.
this should be a SERVER_ERROR , reaching here means this filter was added to the wrong place in the code and not a user mistake.
1) When would getCause return null? 2) Why drop the exeption message and use the cause' message?
simplify this
Does it have setAll or similar method that you can use here instead of loop?
Shouldn't the message be that the site ID doesn't exist?
Shouldn't this close the iterator before returning the list?
Not sure if this is right... Even if the current value on the left is null, the update has come from somewhere, and I think it must have been triggered from the left, which means we actually got a null record with a known timestamp. Should we use this timestamp instead of UNKNOWN as the join result? It seems weird to produce -1 timestamps, since we can't handle them.
I think it's better to replace this(type, data, new ArrayList<ColumnDef.TYPE>().
Use a Visitor.
do we care to check the length to be positive here?
this is not really a "refAccount" (i.e. not a reference) - can we name it appropriately and declare it where it is required (not this early).
What do you think about renaming this local generation variable (and the one below) to distinguish them from the AbstractCoordinator field (or vice versa)? To make it easier to keep track of which generation variables can be null (these) and which cannot (instance variable). Not sure there's a better name out there, just something to consider.
Shouldn't we use the material library version to get sexiness pre-L? (And consistent behavior in general.)
Add message telling people to use the builder.
why not log details of the transformer ? that would be useful i think to debug
That print stack trace would be useless if just printed so better to ignore it too.
Use parameterized logging instead of string concatenation.
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
Shouldn't this always create a SchemaManager? If the URL is in the manager then that's a good thing (is that case detected?). Otherwise, the right thing to do is to copy the Schema to a managed location and rely on that one. That addresses the concern that the schema is changed without going through Kite (since Kite currently has just a pointer).
lets add a short blurb in the field description and in the .md doc file describing that records with a null field get filtered out.
Would it make more sense to add an intermediate sample of getting the blob properties and retrieving the blobSize from BlobProperties to set the initial stream size? I would think that would be the more common way to determine this.
you can either remove else or add pair of curly brackets
why is this useful?
you put the newThread interrupt in the wrong spot. You want a catch (InterruptedException ie) here just above the catch (Exception e). In that new catch clause is where you call newThread.get().interrupt(). That interrupt will (potentially) interrupt the sleep and when interrupting the sleep, you just simply "return". You want to tell the inner thread to stop doing what its doing - and you do taht by catching the interrupt and just returning.
checking for nullable parent was added specially, cause going into project node simply has no meaning
This exception will be written in the logs and in the console output. It would be nice to add some valuable information : the location of the file and some tips, for instance. "Check the content and permissions of "+currentWK+"."
why we need to check for getVm().isInitialized() ?
retList is not actually used so it will always be empty. Should it be passed into the call to addTabCompletionOptions?
StringPool.EMPTY instead
declare as final static or remove declaration.
To me it seems clearer to make conditional branches based on boolean fields. If we switch to storing information whenever we have a non-null place to store the result, then we should probably do so consistently, using if (accessibilityAccumulator != null) instead of if (calculateAccessibility). I like the form with booleans though.
why not use the field directly ?
The trick with create is you need to convert the String to the Account.Id here in create and embed it into the view instance you return to the caller. :-(
This must be done from whitin the locked block, after we've received the sigal from "notResolving". Otherwise a new thread might come here and dispose of the old one's pools. Likewise for all calls to createThreadPools
any reasons not to use platform aware return Unpooled.buffer(capacity) ?
You don't have to test if the hive is in the nether, because the nether hive is from binnie and not from forestry.
Looks wrong. My guess is you want to invert this: if any parent has a member type return 0; if none do return i.
pls call this(null, DEFAULT_LIMIT)
I think it would be worth making this error a bit more useful. At least adding the node number so that if errors pop up in the log then someone can see if a particular device is generating lots of errors.
The removed bit is important! It needs to know if the dropdown is the focusedWidget (in other words, if it is the current selection by tabbing) in order to highlight the widget with yellow - that's what returning ACTIVE_MODE does. You can probably find another workaround to avoid using TabbingManager, but you need some way to tell if it's been tabbed to
May be it is better to cast meta to BinaryTypeImpl right here?
Here I would also prefer a one-liner with a ternary operator.
null == adapter
write to the logger instead (like in dropTestTables())
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
doc
\>= ?
The value returned by isPlaced depends on the mapped flag as well. It would be a lot simpler if this provider had tuples of [seqID, start, mappedFlag, usePositionDeltaEncoding, expectedIsPlaced], with test cases for each possible combination, and the test just created a new record for each case using those values, and verified isPlaced.
since we will do it for every commit, what if we will move forming of those sets to current register thing where we update it with new index as soon as its added and do not touch it anymore
I'd favour to narrow down the exception being thrown here, Exception is too generic. Perhaps anything that inherits or it is RuntimeExceptioon.
I think this is actually "getClusterItem". We could have a separate one for "getCluster", I think. And an overloaded method for "getMarker".
verifyExceptionMatch() blocks on future.get(), so isDone() will always be true when you're here, no? Also, if the callback was received, then we should ensure that future.get() returns immediately as well, so shouldn't it be a timed get within verifyExceptionMatch()?
This class has no fields so its methods should be static.
It is OK to call two different methods here. The implementation of the two methods can be unified in the AccountsLogic class.
I think you want to pass in the errorListener to super
This needs changed levers on the ground need to be able to be triggered
can it be replaced with "snapshotLeaseDomainId == null"?
I thought there was an issue with unboxing the value from expectedMetrics.get(metric.name()). I think it would be cleaner to do:  Long value = expectedMetrics.get(metric.name()); if (value != null) { long expectedValue = value.longValue(); ...
change to ILPQuickOptimizer Also, what happens when controlTaskId is null? It seems like DolphinDriver can return a null value (if the evaluator hasn't been setup yet), and we don't check after calling initializeCtrlTaskContextId whether it did return null.
throw error here. I can hardly imagine what we can do with empty configuration.
NullPointerExceptionis more specific. You can use Objects.requireNonNull(request)
other methods like this put name first, then id. switch for consistency
Why use runLater if window creation can be done in the ShowPreferences() instead?
Why is there a fromByteArray method? Why not call the constructor directly?
do we want this to continue even if the thread was interrupted above?
if do not need mod, use Collections.empyList()
what about changing TypeExtractor to be a CDI managed bean? so it could be specialized -- extensible
Maybe diving to deep into the state machine pattern but to me it would feel more consistent to have all these methods use a switch. In my head that makes it easy to skim through and see what states the method cares about and what it does in the default case.
While we are doing this, I think we can also get rid of this hard coded numbers. We can have an array to store the name of the tabs, and count would be the size of that array. What do you think? Should we do it now or later or never :)?
Because of this, it might be more efficient to iterate over all columns, do the column checks first and then iterate ove rall cubes in the column. Especially when modded WorldProviders are allowed, with arbitrary logic in those methods. Also so the easy checks first (isRaining and isThundering and randint). I know this is not what vanilla does, but this improvement is essentially free here.
invert
The name is now no longer accurate. Maybe don't replace the line delimiters inside this method.
Correct me if am wrong, my assumption is that the returned collection is always sorted based on the sortWeight of the individual orders
I think it's better to let this exception bubble up and declare it in throws of the method. this is how all other methods in the library work
pls use querydsl instead (already in master)
Think this can be private
How does replacing a NPE with an AssertionException help ? I'd rather try to annotate the method's parameter with @NonNull and watch out for "Null type safety" warnings in Eclipse and fix them.
You probably could reduce it to return type.isPrimitive() || Number.class.isAssignableFrom(type) || Boolean.class.isAssignableFrom(type) || Char.class.isAssignableFrom(type)); (PrimitiveTypes is not really needed in this case).
This will create "problems" when generating the clients, the enabled would have to be kept in the same place.
We appear to be re-implementing some of querying logic to find the host for a standby-container. Instead, leverage the existing APIs in jobModel to query the host for a specific containerId
Instead it should just be super(Assert.checkNotNullParam("name", name));. We don't want a new error code for null checking.
Why change to this?
no need to release the lock here?
You have an internal/framework lock held when you make calls, via notifyListeners, to non-framework code. It would be better if you bucketed _what_ to callout, while inside the framework lock, and then made the callouts themselves outside the lock...otherwise, depending upon the locking model of all of the called entities (Bindings), you could create a deadlock. PS: You may want to run the Eclipse code-formatting function over the changes to align with the std openHAB uses.
This is now comparing to the value from cmd.getRefName but before it was ctl.getRefName.
Remove Subscription with CompositeSubscription. Look here <LINK_0> for an example.
Can we also have test for /v2/api/accounts/{accountId}/charges ?
nit suggestion String quotaProjectId = (String) json.get("quota_project_id");
Remove Coinmarketcap ratesource.
You have channel here as a separate variable, so I don't think we need to use context.
@sebing please put spaces around :
remove the explicit initialization?
Maybe the right thing to do here is return the ByteBuffer and MessageInfo?
suggestion assertThat(ldapUserDetails.getDn()).isEqualTo( "uid=base64withalgorithm-issue-1840,ou=Users,dc=carlspring,dc=com"); assertThat(ldapUserDetails.getUsername()).isEqualTo("base64withalgorithm-issue-1840"); assertThat(ldapUserDetails.getPassword()).isEqualTo( "{bcrypt}$2a$10$lpwlxyjvXKzN1ccCrw2PBuZx.eVesWbfmTbsrCboMU.gsNWVcZWMi"); assertThat(passwordEncoder.matches("password", ldapUserDetails.getPassword())).isEqualTo(true); assertThat(((List<SimpleGrantedAuthority>) ldapUser.getAuthorities())) .contains(new SimpleGrantedAuthority(SystemRole.REPOSITORY_MANAGER.name()), new SimpleGrantedAuthority("USER_ROLE"));
If every output field is supposed to be a string, need to check the type of this field and do the appropriate conversion to string.
<LINK_0> This is only true when insert is failing due to the violation for PK uniqueness, neither foreign key nor unique key. So we still need to query for existence while we are defining foreign key.
@NielsCharlier please see my remark in your docs about conventional capitalisation. I think these should be Resource-Parent and Resource-Type.
Why is it necessary to create a new selection list? Isn't this done in the setup method. Plus, here the variable name shadows the field name - to be avoided.
Out of curiosity, why is the return type of this setter not void?
It may be over thinking this but I got some errors when I tried to make a form name with spaces around the "/" e.g Form with / back slash where as Form with/back slash worked on the device. So maybe we can add another replaceAll() after the first one to replace any patterns like Form_with___back_slash?
Also not comfortable with this.
This String[], and the ValueGetter itself, could both be extracted to constants.
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
@override and function declaration must be at same line.
new byte[0] instead of new String().getBytes() ? Also, doesn't this mean we're creating files for each dashboard regardless of whether they have translations ?
copy
Generics?
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
I don't think this will ever work (due to async framework). probably what you'll need to do is add the span to the ctx in channelRead on success (but not on exception). Then extract it here.
The other place in this class where a DomainException is used could be replaced by this type
Once you add UUID.randomUUID().toString(), you can remove this check.
let's reduce complexity of this method
nit: if (p != null)
Please remove all System.out calls in your code.
I strongly prefer inverting these kinds of tests so that they bail early, instead of wrapping the entire method. E.g.:  if (!mHasStableIds) { return; }  It's a little thing, but getting rid of one level of nesting reduces conditional context for the reader.
This is obviously only relevant to Images. So why are we even getting here if we're hadnling a LUN disk?
This block looks the same as in the other constructor. Should it be DRYed out? I probably wrote this block,but I admit I am having trouble recalling why DefaultsConfigContext needs to explicitly be referenced? We allow config contexts that don't start with the defaults?
For all the cases where 'thin' is not supported, I wonder if this method should catch that? So for example, under case "ear": should it check for if (installThinProject) and break without setting supported = true;?
Shouldn't we assert the result of this is not null? AFAIKT, that means the promise never got a result (or exception) in the default/environment timeout. (Which implies the start failed?)
What if type is not Class type?
do you want to create a new list if its null?
This is unnecessary. A future's state can only be set once
k8s.client.invocation.total
Simplify this by logging a succeeded field?
Suggest adding ArgChecker.isTrue(interpolator instanceof AbstractBoundCurveInterpolator); to get a better error message
use UTF-8
I'm always a bit suspicious about using method calls with ternary operator, since Java will invoke the method even if the precondition equals to false
Not sure if using title change to verify setURL is the correct approach. With the other tests, 'example.com' actually triggers a title change, but your post data call may not neccesarily change the title. idk? You may want to write the test to run upon progress completion instead (see some other tests).
getParent() can return null
I think this can be done more properly using the blockstate properties. Block metadata is going away in 1.13 so we should avoid using it if possible.
an alternative is to log at just one place with the error code.
shouldn't we create an instance of serializedCache?
The other test does not have this delay; why is it needed here?
No need to change this string since this will be calling the REST endpoint, not the local database.
statusHistory
Don't need to return the Arguments.
Looks ugly and potentially a source of future NPEs.
Moreover, I think even we need this mock, it should be used for testAvoidingRedundantWrite() only. As for the other test method, they should be still using the original assignment store class.
also check the database for the domain objects? Can use databaseHelper.lookupObject()
The prefix M is used at several places. It could be extracted out as a constant.
I this refactoring, very nice. Could make this method protected.
I _think_ this is ok - typically for netty applications, you want to avoid blocking the main event loop - but I guess in this case, we want to avoid the acceptor event loop blindly accepting connections when the worker group has to deal with a potentially blocked queue. I wonder if, given that the act of adding an item to a queue in logstash can block, whether the work group would be better in its own thread pool, but I think this should be ok in the short term
Instead of doing this, maybe setting the response status to something not 200-299 will be better. ([cron job reference](<LINK_0> / [task queue reference](<LINK_1>
@antonini please name it user
delete this message
This needs cleanup
maybe have org.kframework.kil.Sort#toBackend and org.kframework.backend.java.kil.Sort#toFrontend?
This condition seems to be backwards. I think it should be index < array.length
This involves a look up of the character encoding type table. Use MessagePack.UTF8
- use RemoteConfig here which knows how to parse a remote section - maybe you need to enhance RemoteConfig to support renaming
imho it would be nicer if this exception was thrown fromgetCipherStorageForCurrentAPILevel
